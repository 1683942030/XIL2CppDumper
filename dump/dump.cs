
//NameSpace:
internal class <Module>
{
}
//NameSpace:
internal sealed class Locale
{
	// Methods
	public static string GetText(string msg);
	public static string GetText(string fmt, object[] args);

}
//NameSpace:
internal static class SR
{
	// Methods
	internal static string Format(string resourceFormat, object p1);
	internal static string Format(string resourceFormat, object p1, object p2);

}
//NameSpace:Microsoft.Win32
internal interface IRegistryApi
{
	// Methods
	public abstract RegistryKey OpenSubKey(RegistryKey rkey, string keyname, bool writtable);
	public abstract void Flush(RegistryKey rkey);
	public abstract void Close(RegistryKey rkey);
	public abstract object GetValue(RegistryKey rkey, string name, object default_value, RegistryValueOptions options);
	public abstract string[] GetSubKeyNames(RegistryKey rkey);
	public abstract string ToString(RegistryKey rkey);
	public abstract IntPtr GetHandle(RegistryKey key);

}
//NameSpace:Microsoft.Win32
public static class Registry
{
	// Fields
	public static readonly RegistryKey ClassesRoot;
	public static readonly RegistryKey CurrentConfig;
	public static readonly RegistryKey CurrentUser;
	public static readonly RegistryKey DynData;
	public static readonly RegistryKey LocalMachine;
	public static readonly RegistryKey PerformanceData;
	public static readonly RegistryKey Users;

	// Methods
	private static void .cctor();

}
//NameSpace:Microsoft.Win32
public enum RegistryHive
{
	// Fields
	public int value__;
	public const RegistryHive ClassesRoot;
	public const RegistryHive CurrentConfig;
	public const RegistryHive CurrentUser;
	public const RegistryHive DynData;
	public const RegistryHive LocalMachine;
	public const RegistryHive PerformanceData;
	public const RegistryHive Users;

}
//NameSpace:Microsoft.Win32
public sealed class RegistryKey : MarshalByRefObject, IDisposable
{
	// Fields
	private object handle;
	private SafeRegistryHandle safe_handle;
	private object hive;
	private readonly string qname;
	private readonly bool isRemoteRoot;
	private readonly bool isWritable;
	private static readonly IRegistryApi RegistryApi;

	// Properties
	public string Name { get; }
	public SafeRegistryHandle Handle { get; }
	internal bool IsRoot { get; }
	internal RegistryHive Hive { get; }
	internal object InternalHandle { get; }

	// Methods
	private static void .cctor();
	internal void .ctor(RegistryHive hiveId);
	internal void .ctor(RegistryHive hiveId, IntPtr keyHandle, bool remoteRoot);
	internal void .ctor(object data, string keyName, bool writable);
	internal static bool IsEquals(RegistryKey a, RegistryKey b);
	public void Dispose();
	public string get_Name();
	public void Flush();
	public void Close();
	public SafeRegistryHandle get_Handle();
	public RegistryKey OpenSubKey(string name);
	public RegistryKey OpenSubKey(string name, bool writable);
	public object GetValue(string name);
	public object GetValue(string name, object defaultValue);
	public string[] GetSubKeyNames();
	public override string ToString();
	internal bool get_IsRoot();
	internal RegistryHive get_Hive();
	internal object get_InternalHandle();
	private void AssertKeyStillValid();
	private void AssertKeyNameLength(string name);
	internal static string DecodeString(byte[] data);
	internal static IOException CreateMarkedForDeletionException();
	private static string GetHiveName(RegistryHive hive);

}
//NameSpace:Microsoft.Win32
public enum RegistryValueKind
{
	// Fields
	public int value__;
	public const RegistryValueKind Unknown;
	public const RegistryValueKind String;
	public const RegistryValueKind ExpandString;
	public const RegistryValueKind Binary;
	public const RegistryValueKind DWord;
	public const RegistryValueKind MultiString;
	public const RegistryValueKind QWord;
	public const RegistryValueKind None;

}
//NameSpace:Microsoft.Win32
public enum RegistryValueOptions
{
	// Fields
	public int value__;
	public const RegistryValueOptions None;
	public const RegistryValueOptions DoNotExpandEnvironmentNames;

}
//NameSpace:Microsoft.Win32
internal class ExpandString
{
	// Fields
	private string value;

	// Methods
	public void .ctor(string s);
	public override string ToString();
	public string Expand();

}
//NameSpace:Microsoft.Win32
internal class RegistryKeyComparer : IEqualityComparer
{
	// Methods
	public bool Equals(object x, object y);
	public int GetHashCode(object obj);
	public void .ctor();

}
//NameSpace:Microsoft.Win32
internal class KeyHandler
{
	// Fields
	private static Hashtable key_to_handler;
	private static Hashtable dir_to_handler;
	public string Dir;
	private string ActualDir;
	public bool IsVolatile;
	private Hashtable values;
	private string file;
	private bool dirty;
	private static string user_store;
	private static string machine_store;

	// Properties
	public bool IsMarkedForDeletion { get; }
	private static string UserStore { get; }
	private static string MachineStore { get; }

	// Methods
	private static void .cctor();
	private void .ctor(RegistryKey rkey, string basedir);
	private void .ctor(RegistryKey rkey, string basedir, bool is_volatile);
	public void Load();
	private void LoadKey(SecurityElement se);
	public RegistryKey Ensure(RegistryKey rkey, string extra, bool writable, bool is_volatile);
	public RegistryKey Probe(RegistryKey rkey, string extra, bool writable);
	private static string CombineName(RegistryKey rkey, string extra);
	private static long GetSystemBootTime();
	private static long GetRegisteredBootTime(string path);
	private static void SaveRegisteredBootTime(string path, long btime);
	private static void CleanVolatileKeys();
	public static bool VolatileKeyExists(string dir);
	public static string GetVolatileDir(string dir);
	public static KeyHandler Lookup(RegistryKey rkey, bool createNonExisting);
	private static string GetRootFromDir(string dir);
	public static void Drop(RegistryKey rkey);
	public object GetValue(string name, RegistryValueOptions options);
	public string[] GetSubKeyNames();
	public void Flush();
	public bool ValueExists(string name);
	public bool get_IsMarkedForDeletion();
	protected override void Finalize();
	private void Save();
	private static string get_UserStore();
	private static string get_MachineStore();

}
//NameSpace:Microsoft.Win32
internal class UnixRegistryApi : IRegistryApi
{
	// Methods
	private static string ToUnix(string keyname);
	private static bool IsWellKnownKey(string parentKeyName, string keyname);
	public RegistryKey OpenSubKey(RegistryKey rkey, string keyname, bool writable);
	public void Flush(RegistryKey rkey);
	public void Close(RegistryKey rkey);
	public object GetValue(RegistryKey rkey, string name, object default_value, RegistryValueOptions options);
	public string[] GetSubKeyNames(RegistryKey rkey);
	public string ToString(RegistryKey rkey);
	private RegistryKey CreateSubKey(RegistryKey rkey, string keyname, bool writable);
	private RegistryKey CreateSubKey(RegistryKey rkey, string keyname, bool writable, bool is_volatile);
	public IntPtr GetHandle(RegistryKey key);
	public void .ctor();

}
//NameSpace:Microsoft.Win32
internal class Win32RegistryApi : IRegistryApi
{
	// Fields
	private readonly int NativeBytesPerCharacter;

	// Methods
	private static extern int RegCloseKey(IntPtr keyHandle);
	private static extern int RegFlushKey(IntPtr keyHandle);
	private static extern int RegOpenKeyEx(IntPtr keyBase, string keyName, IntPtr reserved, int access, out IntPtr keyHandle);
	internal static extern int RegEnumKeyEx(IntPtr keyHandle, int dwIndex, char* lpName, int lpcbName, int[] lpReserved, out StringBuilder lpClass, int[] lpcbClass, long[] lpftLastWriteTime);
	private static extern int RegQueryValueEx(IntPtr keyBase, string valueName, IntPtr reserved, RegistryValueKind type, IntPtr zero, int dataSize);
	private static extern int RegQueryValueEx(IntPtr keyBase, string valueName, IntPtr reserved, RegistryValueKind type, out byte[] data, int dataSize);
	private static extern int RegQueryValueEx(IntPtr keyBase, string valueName, IntPtr reserved, RegistryValueKind type, int data, int dataSize);
	private static extern int RegQueryValueEx(IntPtr keyBase, string valueName, IntPtr reserved, RegistryValueKind type, long data, int dataSize);
	internal static extern int RegQueryInfoKey(IntPtr hKey, out StringBuilder lpClass, int[] lpcbClass, IntPtr lpReserved_MustBeZero, int lpcSubKeys, int[] lpcbMaxSubKeyLen, int[] lpcbMaxClassLen, int lpcValues, int[] lpcbMaxValueNameLen, int[] lpcbMaxValueLen, int[] lpcbSecurityDescriptor, int[] lpftLastWriteTime);
	public IntPtr GetHandle(RegistryKey key);
	private static bool IsHandleValid(RegistryKey key);
	public object GetValue(RegistryKey rkey, string name, object defaultValue, RegistryValueOptions options);
	private int GetBinaryValue(RegistryKey rkey, string name, RegistryValueKind type, out byte[] data, int size);
	public int SubKeyCount(RegistryKey rkey);
	public RegistryKey OpenSubKey(RegistryKey rkey, string keyName, bool writable);
	public void Flush(RegistryKey rkey);
	public void Close(RegistryKey rkey);
	public string[] GetSubKeyNames(RegistryKey rkey);
	private void GenerateException(int errorCode);
	public string ToString(RegistryKey rkey);
	internal static string CombineName(RegistryKey rkey, string localName);
	public void .ctor();

}
//NameSpace:Microsoft.Win32
internal static class Win32Native
{
	// Methods
	public static string GetMessage(int hr);
	public static int MakeHRFromErrorCode(int errorCode);

}
//NameSpace:
internal class Win32Native.WIN32_FIND_DATA
{
	// Fields
	internal int dwFileAttributes;
	internal string cFileName;

	// Methods
	public void .ctor();

}
//NameSpace:Microsoft.Win32.SafeHandles
public sealed class SafeFileHandle : SafeHandleZeroOrMinusOneIsInvalid
{
	// Methods
	public void .ctor(IntPtr preexistingHandle, bool ownsHandle);
	protected override bool ReleaseHandle();

}
//NameSpace:Microsoft.Win32.SafeHandles
internal sealed class SafeFindHandle : SafeHandleZeroOrMinusOneIsInvalid
{
	// Methods
	internal void .ctor(IntPtr preexistingHandle);
	protected override bool ReleaseHandle();

}
//NameSpace:Microsoft.Win32.SafeHandles
public sealed class SafeRegistryHandle : SafeHandleZeroOrMinusOneIsInvalid
{
	// Methods
	public void .ctor(IntPtr preexistingHandle, bool ownsHandle);
	protected override bool ReleaseHandle();

}
//NameSpace:Microsoft.Win32.SafeHandles
public sealed class SafeWaitHandle : SafeHandleZeroOrMinusOneIsInvalid
{
	// Methods
	public void .ctor(IntPtr existingHandle, bool ownsHandle);
	protected override bool ReleaseHandle();

}
//NameSpace:Microsoft.Win32.SafeHandles
public abstract class SafeHandleZeroOrMinusOneIsInvalid : SafeHandle
{
	// Properties
	public override bool IsInvalid { get; }

	// Methods
	protected void .ctor(bool ownsHandle);
	public override bool get_IsInvalid();

}
//NameSpace:Mono
public static class Runtime
{
	// Methods
	private static void mono_runtime_install_handlers();
	public static void InstallSignalHandlers();
	private static void mono_runtime_cleanup_handlers();
	public static void RemoveSignalHandlers();
	public static string GetDisplayName();
	private static string GetNativeStackTrace(Exception exception);
	public static bool SetGCAllowSynchronousMajor(bool flag);

}
//NameSpace:Mono
internal struct RuntimeClassHandle
{
	// Fields
	private RuntimeStructs.MonoClass* value;

	// Properties
	internal RuntimeStructs.MonoClass* Value { get; }

	// Methods
	internal void .ctor(RuntimeStructs.MonoClass* value);
	internal void .ctor(IntPtr ptr);
	internal RuntimeStructs.MonoClass* get_Value();
	public override bool Equals(object obj);
	public override int GetHashCode();
	internal static IntPtr GetTypeFromClass(RuntimeStructs.MonoClass* klass);
	internal RuntimeTypeHandle GetTypeHandle();

}
//NameSpace:Mono
internal struct RuntimeRemoteClassHandle
{
	// Fields
	private RuntimeStructs.RemoteClass* value;

	// Properties
	internal RuntimeClassHandle ProxyClass { get; }

	// Methods
	internal RuntimeClassHandle get_ProxyClass();

}
//NameSpace:Mono
internal struct RuntimeGenericParamInfoHandle
{
	// Fields
	private RuntimeStructs.GenericParamInfo* value;

	// Properties
	internal Type[] Constraints { get; }
	internal GenericParameterAttributes Attributes { get; }

	// Methods
	internal void .ctor(IntPtr ptr);
	internal Type[] get_Constraints();
	internal GenericParameterAttributes get_Attributes();
	private Type[] GetConstraints();
	private int GetConstraintsCount();

}
//NameSpace:Mono
internal struct RuntimeEventHandle
{
	// Fields
	private IntPtr value;

	// Properties
	public IntPtr Value { get; }

	// Methods
	internal void .ctor(IntPtr v);
	public IntPtr get_Value();
	public override bool Equals(object obj);
	public override int GetHashCode();

}
//NameSpace:Mono
internal struct RuntimePropertyHandle
{
	// Fields
	private IntPtr value;

	// Properties
	public IntPtr Value { get; }

	// Methods
	internal void .ctor(IntPtr v);
	public IntPtr get_Value();
	public override bool Equals(object obj);
	public override int GetHashCode();

}
//NameSpace:Mono
internal struct RuntimeGPtrArrayHandle
{
	// Fields
	private RuntimeStructs.GPtrArray* value;

	// Properties
	internal int Length { get; }
	internal IntPtr Item { get; }

	// Methods
	internal void .ctor(IntPtr ptr);
	internal int get_Length();
	internal IntPtr get_Item(int i);
	internal IntPtr Lookup(int i);
	private static void GPtrArrayFree(RuntimeStructs.GPtrArray* value);
	internal static void DestroyAndFree(RuntimeGPtrArrayHandle h);

}
//NameSpace:Mono
internal static class RuntimeMarshal
{
	// Methods
	internal static string PtrToUtf8String(IntPtr ptr);
	internal static SafeStringMarshal MarshalString(string str);
	private static int DecodeBlobSize(IntPtr in_ptr, out IntPtr out_ptr);
	internal static byte[] DecodeBlobArray(IntPtr ptr);
	internal static int AsciHexDigitValue(int c);
	internal static void FreeAssemblyName(MonoAssemblyName name, bool freeStruct);

}
//NameSpace:Mono
internal static class RuntimeStructs
{
}
//NameSpace:
internal struct RuntimeStructs.RemoteClass
{
	// Fields
	internal IntPtr default_vtable;
	internal IntPtr xdomain_vtable;
	internal RuntimeStructs.MonoClass* proxy_class;
	internal IntPtr proxy_class_name;
	internal uint interface_count;

}
//NameSpace:
internal struct RuntimeStructs.MonoClass
{
}
//NameSpace:
internal struct RuntimeStructs.GenericParamInfo
{
	// Fields
	internal RuntimeStructs.MonoClass* pklass;
	internal IntPtr name;
	internal ushort flags;
	internal uint token;
	internal RuntimeStructs.MonoClass** constraints;

}
//NameSpace:
internal struct RuntimeStructs.GPtrArray
{
	// Fields
	internal IntPtr* data;
	internal int len;

}
//NameSpace:
private struct RuntimeStructs.HandleStackMark
{
	// Fields
	private int size;
	private int interior_size;
	private IntPtr chunk;

}
//NameSpace:
private struct RuntimeStructs.MonoError
{
	// Fields
	private ushort error_code;
	private ushort hidden_0;
	private IntPtr hidden_1;
	private IntPtr hidden_2;
	private IntPtr hidden_3;
	private IntPtr hidden_4;
	private IntPtr hidden_5;
	private IntPtr hidden_6;
	private IntPtr hidden_7;
	private IntPtr hidden_8;
	private IntPtr hidden_11;
	private IntPtr hidden_12;
	private IntPtr hidden_13;
	private IntPtr hidden_14;
	private IntPtr hidden_15;
	private IntPtr hidden_16;
	private IntPtr hidden_17;
	private IntPtr hidden_18;

}
//NameSpace:Mono
internal struct MonoAssemblyName
{
	// Fields
	internal IntPtr name;
	internal IntPtr culture;
	internal IntPtr hash_value;
	internal IntPtr public_key;
	internal MonoAssemblyName.<public_key_token>e__FixedBuffer public_key_token;
	internal uint hash_alg;
	internal uint hash_len;
	internal uint flags;
	internal ushort major;
	internal ushort minor;
	internal ushort build;
	internal ushort revision;
	internal ushort arch;

}
//NameSpace:
public struct MonoAssemblyName.<public_key_token>e__FixedBuffer
{
	// Fields
	public byte FixedElementField;

}
//NameSpace:Mono
internal struct SafeGPtrArrayHandle : IDisposable
{
	// Fields
	private RuntimeGPtrArrayHandle handle;

	// Properties
	internal int Length { get; }
	internal IntPtr Item { get; }

	// Methods
	internal void .ctor(IntPtr ptr);
	public void Dispose();
	internal int get_Length();
	internal IntPtr get_Item(int i);

}
//NameSpace:Mono
internal struct SafeStringMarshal : IDisposable
{
	// Fields
	private readonly string str;
	private IntPtr marshaled_string;

	// Properties
	public IntPtr Value { get; }

	// Methods
	public static IntPtr StringToUtf8(string str);
	public static void GFree(IntPtr ptr);
	public void .ctor(string str);
	public IntPtr get_Value();
	public void Dispose();

}
//NameSpace:Mono.Xml
internal class SecurityParser : SmallXmlParser, SmallXmlParser.IContentHandler
{
	// Fields
	private SecurityElement root;
	private SecurityElement current;
	private Stack stack;

	// Methods
	public void .ctor();
	public void LoadXml(string xml);
	public SecurityElement ToXml();
	public void OnStartParsing(SmallXmlParser parser);
	public void OnProcessingInstruction(string name, string text);
	public void OnIgnorableWhitespace(string s);
	public void OnStartElement(string name, SmallXmlParser.IAttrList attrs);
	public void OnEndElement(string name);
	public void OnChars(string ch);
	public void OnEndParsing(SmallXmlParser parser);

}
//NameSpace:Mono.Xml
internal class SmallXmlParser
{
	// Fields
	private SmallXmlParser.IContentHandler handler;
	private TextReader reader;
	private Stack elementNames;
	private Stack xmlSpaces;
	private string xmlSpace;
	private StringBuilder buffer;
	private char[] nameBuffer;
	private bool isWhitespace;
	private SmallXmlParser.AttrListImpl attributes;
	private int line;
	private int column;
	private bool resetColumn;

	// Methods
	public void .ctor();
	private Exception Error(string msg);
	private Exception UnexpectedEndError();
	private bool IsNameChar(char c, bool start);
	private bool IsWhitespace(int c);
	public void SkipWhitespaces();
	private void HandleWhitespaces();
	public void SkipWhitespaces(bool expected);
	private int Peek();
	private int Read();
	public void Expect(int c);
	private string ReadUntil(char until, bool handleReferences);
	public string ReadName();
	public void Parse(TextReader input, SmallXmlParser.IContentHandler handler);
	private void Cleanup();
	public void ReadContent();
	private void HandleBufferedContent();
	private void ReadCharacters();
	private void ReadReference();
	private int ReadCharacterReference();
	private void ReadAttribute(SmallXmlParser.AttrListImpl a);
	private void ReadCDATASection();
	private void ReadComment();

}
//NameSpace:
public interface SmallXmlParser.IContentHandler
{
	// Methods
	public abstract void OnStartParsing(SmallXmlParser parser);
	public abstract void OnEndParsing(SmallXmlParser parser);
	public abstract void OnStartElement(string name, SmallXmlParser.IAttrList attrs);
	public abstract void OnEndElement(string name);
	public abstract void OnProcessingInstruction(string name, string text);
	public abstract void OnChars(string text);
	public abstract void OnIgnorableWhitespace(string text);

}
//NameSpace:
public interface SmallXmlParser.IAttrList
{
	// Properties
	public abstract int Length { get; }
	public abstract string[] Names { get; }
	public abstract string[] Values { get; }

	// Methods
	public abstract int get_Length();
	public abstract string GetName(int i);
	public abstract string GetValue(int i);
	public abstract string GetValue(string name);
	public abstract string[] get_Names();
	public abstract string[] get_Values();

}
//NameSpace:
private class SmallXmlParser.AttrListImpl : SmallXmlParser.IAttrList
{
	// Fields
	private List`1<string> attrNames;
	private List`1<string> attrValues;

	// Properties
	public int Length { get; }
	public string[] Names { get; }
	public string[] Values { get; }

	// Methods
	public int get_Length();
	public string GetName(int i);
	public string GetValue(int i);
	public string GetValue(string name);
	public string[] get_Names();
	public string[] get_Values();
	internal void Clear();
	internal void Add(string name, string value);
	public void .ctor();

}
//NameSpace:Mono.Xml
internal class SmallXmlParserException : SystemException
{
	// Fields
	private int line;
	private int column;

	// Methods
	public void .ctor(string msg, int line, int column);

}
//NameSpace:Mono.Globalization.Unicode
internal class CodePointIndexer
{
	// Fields
	private readonly CodePointIndexer.TableRange[] ranges;
	public readonly int TotalCount;
	private int defaultIndex;
	private int defaultCP;

	// Methods
	public void .ctor(int[] starts, int[] ends, int defaultIndex, int defaultCP);
	public int ToIndex(int cp);

}
//NameSpace:
internal struct CodePointIndexer.TableRange
{
	// Fields
	public readonly int Start;
	public readonly int End;
	public readonly int Count;
	public readonly int IndexStart;
	public readonly int IndexEnd;

	// Methods
	public void .ctor(int start, int end, int indexStart);

}
//NameSpace:Mono.Globalization.Unicode
internal class TailoringInfo
{
	// Fields
	public readonly int LCID;
	public readonly int TailoringIndex;
	public readonly int TailoringCount;
	public readonly bool FrenchSort;

	// Methods
	public void .ctor(int lcid, int tailoringIndex, int tailoringCount, bool frenchSort);

}
//NameSpace:Mono.Globalization.Unicode
internal class Contraction
{
	// Fields
	public int Index;
	public readonly char[] Source;
	public readonly string Replacement;
	public readonly byte[] SortKey;

	// Methods
	public void .ctor(int index, char[] source, string replacement, byte[] sortkey);

}
//NameSpace:Mono.Globalization.Unicode
internal class ContractionComparer : IComparer`1<Contraction>
{
	// Fields
	public static readonly ContractionComparer Instance;

	// Methods
	public int Compare(Contraction c1, Contraction c2);
	public void .ctor();
	private static void .cctor();

}
//NameSpace:Mono.Globalization.Unicode
internal class Level2Map
{
	// Fields
	public byte Source;
	public byte Replace;

	// Methods
	public void .ctor(byte source, byte replace);

}
//NameSpace:Mono.Globalization.Unicode
internal class MSCompatUnicodeTable
{
	// Fields
	public static int MaxExpansionLength;
	private static readonly byte* ignorableFlags;
	private static readonly byte* categories;
	private static readonly byte* level1;
	private static readonly byte* level2;
	private static readonly byte* level3;
	private static byte* cjkCHScategory;
	private static byte* cjkCHTcategory;
	private static byte* cjkJAcategory;
	private static byte* cjkKOcategory;
	private static byte* cjkCHSlv1;
	private static byte* cjkCHTlv1;
	private static byte* cjkJAlv1;
	private static byte* cjkKOlv1;
	private static byte* cjkKOlv2;
	private static readonly char[] tailoringArr;
	private static readonly TailoringInfo[] tailoringInfos;
	private static object forLock;
	public static readonly bool isReady;

	// Properties
	public static bool IsReady { get; }

	// Methods
	public static TailoringInfo GetTailoringInfo(int lcid);
	public static void BuildTailoringTables(CultureInfo culture, TailoringInfo t, Contraction[] contractions, Level2Map[] diacriticals);
	private static void SetCJKReferences(string name, CodePointIndexer cjkIndexer, byte* catTable, byte* lv1Table, CodePointIndexer lv2Indexer, byte* lv2Table);
	public static byte Category(int cp);
	public static byte Level1(int cp);
	public static byte Level2(int cp);
	public static byte Level3(int cp);
	public static bool IsIgnorable(int cp, byte flag);
	public static bool IsIgnorableNonSpacing(int cp);
	public static int ToKanaTypeInsensitive(int i);
	public static int ToWidthCompat(int i);
	public static bool HasSpecialWeight(char c);
	public static bool IsHalfWidthKana(char c);
	public static bool IsHiragana(char c);
	public static bool IsJapaneseSmallLetter(char c);
	public static bool get_IsReady();
	private static IntPtr GetResource(string name);
	private static uint UInt32FromBytePtr(byte* raw, uint idx);
	private static void .cctor();
	public static void FillCJK(string culture, CodePointIndexer cjkIndexer, byte* catTable, byte* lv1Table, CodePointIndexer lv2Indexer, byte* lv2Table);
	private static void FillCJKCore(string culture, CodePointIndexer cjkIndexer, byte* catTable, byte* lv1Table, CodePointIndexer cjkLv2Indexer, byte* lv2Table);

}
//NameSpace:
private sealed class MSCompatUnicodeTable.<>c
{
	// Fields
	public static readonly MSCompatUnicodeTable.<>c <>9;
	public static Comparison`1<Level2Map> <>9__17_0;

	// Methods
	private static void .cctor();
	public void .ctor();
	internal int <BuildTailoringTables>b__17_0(Level2Map a, Level2Map b);

}
//NameSpace:Mono.Globalization.Unicode
internal class MSCompatUnicodeTableUtil
{
	// Fields
	public static readonly CodePointIndexer Ignorable;
	public static readonly CodePointIndexer Category;
	public static readonly CodePointIndexer Level1;
	public static readonly CodePointIndexer Level2;
	public static readonly CodePointIndexer Level3;
	public static readonly CodePointIndexer CjkCHS;
	public static readonly CodePointIndexer Cjk;

	// Methods
	private static void .cctor();

}
//NameSpace:Mono.Globalization.Unicode
internal class NormalizationTableUtil
{
	// Fields
	public static readonly CodePointIndexer Prop;
	public static readonly CodePointIndexer Map;
	public static readonly CodePointIndexer Combining;
	public static readonly CodePointIndexer Composite;
	public static readonly CodePointIndexer Helper;

	// Methods
	private static void .cctor();
	public static int PropIdx(int cp);
	public static int MapIdx(int cp);

}
//NameSpace:Mono.Globalization.Unicode
internal class SimpleCollator
{
	// Fields
	private static bool QuickCheckDisabled;
	private static SimpleCollator invariant;
	private readonly TextInfo textInfo;
	private readonly CodePointIndexer cjkIndexer;
	private readonly Contraction[] contractions;
	private readonly Level2Map[] level2Maps;
	private readonly byte[] unsafeFlags;
	private readonly byte* cjkCatTable;
	private readonly byte* cjkLv1Table;
	private readonly byte* cjkLv2Table;
	private readonly CodePointIndexer cjkLv2Indexer;
	private readonly int lcid;
	private readonly bool frenchSort;

	// Methods
	public void .ctor(CultureInfo culture);
	private void SetCJKTable(CultureInfo culture, CodePointIndexer cjkIndexer, byte* catTable, byte* lv1Table, CodePointIndexer lv2Indexer, byte* lv2Table);
	private static CultureInfo GetNeutralCulture(CultureInfo info);
	private byte Category(int cp);
	private byte Level1(int cp);
	private byte Level2(int cp, SimpleCollator.ExtenderType ext);
	private static bool IsHalfKana(int cp, CompareOptions opt);
	private Contraction GetContraction(string s, int start, int end);
	private Contraction GetContraction(string s, int start, int end, Contraction[] clist);
	private Contraction GetTailContraction(string s, int start, int end);
	private Contraction GetTailContraction(string s, int start, int end, Contraction[] clist);
	private int FilterOptions(int i, CompareOptions opt);
	private SimpleCollator.ExtenderType GetExtenderType(int i);
	private static byte ToDashTypeValue(SimpleCollator.ExtenderType ext, CompareOptions opt);
	private int FilterExtender(int i, SimpleCollator.ExtenderType ext, CompareOptions opt);
	private static bool IsIgnorable(int i, CompareOptions opt);
	private bool IsSafe(int i);
	public SortKey GetSortKey(string s, CompareOptions options);
	public SortKey GetSortKey(string s, int start, int length, CompareOptions options);
	private void GetSortKey(string s, int start, int end, SortKeyBuffer buf, CompareOptions opt);
	private void FillSortKeyRaw(int i, SimpleCollator.ExtenderType ext, SortKeyBuffer buf, CompareOptions opt);
	private void FillSurrogateSortKeyRaw(int i, SortKeyBuffer buf);
	internal int Compare(string s1, int idx1, int len1, string s2, int idx2, int len2, CompareOptions options);
	private void ClearBuffer(byte* buffer, int size);
	private int CompareInternal(string s1, int idx1, int len1, string s2, int idx2, int len2, out bool targetConsumed, out bool sourceConsumed, bool skipHeadingExtenders, bool immediateBreakup, SimpleCollator.Context ctx);
	private int CompareFlagPair(bool b1, bool b2);
	public bool IsPrefix(string src, string target, CompareOptions opt);
	public bool IsPrefix(string s, string target, int start, int length, CompareOptions opt);
	private bool IsPrefix(string s, string target, int start, int length, bool skipHeadingExtenders, SimpleCollator.Context ctx);
	public bool IsSuffix(string src, string target, CompareOptions opt);
	public bool IsSuffix(string s, string target, int start, int length, CompareOptions opt);
	private int QuickIndexOf(string s, string target, int start, int length, out bool testWasUnable);
	public int IndexOf(string s, string target, int start, int length, CompareOptions opt);
	private int IndexOfOrdinal(string s, string target, int start, int length);
	private int IndexOfOrdinal(string s, char target, int start, int length);
	private int IndexOfSortKey(string s, int start, int length, byte* sortkey, char target, int ti, bool noLv4, SimpleCollator.Context ctx);
	private int IndexOf(string s, string target, int start, int length, byte* targetSortKey, SimpleCollator.Context ctx);
	public int LastIndexOf(string s, string target, int start, int length, CompareOptions opt);
	private int LastIndexOfOrdinal(string s, string target, int start, int length);
	private int LastIndexOfSortKey(string s, int start, int orgStart, int length, byte* sortkey, int ti, bool noLv4, SimpleCollator.Context ctx);
	private int LastIndexOf(string s, string target, int start, int length, byte* targetSortKey, SimpleCollator.Context ctx);
	private bool MatchesForward(string s, int idx, int end, int ti, byte* sortkey, bool noLv4, SimpleCollator.Context ctx);
	private bool MatchesForwardCore(string s, int idx, int end, int ti, byte* sortkey, bool noLv4, SimpleCollator.ExtenderType ext, Contraction ct, SimpleCollator.Context ctx);
	private bool MatchesPrimitive(CompareOptions opt, byte* source, int si, SimpleCollator.ExtenderType ext, byte* target, int ti, bool noLv4);
	private bool MatchesBackward(string s, int idx, int end, int orgStart, int ti, byte* sortkey, bool noLv4, SimpleCollator.Context ctx);
	private bool MatchesBackwardCore(string s, int idx, int end, int orgStart, int ti, byte* sortkey, bool noLv4, SimpleCollator.ExtenderType ext, Contraction ct, SimpleCollator.Context ctx);
	private static void .cctor();

}
//NameSpace:
internal struct SimpleCollator.Context
{
	// Fields
	public readonly CompareOptions Option;
	public readonly byte* NeverMatchFlags;
	public readonly byte* AlwaysMatchFlags;
	public byte* Buffer1;
	public byte* Buffer2;
	public int PrevCode;
	public byte* PrevSortKey;

	// Methods
	public void .ctor(CompareOptions opt, byte* alwaysMatchFlags, byte* neverMatchFlags, byte* buffer1, byte* buffer2, byte* prev1);

}
//NameSpace:
private struct SimpleCollator.PreviousInfo
{
	// Fields
	public int Code;
	public byte* SortKey;

	// Methods
	public void .ctor(bool dummy);

}
//NameSpace:
private struct SimpleCollator.Escape
{
	// Fields
	public string Source;
	public int Index;
	public int Start;
	public int End;
	public int Optional;

}
//NameSpace:
private enum SimpleCollator.ExtenderType
{
	// Fields
	public int value__;
	public const SimpleCollator.ExtenderType None;
	public const SimpleCollator.ExtenderType Simple;
	public const SimpleCollator.ExtenderType Voiced;
	public const SimpleCollator.ExtenderType Conditional;
	public const SimpleCollator.ExtenderType Buggy;

}
//NameSpace:Mono.Globalization.Unicode
internal class SortKeyBuffer
{
	// Fields
	private byte[] l1b;
	private byte[] l2b;
	private byte[] l3b;
	private byte[] l4sb;
	private byte[] l4tb;
	private byte[] l4kb;
	private byte[] l4wb;
	private byte[] l5b;
	private string source;
	private int l1;
	private int l2;
	private int l3;
	private int l4s;
	private int l4t;
	private int l4k;
	private int l4w;
	private int l5;
	private int lcid;
	private CompareOptions options;
	private bool processLevel2;
	private bool frenchSort;
	private bool frenchSorted;

	// Methods
	public void .ctor(int lcid);
	public void Reset();
	internal void Initialize(CompareOptions options, int lcid, string s, bool frenchSort);
	internal void AppendCJKExtension(byte lv1msb, byte lv1lsb);
	internal void AppendKana(byte category, byte lv1, byte lv2, byte lv3, bool isSmallKana, byte markType, bool isKatakana, bool isHalfWidth);
	internal void AppendNormal(byte category, byte lv1, byte lv2, byte lv3);
	private void AppendLevel5(byte category, byte lv1);
	private void AppendBufferPrimitive(byte value, byte[] buf, int bidx);
	public SortKey GetResultAndReset();
	private int GetOptimizedLength(byte[] data, int len, byte defaultValue);
	public SortKey GetResult();

}
//NameSpace:Mono.Security
internal class ASN1
{
	// Fields
	private byte m_nTag;
	private byte[] m_aValue;
	private ArrayList elist;

	// Properties
	public int Count { get; }
	public byte Tag { get; }
	public int Length { get; }
	public byte[] Value { get; set; }
	public ASN1 Item { get; }

	// Methods
	public void .ctor(byte tag);
	public void .ctor(byte tag, byte[] data);
	public void .ctor(byte[] data);
	public int get_Count();
	public byte get_Tag();
	public int get_Length();
	public byte[] get_Value();
	public void set_Value(byte[] value);
	private bool CompareArray(byte[] array1, byte[] array2);
	public bool CompareValue(byte[] value);
	public ASN1 Add(ASN1 asn1);
	public virtual byte[] GetBytes();
	protected void Decode(byte[] asn1, int anPos, int anLength);
	protected void DecodeTLV(byte[] asn1, int pos, out byte tag, out int length, out byte[] content);
	public ASN1 get_Item(int index);
	public ASN1 Element(int index, byte anTag);
	public override string ToString();

}
//NameSpace:Mono.Security
internal static class ASN1Convert
{
	// Methods
	public static ASN1 FromInt32(int value);
	public static ASN1 FromOid(string oid);
	public static int ToInt32(ASN1 asn1);
	public static string ToOid(ASN1 asn1);
	public static DateTime ToDateTime(ASN1 time);

}
//NameSpace:Mono.Security
internal sealed class BitConverterLE
{
	// Methods
	private static byte[] GetUIntBytes(byte* bytes);
	private static byte[] GetULongBytes(byte* bytes);
	internal static byte[] GetBytes(int value);
	internal static byte[] GetBytes(float value);
	internal static byte[] GetBytes(double value);
	private static void UIntFromBytes(byte* dst, byte[] src, int startIndex);
	private static void ULongFromBytes(byte* dst, byte[] src, int startIndex);
	internal static float ToSingle(byte[] value, int startIndex);
	internal static double ToDouble(byte[] value, int startIndex);

}
//NameSpace:Mono.Security
internal sealed class PKCS7
{
}
//NameSpace:
public class PKCS7.ContentInfo
{
	// Fields
	private string contentType;
	private ASN1 content;

	// Properties
	public ASN1 ASN1 { get; }
	public ASN1 Content { get; set; }
	public string ContentType { get; set; }

	// Methods
	public void .ctor();
	public void .ctor(string oid);
	public void .ctor(byte[] data);
	public void .ctor(ASN1 asn1);
	public ASN1 get_ASN1();
	public ASN1 get_Content();
	public void set_Content(ASN1 value);
	public string get_ContentType();
	public void set_ContentType(string value);
	internal ASN1 GetASN1();

}
//NameSpace:
public class PKCS7.EncryptedData
{
	// Fields
	private byte _version;
	private PKCS7.ContentInfo _content;
	private PKCS7.ContentInfo _encryptionAlgorithm;
	private byte[] _encrypted;

	// Properties
	public PKCS7.ContentInfo EncryptionAlgorithm { get; }
	public byte[] EncryptedContent { get; }

	// Methods
	public void .ctor();
	public void .ctor(ASN1 asn1);
	public PKCS7.ContentInfo get_EncryptionAlgorithm();
	public byte[] get_EncryptedContent();

}
//NameSpace:Mono.Security.X509
internal class SafeBag
{
	// Fields
	private string _bagOID;
	private ASN1 _asn1;

	// Properties
	public string BagOID { get; }
	public ASN1 ASN1 { get; }

	// Methods
	public void .ctor(string bagOID, ASN1 asn1);
	public string get_BagOID();
	public ASN1 get_ASN1();

}
//NameSpace:Mono.Security.X509
internal class PKCS12 : ICloneable
{
	// Fields
	private byte[] _password;
	private ArrayList _keyBags;
	private ArrayList _secretBags;
	private X509CertificateCollection _certs;
	private bool _keyBagsChanged;
	private bool _secretBagsChanged;
	private bool _certsChanged;
	private int _iterations;
	private ArrayList _safeBags;
	private RandomNumberGenerator _rng;
	private static int password_max_length;

	// Properties
	public void Password { set; }
	public int IterationCount { get; set; }
	public ArrayList Keys { get; }
	public X509CertificateCollection Certificates { get; }
	internal RandomNumberGenerator RNG { get; }
	public static int MaximumPasswordLength { get; }

	// Methods
	public void .ctor();
	public void .ctor(byte[] data);
	public void .ctor(byte[] data, string password);
	private void Decode(byte[] data);
	protected override void Finalize();
	public void set_Password(string value);
	public int get_IterationCount();
	public void set_IterationCount(int value);
	public ArrayList get_Keys();
	public X509CertificateCollection get_Certificates();
	internal RandomNumberGenerator get_RNG();
	private bool Compare(byte[] expected, byte[] actual);
	private SymmetricAlgorithm GetSymmetricAlgorithm(string algorithmOid, byte[] salt, int iterationCount);
	public byte[] Decrypt(string algorithmOid, byte[] salt, int iterationCount, byte[] encryptedData);
	public byte[] Decrypt(PKCS7.EncryptedData ed);
	public byte[] Encrypt(string algorithmOid, byte[] salt, int iterationCount, byte[] data);
	private DSAParameters GetExistingParameters(out bool found);
	private void AddPrivateKey(PKCS8.PrivateKeyInfo pki);
	private void ReadSafeBag(ASN1 safeBag);
	private ASN1 CertificateSafeBag(X509Certificate x509, IDictionary attributes);
	private byte[] MAC(byte[] password, byte[] salt, int iterations, byte[] data);
	public byte[] GetBytes();
	private PKCS7.ContentInfo EncryptedContentInfo(ASN1 safeBags, string algorithmOid);
	public void AddCertificate(X509Certificate cert);
	public void AddCertificate(X509Certificate cert, IDictionary attributes);
	public void RemoveCertificate(X509Certificate cert);
	public void RemoveCertificate(X509Certificate cert, IDictionary attrs);
	public object Clone();
	public static int get_MaximumPasswordLength();
	private static void .cctor();

}
//NameSpace:
public class PKCS12.DeriveBytes
{
	// Fields
	private static byte[] keyDiversifier;
	private static byte[] ivDiversifier;
	private static byte[] macDiversifier;
	private string _hashName;
	private int _iterations;
	private byte[] _password;
	private byte[] _salt;

	// Properties
	public void HashName { set; }
	public void IterationCount { set; }
	public void Password { set; }
	public void Salt { set; }

	// Methods
	public void .ctor();
	public void set_HashName(string value);
	public void set_IterationCount(int value);
	public void set_Password(byte[] value);
	public void set_Salt(byte[] value);
	private void Adjust(byte[] a, int aOff, byte[] b);
	private byte[] Derive(byte[] diversifier, int n);
	public byte[] DeriveKey(int size);
	public byte[] DeriveIV(int size);
	public byte[] DeriveMAC(int size);
	private static void .cctor();

}
//NameSpace:Mono.Security.X509
internal sealed class X501
{
	// Fields
	private static byte[] countryName;
	private static byte[] organizationName;
	private static byte[] organizationalUnitName;
	private static byte[] commonName;
	private static byte[] localityName;
	private static byte[] stateOrProvinceName;
	private static byte[] streetAddress;
	private static byte[] domainComponent;
	private static byte[] userid;
	private static byte[] email;
	private static byte[] dnQualifier;
	private static byte[] title;
	private static byte[] surname;
	private static byte[] givenName;
	private static byte[] initial;

	// Methods
	public static string ToString(ASN1 seq);
	private static void AppendEntry(StringBuilder sb, ASN1 entry, bool quotes);
	private static void .cctor();

}
//NameSpace:Mono.Security.X509
internal class X509Certificate : ISerializable
{
	// Fields
	private ASN1 decoder;
	private byte[] m_encodedcert;
	private DateTime m_from;
	private DateTime m_until;
	private ASN1 issuer;
	private string m_issuername;
	private string m_keyalgo;
	private byte[] m_keyalgoparams;
	private ASN1 subject;
	private string m_subject;
	private byte[] m_publickey;
	private byte[] signature;
	private string m_signaturealgo;
	private byte[] m_signaturealgoparams;
	private RSA _rsa;
	private DSA _dsa;
	private int version;
	private byte[] serialnumber;
	private byte[] issuerUniqueID;
	private byte[] subjectUniqueID;
	private X509ExtensionCollection extensions;
	private static string encoding_error;

	// Properties
	public DSA DSA { get; }
	public virtual byte[] KeyAlgorithmParameters { get; }
	public virtual RSA RSA { get; }
	public virtual byte[] RawData { get; }

	// Methods
	private void Parse(byte[] data);
	public void .ctor(byte[] data);
	private byte[] GetUnsignedBigInteger(byte[] integer);
	public DSA get_DSA();
	public virtual byte[] get_KeyAlgorithmParameters();
	public virtual RSA get_RSA();
	public virtual byte[] get_RawData();
	public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
	private static byte[] PEM(string type, byte[] data);
	private static void .cctor();

}
//NameSpace:Mono.Security.X509
internal class X509CertificateCollection : CollectionBase, IEnumerable
{
	// Properties
	public X509Certificate Item { get; }

	// Methods
	public void .ctor();
	public X509Certificate get_Item(int index);
	public int Add(X509Certificate value);
	public X509CertificateCollection.X509CertificateEnumerator GetEnumerator();
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();
	public override int GetHashCode();

}
//NameSpace:
public class X509CertificateCollection.X509CertificateEnumerator : IEnumerator
{
	// Fields
	private IEnumerator enumerator;

	// Properties
	public X509Certificate Current { get; }
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	public void .ctor(X509CertificateCollection mappings);
	public X509Certificate get_Current();
	private object System.Collections.IEnumerator.get_Current();
	private bool System.Collections.IEnumerator.MoveNext();
	public bool MoveNext();

}
//NameSpace:Mono.Security.X509
internal class X509Extension
{
	// Fields
	protected string extnOid;
	protected bool extnCritical;
	protected ASN1 extnValue;

	// Methods
	public void .ctor(ASN1 asn1);
	protected virtual void Decode();
	public override bool Equals(object obj);
	public override int GetHashCode();
	private void WriteLine(StringBuilder sb, int n, int pos);
	public override string ToString();

}
//NameSpace:Mono.Security.X509
internal sealed class X509ExtensionCollection : CollectionBase, IEnumerable
{
	// Fields
	private bool readOnly;

	// Methods
	public void .ctor();
	public void .ctor(ASN1 asn1);
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();

}
//NameSpace:Mono.Security.Cryptography
internal class ARC4Managed : RC4, ICryptoTransform, IDisposable
{
	// Fields
	private byte[] key;
	private byte[] state;
	private byte x;
	private byte y;
	private bool m_disposed;

	// Properties
	public override byte[] Key { get; set; }

	// Methods
	public void .ctor();
	protected override void Finalize();
	protected override void Dispose(bool disposing);
	public override byte[] get_Key();
	public override void set_Key(byte[] value);
	public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgvIV);
	public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgvIV);
	public override void GenerateIV();
	public override void GenerateKey();
	private void KeySetup(byte[] key);
	private void CheckInput(byte[] inputBuffer, int inputOffset, int inputCount);
	private int InternalTransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
	public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);

}
//NameSpace:Mono.Security.Cryptography
internal sealed class KeyBuilder
{
	// Fields
	private static RandomNumberGenerator rng;

	// Properties
	private static RandomNumberGenerator Rng { get; }

	// Methods
	private static RandomNumberGenerator get_Rng();
	public static byte[] Key(int size);
	public static byte[] IV(int size);

}
//NameSpace:Mono.Security.Cryptography
internal class KeyPairPersistence
{
	// Fields
	private static bool _userPathExists;
	private static string _userPath;
	private static bool _machinePathExists;
	private static string _machinePath;
	private CspParameters _params;
	private string _keyvalue;
	private string _filename;
	private string _container;
	private static object lockobj;

	// Properties
	public string Filename { get; }
	public string KeyValue { get; set; }
	private static string UserPath { get; }
	private static string MachinePath { get; }
	private bool CanChange { get; }
	private bool UseDefaultKeyContainer { get; }
	private bool UseMachineKeyStore { get; }
	private string ContainerName { get; }

	// Methods
	public void .ctor(CspParameters parameters);
	public void .ctor(CspParameters parameters, string keyPair);
	public string get_Filename();
	public string get_KeyValue();
	public void set_KeyValue(string value);
	public bool Load();
	public void Save();
	public void Remove();
	private static string get_UserPath();
	private static string get_MachinePath();
	internal static bool _CanSecure(string root);
	internal static bool _ProtectUser(string path);
	internal static bool _ProtectMachine(string path);
	internal static bool _IsUserProtected(string path);
	internal static bool _IsMachineProtected(string path);
	private static bool CanSecure(string path);
	private static bool ProtectUser(string path);
	private static bool ProtectMachine(string path);
	private static bool IsUserProtected(string path);
	private static bool IsMachineProtected(string path);
	private bool get_CanChange();
	private bool get_UseDefaultKeyContainer();
	private bool get_UseMachineKeyStore();
	private string get_ContainerName();
	private CspParameters Copy(CspParameters p);
	private void FromXml(string xml);
	private string ToXml();
	private static void .cctor();

}
//NameSpace:Mono.Security.Cryptography
internal abstract class MD2 : HashAlgorithm
{
	// Methods
	protected void .ctor();
	public static MD2 Create();

}
//NameSpace:Mono.Security.Cryptography
internal class MD2Managed : MD2
{
	// Fields
	private byte[] state;
	private byte[] checksum;
	private byte[] buffer;
	private int count;
	private byte[] x;
	private static readonly byte[] PI_SUBST;

	// Methods
	private byte[] Padding(int nLength);
	public void .ctor();
	public override void Initialize();
	protected override void HashCore(byte[] array, int ibStart, int cbSize);
	protected override byte[] HashFinal();
	private void MD2Transform(byte[] state, byte[] checksum, byte[] block, int index);
	private static void .cctor();

}
//NameSpace:Mono.Security.Cryptography
internal abstract class MD4 : HashAlgorithm
{
	// Methods
	protected void .ctor();
	public static MD4 Create();

}
//NameSpace:Mono.Security.Cryptography
internal class MD4Managed : MD4
{
	// Fields
	private uint[] state;
	private byte[] buffer;
	private uint[] count;
	private uint[] x;
	private byte[] digest;

	// Methods
	public void .ctor();
	public override void Initialize();
	protected override void HashCore(byte[] array, int ibStart, int cbSize);
	protected override byte[] HashFinal();
	private byte[] Padding(int nLength);
	private uint F(uint x, uint y, uint z);
	private uint G(uint x, uint y, uint z);
	private uint H(uint x, uint y, uint z);
	private uint ROL(uint x, byte n);
	private void FF(uint a, uint b, uint c, uint d, uint x, byte s);
	private void GG(uint a, uint b, uint c, uint d, uint x, byte s);
	private void HH(uint a, uint b, uint c, uint d, uint x, byte s);
	private void Encode(byte[] output, uint[] input);
	private void Decode(uint[] output, byte[] input, int index);
	private void MD4Transform(uint[] state, byte[] block, int index);

}
//NameSpace:Mono.Security.Cryptography
internal sealed class PKCS1
{
	// Fields
	private static byte[] emptySHA1;
	private static byte[] emptySHA256;
	private static byte[] emptySHA384;
	private static byte[] emptySHA512;

	// Methods
	internal static HashAlgorithm CreateFromName(string name);
	private static void .cctor();

}
//NameSpace:Mono.Security.Cryptography
internal sealed class PKCS8
{
}
//NameSpace:
public class PKCS8.PrivateKeyInfo
{
	// Fields
	private int _version;
	private string _algorithm;
	private byte[] _key;
	private ArrayList _list;

	// Properties
	public byte[] PrivateKey { get; }

	// Methods
	public void .ctor();
	public void .ctor(byte[] data);
	public byte[] get_PrivateKey();
	private void Decode(byte[] data);
	private static byte[] RemoveLeadingZero(byte[] bigInt);
	private static byte[] Normalize(byte[] bigInt, int length);
	public static RSA DecodeRSA(byte[] keypair);
	public static DSA DecodeDSA(byte[] privateKey, DSAParameters dsaParameters);

}
//NameSpace:
public class PKCS8.EncryptedPrivateKeyInfo
{
	// Fields
	private string _algorithm;
	private byte[] _salt;
	private int _iterations;
	private byte[] _data;

	// Properties
	public string Algorithm { get; }
	public byte[] EncryptedData { get; }
	public byte[] Salt { get; }
	public int IterationCount { get; }

	// Methods
	public void .ctor();
	public void .ctor(byte[] data);
	public string get_Algorithm();
	public byte[] get_EncryptedData();
	public byte[] get_Salt();
	public int get_IterationCount();
	private void Decode(byte[] data);

}
//NameSpace:Mono.Security.Cryptography
internal abstract class RC4 : SymmetricAlgorithm
{
	// Fields
	private static KeySizes[] s_legalBlockSizes;
	private static KeySizes[] s_legalKeySizes;

	// Properties
	public override byte[] IV { get; set; }

	// Methods
	public void .ctor();
	public override byte[] get_IV();
	public override void set_IV(byte[] value);
	public static RC4 Create();
	private static void .cctor();

}
//NameSpace:Mono.Security.Cryptography
internal class RSAManaged : RSA
{
	// Fields
	private bool isCRTpossible;
	private bool keyBlinding;
	private bool keypairGenerated;
	private bool m_disposed;
	private BigInteger d;
	private BigInteger p;
	private BigInteger q;
	private BigInteger dp;
	private BigInteger dq;
	private BigInteger qInv;
	private BigInteger n;
	private BigInteger e;
	private RSAManaged.KeyGeneratedEventHandler KeyGenerated;

	// Properties
	public override int KeySize { get; }
	public bool PublicOnly { get; }

	// Methods
	public void .ctor(int keySize);
	protected override void Finalize();
	private void GenerateKeyPair();
	public override int get_KeySize();
	public bool get_PublicOnly();
	public override RSAParameters ExportParameters(bool includePrivateParameters);
	public override void ImportParameters(RSAParameters parameters);
	protected override void Dispose(bool disposing);
	public void add_KeyGenerated(RSAManaged.KeyGeneratedEventHandler value);
	public void remove_KeyGenerated(RSAManaged.KeyGeneratedEventHandler value);
	public override string ToXmlString(bool includePrivateParameters);
	private byte[] GetPaddedValue(BigInteger value, int length);

}
//NameSpace:
public sealed class RSAManaged.KeyGeneratedEventHandler : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(object sender, EventArgs e);
	public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:Mono.Security.Cryptography
internal abstract class SymmetricTransform : ICryptoTransform, IDisposable
{
	// Fields
	protected SymmetricAlgorithm algo;
	protected bool encrypt;
	protected int BlockSizeByte;
	protected byte[] temp;
	protected byte[] temp2;
	private byte[] workBuff;
	private byte[] workout;
	protected PaddingMode padmode;
	protected int FeedBackByte;
	private bool m_disposed;
	protected bool lastBlock;
	private RandomNumberGenerator _rng;

	// Properties
	private bool KeepLastBlock { get; }

	// Methods
	public void .ctor(SymmetricAlgorithm symmAlgo, bool encryption, byte[] rgbIV);
	protected override void Finalize();
	private void System.IDisposable.Dispose();
	protected virtual void Dispose(bool disposing);
	protected virtual void Transform(byte[] input, byte[] output);
	protected abstract void ECB(byte[] input, byte[] output);
	protected virtual void CBC(byte[] input, byte[] output);
	protected virtual void CFB(byte[] input, byte[] output);
	protected virtual void OFB(byte[] input, byte[] output);
	protected virtual void CTS(byte[] input, byte[] output);
	private void CheckInput(byte[] inputBuffer, int inputOffset, int inputCount);
	private bool get_KeepLastBlock();
	private int InternalTransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
	private void Random(byte[] buffer, int start, int length);
	private void ThrowBadPaddingException(PaddingMode padding, int length, int position);
	protected virtual byte[] FinalEncrypt(byte[] inputBuffer, int inputOffset, int inputCount);
	protected virtual byte[] FinalDecrypt(byte[] inputBuffer, int inputOffset, int inputCount);
	public virtual byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);

}
//NameSpace:Mono.Security.Cryptography
internal class DSAManaged : DSA
{
	// Fields
	private bool keypairGenerated;
	private bool m_disposed;
	private BigInteger p;
	private BigInteger q;
	private BigInteger g;
	private BigInteger x;
	private BigInteger y;
	private BigInteger j;
	private BigInteger seed;
	private int counter;
	private bool j_missing;
	private RandomNumberGenerator rng;
	private DSAManaged.KeyGeneratedEventHandler KeyGenerated;

	// Properties
	private RandomNumberGenerator Random { get; }
	public override int KeySize { get; }
	public bool PublicOnly { get; }

	// Methods
	public void .ctor(int dwKeySize);
	protected override void Finalize();
	private void Generate();
	private void GenerateKeyPair();
	private void add(byte[] a, byte[] b, int value);
	private void GenerateParams(int keyLength);
	private RandomNumberGenerator get_Random();
	public override int get_KeySize();
	public bool get_PublicOnly();
	private byte[] NormalizeArray(byte[] array);
	public override DSAParameters ExportParameters(bool includePrivateParameters);
	public override void ImportParameters(DSAParameters parameters);
	protected override void Dispose(bool disposing);
	public void add_KeyGenerated(DSAManaged.KeyGeneratedEventHandler value);
	public void remove_KeyGenerated(DSAManaged.KeyGeneratedEventHandler value);

}
//NameSpace:
public sealed class DSAManaged.KeyGeneratedEventHandler : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(object sender, EventArgs e);
	public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:Mono.Math
internal class BigInteger
{
	// Fields
	private uint length;
	private uint[] data;
	internal static readonly uint[] smallPrimes;
	private static RandomNumberGenerator rng;

	// Properties
	private static RandomNumberGenerator Rng { get; }

	// Methods
	public void .ctor(BigInteger.Sign sign, uint len);
	public void .ctor(BigInteger bi);
	public void .ctor(BigInteger bi, uint len);
	public void .ctor(byte[] inData);
	public void .ctor(uint ui);
	public static BigInteger op_Implicit(uint value);
	public static BigInteger op_Implicit(int value);
	public static BigInteger op_Subtraction(BigInteger bi1, BigInteger bi2);
	public static uint op_Modulus(BigInteger bi, uint ui);
	public static BigInteger op_Modulus(BigInteger bi1, BigInteger bi2);
	public static BigInteger op_Division(BigInteger bi1, BigInteger bi2);
	public static BigInteger op_Multiply(BigInteger bi1, BigInteger bi2);
	public static BigInteger op_Multiply(BigInteger bi, int i);
	public static BigInteger op_LeftShift(BigInteger bi1, int shiftVal);
	public static BigInteger op_RightShift(BigInteger bi1, int shiftVal);
	private static RandomNumberGenerator get_Rng();
	public static BigInteger GenerateRandom(int bits, RandomNumberGenerator rng);
	public static BigInteger GenerateRandom(int bits);
	public void Randomize(RandomNumberGenerator rng);
	public void Randomize();
	public int BitCount();
	public bool TestBit(uint bitNum);
	public bool TestBit(int bitNum);
	public void SetBit(uint bitNum);
	public void SetBit(uint bitNum, bool value);
	public int LowestSetBit();
	public byte[] GetBytes();
	public static bool op_Equality(BigInteger bi1, uint ui);
	public static bool op_Inequality(BigInteger bi1, uint ui);
	public static bool op_Equality(BigInteger bi1, BigInteger bi2);
	public static bool op_Inequality(BigInteger bi1, BigInteger bi2);
	public static bool op_GreaterThan(BigInteger bi1, BigInteger bi2);
	public static bool op_LessThan(BigInteger bi1, BigInteger bi2);
	public static bool op_GreaterThanOrEqual(BigInteger bi1, BigInteger bi2);
	public static bool op_LessThanOrEqual(BigInteger bi1, BigInteger bi2);
	public string ToString(uint radix);
	public string ToString(uint radix, string characterSet);
	private void Normalize();
	public void Clear();
	public override int GetHashCode();
	public override string ToString();
	public override bool Equals(object o);
	public BigInteger ModInverse(BigInteger modulus);
	public BigInteger ModPow(BigInteger exp, BigInteger n);
	public bool IsProbablePrime();
	public static BigInteger GeneratePseudoPrime(int bits);
	public void Incr2();
	private static void .cctor();

}
//NameSpace:
public enum BigInteger.Sign
{
	// Fields
	public int value__;
	public const BigInteger.Sign Negative;
	public const BigInteger.Sign Zero;
	public const BigInteger.Sign Positive;

}
//NameSpace:
internal sealed class BigInteger.ModulusRing
{
	// Fields
	private BigInteger mod;
	private BigInteger constant;

	// Methods
	public void .ctor(BigInteger modulus);
	public void BarrettReduction(BigInteger x);
	public BigInteger Multiply(BigInteger a, BigInteger b);
	public BigInteger Difference(BigInteger a, BigInteger b);
	public BigInteger Pow(BigInteger a, BigInteger k);
	public BigInteger Pow(uint b, BigInteger exp);

}
//NameSpace:
private sealed class BigInteger.Kernel
{
	// Methods
	public static BigInteger Subtract(BigInteger big, BigInteger small);
	public static void MinusEq(BigInteger big, BigInteger small);
	public static void PlusEq(BigInteger bi1, BigInteger bi2);
	public static BigInteger.Sign Compare(BigInteger bi1, BigInteger bi2);
	public static uint SingleByteDivideInPlace(BigInteger n, uint d);
	public static uint DwordMod(BigInteger n, uint d);
	public static BigInteger[] DwordDivMod(BigInteger n, uint d);
	public static BigInteger[] multiByteDivide(BigInteger bi1, BigInteger bi2);
	public static BigInteger LeftShift(BigInteger bi, int n);
	public static BigInteger RightShift(BigInteger bi, int n);
	public static BigInteger MultiplyByDword(BigInteger n, uint f);
	public static void Multiply(uint[] x, uint xOffset, uint xLen, uint[] y, uint yOffset, uint yLen, uint[] d, uint dOffset);
	public static void MultiplyMod2p32pmod(uint[] x, int xOffset, int xLen, uint[] y, int yOffest, int yLen, uint[] d, int dOffset, int mod);
	public static uint modInverse(BigInteger bi, uint modulus);
	public static BigInteger modInverse(BigInteger bi, BigInteger modulus);

}
//NameSpace:Mono.Math.Prime
internal enum ConfidenceFactor
{
	// Fields
	public int value__;
	public const ConfidenceFactor ExtraLow;
	public const ConfidenceFactor Low;
	public const ConfidenceFactor Medium;
	public const ConfidenceFactor High;
	public const ConfidenceFactor ExtraHigh;
	public const ConfidenceFactor Provable;

}
//NameSpace:Mono.Math.Prime
internal sealed class PrimalityTest : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual bool Invoke(BigInteger bi, ConfidenceFactor confidence);
	public virtual IAsyncResult BeginInvoke(BigInteger bi, ConfidenceFactor confidence, AsyncCallback callback, object object);
	public virtual bool EndInvoke(IAsyncResult result);

}
//NameSpace:Mono.Math.Prime
internal sealed class PrimalityTests
{
	// Methods
	private static int GetSPPRounds(BigInteger bi, ConfidenceFactor confidence);
	public static bool Test(BigInteger n, ConfidenceFactor confidence);
	public static bool RabinMillerTest(BigInteger n, ConfidenceFactor confidence);
	public static bool SmallPrimeSppTest(BigInteger bi, ConfidenceFactor confidence);

}
//NameSpace:Mono.Math.Prime.Generator
internal abstract class PrimeGeneratorBase
{
	// Properties
	public virtual ConfidenceFactor Confidence { get; }
	public virtual PrimalityTest PrimalityTest { get; }
	public virtual int TrialDivisionBounds { get; }

	// Methods
	public virtual ConfidenceFactor get_Confidence();
	public virtual PrimalityTest get_PrimalityTest();
	public virtual int get_TrialDivisionBounds();
	public abstract BigInteger GenerateNewPrime(int bits);
	protected void .ctor();

}
//NameSpace:Mono.Math.Prime.Generator
internal class SequentialSearchPrimeGeneratorBase : PrimeGeneratorBase
{
	// Methods
	protected virtual BigInteger GenerateSearchBase(int bits, object context);
	public override BigInteger GenerateNewPrime(int bits);
	public virtual BigInteger GenerateNewPrime(int bits, object context);
	protected virtual bool IsPrimeAcceptable(BigInteger bi, object context);
	public void .ctor();

}
//NameSpace:System
internal static class ThrowHelper
{
	// Methods
	internal static void ThrowArgumentNullException(ExceptionArgument argument);
	private static Exception CreateArgumentNullException(ExceptionArgument argument);
	internal static void ThrowArgumentOutOfRangeException();
	internal static void ThrowWrongValueTypeArgumentException(object value, Type targetType);
	internal static void ThrowArgumentException(ExceptionResource resource);
	internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
	internal static void ThrowInvalidOperationException(ExceptionResource resource);
	internal static void ThrowNotSupportedException(ExceptionResource resource);
	internal static void IfNullAndNullsAreIllegalThenThrow(object value, ExceptionArgument argName);
	internal static string GetArgumentName(ExceptionArgument argument);
	internal static string GetResourceName(ExceptionResource resource);

}
//NameSpace:System
internal interface IValueTupleInternal : ITuple
{
}
//NameSpace:System
public struct ValueTuple : IEquatable`1<ValueTuple>, IStructuralEquatable, IStructuralComparable, IComparable, IComparable`1<ValueTuple>, IValueTupleInternal, ITuple
{
	// Methods
	public override bool Equals(object obj);
	public bool Equals(ValueTuple other);
	private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
	private int System.IComparable.CompareTo(object other);
	public int CompareTo(ValueTuple other);
	private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
	public override int GetHashCode();
	private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
	public override string ToString();
	internal static int CombineHashCodes(int h1, int h2);

}
//NameSpace:System
public struct ValueTuple`2 : IEquatable`1<ValueTuple`2<TT>>, IStructuralEquatable, IStructuralComparable, IComparable, IComparable`1<ValueTuple`2<TT>>, IValueTupleInternal, ITuple
{
	// Fields
	public T Item1;
	public T Item2;

	// Methods
	public override bool Equals(object obj);
	public bool Equals(ValueTuple`2<TT> other);
	private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
	private int System.IComparable.CompareTo(object other);
	public int CompareTo(ValueTuple`2<TT> other);
	private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
	public override int GetHashCode();
	private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
	private int GetHashCodeCore(IEqualityComparer comparer);
	public override string ToString();

}
//NameSpace:System
public abstract class Array : ICollection, IEnumerable, IList, IStructuralComparable, IStructuralEquatable, ICloneable
{
	// Properties
	private int System.Collections.ICollection.Count { get; }
	private bool System.Collections.IList.IsReadOnly { get; }
	private object System.Collections.IList.Item { get; set; }
	public long LongLength { get; }
	public bool IsFixedSize { get; }
	public bool IsReadOnly { get; }
	public bool IsSynchronized { get; }
	public object SyncRoot { get; }
	public int Length { get; }
	public int Rank { get; }

	// Methods
	public static Array CreateInstance(Type elementType, long[] lengths);
	public static ReadOnlyCollection`1<T> AsReadOnly(T[] array);
	public static void Resize(T[] array, int newSize);
	private int System.Collections.ICollection.get_Count();
	private bool System.Collections.IList.get_IsReadOnly();
	private object System.Collections.IList.get_Item(int index);
	private void System.Collections.IList.set_Item(int index, object value);
	private int System.Collections.IList.Add(object value);
	private bool System.Collections.IList.Contains(object value);
	private void System.Collections.IList.Clear();
	private int System.Collections.IList.IndexOf(object value);
	private void System.Collections.IList.Insert(int index, object value);
	private void System.Collections.IList.Remove(object value);
	private void System.Collections.IList.RemoveAt(int index);
	public void CopyTo(Array array, int index);
	public object Clone();
	private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
	private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
	internal static int CombineHashCodes(int h1, int h2);
	private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
	public static int BinarySearch(Array array, object value);
	public static T[] ConvertAll(T[] array, Converter`2<TT> converter);
	public static void Copy(Array sourceArray, Array destinationArray, long length);
	public static void Copy(Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);
	public void CopyTo(Array array, long index);
	public static void ForEach(T[] array, Action`1<T> action);
	public long get_LongLength();
	public long GetLongLength(int dimension);
	public object GetValue(long index);
	public object GetValue(long index1, long index2);
	public object GetValue(long index1, long index2, long index3);
	public object GetValue(long[] indices);
	public bool get_IsFixedSize();
	public bool get_IsReadOnly();
	public bool get_IsSynchronized();
	public object get_SyncRoot();
	public static int BinarySearch(Array array, int index, int length, object value);
	public static int BinarySearch(Array array, object value, IComparer comparer);
	public static int BinarySearch(Array array, int index, int length, object value, IComparer comparer);
	private static int GetMedian(int low, int hi);
	public static int BinarySearch(T[] array, T value);
	public static int BinarySearch(T[] array, T value, IComparer`1<T> comparer);
	public static int BinarySearch(T[] array, int index, int length, T value);
	public static int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
	public static int IndexOf(Array array, object value);
	public static int IndexOf(Array array, object value, int startIndex);
	public static int IndexOf(Array array, object value, int startIndex, int count);
	public static int IndexOf(T[] array, T value);
	public static int IndexOf(T[] array, T value, int startIndex);
	public static int IndexOf(T[] array, T value, int startIndex, int count);
	public static int LastIndexOf(Array array, object value);
	public static int LastIndexOf(Array array, object value, int startIndex);
	public static int LastIndexOf(Array array, object value, int startIndex, int count);
	public static int LastIndexOf(T[] array, T value);
	public static int LastIndexOf(T[] array, T value, int startIndex);
	public static int LastIndexOf(T[] array, T value, int startIndex, int count);
	public static void Reverse(Array array);
	public static void Reverse(Array array, int index, int length);
	public static void Reverse(T[] array);
	public static void Reverse(T[] array, int index, int length);
	public void SetValue(object value, long index);
	public void SetValue(object value, long index1, long index2);
	public void SetValue(object value, long index1, long index2, long index3);
	public void SetValue(object value, long[] indices);
	public static void Sort(Array array);
	public static void Sort(Array array, int index, int length);
	public static void Sort(Array array, IComparer comparer);
	public static void Sort(Array array, int index, int length, IComparer comparer);
	public static void Sort(Array keys, Array items);
	public static void Sort(Array keys, Array items, IComparer comparer);
	public static void Sort(Array keys, Array items, int index, int length);
	public static void Sort(Array keys, Array items, int index, int length, IComparer comparer);
	public static void Sort(T[] array);
	public static void Sort(T[] array, int index, int length);
	public static void Sort(T[] array, IComparer`1<T> comparer);
	public static void Sort(T[] array, int index, int length, IComparer`1<T> comparer);
	public static void Sort(T[] array, Comparison`1<T> comparison);
	public static void Sort(T[] keys, T[] items);
	public static void Sort(T[] keys, T[] items, int index, int length);
	public static void Sort(T[] keys, T[] items, IComparer`1<T> comparer);
	public static void Sort(T[] keys, T[] items, int index, int length, IComparer`1<T> comparer);
	public static bool Exists(T[] array, Predicate`1<T> match);
	public static void Fill(T[] array, T value);
	public static void Fill(T[] array, T value, int startIndex, int count);
	public static T Find(T[] array, Predicate`1<T> match);
	public static T[] FindAll(T[] array, Predicate`1<T> match);
	public static int FindIndex(T[] array, Predicate`1<T> match);
	public static int FindIndex(T[] array, int startIndex, Predicate`1<T> match);
	public static int FindIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
	public static T FindLast(T[] array, Predicate`1<T> match);
	public static int FindLastIndex(T[] array, Predicate`1<T> match);
	public static int FindLastIndex(T[] array, int startIndex, Predicate`1<T> match);
	public static int FindLastIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
	public static bool TrueForAll(T[] array, Predicate`1<T> match);
	public IEnumerator GetEnumerator();
	private void .ctor();
	internal int InternalArray__ICollection_get_Count();
	internal bool InternalArray__ICollection_get_IsReadOnly();
	internal IEnumerator`1<T> InternalArray__IEnumerable_GetEnumerator();
	internal void InternalArray__ICollection_Clear();
	internal void InternalArray__ICollection_Add(T item);
	internal bool InternalArray__ICollection_Remove(T item);
	internal bool InternalArray__ICollection_Contains(T item);
	internal void InternalArray__ICollection_CopyTo(T[] array, int arrayIndex);
	internal T InternalArray__IReadOnlyList_get_Item(int index);
	internal int InternalArray__IReadOnlyCollection_get_Count();
	internal void InternalArray__Insert(int index, T item);
	internal void InternalArray__RemoveAt(int index);
	internal int InternalArray__IndexOf(T item);
	internal T InternalArray__get_Item(int index);
	internal void InternalArray__set_Item(int index, T item);
	internal void GetGenericValueImpl(int pos, out T value);
	internal void SetGenericValueImpl(int pos, T value);
	public int get_Length();
	public int get_Rank();
	private int GetRank();
	public int GetLength(int dimension);
	public int GetLowerBound(int dimension);
	public object GetValue(int[] indices);
	public void SetValue(object value, int[] indices);
	internal object GetValueImpl(int pos);
	internal void SetValueImpl(object value, int pos);
	internal static bool FastCopy(Array source, int source_idx, Array dest, int dest_idx, int length);
	internal static Array CreateInstanceImpl(Type elementType, int[] lengths, int[] bounds);
	public int GetUpperBound(int dimension);
	public object GetValue(int index);
	public object GetValue(int index1, int index2);
	public object GetValue(int index1, int index2, int index3);
	public void SetValue(object value, int index);
	public void SetValue(object value, int index1, int index2);
	public void SetValue(object value, int index1, int index2, int index3);
	internal static Array UnsafeCreateInstance(Type elementType, int[] lengths, int[] lowerBounds);
	internal static Array UnsafeCreateInstance(Type elementType, int length1, int length2);
	internal static Array UnsafeCreateInstance(Type elementType, int[] lengths);
	public static Array CreateInstance(Type elementType, int length);
	public static Array CreateInstance(Type elementType, int length1, int length2);
	public static Array CreateInstance(Type elementType, int length1, int length2, int length3);
	public static Array CreateInstance(Type elementType, int[] lengths);
	public static Array CreateInstance(Type elementType, int[] lengths, int[] lowerBounds);
	public static void Clear(Array array, int index, int length);
	private static void ClearInternal(Array a, int index, int count);
	public static void Copy(Array sourceArray, Array destinationArray, int length);
	public static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
	private static Exception CreateArrayTypeMismatchException();
	private static bool CanAssignArrayElement(Type source, Type target);
	public static void ConstrainedCopy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
	public static T[] Empty();
	public void Initialize();
	private static int IndexOfImpl(T[] array, T value, int startIndex, int count);
	private static int LastIndexOfImpl(T[] array, T value, int startIndex, int count);
	private static void SortImpl(Array keys, Array items, int index, int length, IComparer comparer);
	internal static T UnsafeLoad(T[] array, int index);
	internal static void UnsafeStore(T[] array, int index, T value);
	internal static T UnsafeMov(T instance);

}
//NameSpace:
private sealed class Array.ArrayEnumerator : IEnumerator, ICloneable
{
	// Fields
	private Array _array;
	private int _index;
	private int _endIndex;

	// Properties
	public object Current { get; }

	// Methods
	internal void .ctor(Array array);
	public bool MoveNext();
	public object Clone();
	public object get_Current();

}
//NameSpace:
internal struct Array.InternalEnumerator`1 : IEnumerator`1<T>, IDisposable, IEnumerator
{
	// Fields
	private readonly Array array;
	private int idx;

	// Properties
	public T Current { get; }
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	internal void .ctor(Array array);
	public void Dispose();
	public bool MoveNext();
	public T get_Current();
	private object System.Collections.IEnumerator.get_Current();

}
//NameSpace:
internal class Array.EmptyInternalEnumerator`1 : IEnumerator`1<T>, IDisposable, IEnumerator
{
	// Fields
	public static readonly EmptyInternalEnumerator`1<T> Value;

	// Properties
	public T Current { get; }
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	public void Dispose();
	public bool MoveNext();
	public T get_Current();
	private object System.Collections.IEnumerator.get_Current();
	public void .ctor();
	private static void .cctor();

}
//NameSpace:
private struct Array.SorterObjectArray
{
	// Fields
	private object[] keys;
	private object[] items;
	private IComparer comparer;

	// Methods
	internal void .ctor(object[] keys, object[] items, IComparer comparer);
	internal void SwapIfGreaterWithItems(int a, int b);
	private void Swap(int i, int j);
	internal void Sort(int left, int length);
	private void IntrospectiveSort(int left, int length);
	private void IntroSort(int lo, int hi, int depthLimit);
	private int PickPivotAndPartition(int lo, int hi);
	private void Heapsort(int lo, int hi);
	private void DownHeap(int i, int n, int lo);
	private void InsertionSort(int lo, int hi);

}
//NameSpace:
private struct Array.SorterGenericArray
{
	// Fields
	private Array keys;
	private Array items;
	private IComparer comparer;

	// Methods
	internal void .ctor(Array keys, Array items, IComparer comparer);
	internal void SwapIfGreaterWithItems(int a, int b);
	private void Swap(int i, int j);
	internal void Sort(int left, int length);
	private void IntrospectiveSort(int left, int length);
	private void IntroSort(int lo, int hi, int depthLimit);
	private int PickPivotAndPartition(int lo, int hi);
	private void Heapsort(int lo, int hi);
	private void DownHeap(int i, int n, int lo);
	private void InsertionSort(int lo, int hi);

}
//NameSpace:System
internal interface ITupleInternal : ITuple
{
	// Methods
	public abstract string ToString(StringBuilder sb);

}
//NameSpace:System
public static class Tuple
{
	// Methods
	public static Tuple`2<TT> Create(T item1, T item2);
	internal static int CombineHashCodes(int h1, int h2);
	internal static int CombineHashCodes(int h1, int h2, int h3);
	internal static int CombineHashCodes(int h1, int h2, int h3, int h4);

}
//NameSpace:System
public class Tuple`2 : IStructuralEquatable, IStructuralComparable, IComparable, ITupleInternal, ITuple
{
	// Fields
	private readonly T m_Item1;
	private readonly T m_Item2;

	// Properties
	public T Item1 { get; }
	public T Item2 { get; }

	// Methods
	public T get_Item1();
	public T get_Item2();
	public void .ctor(T item1, T item2);
	public override bool Equals(object obj);
	private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
	private int System.IComparable.CompareTo(object obj);
	private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
	public override int GetHashCode();
	private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
	public override string ToString();
	private string System.ITupleInternal.ToString(StringBuilder sb);

}
//NameSpace:System
public class Tuple`3 : IStructuralEquatable, IStructuralComparable, IComparable, ITupleInternal, ITuple
{
	// Fields
	private readonly T m_Item1;
	private readonly T m_Item2;
	private readonly T m_Item3;

	// Properties
	public T Item1 { get; }
	public T Item2 { get; }
	public T Item3 { get; }

	// Methods
	public T get_Item1();
	public T get_Item2();
	public T get_Item3();
	public void .ctor(T item1, T item2, T item3);
	public override bool Equals(object obj);
	private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
	private int System.IComparable.CompareTo(object obj);
	private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
	public override int GetHashCode();
	private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
	public override string ToString();
	private string System.ITupleInternal.ToString(StringBuilder sb);

}
//NameSpace:System
public class Tuple`4 : IStructuralEquatable, IStructuralComparable, IComparable, ITupleInternal, ITuple
{
	// Fields
	private readonly T m_Item1;
	private readonly T m_Item2;
	private readonly T m_Item3;
	private readonly T m_Item4;

	// Properties
	public T Item1 { get; }
	public T Item2 { get; }
	public T Item3 { get; }
	public T Item4 { get; }

	// Methods
	public T get_Item1();
	public T get_Item2();
	public T get_Item3();
	public T get_Item4();
	public override bool Equals(object obj);
	private bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
	private int System.IComparable.CompareTo(object obj);
	private int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
	public override int GetHashCode();
	private int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
	public override string ToString();
	private string System.ITupleInternal.ToString(StringBuilder sb);

}
//NameSpace:System
internal class MonoTODOAttribute : Attribute
{
	// Fields
	private string comment;

	// Methods
	public void .ctor();
	public void .ctor(string comment);

}
//NameSpace:System
internal class MonoLimitationAttribute : MonoTODOAttribute
{
	// Methods
	public void .ctor(string comment);

}
//NameSpace:System
public class AggregateException : Exception
{
	// Fields
	private ReadOnlyCollection`1<Exception> m_innerExceptions;

	// Properties
	public ReadOnlyCollection`1<Exception> InnerExceptions { get; }

	// Methods
	public void .ctor();
	public void .ctor(IEnumerable`1<Exception> innerExceptions);
	public void .ctor(Exception[] innerExceptions);
	public void .ctor(string message, IEnumerable`1<Exception> innerExceptions);
	public void .ctor(string message, Exception[] innerExceptions);
	private void .ctor(string message, IList`1<Exception> innerExceptions);
	internal void .ctor(IEnumerable`1<ExceptionDispatchInfo> innerExceptionInfos);
	internal void .ctor(string message, IEnumerable`1<ExceptionDispatchInfo> innerExceptionInfos);
	private void .ctor(string message, IList`1<ExceptionDispatchInfo> innerExceptionInfos);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public override void GetObjectData(SerializationInfo info, StreamingContext context);
	public ReadOnlyCollection`1<Exception> get_InnerExceptions();
	public AggregateException Flatten();
	public override string ToString();

}
//NameSpace:System
internal static class AppContextSwitches
{
	// Fields
	public static readonly bool ThrowExceptionIfDisposedCancellationTokenSource;

	// Methods
	private static void .cctor();

}
//NameSpace:System
internal class __Filters
{
	// Fields
	internal static readonly __Filters Instance;

	// Methods
	internal virtual bool FilterAttribute(MemberInfo m, object filterCriteria);
	internal virtual bool FilterName(MemberInfo m, object filterCriteria);
	internal virtual bool FilterIgnoreCase(MemberInfo m, object filterCriteria);
	public void .ctor();
	private static void .cctor();

}
//NameSpace:System
internal sealed class LocalDataStoreHolder
{
	// Fields
	private LocalDataStore m_Store;

	// Properties
	public LocalDataStore Store { get; }

	// Methods
	public void .ctor(LocalDataStore store);
	protected override void Finalize();
	public LocalDataStore get_Store();

}
//NameSpace:System
internal sealed class LocalDataStoreElement
{
	// Fields
	private object m_value;
	private long m_cookie;

	// Properties
	public object Value { get; set; }
	public long Cookie { get; }

	// Methods
	public void .ctor(long cookie);
	public object get_Value();
	public void set_Value(object value);
	public long get_Cookie();

}
//NameSpace:System
internal sealed class LocalDataStore
{
	// Fields
	private LocalDataStoreElement[] m_DataTable;
	private LocalDataStoreMgr m_Manager;

	// Methods
	public void .ctor(LocalDataStoreMgr mgr, int InitialCapacity);
	internal void Dispose();
	public object GetData(LocalDataStoreSlot slot);
	public void SetData(LocalDataStoreSlot slot, object data);
	internal void FreeData(int slot, long cookie);
	private LocalDataStoreElement PopulateElement(LocalDataStoreSlot slot);

}
//NameSpace:System
public sealed class LocalDataStoreSlot
{
	// Fields
	private LocalDataStoreMgr m_mgr;
	private int m_slot;
	private long m_cookie;

	// Properties
	internal LocalDataStoreMgr Manager { get; }
	internal int Slot { get; }
	internal long Cookie { get; }

	// Methods
	internal void .ctor(LocalDataStoreMgr mgr, int slot, long cookie);
	internal LocalDataStoreMgr get_Manager();
	internal int get_Slot();
	internal long get_Cookie();
	protected override void Finalize();

}
//NameSpace:System
internal sealed class LocalDataStoreMgr
{
	// Fields
	private bool[] m_SlotInfoTable;
	private int m_FirstAvailableSlot;
	private List`1<LocalDataStore> m_ManagedLocalDataStores;
	private Dictionary`2<stringLocalDataStoreSlot> m_KeyToSlotMap;
	private long m_CookieGenerator;

	// Methods
	public LocalDataStoreHolder CreateLocalDataStore();
	public void DeleteLocalDataStore(LocalDataStore store);
	public LocalDataStoreSlot AllocateDataSlot();
	public LocalDataStoreSlot AllocateNamedDataSlot(string name);
	public LocalDataStoreSlot GetNamedDataSlot(string name);
	public void FreeNamedDataSlot(string name);
	internal void FreeDataSlot(int slot, long cookie);
	public void ValidateSlot(LocalDataStoreSlot slot);
	internal int GetSlotTableLength();
	public void .ctor();

}
//NameSpace:System
public sealed class Action`1 : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(T obj);
	public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System
public sealed class Action : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke();
	public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System
public sealed class Action`2 : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(T arg1, T arg2);
	public virtual IAsyncResult BeginInvoke(T arg1, T arg2, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System
public sealed class Action`3 : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(T arg1, T arg2, T arg3);
	public virtual IAsyncResult BeginInvoke(T arg1, T arg2, T arg3, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System
public sealed class Func`1 : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual T Invoke();
	public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
	public virtual T EndInvoke(IAsyncResult result);

}
//NameSpace:System
public sealed class Func`2 : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual T Invoke(T arg);
	public virtual IAsyncResult BeginInvoke(T arg, AsyncCallback callback, object object);
	public virtual T EndInvoke(IAsyncResult result);

}
//NameSpace:System
public sealed class Func`3 : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual T Invoke(T arg1, T arg2);
	public virtual IAsyncResult BeginInvoke(T arg1, T arg2, AsyncCallback callback, object object);
	public virtual T EndInvoke(IAsyncResult result);

}
//NameSpace:System
public sealed class Func`4 : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual T Invoke(T arg1, T arg2, T arg3);
	public virtual IAsyncResult BeginInvoke(T arg1, T arg2, T arg3, AsyncCallback callback, object object);
	public virtual T EndInvoke(IAsyncResult result);

}
//NameSpace:System
public sealed class Func`5 : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual T Invoke(T arg1, T arg2, T arg3, T arg4);
	public virtual IAsyncResult BeginInvoke(T arg1, T arg2, T arg3, T arg4, AsyncCallback callback, object object);
	public virtual T EndInvoke(IAsyncResult result);

}
//NameSpace:System
public sealed class Comparison`1 : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual int Invoke(T x, T y);
	public virtual IAsyncResult BeginInvoke(T x, T y, AsyncCallback callback, object object);
	public virtual int EndInvoke(IAsyncResult result);

}
//NameSpace:System
public sealed class Converter`2 : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual T Invoke(T input);
	public virtual IAsyncResult BeginInvoke(T input, AsyncCallback callback, object object);
	public virtual T EndInvoke(IAsyncResult result);

}
//NameSpace:System
public sealed class Predicate`1 : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual bool Invoke(T obj);
	public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
	public virtual bool EndInvoke(IAsyncResult result);

}
//NameSpace:System
public sealed class Activator : _Activator
{
	// Methods
	public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture);
	public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes);
	public static object CreateInstance(Type type, object[] args);
	public static object CreateInstance(Type type, object[] args, object[] activationAttributes);
	public static object CreateInstance(Type type);
	public static object CreateInstance(Type type, bool nonPublic);
	public static T CreateInstance();

}
//NameSpace:System
public class AppDomainUnloadedException : SystemException
{
	// Methods
	public void .ctor();
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class ApplicationException : Exception
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	public void .ctor(string message, Exception innerException);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class ArgumentException : SystemException, ISerializable
{
	// Fields
	private string m_paramName;

	// Properties
	public override string Message { get; }

	// Methods
	public void .ctor();
	public void .ctor(string message);
	public void .ctor(string message, Exception innerException);
	public void .ctor(string message, string paramName);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public override string get_Message();
	public override void GetObjectData(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class ArgumentNullException : ArgumentException
{
	// Methods
	public void .ctor();
	public void .ctor(string paramName);
	public void .ctor(string paramName, string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class ArgumentOutOfRangeException : ArgumentException, ISerializable
{
	// Fields
	private static string _rangeMessage;
	private object m_actualValue;

	// Properties
	private static string RangeMessage { get; }
	public override string Message { get; }

	// Methods
	private static string get_RangeMessage();
	public void .ctor();
	public void .ctor(string paramName);
	public void .ctor(string paramName, string message);
	public void .ctor(string paramName, object actualValue, string message);
	public override string get_Message();
	public override void GetObjectData(SerializationInfo info, StreamingContext context);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class ArithmeticException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	public void .ctor(string message, Exception innerException);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class ArrayTypeMismatchException : SystemException
{
	// Methods
	public void .ctor();
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public sealed class AsyncCallback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(IAsyncResult ar);
	public virtual IAsyncResult BeginInvoke(IAsyncResult ar, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System
public abstract class Attribute : _Attribute
{
	// Methods
	private static Attribute[] InternalGetCustomAttributes(PropertyInfo element, Type type, bool inherit);
	private static Attribute[] InternalGetCustomAttributes(EventInfo element, Type type, bool inherit);
	private static bool InternalIsDefined(PropertyInfo element, Type attributeType, bool inherit);
	private static bool InternalIsDefined(EventInfo element, Type attributeType, bool inherit);
	public static Attribute[] GetCustomAttributes(MemberInfo element, Type type, bool inherit);
	public static bool IsDefined(MemberInfo element, Type attributeType);
	public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
	public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
	public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType, bool inherit);
	public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
	public static Attribute GetCustomAttribute(Assembly element, Type attributeType, bool inherit);
	protected void .ctor();
	public override bool Equals(object obj);
	private static bool AreFieldValuesEqual(object thisValue, object thatValue);
	public override int GetHashCode();

}
//NameSpace:System
public enum AttributeTargets
{
	// Fields
	public int value__;
	public const AttributeTargets Assembly;
	public const AttributeTargets Module;
	public const AttributeTargets Class;
	public const AttributeTargets Struct;
	public const AttributeTargets Enum;
	public const AttributeTargets Constructor;
	public const AttributeTargets Method;
	public const AttributeTargets Property;
	public const AttributeTargets Field;
	public const AttributeTargets Event;
	public const AttributeTargets Interface;
	public const AttributeTargets Parameter;
	public const AttributeTargets Delegate;
	public const AttributeTargets ReturnValue;
	public const AttributeTargets GenericParameter;
	public const AttributeTargets All;

}
//NameSpace:System
public sealed class AttributeUsageAttribute : Attribute
{
	// Fields
	internal AttributeTargets m_attributeTarget;
	internal bool m_allowMultiple;
	internal bool m_inherited;
	internal static AttributeUsageAttribute Default;

	// Properties
	public bool AllowMultiple { get; set; }
	public bool Inherited { get; set; }

	// Methods
	public void .ctor(AttributeTargets validOn);
	public bool get_AllowMultiple();
	public void set_AllowMultiple(bool value);
	public bool get_Inherited();
	public void set_Inherited(bool value);
	private static void .cctor();

}
//NameSpace:System
public class BadImageFormatException : SystemException
{
	// Fields
	private string _fileName;
	private string _fusionLog;

	// Properties
	public override string Message { get; }
	public string FusionLog { get; }

	// Methods
	public void .ctor();
	public void .ctor(string message);
	public void .ctor(string message, Exception inner);
	public void .ctor(string message, string fileName);
	public override string get_Message();
	private void SetMessageField();
	public override string ToString();
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public string get_FusionLog();
	public override void GetObjectData(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public static class BitConverter
{
	// Fields
	public static readonly bool IsLittleEndian;

	// Methods
	private static bool AmILittleEndian();
	public static byte[] GetBytes(short value);
	public static byte[] GetBytes(int value);
	public static short ToInt16(byte[] value, int startIndex);
	public static int ToInt32(byte[] value, int startIndex);
	public static long ToInt64(byte[] value, int startIndex);
	public static ushort ToUInt16(byte[] value, int startIndex);
	public static uint ToUInt32(byte[] value, int startIndex);
	public static ulong ToUInt64(byte[] value, int startIndex);
	private static char GetHexValue(int i);
	public static string ToString(byte[] value, int startIndex, int length);
	public static string ToString(byte[] value);
	public static long DoubleToInt64Bits(double value);
	public static double Int64BitsToDouble(long value);
	private static void .cctor();

}
//NameSpace:System
public struct Boolean : IComparable, IConvertible, IComparable`1<bool>, IEquatable`1<bool>
{
	// Fields
	private bool m_value;
	internal const int True;
	internal const int False;
	internal const string TrueLiteral;
	internal const string FalseLiteral;
	public static readonly string TrueString;
	public static readonly string FalseString;

	// Methods
	public override int GetHashCode();
	public override string ToString();
	public string ToString(IFormatProvider provider);
	public override bool Equals(object obj);
	public bool Equals(bool obj);
	public int CompareTo(object obj);
	public int CompareTo(bool value);
	public static bool Parse(string value);
	public static bool TryParse(string value, out bool result);
	private static string TrimWhiteSpaceAndNull(string value);
	public TypeCode GetTypeCode();
	private bool System.IConvertible.ToBoolean(IFormatProvider provider);
	private char System.IConvertible.ToChar(IFormatProvider provider);
	private sbyte System.IConvertible.ToSByte(IFormatProvider provider);
	private byte System.IConvertible.ToByte(IFormatProvider provider);
	private short System.IConvertible.ToInt16(IFormatProvider provider);
	private ushort System.IConvertible.ToUInt16(IFormatProvider provider);
	private int System.IConvertible.ToInt32(IFormatProvider provider);
	private uint System.IConvertible.ToUInt32(IFormatProvider provider);
	private long System.IConvertible.ToInt64(IFormatProvider provider);
	private ulong System.IConvertible.ToUInt64(IFormatProvider provider);
	private float System.IConvertible.ToSingle(IFormatProvider provider);
	private double System.IConvertible.ToDouble(IFormatProvider provider);
	private Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
	private DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
	private object System.IConvertible.ToType(Type type, IFormatProvider provider);
	private static void .cctor();

}
//NameSpace:System
public static class Buffer
{
	// Methods
	internal static bool InternalBlockCopy(Array src, int srcOffsetBytes, Array dst, int dstOffsetBytes, int byteCount);
	internal static int IndexOfByte(byte* src, byte value, int index, int count);
	private static int _ByteLength(Array array);
	internal static void ZeroMemory(byte* src, long len);
	internal static void Memcpy(byte[] dest, int destIndex, byte* src, int srcIndex, int len);
	internal static void Memcpy(byte* pDest, int destIndex, byte[] src, int srcIndex, int len);
	public static int ByteLength(Array array);
	public static void BlockCopy(Array src, int srcOffset, Array dst, int dstOffset, int count);
	internal static void memcpy4(byte* dest, byte* src, int size);
	internal static void memcpy2(byte* dest, byte* src, int size);
	private static void memcpy1(byte* dest, byte* src, int size);
	internal static void Memcpy(byte* dest, byte* src, int size);

}
//NameSpace:System
public struct Byte : IComparable, IFormattable, IConvertible, IComparable`1<byte>, IEquatable`1<byte>
{
	// Fields
	private byte m_value;
	public const byte MaxValue;
	public const byte MinValue;

	// Methods
	public int CompareTo(object value);
	public int CompareTo(byte value);
	public override bool Equals(object obj);
	public bool Equals(byte obj);
	public override int GetHashCode();
	public static byte Parse(string s, IFormatProvider provider);
	public static byte Parse(string s, NumberStyles style, IFormatProvider provider);
	private static byte Parse(string s, NumberStyles style, NumberFormatInfo info);
	public override string ToString();
	public string ToString(string format);
	public string ToString(IFormatProvider provider);
	public string ToString(string format, IFormatProvider provider);
	public TypeCode GetTypeCode();
	private bool System.IConvertible.ToBoolean(IFormatProvider provider);
	private char System.IConvertible.ToChar(IFormatProvider provider);
	private sbyte System.IConvertible.ToSByte(IFormatProvider provider);
	private byte System.IConvertible.ToByte(IFormatProvider provider);
	private short System.IConvertible.ToInt16(IFormatProvider provider);
	private ushort System.IConvertible.ToUInt16(IFormatProvider provider);
	private int System.IConvertible.ToInt32(IFormatProvider provider);
	private uint System.IConvertible.ToUInt32(IFormatProvider provider);
	private long System.IConvertible.ToInt64(IFormatProvider provider);
	private ulong System.IConvertible.ToUInt64(IFormatProvider provider);
	private float System.IConvertible.ToSingle(IFormatProvider provider);
	private double System.IConvertible.ToDouble(IFormatProvider provider);
	private Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
	private DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
	private object System.IConvertible.ToType(Type type, IFormatProvider provider);

}
//NameSpace:System
public class CannotUnloadAppDomainException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public struct Char : IComparable, IConvertible, IComparable`1<char>, IEquatable`1<char>
{
	// Fields
	internal char m_value;
	public const char MaxValue;
	public const char MinValue;
	private static readonly byte[] categoryForLatin1;
	internal const int UNICODE_PLANE00_END;
	internal const int UNICODE_PLANE01_START;
	internal const int UNICODE_PLANE16_END;
	internal const int HIGH_SURROGATE_START;
	internal const int LOW_SURROGATE_END;

	// Methods
	private static bool IsLatin1(char ch);
	private static bool IsAscii(char ch);
	private static UnicodeCategory GetLatin1UnicodeCategory(char ch);
	public override int GetHashCode();
	public override bool Equals(object obj);
	public bool Equals(char obj);
	public int CompareTo(object value);
	public int CompareTo(char value);
	public override string ToString();
	public string ToString(IFormatProvider provider);
	public static string ToString(char c);
	public static char Parse(string s);
	public static bool IsDigit(char c);
	internal static bool CheckLetter(UnicodeCategory uc);
	public static bool IsLetter(char c);
	private static bool IsWhiteSpaceLatin1(char c);
	public static bool IsWhiteSpace(char c);
	public static bool IsUpper(char c);
	public static bool IsLower(char c);
	internal static bool CheckLetterOrDigit(UnicodeCategory uc);
	public static bool IsLetterOrDigit(char c);
	public static char ToUpper(char c, CultureInfo culture);
	public static char ToUpper(char c);
	public static char ToUpperInvariant(char c);
	public static char ToLower(char c, CultureInfo culture);
	public static char ToLower(char c);
	public static char ToLowerInvariant(char c);
	public TypeCode GetTypeCode();
	private bool System.IConvertible.ToBoolean(IFormatProvider provider);
	private char System.IConvertible.ToChar(IFormatProvider provider);
	private sbyte System.IConvertible.ToSByte(IFormatProvider provider);
	private byte System.IConvertible.ToByte(IFormatProvider provider);
	private short System.IConvertible.ToInt16(IFormatProvider provider);
	private ushort System.IConvertible.ToUInt16(IFormatProvider provider);
	private int System.IConvertible.ToInt32(IFormatProvider provider);
	private uint System.IConvertible.ToUInt32(IFormatProvider provider);
	private long System.IConvertible.ToInt64(IFormatProvider provider);
	private ulong System.IConvertible.ToUInt64(IFormatProvider provider);
	private float System.IConvertible.ToSingle(IFormatProvider provider);
	private double System.IConvertible.ToDouble(IFormatProvider provider);
	private Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
	private DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
	private object System.IConvertible.ToType(Type type, IFormatProvider provider);
	internal static bool CheckNumber(UnicodeCategory uc);
	public static bool IsNumber(char c);
	public static bool IsSurrogate(char c);
	public static bool IsSurrogate(string s, int index);
	public static UnicodeCategory GetUnicodeCategory(char c);
	public static UnicodeCategory GetUnicodeCategory(string s, int index);
	public static bool IsHighSurrogate(char c);
	public static bool IsHighSurrogate(string s, int index);
	public static bool IsLowSurrogate(char c);
	public static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);
	public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
	private static void .cctor();

}
//NameSpace:System
public sealed class CharEnumerator : IEnumerator, ICloneable, IEnumerator`1<char>, IDisposable
{
	// Fields
	private string str;
	private int index;
	private char currentElement;

	// Properties
	private object System.Collections.IEnumerator.Current { get; }
	public char Current { get; }

	// Methods
	internal void .ctor(string str);
	public object Clone();
	public bool MoveNext();
	public void Dispose();
	private object System.Collections.IEnumerator.get_Current();
	public char get_Current();
	internal void .ctor();

}
//NameSpace:System
public sealed class CLSCompliantAttribute : Attribute
{
	// Fields
	private bool m_compliant;

	// Methods
	public void .ctor(bool isCompliant);

}
//NameSpace:System
public sealed class ConsoleCancelEventHandler : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(object sender, ConsoleCancelEventArgs e);
	public virtual IAsyncResult BeginInvoke(object sender, ConsoleCancelEventArgs e, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System
public sealed class ConsoleCancelEventArgs : EventArgs
{
	// Fields
	private ConsoleSpecialKey _type;
	private bool _cancel;

	// Properties
	public bool Cancel { get; }

	// Methods
	internal void .ctor(ConsoleSpecialKey type);
	public bool get_Cancel();
	internal void .ctor();

}
//NameSpace:System
public enum ConsoleColor
{
	// Fields
	public int value__;
	public const ConsoleColor Black;
	public const ConsoleColor DarkBlue;
	public const ConsoleColor DarkGreen;
	public const ConsoleColor DarkCyan;
	public const ConsoleColor DarkRed;
	public const ConsoleColor DarkMagenta;
	public const ConsoleColor DarkYellow;
	public const ConsoleColor Gray;
	public const ConsoleColor DarkGray;
	public const ConsoleColor Blue;
	public const ConsoleColor Green;
	public const ConsoleColor Cyan;
	public const ConsoleColor Red;
	public const ConsoleColor Magenta;
	public const ConsoleColor Yellow;
	public const ConsoleColor White;

}
//NameSpace:System
public enum ConsoleKey
{
	// Fields
	public int value__;
	public const ConsoleKey Backspace;
	public const ConsoleKey Tab;
	public const ConsoleKey Clear;
	public const ConsoleKey Enter;
	public const ConsoleKey Pause;
	public const ConsoleKey Escape;
	public const ConsoleKey Spacebar;
	public const ConsoleKey PageUp;
	public const ConsoleKey PageDown;
	public const ConsoleKey End;
	public const ConsoleKey Home;
	public const ConsoleKey LeftArrow;
	public const ConsoleKey UpArrow;
	public const ConsoleKey RightArrow;
	public const ConsoleKey DownArrow;
	public const ConsoleKey Select;
	public const ConsoleKey Print;
	public const ConsoleKey Execute;
	public const ConsoleKey PrintScreen;
	public const ConsoleKey Insert;
	public const ConsoleKey Delete;
	public const ConsoleKey Help;
	public const ConsoleKey D0;
	public const ConsoleKey D1;
	public const ConsoleKey D2;
	public const ConsoleKey D3;
	public const ConsoleKey D4;
	public const ConsoleKey D5;
	public const ConsoleKey D6;
	public const ConsoleKey D7;
	public const ConsoleKey D8;
	public const ConsoleKey D9;
	public const ConsoleKey A;
	public const ConsoleKey B;
	public const ConsoleKey C;
	public const ConsoleKey D;
	public const ConsoleKey E;
	public const ConsoleKey F;
	public const ConsoleKey G;
	public const ConsoleKey H;
	public const ConsoleKey I;
	public const ConsoleKey J;
	public const ConsoleKey K;
	public const ConsoleKey L;
	public const ConsoleKey M;
	public const ConsoleKey N;
	public const ConsoleKey O;
	public const ConsoleKey P;
	public const ConsoleKey Q;
	public const ConsoleKey R;
	public const ConsoleKey S;
	public const ConsoleKey T;
	public const ConsoleKey U;
	public const ConsoleKey V;
	public const ConsoleKey W;
	public const ConsoleKey X;
	public const ConsoleKey Y;
	public const ConsoleKey Z;
	public const ConsoleKey LeftWindows;
	public const ConsoleKey RightWindows;
	public const ConsoleKey Applications;
	public const ConsoleKey Sleep;
	public const ConsoleKey NumPad0;
	public const ConsoleKey NumPad1;
	public const ConsoleKey NumPad2;
	public const ConsoleKey NumPad3;
	public const ConsoleKey NumPad4;
	public const ConsoleKey NumPad5;
	public const ConsoleKey NumPad6;
	public const ConsoleKey NumPad7;
	public const ConsoleKey NumPad8;
	public const ConsoleKey NumPad9;
	public const ConsoleKey Multiply;
	public const ConsoleKey Add;
	public const ConsoleKey Separator;
	public const ConsoleKey Subtract;
	public const ConsoleKey Decimal;
	public const ConsoleKey Divide;
	public const ConsoleKey F1;
	public const ConsoleKey F2;
	public const ConsoleKey F3;
	public const ConsoleKey F4;
	public const ConsoleKey F5;
	public const ConsoleKey F6;
	public const ConsoleKey F7;
	public const ConsoleKey F8;
	public const ConsoleKey F9;
	public const ConsoleKey F10;
	public const ConsoleKey F11;
	public const ConsoleKey F12;
	public const ConsoleKey F13;
	public const ConsoleKey F14;
	public const ConsoleKey F15;
	public const ConsoleKey F16;
	public const ConsoleKey F17;
	public const ConsoleKey F18;
	public const ConsoleKey F19;
	public const ConsoleKey F20;
	public const ConsoleKey F21;
	public const ConsoleKey F22;
	public const ConsoleKey F23;
	public const ConsoleKey F24;
	public const ConsoleKey BrowserBack;
	public const ConsoleKey BrowserForward;
	public const ConsoleKey BrowserRefresh;
	public const ConsoleKey BrowserStop;
	public const ConsoleKey BrowserSearch;
	public const ConsoleKey BrowserFavorites;
	public const ConsoleKey BrowserHome;
	public const ConsoleKey VolumeMute;
	public const ConsoleKey VolumeDown;
	public const ConsoleKey VolumeUp;
	public const ConsoleKey MediaNext;
	public const ConsoleKey MediaPrevious;
	public const ConsoleKey MediaStop;
	public const ConsoleKey MediaPlay;
	public const ConsoleKey LaunchMail;
	public const ConsoleKey LaunchMediaSelect;
	public const ConsoleKey LaunchApp1;
	public const ConsoleKey LaunchApp2;
	public const ConsoleKey Oem1;
	public const ConsoleKey OemPlus;
	public const ConsoleKey OemComma;
	public const ConsoleKey OemMinus;
	public const ConsoleKey OemPeriod;
	public const ConsoleKey Oem2;
	public const ConsoleKey Oem3;
	public const ConsoleKey Oem4;
	public const ConsoleKey Oem5;
	public const ConsoleKey Oem6;
	public const ConsoleKey Oem7;
	public const ConsoleKey Oem8;
	public const ConsoleKey Oem102;
	public const ConsoleKey Process;
	public const ConsoleKey Packet;
	public const ConsoleKey Attention;
	public const ConsoleKey CrSel;
	public const ConsoleKey ExSel;
	public const ConsoleKey EraseEndOfFile;
	public const ConsoleKey Play;
	public const ConsoleKey Zoom;
	public const ConsoleKey NoName;
	public const ConsoleKey Pa1;
	public const ConsoleKey OemClear;

}
//NameSpace:System
public struct ConsoleKeyInfo
{
	// Fields
	private char _keyChar;
	private ConsoleKey _key;
	private ConsoleModifiers _mods;

	// Properties
	public char KeyChar { get; }
	public ConsoleKey Key { get; }

	// Methods
	public void .ctor(char keyChar, ConsoleKey key, bool shift, bool alt, bool control);
	public char get_KeyChar();
	public ConsoleKey get_Key();
	public override bool Equals(object value);
	public bool Equals(ConsoleKeyInfo obj);
	public override int GetHashCode();

}
//NameSpace:System
public enum ConsoleModifiers
{
	// Fields
	public int value__;
	public const ConsoleModifiers Alt;
	public const ConsoleModifiers Shift;
	public const ConsoleModifiers Control;

}
//NameSpace:System
public enum ConsoleSpecialKey
{
	// Fields
	public int value__;
	public const ConsoleSpecialKey ControlC;
	public const ConsoleSpecialKey ControlBreak;

}
//NameSpace:System
public abstract class ContextBoundObject : MarshalByRefObject
{
	// Methods
	protected void .ctor();

}
//NameSpace:System
public class ContextStaticAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System
public enum Base64FormattingOptions
{
	// Fields
	public int value__;
	public const Base64FormattingOptions None;
	public const Base64FormattingOptions InsertLineBreaks;

}
//NameSpace:System
public static class Convert
{
	// Fields
	internal static readonly RuntimeType[] ConvertTypes;
	private static readonly RuntimeType EnumType;
	internal static readonly char[] base64Table;
	public static readonly object DBNull;

	// Methods
	public static TypeCode GetTypeCode(object value);
	public static object ChangeType(object value, TypeCode typeCode, IFormatProvider provider);
	internal static object DefaultToType(IConvertible value, Type targetType, IFormatProvider provider);
	public static object ChangeType(object value, Type conversionType, IFormatProvider provider);
	public static bool ToBoolean(object value, IFormatProvider provider);
	public static bool ToBoolean(sbyte value);
	public static bool ToBoolean(byte value);
	public static bool ToBoolean(short value);
	public static bool ToBoolean(ushort value);
	public static bool ToBoolean(int value);
	public static bool ToBoolean(uint value);
	public static bool ToBoolean(long value);
	public static bool ToBoolean(ulong value);
	public static bool ToBoolean(string value, IFormatProvider provider);
	public static bool ToBoolean(float value);
	public static bool ToBoolean(double value);
	public static bool ToBoolean(Decimal value);
	public static char ToChar(object value, IFormatProvider provider);
	public static char ToChar(sbyte value);
	public static char ToChar(byte value);
	public static char ToChar(short value);
	public static char ToChar(ushort value);
	public static char ToChar(int value);
	public static char ToChar(uint value);
	public static char ToChar(long value);
	public static char ToChar(ulong value);
	public static char ToChar(string value, IFormatProvider provider);
	public static sbyte ToSByte(object value, IFormatProvider provider);
	public static sbyte ToSByte(bool value);
	public static sbyte ToSByte(char value);
	public static sbyte ToSByte(byte value);
	public static sbyte ToSByte(short value);
	public static sbyte ToSByte(ushort value);
	public static sbyte ToSByte(int value);
	public static sbyte ToSByte(uint value);
	public static sbyte ToSByte(long value);
	public static sbyte ToSByte(ulong value);
	public static sbyte ToSByte(float value);
	public static sbyte ToSByte(double value);
	public static sbyte ToSByte(Decimal value);
	public static sbyte ToSByte(string value, IFormatProvider provider);
	public static byte ToByte(object value, IFormatProvider provider);
	public static byte ToByte(bool value);
	public static byte ToByte(char value);
	public static byte ToByte(sbyte value);
	public static byte ToByte(short value);
	public static byte ToByte(ushort value);
	public static byte ToByte(int value);
	public static byte ToByte(uint value);
	public static byte ToByte(long value);
	public static byte ToByte(ulong value);
	public static byte ToByte(float value);
	public static byte ToByte(double value);
	public static byte ToByte(Decimal value);
	public static byte ToByte(string value);
	public static byte ToByte(string value, IFormatProvider provider);
	public static short ToInt16(object value, IFormatProvider provider);
	public static short ToInt16(bool value);
	public static short ToInt16(char value);
	public static short ToInt16(sbyte value);
	public static short ToInt16(byte value);
	public static short ToInt16(ushort value);
	public static short ToInt16(int value);
	public static short ToInt16(uint value);
	public static short ToInt16(long value);
	public static short ToInt16(ulong value);
	public static short ToInt16(float value);
	public static short ToInt16(double value);
	public static short ToInt16(Decimal value);
	public static short ToInt16(string value, IFormatProvider provider);
	public static ushort ToUInt16(object value, IFormatProvider provider);
	public static ushort ToUInt16(bool value);
	public static ushort ToUInt16(char value);
	public static ushort ToUInt16(sbyte value);
	public static ushort ToUInt16(byte value);
	public static ushort ToUInt16(short value);
	public static ushort ToUInt16(int value);
	public static ushort ToUInt16(uint value);
	public static ushort ToUInt16(long value);
	public static ushort ToUInt16(ulong value);
	public static ushort ToUInt16(float value);
	public static ushort ToUInt16(double value);
	public static ushort ToUInt16(Decimal value);
	public static ushort ToUInt16(string value, IFormatProvider provider);
	public static int ToInt32(object value);
	public static int ToInt32(object value, IFormatProvider provider);
	public static int ToInt32(bool value);
	public static int ToInt32(char value);
	public static int ToInt32(byte value);
	public static int ToInt32(short value);
	public static int ToInt32(ushort value);
	public static int ToInt32(uint value);
	public static int ToInt32(long value);
	public static int ToInt32(ulong value);
	public static int ToInt32(float value);
	public static int ToInt32(double value);
	public static int ToInt32(Decimal value);
	public static int ToInt32(string value, IFormatProvider provider);
	public static uint ToUInt32(object value);
	public static uint ToUInt32(object value, IFormatProvider provider);
	public static uint ToUInt32(bool value);
	public static uint ToUInt32(char value);
	public static uint ToUInt32(sbyte value);
	public static uint ToUInt32(byte value);
	public static uint ToUInt32(short value);
	public static uint ToUInt32(ushort value);
	public static uint ToUInt32(int value);
	public static uint ToUInt32(long value);
	public static uint ToUInt32(ulong value);
	public static uint ToUInt32(float value);
	public static uint ToUInt32(double value);
	public static uint ToUInt32(Decimal value);
	public static uint ToUInt32(string value, IFormatProvider provider);
	public static long ToInt64(object value, IFormatProvider provider);
	public static long ToInt64(bool value);
	public static long ToInt64(char value);
	public static long ToInt64(sbyte value);
	public static long ToInt64(byte value);
	public static long ToInt64(short value);
	public static long ToInt64(ushort value);
	public static long ToInt64(int value);
	public static long ToInt64(uint value);
	public static long ToInt64(ulong value);
	public static long ToInt64(float value);
	public static long ToInt64(double value);
	public static long ToInt64(Decimal value);
	public static long ToInt64(string value);
	public static long ToInt64(string value, IFormatProvider provider);
	public static ulong ToUInt64(object value, IFormatProvider provider);
	public static ulong ToUInt64(bool value);
	public static ulong ToUInt64(char value);
	public static ulong ToUInt64(sbyte value);
	public static ulong ToUInt64(byte value);
	public static ulong ToUInt64(short value);
	public static ulong ToUInt64(ushort value);
	public static ulong ToUInt64(int value);
	public static ulong ToUInt64(uint value);
	public static ulong ToUInt64(long value);
	public static ulong ToUInt64(float value);
	public static ulong ToUInt64(double value);
	public static ulong ToUInt64(Decimal value);
	public static ulong ToUInt64(string value, IFormatProvider provider);
	public static float ToSingle(object value, IFormatProvider provider);
	public static float ToSingle(sbyte value);
	public static float ToSingle(byte value);
	public static float ToSingle(short value);
	public static float ToSingle(ushort value);
	public static float ToSingle(int value);
	public static float ToSingle(uint value);
	public static float ToSingle(long value);
	public static float ToSingle(ulong value);
	public static float ToSingle(double value);
	public static float ToSingle(Decimal value);
	public static float ToSingle(string value, IFormatProvider provider);
	public static float ToSingle(bool value);
	public static double ToDouble(object value, IFormatProvider provider);
	public static double ToDouble(sbyte value);
	public static double ToDouble(byte value);
	public static double ToDouble(short value);
	public static double ToDouble(ushort value);
	public static double ToDouble(int value);
	public static double ToDouble(uint value);
	public static double ToDouble(long value);
	public static double ToDouble(ulong value);
	public static double ToDouble(float value);
	public static double ToDouble(Decimal value);
	public static double ToDouble(string value, IFormatProvider provider);
	public static double ToDouble(bool value);
	public static Decimal ToDecimal(object value, IFormatProvider provider);
	public static Decimal ToDecimal(sbyte value);
	public static Decimal ToDecimal(byte value);
	public static Decimal ToDecimal(short value);
	public static Decimal ToDecimal(ushort value);
	public static Decimal ToDecimal(int value);
	public static Decimal ToDecimal(uint value);
	public static Decimal ToDecimal(long value);
	public static Decimal ToDecimal(ulong value);
	public static Decimal ToDecimal(float value);
	public static Decimal ToDecimal(double value);
	public static Decimal ToDecimal(string value, IFormatProvider provider);
	public static Decimal ToDecimal(bool value);
	public static DateTime ToDateTime(string value, IFormatProvider provider);
	public static string ToString(object value, IFormatProvider provider);
	public static string ToString(char value, IFormatProvider provider);
	public static string ToString(int value, IFormatProvider provider);
	public static int ToInt32(string value, int fromBase);
	public static string ToBase64String(byte[] inArray);
	public static string ToBase64String(byte[] inArray, int offset, int length, Base64FormattingOptions options);
	private static int ConvertToBase64Array(char* outChars, byte* inData, int offset, int length, bool insertLineBreaks);
	private static int ToBase64_CalculateAndValidateOutputLength(int inputLength, bool insertLineBreaks);
	public static byte[] FromBase64String(string s);
	private static byte[] FromBase64CharPtr(char* inputPtr, int inputLength);
	private static int FromBase64_Decode(char* startInputPtr, int inputLength, byte* startDestPtr, int destLength);
	private static int FromBase64_ComputeResultLength(char* inputPtr, int inputLength);
	private static void .cctor();

}
//NameSpace:System
public struct DateTime : IComparable, IFormattable, IConvertible, ISerializable, IComparable`1<DateTime>, IEquatable`1<DateTime>
{
	// Fields
	private const long TicksPerMillisecond;
	private const long TicksPerSecond;
	private const long TicksPerMinute;
	private const long TicksPerHour;
	private const long TicksPerDay;
	private const int MillisPerSecond;
	private const int MillisPerMinute;
	private const int MillisPerHour;
	private const int MillisPerDay;
	private const int DaysPerYear;
	private const int DaysPer4Years;
	private const int DaysPer100Years;
	private const int DaysPer400Years;
	private const int DaysTo1601;
	private const int DaysTo1899;
	internal const int DaysTo1970;
	private const int DaysTo10000;
	internal const long MinTicks;
	internal const long MaxTicks;
	private const long MaxMillis;
	private const long FileTimeOffset;
	private const long DoubleDateOffset;
	private const long OADateMinAsTicks;
	private const double OADateMinAsDouble;
	private const double OADateMaxAsDouble;
	private const int DatePartYear;
	private const int DatePartDayOfYear;
	private const int DatePartMonth;
	private const int DatePartDay;
	private static readonly int[] DaysToMonth365;
	private static readonly int[] DaysToMonth366;
	public static readonly DateTime MinValue;
	public static readonly DateTime MaxValue;
	private const ulong TicksMask;
	private const ulong FlagsMask;
	private const ulong LocalMask;
	private const long TicksCeiling;
	private const ulong KindUnspecified;
	private const ulong KindUtc;
	private const ulong KindLocal;
	private const ulong KindLocalAmbiguousDst;
	private const int KindShift;
	private const string TicksField;
	private const string DateDataField;
	private ulong dateData;

	// Properties
	internal long InternalTicks { get; }
	private ulong InternalKind { get; }
	public DateTime Date { get; }
	public int Day { get; }
	public DayOfWeek DayOfWeek { get; }
	public int Hour { get; }
	public DateTimeKind Kind { get; }
	public int Minute { get; }
	public int Month { get; }
	public static DateTime Now { get; }
	public static DateTime UtcNow { get; }
	public int Second { get; }
	public long Ticks { get; }
	public TimeSpan TimeOfDay { get; }
	public int Year { get; }

	// Methods
	public void .ctor(long ticks);
	private void .ctor(ulong dateData);
	public void .ctor(long ticks, DateTimeKind kind);
	internal void .ctor(long ticks, DateTimeKind kind, bool isAmbiguousDst);
	public void .ctor(int year, int month, int day);
	public void .ctor(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);
	public void .ctor(int year, int month, int day, int hour, int minute, int second, int millisecond);
	private void .ctor(SerializationInfo info, StreamingContext context);
	internal long get_InternalTicks();
	private ulong get_InternalKind();
	public DateTime Add(TimeSpan value);
	private DateTime Add(double value, int scale);
	public DateTime AddDays(double value);
	public DateTime AddMilliseconds(double value);
	public DateTime AddMonths(int months);
	public DateTime AddSeconds(double value);
	public DateTime AddTicks(long value);
	public DateTime AddYears(int value);
	public int CompareTo(object value);
	public int CompareTo(DateTime value);
	private static long DateToTicks(int year, int month, int day);
	private static long TimeToTicks(int hour, int minute, int second);
	public static int DaysInMonth(int year, int month);
	public override bool Equals(object value);
	public bool Equals(DateTime value);
	public static DateTime FromBinary(long dateData);
	internal static DateTime FromBinaryRaw(long dateData);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	public static DateTime SpecifyKind(DateTime value, DateTimeKind kind);
	internal long ToBinaryRaw();
	public DateTime get_Date();
	private int GetDatePart(int part);
	public int get_Day();
	public DayOfWeek get_DayOfWeek();
	public override int GetHashCode();
	public int get_Hour();
	public DateTimeKind get_Kind();
	public int get_Minute();
	public int get_Month();
	public static DateTime get_Now();
	public static DateTime get_UtcNow();
	internal static long GetSystemTimeAsFileTime();
	public int get_Second();
	public long get_Ticks();
	public TimeSpan get_TimeOfDay();
	public int get_Year();
	public static bool IsLeapYear(int year);
	public static DateTime Parse(string s, IFormatProvider provider);
	public static DateTime ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style);
	public override string ToString();
	public string ToString(IFormatProvider provider);
	public string ToString(string format, IFormatProvider provider);
	public DateTime ToUniversalTime();
	public static DateTime op_Addition(DateTime d, TimeSpan t);
	public static DateTime op_Subtraction(DateTime d, TimeSpan t);
	public static TimeSpan op_Subtraction(DateTime d1, DateTime d2);
	public static bool op_Equality(DateTime d1, DateTime d2);
	public static bool op_LessThan(DateTime t1, DateTime t2);
	public static bool op_LessThanOrEqual(DateTime t1, DateTime t2);
	public static bool op_GreaterThan(DateTime t1, DateTime t2);
	public static bool op_GreaterThanOrEqual(DateTime t1, DateTime t2);
	public TypeCode GetTypeCode();
	private bool System.IConvertible.ToBoolean(IFormatProvider provider);
	private char System.IConvertible.ToChar(IFormatProvider provider);
	private sbyte System.IConvertible.ToSByte(IFormatProvider provider);
	private byte System.IConvertible.ToByte(IFormatProvider provider);
	private short System.IConvertible.ToInt16(IFormatProvider provider);
	private ushort System.IConvertible.ToUInt16(IFormatProvider provider);
	private int System.IConvertible.ToInt32(IFormatProvider provider);
	private uint System.IConvertible.ToUInt32(IFormatProvider provider);
	private long System.IConvertible.ToInt64(IFormatProvider provider);
	private ulong System.IConvertible.ToUInt64(IFormatProvider provider);
	private float System.IConvertible.ToSingle(IFormatProvider provider);
	private double System.IConvertible.ToDouble(IFormatProvider provider);
	private Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
	private DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
	private object System.IConvertible.ToType(Type type, IFormatProvider provider);
	internal static bool TryCreate(int year, int month, int day, int hour, int minute, int second, int millisecond, out DateTime result);
	private static void .cctor();

}
//NameSpace:System
public enum DateTimeKind
{
	// Fields
	public int value__;
	public const DateTimeKind Unspecified;
	public const DateTimeKind Utc;
	public const DateTimeKind Local;

}
//NameSpace:System
public enum DayOfWeek
{
	// Fields
	public int value__;
	public const DayOfWeek Sunday;
	public const DayOfWeek Monday;
	public const DayOfWeek Tuesday;
	public const DayOfWeek Wednesday;
	public const DayOfWeek Thursday;
	public const DayOfWeek Friday;
	public const DayOfWeek Saturday;

}
//NameSpace:System
public sealed class DBNull : ISerializable, IConvertible
{
	// Fields
	public static readonly DBNull Value;

	// Methods
	private void .ctor();
	private void .ctor(SerializationInfo info, StreamingContext context);
	public void GetObjectData(SerializationInfo info, StreamingContext context);
	public override string ToString();
	public string ToString(IFormatProvider provider);
	public TypeCode GetTypeCode();
	private bool System.IConvertible.ToBoolean(IFormatProvider provider);
	private char System.IConvertible.ToChar(IFormatProvider provider);
	private sbyte System.IConvertible.ToSByte(IFormatProvider provider);
	private byte System.IConvertible.ToByte(IFormatProvider provider);
	private short System.IConvertible.ToInt16(IFormatProvider provider);
	private ushort System.IConvertible.ToUInt16(IFormatProvider provider);
	private int System.IConvertible.ToInt32(IFormatProvider provider);
	private uint System.IConvertible.ToUInt32(IFormatProvider provider);
	private long System.IConvertible.ToInt64(IFormatProvider provider);
	private ulong System.IConvertible.ToUInt64(IFormatProvider provider);
	private float System.IConvertible.ToSingle(IFormatProvider provider);
	private double System.IConvertible.ToDouble(IFormatProvider provider);
	private Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
	private DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
	private object System.IConvertible.ToType(Type type, IFormatProvider provider);
	private static void .cctor();

}
//NameSpace:System
public struct Decimal : IFormattable, IComparable, IConvertible, IDeserializationCallback, IComparable`1<Decimal>, IEquatable`1<Decimal>
{
	// Fields
	private const int SignMask;
	private const byte DECIMAL_NEG;
	private const byte DECIMAL_ADD;
	private const int ScaleMask;
	private const int ScaleShift;
	private const int MaxInt32Scale;
	private static uint[] Powers10;
	public static readonly Decimal Zero;
	public static readonly Decimal One;
	public static readonly Decimal MinusOne;
	public static readonly Decimal MaxValue;
	public static readonly Decimal MinValue;
	private static readonly Decimal NearNegativeZero;
	private static readonly Decimal NearPositiveZero;
	private int flags;
	private int hi;
	private int lo;
	private int mid;

	// Methods
	public void .ctor(int value);
	public void .ctor(uint value);
	public void .ctor(long value);
	public void .ctor(ulong value);
	public void .ctor(float value);
	public void .ctor(double value);
	public void .ctor(int[] bits);
	private void SetBits(int[] bits);
	public void .ctor(int lo, int mid, int hi, bool isNegative, byte scale);
	private void OnSerializing(StreamingContext ctx);
	private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
	private void .ctor(int lo, int mid, int hi, int flags);
	private static int FCallCompare(Decimal d1, Decimal d2);
	public int CompareTo(object value);
	public int CompareTo(Decimal value);
	public override bool Equals(object value);
	public bool Equals(Decimal value);
	public override int GetHashCode();
	public override string ToString();
	public string ToString(IFormatProvider provider);
	public string ToString(string format, IFormatProvider provider);
	public static Decimal Parse(string s, IFormatProvider provider);
	public static Decimal Parse(string s, NumberStyles style, IFormatProvider provider);
	public static int[] GetBits(Decimal d);
	internal static Decimal ToDecimal(byte[] buffer);
	public static Decimal Round(Decimal d, int decimals);
	private static void FCallRound(Decimal d, int decimals);
	public static byte ToByte(Decimal value);
	public static sbyte ToSByte(Decimal value);
	public static short ToInt16(Decimal value);
	public static double ToDouble(Decimal d);
	internal static int FCallToInt32(Decimal d);
	public static int ToInt32(Decimal d);
	public static long ToInt64(Decimal d);
	public static ushort ToUInt16(Decimal value);
	public static uint ToUInt32(Decimal d);
	public static ulong ToUInt64(Decimal d);
	public static float ToSingle(Decimal d);
	private static void FCallTruncate(Decimal d);
	public static Decimal op_Implicit(byte value);
	public static Decimal op_Implicit(sbyte value);
	public static Decimal op_Implicit(short value);
	public static Decimal op_Implicit(ushort value);
	public static Decimal op_Implicit(int value);
	public static Decimal op_Implicit(uint value);
	public static Decimal op_Implicit(long value);
	public static Decimal op_Implicit(ulong value);
	public static Decimal op_Explicit(float value);
	public static Decimal op_Explicit(double value);
	public static float op_Explicit(Decimal value);
	public static double op_Explicit(Decimal value);
	public static bool op_Equality(Decimal d1, Decimal d2);
	public static bool op_Inequality(Decimal d1, Decimal d2);
	public TypeCode GetTypeCode();
	private bool System.IConvertible.ToBoolean(IFormatProvider provider);
	private char System.IConvertible.ToChar(IFormatProvider provider);
	private sbyte System.IConvertible.ToSByte(IFormatProvider provider);
	private byte System.IConvertible.ToByte(IFormatProvider provider);
	private short System.IConvertible.ToInt16(IFormatProvider provider);
	private ushort System.IConvertible.ToUInt16(IFormatProvider provider);
	private int System.IConvertible.ToInt32(IFormatProvider provider);
	private uint System.IConvertible.ToUInt32(IFormatProvider provider);
	private long System.IConvertible.ToInt64(IFormatProvider provider);
	private ulong System.IConvertible.ToUInt64(IFormatProvider provider);
	private float System.IConvertible.ToSingle(IFormatProvider provider);
	private double System.IConvertible.ToDouble(IFormatProvider provider);
	private Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
	private DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
	private object System.IConvertible.ToType(Type type, IFormatProvider provider);
	private static void .cctor();

}
//NameSpace:System
internal class DefaultBinder : Binder
{
	// Methods
	public override MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, object[] args, ParameterModifier[] modifiers, CultureInfo cultureInfo, string[] names, out object state);
	public override FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo cultureInfo);
	public override MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
	public override PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
	public override object ChangeType(object value, Type type, CultureInfo cultureInfo);
	public override void ReorderArgumentArray(object[] args, object state);
	public static MethodBase ExactBinding(MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
	public static PropertyInfo ExactPropertyBinding(PropertyInfo[] match, Type returnType, Type[] types, ParameterModifier[] modifiers);
	private static int FindMostSpecific(ParameterInfo[] p1, int[] paramOrder1, Type paramArrayType1, ParameterInfo[] p2, int[] paramOrder2, Type paramArrayType2, Type[] types, object[] args);
	private static int FindMostSpecificType(Type c1, Type c2, Type t);
	private static int FindMostSpecificMethod(MethodBase m1, int[] paramOrder1, Type paramArrayType1, MethodBase m2, int[] paramOrder2, Type paramArrayType2, Type[] types, object[] args);
	private static int FindMostSpecificField(FieldInfo cur1, FieldInfo cur2);
	private static int FindMostSpecificProperty(PropertyInfo cur1, PropertyInfo cur2);
	internal static bool CompareMethodSigAndName(MethodBase m1, MethodBase m2);
	internal static int GetHierarchyDepth(Type t);
	internal static MethodBase FindMostDerivedNewSlotMeth(MethodBase[] match, int cMatches);
	private static void ReorderParams(int[] paramOrder, object[] vars);
	private static bool CreateParamOrder(int[] paramOrder, ParameterInfo[] pars, string[] names);
	private static bool CanConvertPrimitive(RuntimeType source, RuntimeType target);
	private static bool CanConvertPrimitiveObjectToType(object source, RuntimeType type);
	public void .ctor();

}
//NameSpace:
internal class DefaultBinder.BinderState
{
	// Fields
	internal int[] m_argsMap;
	internal int m_originalSize;
	internal bool m_isParamArray;

	// Methods
	internal void .ctor(int[] argsMap, int originalSize, bool isParamArray);

}
//NameSpace:
private sealed class DefaultBinder.<>c
{
	// Fields
	public static readonly DefaultBinder.<>c <>9;
	public static Predicate`1<Type> <>9__3_0;

	// Methods
	private static void .cctor();
	public void .ctor();
	internal bool <SelectProperty>b__3_0(Type t);

}
//NameSpace:System
public class DivideByZeroException : ArithmeticException
{
	// Methods
	public void .ctor();
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class DllNotFoundException : TypeLoadException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public struct Double : IComparable, IFormattable, IConvertible, IComparable`1<double>, IEquatable`1<double>
{
	// Fields
	internal double m_value;
	public const double MinValue;
	public const double MaxValue;
	public const double Epsilon;
	public const double NegativeInfinity;
	public const double PositiveInfinity;
	public const double NaN;
	internal static double NegativeZero;

	// Methods
	public static bool IsPositiveInfinity(double d);
	public static bool IsNaN(double d);
	public int CompareTo(object value);
	public int CompareTo(double value);
	public override bool Equals(object obj);
	public bool Equals(double obj);
	public override int GetHashCode();
	public override string ToString();
	public string ToString(IFormatProvider provider);
	public string ToString(string format, IFormatProvider provider);
	public static double Parse(string s);
	public static double Parse(string s, IFormatProvider provider);
	public static double Parse(string s, NumberStyles style, IFormatProvider provider);
	private static double Parse(string s, NumberStyles style, NumberFormatInfo info);
	public TypeCode GetTypeCode();
	private bool System.IConvertible.ToBoolean(IFormatProvider provider);
	private char System.IConvertible.ToChar(IFormatProvider provider);
	private sbyte System.IConvertible.ToSByte(IFormatProvider provider);
	private byte System.IConvertible.ToByte(IFormatProvider provider);
	private short System.IConvertible.ToInt16(IFormatProvider provider);
	private ushort System.IConvertible.ToUInt16(IFormatProvider provider);
	private int System.IConvertible.ToInt32(IFormatProvider provider);
	private uint System.IConvertible.ToUInt32(IFormatProvider provider);
	private long System.IConvertible.ToInt64(IFormatProvider provider);
	private ulong System.IConvertible.ToUInt64(IFormatProvider provider);
	private float System.IConvertible.ToSingle(IFormatProvider provider);
	private double System.IConvertible.ToDouble(IFormatProvider provider);
	private Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
	private DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
	private object System.IConvertible.ToType(Type type, IFormatProvider provider);
	private static void .cctor();

}
//NameSpace:System
internal sealed class Empty : ISerializable
{
	// Fields
	public static readonly Empty Value;

	// Methods
	private void .ctor();
	public override string ToString();
	public void GetObjectData(SerializationInfo info, StreamingContext context);
	private static void .cctor();

}
//NameSpace:System
public class EntryPointNotFoundException : TypeLoadException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public abstract struct Enum : IComparable, IFormattable, IConvertible
{
	// Fields
	private static readonly char[] enumSeperatorCharArray;
	private const string enumSeperator;

	// Methods
	private static Enum.ValuesAndNames GetCachedValuesAndNames(RuntimeType enumType, bool getNames);
	private static string InternalFormattedHexString(object value);
	private static string InternalFormat(RuntimeType eT, object value);
	private static string InternalFlagsFormat(RuntimeType eT, object value);
	internal static ulong ToUInt64(object value);
	private static int InternalCompareTo(object o1, object o2);
	internal static RuntimeType InternalGetUnderlyingType(RuntimeType enumType);
	private static bool GetEnumValuesAndNames(RuntimeType enumType, out ulong[] values, out string[] names);
	public static Type GetUnderlyingType(Type enumType);
	internal static ulong[] InternalGetValues(RuntimeType enumType);
	public static string GetName(Type enumType, object value);
	internal static string[] InternalGetNames(RuntimeType enumType);
	public static bool IsDefined(Type enumType, object value);
	private object get_value();
	internal object GetValue();
	private bool InternalHasFlag(Enum flags);
	private int get_hashcode();
	public override bool Equals(object obj);
	public override int GetHashCode();
	public override string ToString();
	public string ToString(string format, IFormatProvider provider);
	public int CompareTo(object target);
	public string ToString(string format);
	public string ToString(IFormatProvider provider);
	public bool HasFlag(Enum flag);
	public TypeCode GetTypeCode();
	private bool System.IConvertible.ToBoolean(IFormatProvider provider);
	private char System.IConvertible.ToChar(IFormatProvider provider);
	private sbyte System.IConvertible.ToSByte(IFormatProvider provider);
	private byte System.IConvertible.ToByte(IFormatProvider provider);
	private short System.IConvertible.ToInt16(IFormatProvider provider);
	private ushort System.IConvertible.ToUInt16(IFormatProvider provider);
	private int System.IConvertible.ToInt32(IFormatProvider provider);
	private uint System.IConvertible.ToUInt32(IFormatProvider provider);
	private long System.IConvertible.ToInt64(IFormatProvider provider);
	private ulong System.IConvertible.ToUInt64(IFormatProvider provider);
	private float System.IConvertible.ToSingle(IFormatProvider provider);
	private double System.IConvertible.ToDouble(IFormatProvider provider);
	private Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
	private DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
	private object System.IConvertible.ToType(Type type, IFormatProvider provider);
	protected void .ctor();
	private static void .cctor();

}
//NameSpace:
private class Enum.ValuesAndNames
{
	// Fields
	public ulong[] Values;
	public string[] Names;

	// Methods
	public void .ctor(ulong[] values, string[] names);

}
//NameSpace:System
public class EventArgs
{
	// Fields
	public static readonly EventArgs Empty;

	// Methods
	public void .ctor();
	private static void .cctor();

}
//NameSpace:System
public sealed class EventHandler : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(object sender, EventArgs e);
	public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System
public sealed class EventHandler`1 : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(object sender, T e);
	public virtual IAsyncResult BeginInvoke(object sender, T e, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System
public class Exception : ISerializable, _Exception
{
	// Fields
	private static object s_EDILock;
	private string _className;
	internal string _message;
	private IDictionary _data;
	private Exception _innerException;
	private string _helpURL;
	private object _stackTrace;
	private string _stackTraceString;
	private string _remoteStackTraceString;
	private int _remoteStackIndex;
	private object _dynamicMethods;
	internal int _HResult;
	private string _source;
	private SafeSerializationManager _safeSerializationManager;
	internal StackTrace[] captured_traces;
	private IntPtr[] native_trace_ips;
	private const int _COMPlusExceptionCode;

	// Properties
	public virtual string Message { get; }
	public Exception InnerException { get; }
	public virtual string StackTrace { get; }
	public virtual string Source { get; }
	public int HResult { get; set; }

	// Methods
	private void Init();
	public void .ctor();
	public void .ctor(string message);
	public void .ctor(string message, Exception innerException);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public virtual string get_Message();
	private string GetClassName();
	public Exception get_InnerException();
	public virtual string get_StackTrace();
	private string GetStackTrace(bool needFileInfo);
	internal void SetErrorCode(int hr);
	public virtual string get_Source();
	public override string ToString();
	private string ToString(bool needFileLineInfo, bool needMessage);
	public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
	private void OnDeserialized(StreamingContext context);
	private string StripFileInfo(string stackTrace, bool isRemoteStackTrace);
	internal void RestoreExceptionDispatchInfo(ExceptionDispatchInfo exceptionDispatchInfo);
	public int get_HResult();
	protected void set_HResult(int value);
	public Type GetType();
	internal static string GetMessageFromNativeResources(Exception.ExceptionMessageKind kind);
	internal Exception FixRemotingException();
	private static void .cctor();

}
//NameSpace:
internal enum Exception.ExceptionMessageKind
{
	// Fields
	public int value__;
	public const Exception.ExceptionMessageKind ThreadAbort;
	public const Exception.ExceptionMessageKind ThreadInterrupted;
	public const Exception.ExceptionMessageKind OutOfMemory;

}
//NameSpace:System
public sealed class ExecutionEngineException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	public void .ctor(string message, Exception innerException);
	internal void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class FieldAccessException : MemberAccessException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class FlagsAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System
public class FormatException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	public void .ctor(string message, Exception innerException);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public static class GC
{
	// Fields
	internal static readonly object EPHEMERON_TOMBSTONE;

	// Methods
	internal static void register_ephemeron_array(Ephemeron[] array);
	private static object get_ephemeron_tombstone();
	public static void KeepAlive(object obj);
	private static void _SuppressFinalize(object o);
	public static void SuppressFinalize(object obj);
	private static void _ReRegisterForFinalize(object o);
	public static void ReRegisterForFinalize(object obj);
	private static void .cctor();

}
//NameSpace:System
internal static class DateTimeFormat
{
	// Fields
	internal static readonly TimeSpan NullOffset;
	internal static char[] allStandardFormats;
	internal static string[] fixedNumberFormats;

	// Methods
	internal static void FormatDigits(StringBuilder outputBuffer, int value, int len);
	internal static void FormatDigits(StringBuilder outputBuffer, int value, int len, bool overrideLengthLimit);
	private static void HebrewFormatDigits(StringBuilder outputBuffer, int digits);
	internal static int ParseRepeatPattern(string format, int pos, char patternChar);
	private static string FormatDayOfWeek(int dayOfWeek, int repeat, DateTimeFormatInfo dtfi);
	private static string FormatMonth(int month, int repeatCount, DateTimeFormatInfo dtfi);
	private static string FormatHebrewMonthName(DateTime time, int month, int repeatCount, DateTimeFormatInfo dtfi);
	internal static int ParseQuoteString(string format, int pos, StringBuilder result);
	internal static int ParseNextChar(string format, int pos);
	private static bool IsUseGenitiveForm(string format, int index, int tokenLen, char patternToMatch);
	private static string FormatCustomized(DateTime dateTime, string format, DateTimeFormatInfo dtfi, TimeSpan offset);
	private static void FormatCustomizedTimeZone(DateTime dateTime, TimeSpan offset, string format, int tokenLen, bool timeOnly, StringBuilder result);
	private static void FormatCustomizedRoundripTimeZone(DateTime dateTime, TimeSpan offset, StringBuilder result);
	internal static string GetRealFormat(string format, DateTimeFormatInfo dtfi);
	private static string ExpandPredefinedFormat(string format, DateTime dateTime, DateTimeFormatInfo dtfi, TimeSpan offset);
	internal static string Format(DateTime dateTime, string format, DateTimeFormatInfo dtfi);
	internal static string Format(DateTime dateTime, string format, DateTimeFormatInfo dtfi, TimeSpan offset);
	internal static void InvalidFormatForLocal(string format, DateTime dateTime);
	internal static void InvalidFormatForUtc(string format, DateTime dateTime);
	private static void .cctor();

}
//NameSpace:System
internal static class DateTimeParse
{
	// Fields
	internal static DateTimeParse.MatchNumberDelegate m_hebrewNumberParser;
	private static DateTimeParse.DS[][] dateParsingStates;

	// Methods
	internal static DateTime ParseExact(string s, string format, DateTimeFormatInfo dtfi, DateTimeStyles style);
	internal static bool TryParseExact(string s, string format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTimeResult result);
	private static bool MatchWord(__DTString str, string target);
	private static bool GetTimeZoneName(__DTString str);
	internal static bool IsDigit(char ch);
	private static bool ParseFraction(__DTString str, out double result);
	private static bool ParseTimeZone(__DTString str, TimeSpan result);
	private static bool HandleTimeZone(__DTString str, DateTimeResult result);
	private static bool Lex(DateTimeParse.DS dps, __DTString str, DateTimeToken dtok, DateTimeRawInfo raw, DateTimeResult result, DateTimeFormatInfo dtfi, DateTimeStyles styles);
	private static bool VerifyValidPunctuation(__DTString str);
	private static bool GetYearMonthDayOrder(string datePattern, DateTimeFormatInfo dtfi, out int order);
	private static bool GetYearMonthOrder(string pattern, DateTimeFormatInfo dtfi, out int order);
	private static bool GetMonthDayOrder(string pattern, DateTimeFormatInfo dtfi, out int order);
	private static bool TryAdjustYear(DateTimeResult result, int year, out int adjustedYear);
	private static bool SetDateYMD(DateTimeResult result, int year, int month, int day);
	private static bool SetDateMDY(DateTimeResult result, int month, int day, int year);
	private static bool SetDateDMY(DateTimeResult result, int day, int month, int year);
	private static bool SetDateYDM(DateTimeResult result, int year, int day, int month);
	private static void GetDefaultYear(DateTimeResult result, DateTimeStyles styles);
	private static bool GetDayOfNN(DateTimeResult result, DateTimeStyles styles, DateTimeRawInfo raw, DateTimeFormatInfo dtfi);
	private static bool GetDayOfNNN(DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi);
	private static bool GetDayOfMN(DateTimeResult result, DateTimeStyles styles, DateTimeRawInfo raw, DateTimeFormatInfo dtfi);
	private static bool GetHebrewDayOfNM(DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi);
	private static bool GetDayOfNM(DateTimeResult result, DateTimeStyles styles, DateTimeRawInfo raw, DateTimeFormatInfo dtfi);
	private static bool GetDayOfMNN(DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi);
	private static bool GetDayOfYNN(DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi);
	private static bool GetDayOfNNY(DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi);
	private static bool GetDayOfYMN(DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi);
	private static bool GetDayOfYN(DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi);
	private static bool GetDayOfYM(DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi);
	private static void AdjustTimeMark(DateTimeFormatInfo dtfi, DateTimeRawInfo raw);
	private static bool AdjustHour(int hour, DateTimeParse.TM timeMark);
	private static bool GetTimeOfN(DateTimeFormatInfo dtfi, DateTimeResult result, DateTimeRawInfo raw);
	private static bool GetTimeOfNN(DateTimeFormatInfo dtfi, DateTimeResult result, DateTimeRawInfo raw);
	private static bool GetTimeOfNNN(DateTimeFormatInfo dtfi, DateTimeResult result, DateTimeRawInfo raw);
	private static bool GetDateOfDSN(DateTimeResult result, DateTimeRawInfo raw);
	private static bool GetDateOfNDS(DateTimeResult result, DateTimeRawInfo raw);
	private static bool GetDateOfNNDS(DateTimeResult result, DateTimeRawInfo raw, DateTimeFormatInfo dtfi);
	private static bool ProcessDateTimeSuffix(DateTimeResult result, DateTimeRawInfo raw, DateTimeToken dtok);
	internal static bool ProcessHebrewTerminalState(DateTimeParse.DS dps, DateTimeResult result, DateTimeStyles styles, DateTimeRawInfo raw, DateTimeFormatInfo dtfi);
	internal static bool ProcessTerminaltState(DateTimeParse.DS dps, DateTimeResult result, DateTimeStyles styles, DateTimeRawInfo raw, DateTimeFormatInfo dtfi);
	internal static DateTime Parse(string s, DateTimeFormatInfo dtfi, DateTimeStyles styles);
	internal static bool TryParse(string s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTimeResult result);
	private static bool DetermineTimeZoneAdjustments(DateTimeResult result, DateTimeStyles styles, bool bTimeOnly);
	private static bool DateTimeOffsetTimeZonePostProcessing(DateTimeResult result, DateTimeStyles styles);
	private static bool AdjustTimeZoneToUniversal(DateTimeResult result);
	private static bool AdjustTimeZoneToLocal(DateTimeResult result, bool bTimeOnly);
	private static bool ParseISO8601(DateTimeRawInfo raw, __DTString str, DateTimeStyles styles, DateTimeResult result);
	internal static bool MatchHebrewDigits(__DTString str, int digitLen, out int number);
	internal static bool ParseDigits(__DTString str, int digitLen, out int result);
	internal static bool ParseDigits(__DTString str, int minDigitLen, int maxDigitLen, out int result);
	private static bool ParseFractionExact(__DTString str, int maxDigitLen, double result);
	private static bool ParseSign(__DTString str, bool result);
	private static bool ParseTimeZoneOffset(__DTString str, int len, TimeSpan result);
	private static bool MatchAbbreviatedMonthName(__DTString str, DateTimeFormatInfo dtfi, int result);
	private static bool MatchMonthName(__DTString str, DateTimeFormatInfo dtfi, int result);
	private static bool MatchAbbreviatedDayName(__DTString str, DateTimeFormatInfo dtfi, int result);
	private static bool MatchDayName(__DTString str, DateTimeFormatInfo dtfi, int result);
	private static bool MatchEraName(__DTString str, DateTimeFormatInfo dtfi, int result);
	private static bool MatchTimeMark(__DTString str, DateTimeFormatInfo dtfi, DateTimeParse.TM result);
	private static bool MatchAbbreviatedTimeMark(__DTString str, DateTimeFormatInfo dtfi, DateTimeParse.TM result);
	private static bool CheckNewValue(int currentValue, int newValue, char patternChar, DateTimeResult result);
	private static DateTime GetDateTimeNow(DateTimeResult result, DateTimeStyles styles);
	private static bool CheckDefaultDateTime(DateTimeResult result, Calendar cal, DateTimeStyles styles);
	private static string ExpandPredefinedFormat(string format, DateTimeFormatInfo dtfi, ParsingInfo parseInfo, DateTimeResult result);
	private static bool ParseByFormat(__DTString str, __DTString format, ParsingInfo parseInfo, DateTimeFormatInfo dtfi, DateTimeResult result);
	internal static bool TryParseQuoteString(string format, int pos, StringBuilder result, out int returnValue);
	private static bool DoStrictParse(string s, string formatParam, DateTimeStyles styles, DateTimeFormatInfo dtfi, DateTimeResult result);
	private static Exception GetDateTimeParseException(DateTimeResult result);
	private static void .cctor();

}
//NameSpace:
internal sealed class DateTimeParse.MatchNumberDelegate : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual bool Invoke(__DTString str, int digitLen, out int result);
	public virtual IAsyncResult BeginInvoke(__DTString str, int digitLen, out int result, AsyncCallback callback, object object);
	public virtual bool EndInvoke(__DTString str, out int result, IAsyncResult __result);

}
//NameSpace:
internal enum DateTimeParse.DTT
{
	// Fields
	public int value__;
	public const DateTimeParse.DTT End;
	public const DateTimeParse.DTT NumEnd;
	public const DateTimeParse.DTT NumAmpm;
	public const DateTimeParse.DTT NumSpace;
	public const DateTimeParse.DTT NumDatesep;
	public const DateTimeParse.DTT NumTimesep;
	public const DateTimeParse.DTT MonthEnd;
	public const DateTimeParse.DTT MonthSpace;
	public const DateTimeParse.DTT MonthDatesep;
	public const DateTimeParse.DTT NumDatesuff;
	public const DateTimeParse.DTT NumTimesuff;
	public const DateTimeParse.DTT DayOfWeek;
	public const DateTimeParse.DTT YearSpace;
	public const DateTimeParse.DTT YearDateSep;
	public const DateTimeParse.DTT YearEnd;
	public const DateTimeParse.DTT TimeZone;
	public const DateTimeParse.DTT Era;
	public const DateTimeParse.DTT NumUTCTimeMark;
	public const DateTimeParse.DTT Unk;
	public const DateTimeParse.DTT NumLocalTimeMark;
	public const DateTimeParse.DTT Max;

}
//NameSpace:
internal enum DateTimeParse.TM
{
	// Fields
	public int value__;
	public const DateTimeParse.TM NotSet;
	public const DateTimeParse.TM AM;
	public const DateTimeParse.TM PM;

}
//NameSpace:
internal enum DateTimeParse.DS
{
	// Fields
	public int value__;
	public const DateTimeParse.DS BEGIN;
	public const DateTimeParse.DS N;
	public const DateTimeParse.DS NN;
	public const DateTimeParse.DS D_Nd;
	public const DateTimeParse.DS D_NN;
	public const DateTimeParse.DS D_NNd;
	public const DateTimeParse.DS D_M;
	public const DateTimeParse.DS D_MN;
	public const DateTimeParse.DS D_NM;
	public const DateTimeParse.DS D_MNd;
	public const DateTimeParse.DS D_NDS;
	public const DateTimeParse.DS D_Y;
	public const DateTimeParse.DS D_YN;
	public const DateTimeParse.DS D_YNd;
	public const DateTimeParse.DS D_YM;
	public const DateTimeParse.DS D_YMd;
	public const DateTimeParse.DS D_S;
	public const DateTimeParse.DS T_S;
	public const DateTimeParse.DS T_Nt;
	public const DateTimeParse.DS T_NNt;
	public const DateTimeParse.DS ERROR;
	public const DateTimeParse.DS DX_NN;
	public const DateTimeParse.DS DX_NNN;
	public const DateTimeParse.DS DX_MN;
	public const DateTimeParse.DS DX_NM;
	public const DateTimeParse.DS DX_MNN;
	public const DateTimeParse.DS DX_DS;
	public const DateTimeParse.DS DX_DSN;
	public const DateTimeParse.DS DX_NDS;
	public const DateTimeParse.DS DX_NNDS;
	public const DateTimeParse.DS DX_YNN;
	public const DateTimeParse.DS DX_YMN;
	public const DateTimeParse.DS DX_YN;
	public const DateTimeParse.DS DX_YM;
	public const DateTimeParse.DS TX_N;
	public const DateTimeParse.DS TX_NN;
	public const DateTimeParse.DS TX_NNN;
	public const DateTimeParse.DS TX_TS;
	public const DateTimeParse.DS DX_NNY;

}
//NameSpace:System
internal struct __DTString
{
	// Fields
	internal string Value;
	internal int Index;
	internal int len;
	internal char m_current;
	private CompareInfo m_info;
	private bool m_checkDigitToken;
	private static char[] WhiteSpaceChecks;

	// Properties
	internal CompareInfo CompareInfo { get; }

	// Methods
	internal void .ctor(string str, DateTimeFormatInfo dtfi, bool checkDigitToken);
	internal void .ctor(string str, DateTimeFormatInfo dtfi);
	internal CompareInfo get_CompareInfo();
	internal bool GetNext();
	internal bool AtEnd();
	internal bool Advance(int count);
	internal void GetRegularToken(out TokenType tokenType, out int tokenValue, DateTimeFormatInfo dtfi);
	internal TokenType GetSeparatorToken(DateTimeFormatInfo dtfi, out int indexBeforeSeparator, out char charBeforeSeparator);
	internal bool MatchSpecifiedWord(string target);
	internal bool MatchSpecifiedWord(string target, int endIndex);
	internal bool MatchSpecifiedWords(string target, bool checkWordBoundary, int matchLength);
	internal bool Match(string str);
	internal bool Match(char ch);
	internal int MatchLongestWords(string[] words, int maxMatchStrLen);
	internal int GetRepeatCount();
	internal bool GetNextDigit();
	internal char GetChar();
	internal int GetDigit();
	internal void SkipWhiteSpaces();
	internal bool SkipWhiteSpaceCurrent();
	internal void TrimTail();
	internal void RemoveTrailingInQuoteSpaces();
	internal void RemoveLeadingInQuoteSpaces();
	internal DTSubString GetSubString();
	internal void ConsumeSubString(DTSubString sub);
	private static void .cctor();

}
//NameSpace:System
internal enum DTSubStringType
{
	// Fields
	public int value__;
	public const DTSubStringType Unknown;
	public const DTSubStringType Invalid;
	public const DTSubStringType Number;
	public const DTSubStringType End;
	public const DTSubStringType Other;

}
//NameSpace:System
internal struct DTSubString
{
	// Fields
	internal string s;
	internal int index;
	internal int length;
	internal DTSubStringType type;
	internal int value;

	// Properties
	internal char Item { get; }

	// Methods
	internal char get_Item(int relativeIndex);

}
//NameSpace:System
internal struct DateTimeToken
{
	// Fields
	internal DateTimeParse.DTT dtt;
	internal TokenType suffix;
	internal int num;

}
//NameSpace:System
internal struct DateTimeRawInfo
{
	// Fields
	private int* num;
	internal int numCount;
	internal int month;
	internal int year;
	internal int dayOfWeek;
	internal int era;
	internal DateTimeParse.TM timeMark;
	internal double fraction;
	internal bool hasSameDateAndTimeSeparators;
	internal bool timeZone;

	// Methods
	internal void Init(int* numberBuffer);
	internal void AddNumber(int value);
	internal int GetNumber(int index);

}
//NameSpace:System
internal enum ParseFailureKind
{
	// Fields
	public int value__;
	public const ParseFailureKind None;
	public const ParseFailureKind ArgumentNull;
	public const ParseFailureKind Format;
	public const ParseFailureKind FormatWithParameter;
	public const ParseFailureKind FormatBadDateTimeCalendar;

}
//NameSpace:System
internal enum ParseFlags
{
	// Fields
	public int value__;
	public const ParseFlags HaveYear;
	public const ParseFlags HaveMonth;
	public const ParseFlags HaveDay;
	public const ParseFlags HaveHour;
	public const ParseFlags HaveMinute;
	public const ParseFlags HaveSecond;
	public const ParseFlags HaveTime;
	public const ParseFlags HaveDate;
	public const ParseFlags TimeZoneUsed;
	public const ParseFlags TimeZoneUtc;
	public const ParseFlags ParsedMonthName;
	public const ParseFlags CaptureOffset;
	public const ParseFlags YearDefault;
	public const ParseFlags Rfc1123Pattern;
	public const ParseFlags UtcSortPattern;

}
//NameSpace:System
internal struct DateTimeResult
{
	// Fields
	internal int Year;
	internal int Month;
	internal int Day;
	internal int Hour;
	internal int Minute;
	internal int Second;
	internal double fraction;
	internal int era;
	internal ParseFlags flags;
	internal TimeSpan timeZoneOffset;
	internal Calendar calendar;
	internal DateTime parsedDate;
	internal ParseFailureKind failure;
	internal string failureMessageID;
	internal object failureMessageFormatArgument;
	internal string failureArgumentName;

	// Methods
	internal void Init();
	internal void SetDate(int year, int month, int day);
	internal void SetFailure(ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument);
	internal void SetFailure(ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument, string failureArgumentName);

}
//NameSpace:System
internal struct ParsingInfo
{
	// Fields
	internal Calendar calendar;
	internal int dayOfWeek;
	internal DateTimeParse.TM timeMark;
	internal bool fUseHour12;
	internal bool fUseTwoDigitYear;
	internal bool fAllowInnerWhite;
	internal bool fAllowTrailingWhite;
	internal bool fCustomNumberParser;
	internal DateTimeParse.MatchNumberDelegate parseNumberDelegate;

	// Methods
	internal void Init();

}
//NameSpace:System
internal enum TokenType
{
	// Fields
	public int value__;
	public const TokenType NumberToken;
	public const TokenType YearNumberToken;
	public const TokenType Am;
	public const TokenType Pm;
	public const TokenType MonthToken;
	public const TokenType EndOfString;
	public const TokenType DayOfWeekToken;
	public const TokenType TimeZoneToken;
	public const TokenType EraToken;
	public const TokenType DateWordToken;
	public const TokenType UnknownToken;
	public const TokenType HebrewNumber;
	public const TokenType JapaneseEraToken;
	public const TokenType TEraToken;
	public const TokenType IgnorableSymbol;
	public const TokenType SEP_Unk;
	public const TokenType SEP_End;
	public const TokenType SEP_Space;
	public const TokenType SEP_Am;
	public const TokenType SEP_Pm;
	public const TokenType SEP_Date;
	public const TokenType SEP_Time;
	public const TokenType SEP_YearSuff;
	public const TokenType SEP_MonthSuff;
	public const TokenType SEP_DaySuff;
	public const TokenType SEP_HourSuff;
	public const TokenType SEP_MinuteSuff;
	public const TokenType SEP_SecondSuff;
	public const TokenType SEP_LocalTimeMark;
	public const TokenType SEP_DateOrOffset;
	public const TokenType RegularTokenMask;
	public const TokenType SeparatorTokenMask;

}
//NameSpace:System
public struct Guid : IFormattable, IComparable, IComparable`1<Guid>, IEquatable`1<Guid>
{
	// Fields
	public static readonly Guid Empty;
	private int _a;
	private short _b;
	private short _c;
	private byte _d;
	private byte _e;
	private byte _f;
	private byte _g;
	private byte _h;
	private byte _i;
	private byte _j;
	private byte _k;
	private static object _rngAccess;
	private static RandomNumberGenerator _rng;

	// Methods
	public void .ctor(byte[] b);
	public void .ctor(string g);
	public static Guid Parse(string input);
	private static bool TryParseGuid(string g, Guid.GuidStyles flags, Guid.GuidResult result);
	private static bool TryParseGuidWithHexPrefix(string guidString, Guid.GuidResult result);
	private static bool TryParseGuidWithNoStyle(string guidString, Guid.GuidResult result);
	private static bool TryParseGuidWithDashes(string guidString, Guid.GuidResult result);
	private static bool StringToShort(string str, int requiredLength, int flags, out short result, Guid.GuidResult parseResult);
	private static bool StringToShort(string str, int* parsePos, int requiredLength, int flags, out short result, Guid.GuidResult parseResult);
	private static bool StringToInt(string str, int requiredLength, int flags, out int result, Guid.GuidResult parseResult);
	private static bool StringToInt(string str, int parsePos, int requiredLength, int flags, out int result, Guid.GuidResult parseResult);
	private static bool StringToInt(string str, int* parsePos, int requiredLength, int flags, out int result, Guid.GuidResult parseResult);
	private static bool StringToLong(string str, int parsePos, int flags, out long result, Guid.GuidResult parseResult);
	private static bool StringToLong(string str, int* parsePos, int flags, out long result, Guid.GuidResult parseResult);
	private static string EatAllWhitespace(string str);
	private static bool IsHexPrefix(string str, int i);
	public override string ToString();
	public override int GetHashCode();
	public override bool Equals(object o);
	public bool Equals(Guid g);
	private int GetResult(uint me, uint them);
	public int CompareTo(object value);
	public int CompareTo(Guid value);
	public static bool op_Equality(Guid a, Guid b);
	public string ToString(string format);
	private static char HexToChar(int a);
	private static int HexsToChars(char* guidChars, int offset, int a, int b);
	private static int HexsToChars(char* guidChars, int offset, int a, int b, bool hex);
	public string ToString(string format, IFormatProvider provider);
	public static Guid NewGuid();
	private static void .cctor();

}
//NameSpace:
private enum Guid.GuidStyles
{
	// Fields
	public int value__;
	public const Guid.GuidStyles None;
	public const Guid.GuidStyles AllowParenthesis;
	public const Guid.GuidStyles AllowBraces;
	public const Guid.GuidStyles AllowDashes;
	public const Guid.GuidStyles AllowHexPrefix;
	public const Guid.GuidStyles RequireParenthesis;
	public const Guid.GuidStyles RequireBraces;
	public const Guid.GuidStyles RequireDashes;
	public const Guid.GuidStyles RequireHexPrefix;
	public const Guid.GuidStyles HexFormat;
	public const Guid.GuidStyles NumberFormat;
	public const Guid.GuidStyles DigitFormat;
	public const Guid.GuidStyles BraceFormat;
	public const Guid.GuidStyles ParenthesisFormat;
	public const Guid.GuidStyles Any;

}
//NameSpace:
private enum Guid.GuidParseThrowStyle
{
	// Fields
	public int value__;
	public const Guid.GuidParseThrowStyle None;
	public const Guid.GuidParseThrowStyle All;
	public const Guid.GuidParseThrowStyle AllButOverflow;

}
//NameSpace:
private enum Guid.ParseFailureKind
{
	// Fields
	public int value__;
	public const Guid.ParseFailureKind None;
	public const Guid.ParseFailureKind ArgumentNull;
	public const Guid.ParseFailureKind Format;
	public const Guid.ParseFailureKind FormatWithParameter;
	public const Guid.ParseFailureKind NativeException;
	public const Guid.ParseFailureKind FormatWithInnerException;

}
//NameSpace:
private struct Guid.GuidResult
{
	// Fields
	internal Guid parsedGuid;
	internal Guid.GuidParseThrowStyle throwStyle;
	internal Guid.ParseFailureKind m_failure;
	internal string m_failureMessageID;
	internal object m_failureMessageFormatArgument;
	internal string m_failureArgumentName;
	internal Exception m_innerException;

	// Methods
	internal void Init(Guid.GuidParseThrowStyle canThrow);
	internal void SetFailure(Exception nativeException);
	internal void SetFailure(Guid.ParseFailureKind failure, string failureMessageID);
	internal void SetFailure(Guid.ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument);
	internal void SetFailure(Guid.ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument, string failureArgumentName, Exception innerException);
	internal Exception GetGuidParseException();

}
//NameSpace:System
public interface _AppDomain
{
}
//NameSpace:System
public interface IAppDomainSetup
{
}
//NameSpace:System
public interface IAsyncResult
{
	// Properties
	public abstract WaitHandle AsyncWaitHandle { get; }
	public abstract object AsyncState { get; }
	public abstract bool CompletedSynchronously { get; }

	// Methods
	public abstract WaitHandle get_AsyncWaitHandle();
	public abstract object get_AsyncState();
	public abstract bool get_CompletedSynchronously();

}
//NameSpace:System
public interface ICloneable
{
	// Methods
	public abstract object Clone();

}
//NameSpace:System
public interface IComparable
{
	// Methods
	public abstract int CompareTo(object obj);

}
//NameSpace:System
public interface IComparable`1
{
	// Methods
	public abstract int CompareTo(T other);

}
//NameSpace:System
public interface IConvertible
{
	// Methods
	public abstract TypeCode GetTypeCode();
	public abstract bool ToBoolean(IFormatProvider provider);
	public abstract char ToChar(IFormatProvider provider);
	public abstract sbyte ToSByte(IFormatProvider provider);
	public abstract byte ToByte(IFormatProvider provider);
	public abstract short ToInt16(IFormatProvider provider);
	public abstract ushort ToUInt16(IFormatProvider provider);
	public abstract int ToInt32(IFormatProvider provider);
	public abstract uint ToUInt32(IFormatProvider provider);
	public abstract long ToInt64(IFormatProvider provider);
	public abstract ulong ToUInt64(IFormatProvider provider);
	public abstract float ToSingle(IFormatProvider provider);
	public abstract double ToDouble(IFormatProvider provider);
	public abstract Decimal ToDecimal(IFormatProvider provider);
	public abstract DateTime ToDateTime(IFormatProvider provider);
	public abstract string ToString(IFormatProvider provider);
	public abstract object ToType(Type conversionType, IFormatProvider provider);

}
//NameSpace:System
public interface ICustomFormatter
{
	// Methods
	public abstract string Format(string format, object arg, IFormatProvider formatProvider);

}
//NameSpace:System
public interface IDisposable
{
	// Methods
	public abstract void Dispose();

}
//NameSpace:System
public interface IEquatable`1
{
	// Methods
	public abstract bool Equals(T other);

}
//NameSpace:System
public interface IFormatProvider
{
	// Methods
	public abstract object GetFormat(Type formatType);

}
//NameSpace:System
public interface IFormattable
{
	// Methods
	public abstract string ToString(string format, IFormatProvider formatProvider);

}
//NameSpace:System
public sealed class IndexOutOfRangeException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	internal void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public struct Int16 : IComparable, IFormattable, IConvertible, IComparable`1<short>, IEquatable`1<short>
{
	// Fields
	internal short m_value;
	public const short MaxValue;
	public const short MinValue;

	// Methods
	public int CompareTo(object value);
	public int CompareTo(short value);
	public override bool Equals(object obj);
	public bool Equals(short obj);
	public override int GetHashCode();
	public override string ToString();
	public string ToString(IFormatProvider provider);
	public string ToString(string format, IFormatProvider provider);
	private string ToString(string format, NumberFormatInfo info);
	public static short Parse(string s, IFormatProvider provider);
	public static short Parse(string s, NumberStyles style, IFormatProvider provider);
	private static short Parse(string s, NumberStyles style, NumberFormatInfo info);
	public TypeCode GetTypeCode();
	private bool System.IConvertible.ToBoolean(IFormatProvider provider);
	private char System.IConvertible.ToChar(IFormatProvider provider);
	private sbyte System.IConvertible.ToSByte(IFormatProvider provider);
	private byte System.IConvertible.ToByte(IFormatProvider provider);
	private short System.IConvertible.ToInt16(IFormatProvider provider);
	private ushort System.IConvertible.ToUInt16(IFormatProvider provider);
	private int System.IConvertible.ToInt32(IFormatProvider provider);
	private uint System.IConvertible.ToUInt32(IFormatProvider provider);
	private long System.IConvertible.ToInt64(IFormatProvider provider);
	private ulong System.IConvertible.ToUInt64(IFormatProvider provider);
	private float System.IConvertible.ToSingle(IFormatProvider provider);
	private double System.IConvertible.ToDouble(IFormatProvider provider);
	private Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
	private DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
	private object System.IConvertible.ToType(Type type, IFormatProvider provider);

}
//NameSpace:System
public struct Int32 : IComparable, IFormattable, IConvertible, IComparable`1<int>, IEquatable`1<int>
{
	// Fields
	internal int m_value;
	public const int MaxValue;
	public const int MinValue;

	// Methods
	public int CompareTo(object value);
	public int CompareTo(int value);
	public override bool Equals(object obj);
	public bool Equals(int obj);
	public override int GetHashCode();
	public override string ToString();
	public string ToString(string format);
	public string ToString(IFormatProvider provider);
	public string ToString(string format, IFormatProvider provider);
	public static int Parse(string s);
	public static int Parse(string s, IFormatProvider provider);
	public static int Parse(string s, NumberStyles style, IFormatProvider provider);
	public TypeCode GetTypeCode();
	private bool System.IConvertible.ToBoolean(IFormatProvider provider);
	private char System.IConvertible.ToChar(IFormatProvider provider);
	private sbyte System.IConvertible.ToSByte(IFormatProvider provider);
	private byte System.IConvertible.ToByte(IFormatProvider provider);
	private short System.IConvertible.ToInt16(IFormatProvider provider);
	private ushort System.IConvertible.ToUInt16(IFormatProvider provider);
	private int System.IConvertible.ToInt32(IFormatProvider provider);
	private uint System.IConvertible.ToUInt32(IFormatProvider provider);
	private long System.IConvertible.ToInt64(IFormatProvider provider);
	private ulong System.IConvertible.ToUInt64(IFormatProvider provider);
	private float System.IConvertible.ToSingle(IFormatProvider provider);
	private double System.IConvertible.ToDouble(IFormatProvider provider);
	private Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
	private DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
	private object System.IConvertible.ToType(Type type, IFormatProvider provider);

}
//NameSpace:System
public struct Int64 : IComparable, IFormattable, IConvertible, IComparable`1<long>, IEquatable`1<long>
{
	// Fields
	internal long m_value;
	public const long MaxValue;
	public const long MinValue;

	// Methods
	public int CompareTo(object value);
	public int CompareTo(long value);
	public override bool Equals(object obj);
	public bool Equals(long obj);
	public override int GetHashCode();
	public override string ToString();
	public string ToString(IFormatProvider provider);
	public string ToString(string format, IFormatProvider provider);
	public static long Parse(string s);
	public static long Parse(string s, IFormatProvider provider);
	public static long Parse(string s, NumberStyles style, IFormatProvider provider);
	public static bool TryParse(string s, out long result);
	public TypeCode GetTypeCode();
	private bool System.IConvertible.ToBoolean(IFormatProvider provider);
	private char System.IConvertible.ToChar(IFormatProvider provider);
	private sbyte System.IConvertible.ToSByte(IFormatProvider provider);
	private byte System.IConvertible.ToByte(IFormatProvider provider);
	private short System.IConvertible.ToInt16(IFormatProvider provider);
	private ushort System.IConvertible.ToUInt16(IFormatProvider provider);
	private int System.IConvertible.ToInt32(IFormatProvider provider);
	private uint System.IConvertible.ToUInt32(IFormatProvider provider);
	private long System.IConvertible.ToInt64(IFormatProvider provider);
	private ulong System.IConvertible.ToUInt64(IFormatProvider provider);
	private float System.IConvertible.ToSingle(IFormatProvider provider);
	private double System.IConvertible.ToDouble(IFormatProvider provider);
	private Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
	private DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
	private object System.IConvertible.ToType(Type type, IFormatProvider provider);

}
//NameSpace:System
public class InvalidCastException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class InvalidOperationException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	public void .ctor(string message, Exception innerException);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public sealed class InvalidProgramException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	internal void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class InvalidTimeZoneException : Exception
{
	// Methods
	public void .ctor(string message);
	public void .ctor(string message, Exception innerException);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public void .ctor();

}
//NameSpace:System
public static class Math
{
	// Fields
	private static double doubleRoundLimit;
	private const int maxRoundingDigits;
	private static double[] roundPower10Double;
	public const double PI;
	public const double E;

	// Methods
	public static double Ceiling(double a);
	public static double Cos(double d);
	public static double Floor(double d);
	public static double Sin(double a);
	public static double Round(double a);
	public static double Sqrt(double d);
	public static double Log(double d);
	public static double Pow(double x, double y);
	public static int Abs(int value);
	private static int AbsHelper(int value);
	public static float Abs(float value);
	public static int Max(int val1, int val2);
	public static float Max(float val1, float val2);
	public static int Min(int val1, int val2);
	public static float Min(float val1, float val2);
	public static double Log(double a, double newBase);
	private static void .cctor();

}
//NameSpace:System
public class MemberAccessException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class MethodAccessException : MemberAccessException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class MissingFieldException : MissingMemberException, ISerializable
{
	// Properties
	public override string Message { get; }

	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public override string get_Message();
	public void .ctor(string className, string fieldName);

}
//NameSpace:System
public class MissingMemberException : MemberAccessException, ISerializable
{
	// Fields
	protected string ClassName;
	protected string MemberName;
	protected byte[] Signature;

	// Properties
	public override string Message { get; }

	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public override string get_Message();
	internal static string FormatSignature(byte[] signature);
	public override void GetObjectData(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class MissingMethodException : MissingMemberException, ISerializable
{
	// Fields
	private string signature;

	// Properties
	public override string Message { get; }

	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public override string get_Message();
	public void .ctor(string className, string methodName);
	private void .ctor(string className, string methodName, string signature, string message);

}
//NameSpace:System
public sealed class MulticastNotSupportedException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	internal void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public sealed class NonSerializedAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System
public class NotImplementedException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class NotSupportedException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class NullReferenceException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
internal class Number
{
	// Methods
	public static bool NumberBufferToDecimal(byte* number, Decimal value);
	internal static bool NumberBufferToDouble(byte* number, double value);
	public static string FormatDecimal(Decimal value, string format, NumberFormatInfo info);
	public static string FormatDouble(double value, string format, NumberFormatInfo info);
	public static string FormatInt32(int value, string format, NumberFormatInfo info);
	public static string FormatUInt32(uint value, string format, NumberFormatInfo info);
	public static string FormatInt64(long value, string format, NumberFormatInfo info);
	public static string FormatUInt64(ulong value, string format, NumberFormatInfo info);
	public static string FormatSingle(float value, string format, NumberFormatInfo info);
	private static bool HexNumberToInt32(Number.NumberBuffer number, int value);
	private static bool HexNumberToInt64(Number.NumberBuffer number, long value);
	private static bool HexNumberToUInt32(Number.NumberBuffer number, uint value);
	private static bool HexNumberToUInt64(Number.NumberBuffer number, ulong value);
	private static bool IsWhite(char ch);
	private static bool NumberToInt32(Number.NumberBuffer number, int value);
	private static bool NumberToInt64(Number.NumberBuffer number, long value);
	private static bool NumberToUInt32(Number.NumberBuffer number, uint value);
	private static bool NumberToUInt64(Number.NumberBuffer number, ulong value);
	private static char* MatchChars(char* p, string str);
	private static char* MatchChars(char* p, char* str);
	internal static Decimal ParseDecimal(string value, NumberStyles options, NumberFormatInfo numfmt);
	internal static double ParseDouble(string value, NumberStyles options, NumberFormatInfo numfmt);
	internal static int ParseInt32(string s, NumberStyles style, NumberFormatInfo info);
	internal static long ParseInt64(string value, NumberStyles options, NumberFormatInfo numfmt);
	private static bool ParseNumber(char* str, NumberStyles options, Number.NumberBuffer number, StringBuilder sb, NumberFormatInfo numfmt, bool parseDecimal);
	internal static float ParseSingle(string value, NumberStyles options, NumberFormatInfo numfmt);
	internal static uint ParseUInt32(string value, NumberStyles options, NumberFormatInfo numfmt);
	internal static ulong ParseUInt64(string value, NumberStyles options, NumberFormatInfo numfmt);
	private static void StringToNumber(string str, NumberStyles options, Number.NumberBuffer number, NumberFormatInfo info, bool parseDecimal);
	private static bool TrailingZeros(string s, int index);
	internal static bool TryParseInt64(string s, NumberStyles style, NumberFormatInfo info, out long result);
	internal static bool TryStringToNumber(string str, NumberStyles options, Number.NumberBuffer number, NumberFormatInfo numfmt, bool parseDecimal);
	internal static bool TryStringToNumber(string str, NumberStyles options, Number.NumberBuffer number, StringBuilder sb, NumberFormatInfo numfmt, bool parseDecimal);

}
//NameSpace:
internal struct Number.NumberBuffer
{
	// Fields
	public static readonly int NumberBufferBytes;
	private byte* baseAddress;
	public char* digits;
	public int precision;
	public int scale;
	public bool sign;

	// Methods
	public void .ctor(byte* stackBuffer);
	public byte* PackForNative();
	private static void .cctor();

}
//NameSpace:System
public class ObjectDisposedException : InvalidOperationException
{
	// Fields
	private string objectName;

	// Properties
	public override string Message { get; }
	public string ObjectName { get; }

	// Methods
	private void .ctor();
	public void .ctor(string objectName);
	public void .ctor(string objectName, string message);
	public override string get_Message();
	public string get_ObjectName();
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public override void GetObjectData(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public sealed class ObsoleteAttribute : Attribute
{
	// Fields
	private string _message;
	private bool _error;

	// Methods
	public void .ctor();
	public void .ctor(string message);
	public void .ctor(string message, bool error);

}
//NameSpace:System
public class OperationCanceledException : SystemException
{
	// Fields
	private CancellationToken _cancellationToken;

	// Properties
	public CancellationToken CancellationToken { get; set; }

	// Methods
	public CancellationToken get_CancellationToken();
	private void set_CancellationToken(CancellationToken value);
	public void .ctor();
	public void .ctor(string message);
	public void .ctor(string message, CancellationToken token);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class OutOfMemoryException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class OverflowException : ArithmeticException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	public void .ctor(string message, Exception innerException);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public sealed class ParamArrayAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System
internal struct ParamsArray
{
	// Fields
	private static readonly object[] oneArgArray;
	private static readonly object[] twoArgArray;
	private static readonly object[] threeArgArray;
	private readonly object arg0;
	private readonly object arg1;
	private readonly object arg2;
	private readonly object[] args;

	// Properties
	public int Length { get; }
	public object Item { get; }

	// Methods
	public void .ctor(object arg0);
	public void .ctor(object arg0, object arg1);
	public void .ctor(object arg0, object arg1, object arg2);
	public void .ctor(object[] args);
	public int get_Length();
	public object get_Item(int index);
	private object GetAtSlow(int index);
	private static void .cctor();

}
//NameSpace:System
public class PlatformNotSupportedException : NotSupportedException
{
	// Methods
	public void .ctor();
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class Random
{
	// Fields
	private int inext;
	private int inextp;
	private int[] SeedArray;

	// Methods
	public void .ctor();
	public void .ctor(int Seed);
	protected virtual double Sample();
	private int InternalSample();
	private double GetSampleForLargeRange();
	public virtual int Next(int minValue, int maxValue);
	public virtual int Next(int maxValue);

}
//NameSpace:System
public class RankException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
internal enum TypeNameFormatFlags
{
	// Fields
	public int value__;
	public const TypeNameFormatFlags FormatBasic;
	public const TypeNameFormatFlags FormatNamespace;
	public const TypeNameFormatFlags FormatFullInst;
	public const TypeNameFormatFlags FormatAssembly;
	public const TypeNameFormatFlags FormatSignature;
	public const TypeNameFormatFlags FormatNoVersion;
	public const TypeNameFormatFlags FormatAngleBrackets;
	public const TypeNameFormatFlags FormatStubInfo;
	public const TypeNameFormatFlags FormatGenericParam;
	public const TypeNameFormatFlags FormatSerialization;

}
//NameSpace:System
internal enum TypeNameKind
{
	// Fields
	public int value__;
	public const TypeNameKind Name;
	public const TypeNameKind ToString;
	public const TypeNameKind SerializationName;
	public const TypeNameKind FullName;

}
//NameSpace:System
internal class RuntimeType : TypeInfo, ISerializable, ICloneable
{
	// Fields
	internal static readonly RuntimeType ValueType;
	internal static readonly RuntimeType EnumType;
	private static readonly RuntimeType ObjectType;
	private static readonly RuntimeType StringType;
	private static readonly RuntimeType DelegateType;
	private static Type[] s_SICtorParamTypes;
	private const BindingFlags MemberBindingMask;
	private const BindingFlags InvocationMask;
	private const BindingFlags BinderNonCreateInstance;
	private const BindingFlags BinderGetSetProperty;
	private const BindingFlags BinderSetInvokeProperty;
	private const BindingFlags BinderGetSetField;
	private const BindingFlags BinderSetInvokeField;
	private const BindingFlags BinderNonFieldGetSet;
	private const BindingFlags ClassicBindingMask;
	private static RuntimeType s_typedRef;
	private MonoTypeInfo type_info;
	internal object GenericCache;
	private RuntimeConstructorInfo m_serializationCtor;

	// Properties
	public override Module Module { get; }
	public override Assembly Assembly { get; }
	public override RuntimeTypeHandle TypeHandle { get; }
	public override Type BaseType { get; }
	public override Type UnderlyingSystemType { get; }
	public override bool IsEnum { get; }
	public override GenericParameterAttributes GenericParameterAttributes { get; }
	internal override bool IsSzArray { get; }
	public override bool IsGenericTypeDefinition { get; }
	public override bool IsGenericParameter { get; }
	public override int GenericParameterPosition { get; }
	public override bool IsGenericType { get; }
	public override MemberTypes MemberType { get; }
	public override Type ReflectedType { get; }
	public override int MetadataToken { get; }
	public override bool ContainsGenericParameters { get; }
	public override MethodBase DeclaringMethod { get; }
	public override string AssemblyQualifiedName { get; }
	public override Type DeclaringType { get; }
	public override string Name { get; }
	public override string Namespace { get; }
	public override string FullName { get; }

	// Methods
	private static void ThrowIfTypeNeverValidGenericArgument(RuntimeType type);
	internal static void SanityCheckGenericArguments(RuntimeType[] genericArguments, RuntimeType[] genericParamters);
	private static void SplitName(string fullname, out string name, out string ns);
	private static void FilterHelper(BindingFlags bindingFlags, string name, bool allowPrefixLookup, out bool prefixLookup, out bool ignoreCase, out RuntimeType.MemberListType listType);
	private static void FilterHelper(BindingFlags bindingFlags, string name, out bool ignoreCase, out RuntimeType.MemberListType listType);
	private static bool FilterApplyPrefixLookup(MemberInfo memberInfo, string name, bool ignoreCase);
	private static bool FilterApplyBase(MemberInfo memberInfo, BindingFlags bindingFlags, bool isPublic, bool isNonProtectedInternal, bool isStatic, string name, bool prefixLookup);
	private static bool FilterApplyType(Type type, BindingFlags bindingFlags, string name, bool prefixLookup, string ns);
	private static bool FilterApplyMethodInfo(RuntimeMethodInfo method, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes);
	private static bool FilterApplyConstructorInfo(RuntimeConstructorInfo constructor, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes);
	private static bool FilterApplyMethodBase(MethodBase methodBase, BindingFlags methodFlags, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes);
	internal void .ctor();
	internal bool IsSpecialSerializableType();
	private ListBuilder`1<MethodInfo> GetMethodCandidates(string name, BindingFlags bindingAttr, CallingConventions callConv, Type[] types, bool allowPrefixLookup);
	private ListBuilder`1<ConstructorInfo> GetConstructorCandidates(string name, BindingFlags bindingAttr, CallingConventions callConv, Type[] types, bool allowPrefixLookup);
	private ListBuilder`1<PropertyInfo> GetPropertyCandidates(string name, BindingFlags bindingAttr, Type[] types, bool allowPrefixLookup);
	private ListBuilder`1<EventInfo> GetEventCandidates(string name, BindingFlags bindingAttr, bool allowPrefixLookup);
	private ListBuilder`1<FieldInfo> GetFieldCandidates(string name, BindingFlags bindingAttr, bool allowPrefixLookup);
	private ListBuilder`1<Type> GetNestedTypeCandidates(string fullname, BindingFlags bindingAttr, bool allowPrefixLookup);
	public override MethodInfo[] GetMethods(BindingFlags bindingAttr);
	public override ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
	public override FieldInfo[] GetFields(BindingFlags bindingAttr);
	protected override MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConv, Type[] types, ParameterModifier[] modifiers);
	protected override ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
	protected override PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
	public override EventInfo GetEvent(string name, BindingFlags bindingAttr);
	public override FieldInfo GetField(string name, BindingFlags bindingAttr);
	public override Type GetNestedType(string fullname, BindingFlags bindingAttr);
	public override MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
	public override Module get_Module();
	internal RuntimeModule GetRuntimeModule();
	public override Assembly get_Assembly();
	internal RuntimeAssembly GetRuntimeAssembly();
	public override RuntimeTypeHandle get_TypeHandle();
	public override bool IsInstanceOfType(object o);
	public override bool IsSubclassOf(Type type);
	public override bool IsAssignableFrom(Type c);
	public override bool IsEquivalentTo(Type other);
	public override Type get_BaseType();
	private RuntimeType GetBaseType();
	public override Type get_UnderlyingSystemType();
	protected override TypeAttributes GetAttributeFlagsImpl();
	protected override bool IsContextfulImpl();
	protected override bool IsByRefImpl();
	protected override bool IsPrimitiveImpl();
	protected override bool IsPointerImpl();
	protected override bool IsCOMObjectImpl();
	protected override bool IsValueTypeImpl();
	public override bool get_IsEnum();
	protected override bool HasElementTypeImpl();
	public override GenericParameterAttributes get_GenericParameterAttributes();
	internal override bool get_IsSzArray();
	protected override bool IsArrayImpl();
	public override int GetArrayRank();
	public override Type GetElementType();
	public override string[] GetEnumNames();
	public override Type GetEnumUnderlyingType();
	public override bool IsEnumDefined(object value);
	public override string GetEnumName(object value);
	internal RuntimeType[] GetGenericArgumentsInternal();
	public override Type[] GetGenericArguments();
	public override Type MakeGenericType(Type[] instantiation);
	public override bool get_IsGenericTypeDefinition();
	public override bool get_IsGenericParameter();
	public override int get_GenericParameterPosition();
	public override Type GetGenericTypeDefinition();
	public override bool get_IsGenericType();
	public override object InvokeMember(string name, BindingFlags bindingFlags, Binder binder, object target, object[] providedArgs, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParams);
	public override bool Equals(object obj);
	public static bool op_Equality(RuntimeType left, RuntimeType right);
	public static bool op_Inequality(RuntimeType left, RuntimeType right);
	public object Clone();
	public void GetObjectData(SerializationInfo info, StreamingContext context);
	public override object[] GetCustomAttributes(bool inherit);
	public override object[] GetCustomAttributes(Type attributeType, bool inherit);
	public override bool IsDefined(Type attributeType, bool inherit);
	public override IList`1<CustomAttributeData> GetCustomAttributesData();
	internal override string FormatTypeName(bool serialization);
	public override MemberTypes get_MemberType();
	public override Type get_ReflectedType();
	public override int get_MetadataToken();
	private void CreateInstanceCheckThis();
	internal object CreateInstanceImpl(BindingFlags bindingAttr, Binder binder, object[] args, CultureInfo culture, object[] activationAttributes, StackCrawlMark stackMark);
	internal object CreateInstanceDefaultCtor(bool publicOnly, bool skipCheckThis, bool fillCache, StackCrawlMark stackMark);
	internal MonoCMethod GetDefaultConstructor();
	private string GetDefaultMemberName();
	internal RuntimeConstructorInfo GetSerializationCtor();
	internal object CreateInstanceSlow(bool publicOnly, bool skipCheckThis, bool fillCache, StackCrawlMark stackMark);
	private object CreateInstanceMono(bool nonPublic);
	internal object CheckValue(object value, Binder binder, CultureInfo culture, BindingFlags invokeAttr);
	private object TryConvertToType(object value, bool failed);
	private static object IsConvertibleToPrimitiveType(object value, Type targetType);
	private string GetCachedName(TypeNameKind kind);
	private Type make_array_type(int rank);
	public override Type MakeArrayType();
	public override Type MakeArrayType(int rank);
	private Type make_byref_type();
	public override Type MakeByRefType();
	private static Type MakePointerType(Type type);
	public override Type MakePointerType();
	public override bool get_ContainsGenericParameters();
	public override Type[] GetGenericParameterConstraints();
	internal static object CreateInstanceForAnotherGenericParameter(Type genericType, RuntimeType genericArgument);
	private static Type MakeGenericType(Type gt, Type[] types);
	internal IntPtr GetMethodsByName_native(IntPtr namePtr, BindingFlags bindingAttr, bool ignoreCase);
	internal RuntimeMethodInfo[] GetMethodsByName(string name, BindingFlags bindingAttr, bool ignoreCase, RuntimeType reflectedType);
	private IntPtr GetPropertiesByName_native(IntPtr name, BindingFlags bindingAttr, bool icase);
	private IntPtr GetConstructors_native(BindingFlags bindingAttr);
	private RuntimeConstructorInfo[] GetConstructors_internal(BindingFlags bindingAttr, RuntimeType reflectedType);
	private RuntimePropertyInfo[] GetPropertiesByName(string name, BindingFlags bindingAttr, bool icase, RuntimeType reflectedType);
	protected override TypeCode GetTypeCodeImpl();
	private static TypeCode GetTypeCodeImplInternal(Type type);
	public override string ToString();
	private bool IsGenericCOMObjectImpl();
	private static object CreateInstanceInternal(Type type);
	public override MethodBase get_DeclaringMethod();
	internal string getFullName(bool full_name, bool assembly_qualified);
	private Type[] GetGenericArgumentsInternal(bool runtimeArray);
	private GenericParameterAttributes GetGenericParameterAttributes();
	private int GetGenericParameterPosition();
	private IntPtr GetEvents_native(IntPtr name, BindingFlags bindingAttr);
	private IntPtr GetFields_native(IntPtr name, BindingFlags bindingAttr);
	private RuntimeFieldInfo[] GetFields_internal(string name, BindingFlags bindingAttr, RuntimeType reflectedType);
	private RuntimeEventInfo[] GetEvents_internal(string name, BindingFlags bindingAttr, RuntimeType reflectedType);
	public override Type[] GetInterfaces();
	private IntPtr GetNestedTypes_native(IntPtr name, BindingFlags bindingAttr);
	private RuntimeType[] GetNestedTypes_internal(string displayName, BindingFlags bindingAttr);
	public override string get_AssemblyQualifiedName();
	public override Type get_DeclaringType();
	public override string get_Name();
	public override string get_Namespace();
	public override int GetHashCode();
	public override string get_FullName();
	private static void .cctor();

}
//NameSpace:
internal enum RuntimeType.MemberListType
{
	// Fields
	public int value__;
	public const RuntimeType.MemberListType All;
	public const RuntimeType.MemberListType CaseSensitive;
	public const RuntimeType.MemberListType CaseInsensitive;
	public const RuntimeType.MemberListType HandleToInfo;

}
//NameSpace:
private struct RuntimeType.ListBuilder`1
{
	// Fields
	private T[] _items;
	private T _item;
	private int _count;
	private int _capacity;

	// Properties
	public T Item { get; }
	public int Count { get; }

	// Methods
	public void .ctor(int capacity);
	public T get_Item(int index);
	public T[] ToArray();
	public void CopyTo(object[] array, int index);
	public int get_Count();
	public void Add(T item);

}
//NameSpace:System
internal class ReflectionOnlyType : RuntimeType
{
	// Properties
	public override RuntimeTypeHandle TypeHandle { get; }

	// Methods
	private void .ctor();
	public override RuntimeTypeHandle get_TypeHandle();

}
//NameSpace:System
public struct SByte : IComparable, IFormattable, IConvertible, IComparable`1<sbyte>, IEquatable`1<sbyte>
{
	// Fields
	private sbyte m_value;
	public const sbyte MaxValue;
	public const sbyte MinValue;

	// Methods
	public int CompareTo(object obj);
	public int CompareTo(sbyte value);
	public override bool Equals(object obj);
	public bool Equals(sbyte obj);
	public override int GetHashCode();
	public override string ToString();
	public string ToString(IFormatProvider provider);
	public string ToString(string format, IFormatProvider provider);
	private string ToString(string format, NumberFormatInfo info);
	public static sbyte Parse(string s, IFormatProvider provider);
	public static sbyte Parse(string s, NumberStyles style, IFormatProvider provider);
	private static sbyte Parse(string s, NumberStyles style, NumberFormatInfo info);
	public TypeCode GetTypeCode();
	private bool System.IConvertible.ToBoolean(IFormatProvider provider);
	private char System.IConvertible.ToChar(IFormatProvider provider);
	private sbyte System.IConvertible.ToSByte(IFormatProvider provider);
	private byte System.IConvertible.ToByte(IFormatProvider provider);
	private short System.IConvertible.ToInt16(IFormatProvider provider);
	private ushort System.IConvertible.ToUInt16(IFormatProvider provider);
	private int System.IConvertible.ToInt32(IFormatProvider provider);
	private uint System.IConvertible.ToUInt32(IFormatProvider provider);
	private long System.IConvertible.ToInt64(IFormatProvider provider);
	private ulong System.IConvertible.ToUInt64(IFormatProvider provider);
	private float System.IConvertible.ToSingle(IFormatProvider provider);
	private double System.IConvertible.ToDouble(IFormatProvider provider);
	private Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
	private DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
	private object System.IConvertible.ToType(Type type, IFormatProvider provider);

}
//NameSpace:System
public sealed class SerializableAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System
internal sealed class SharedStatics
{
	// Fields
	private static readonly SharedStatics _sharedStatics;
	private Tokenizer.StringMaker _maker;

	// Methods
	private void .ctor();
	public static Tokenizer.StringMaker GetSharedStringMaker();
	public static void ReleaseSharedStringMaker(Tokenizer.StringMaker maker);
	private static void .cctor();

}
//NameSpace:System
public struct Single : IComparable, IFormattable, IConvertible, IComparable`1<float>, IEquatable`1<float>
{
	// Fields
	internal float m_value;
	public const float MinValue;
	public const float Epsilon;
	public const float MaxValue;
	public const float PositiveInfinity;
	public const float NegativeInfinity;
	public const float NaN;

	// Methods
	public static bool IsInfinity(float f);
	public static bool IsNaN(float f);
	public int CompareTo(object value);
	public int CompareTo(float value);
	public override bool Equals(object obj);
	public bool Equals(float obj);
	public override int GetHashCode();
	public override string ToString();
	public string ToString(IFormatProvider provider);
	public string ToString(string format, IFormatProvider provider);
	public static float Parse(string s, IFormatProvider provider);
	public static float Parse(string s, NumberStyles style, IFormatProvider provider);
	private static float Parse(string s, NumberStyles style, NumberFormatInfo info);
	public TypeCode GetTypeCode();
	private bool System.IConvertible.ToBoolean(IFormatProvider provider);
	private char System.IConvertible.ToChar(IFormatProvider provider);
	private sbyte System.IConvertible.ToSByte(IFormatProvider provider);
	private byte System.IConvertible.ToByte(IFormatProvider provider);
	private short System.IConvertible.ToInt16(IFormatProvider provider);
	private ushort System.IConvertible.ToUInt16(IFormatProvider provider);
	private int System.IConvertible.ToInt32(IFormatProvider provider);
	private uint System.IConvertible.ToUInt32(IFormatProvider provider);
	private long System.IConvertible.ToInt64(IFormatProvider provider);
	private ulong System.IConvertible.ToUInt64(IFormatProvider provider);
	private float System.IConvertible.ToSingle(IFormatProvider provider);
	private double System.IConvertible.ToDouble(IFormatProvider provider);
	private Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
	private DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
	private object System.IConvertible.ToType(Type type, IFormatProvider provider);

}
//NameSpace:System
public sealed class StackOverflowException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	internal void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public sealed class String : IComparable, ICloneable, IConvertible, IEnumerable, IComparable`1<string>, IEnumerable`1<char>, IEquatable`1<string>
{
	// Fields
	private int m_stringLength;
	private char m_firstChar;
	private const int TrimHead;
	private const int TrimTail;
	private const int TrimBoth;
	public static readonly string Empty;
	private const int charPtrAlignConst;
	private const int alignConst;

	// Properties
	public char Chars { get; }
	public int Length { get; }

	// Methods
	public static string Join(string separator, string[] value);
	public static string Join(string separator, string[] value, int startIndex, int count);
	private static int CompareOrdinalIgnoreCaseHelper(string strA, string strB);
	private static bool EqualsHelper(string strA, string strB);
	private static int CompareOrdinalHelper(string strA, string strB);
	public override bool Equals(object obj);
	public bool Equals(string value);
	public bool Equals(string value, StringComparison comparisonType);
	public static bool Equals(string a, string b);
	public static bool Equals(string a, string b, StringComparison comparisonType);
	public static bool op_Equality(string a, string b);
	public static bool op_Inequality(string a, string b);
	public char get_Chars(int index);
	public void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count);
	public char[] ToCharArray();
	public static bool IsNullOrEmpty(string value);
	public static bool IsNullOrWhiteSpace(string value);
	public override int GetHashCode();
	internal int GetLegacyNonRandomizedHashCode();
	public string[] Split(char[] separator);
	internal string[] SplitInternal(char[] separator, int count, StringSplitOptions options);
	private string[] InternalSplitKeepEmptyEntries(int[] sepList, int[] lengthList, int numReplaces, int count);
	private string[] InternalSplitOmitEmptyEntries(int[] sepList, int[] lengthList, int numReplaces, int count);
	private int MakeSeparatorList(char[] separator, int[] sepList);
	public string Substring(int startIndex);
	public string Substring(int startIndex, int length);
	private string InternalSubString(int startIndex, int length);
	public string Trim(char[] trimChars);
	public string TrimEnd(char[] trimChars);
	public void .ctor(char* value);
	public void .ctor(char* value, int startIndex, int length);
	public void .ctor(sbyte* value, int startIndex, int length, Encoding enc);
	internal static string CreateStringFromEncoding(byte* bytes, int byteLength, Encoding encoding);
	public string Normalize(NormalizationForm normalizationForm);
	internal static string FastAllocateString(int length);
	private static void FillStringChecked(string dest, int destPos, string src);
	public void .ctor(char[] value, int startIndex, int length);
	public void .ctor(char[] value);
	internal static void wstrcpy(char* dmem, char* smem, int charCount);
	private string CtorCharArray(char[] value);
	private string CtorCharArrayStartLength(char[] value, int startIndex, int length);
	private static int wcslen(char* ptr);
	private string CtorCharPtr(char* ptr);
	private string CtorCharPtrStartLength(char* ptr, int startIndex, int length);
	public void .ctor(char c, int count);
	public static int Compare(string strA, string strB, StringComparison comparisonType);
	public static int Compare(string strA, string strB, bool ignoreCase, CultureInfo culture);
	public static int Compare(string strA, int indexA, string strB, int indexB, int length, CultureInfo culture, CompareOptions options);
	public static int Compare(string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);
	public int CompareTo(object value);
	public int CompareTo(string strB);
	public static int CompareOrdinal(string strA, string strB);
	public bool Contains(string value);
	public bool EndsWith(string value);
	public bool EndsWith(string value, StringComparison comparisonType);
	internal bool EndsWith(char value);
	public int IndexOf(char value);
	public int IndexOf(char value, int startIndex);
	public int IndexOfAny(char[] anyOf);
	public int IndexOfAny(char[] anyOf, int startIndex);
	public int IndexOf(string value);
	public int IndexOf(string value, int startIndex);
	public int IndexOf(string value, StringComparison comparisonType);
	public int IndexOf(string value, int startIndex, StringComparison comparisonType);
	public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType);
	public int LastIndexOf(char value);
	public int LastIndexOf(char value, int startIndex);
	public int LastIndexOfAny(char[] anyOf);
	public int LastIndexOfAny(char[] anyOf, int startIndex);
	public int LastIndexOf(string value);
	public int LastIndexOf(string value, StringComparison comparisonType);
	public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType);
	public string PadRight(int totalWidth, char paddingChar);
	public bool StartsWith(string value);
	public bool StartsWith(string value, StringComparison comparisonType);
	public string ToLower();
	public string ToLower(CultureInfo culture);
	public string ToLowerInvariant();
	public string ToUpper(CultureInfo culture);
	public string ToUpperInvariant();
	public override string ToString();
	public string ToString(IFormatProvider provider);
	public object Clone();
	private static bool IsBOMWhitespace(char c);
	public string Trim();
	private string TrimHelper(int trimType);
	private string TrimHelper(char[] trimChars, int trimType);
	private string CreateTrimmedString(int start, int end);
	public string Insert(int startIndex, string value);
	public string Replace(char oldChar, char newChar);
	public string Replace(string oldValue, string newValue);
	public string Remove(int startIndex, int count);
	public static string Format(string format, object arg0);
	public static string Format(string format, object arg0, object arg1);
	public static string Format(string format, object arg0, object arg1, object arg2);
	public static string Format(string format, object[] args);
	public static string Format(IFormatProvider provider, string format, object arg0);
	public static string Format(IFormatProvider provider, string format, object arg0, object arg1);
	public static string Format(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
	public static string Format(IFormatProvider provider, string format, object[] args);
	private static string FormatHelper(IFormatProvider provider, string format, ParamsArray args);
	public static string Copy(string str);
	public static string Concat(object arg0, object arg1);
	public static string Concat(object arg0, object arg1, object arg2);
	public static string Concat(object[] args);
	public static string Concat(string str0, string str1);
	public static string Concat(string str0, string str1, string str2);
	public static string Concat(string str0, string str1, string str2, string str3);
	private static string ConcatArray(string[] values, int totalLength);
	public static string Concat(string[] values);
	public TypeCode GetTypeCode();
	private bool System.IConvertible.ToBoolean(IFormatProvider provider);
	private char System.IConvertible.ToChar(IFormatProvider provider);
	private sbyte System.IConvertible.ToSByte(IFormatProvider provider);
	private byte System.IConvertible.ToByte(IFormatProvider provider);
	private short System.IConvertible.ToInt16(IFormatProvider provider);
	private ushort System.IConvertible.ToUInt16(IFormatProvider provider);
	private int System.IConvertible.ToInt32(IFormatProvider provider);
	private uint System.IConvertible.ToUInt32(IFormatProvider provider);
	private long System.IConvertible.ToInt64(IFormatProvider provider);
	private ulong System.IConvertible.ToUInt64(IFormatProvider provider);
	private float System.IConvertible.ToSingle(IFormatProvider provider);
	private double System.IConvertible.ToDouble(IFormatProvider provider);
	private Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
	private DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
	private object System.IConvertible.ToType(Type type, IFormatProvider provider);
	private IEnumerator`1<char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator();
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();
	public int get_Length();
	internal static int CompareOrdinalUnchecked(string strA, int indexA, int lenA, string strB, int indexB, int lenB);
	public int IndexOf(char value, int startIndex, int count);
	internal int IndexOfUnchecked(char value, int startIndex, int count);
	internal int IndexOfUnchecked(string value, int startIndex, int count);
	public int IndexOfAny(char[] anyOf, int startIndex, int count);
	private int IndexOfAnyUnchecked(char[] anyOf, int startIndex, int count);
	public int LastIndexOf(char value, int startIndex, int count);
	internal int LastIndexOfUnchecked(char value, int startIndex, int count);
	public int LastIndexOfAny(char[] anyOf, int startIndex, int count);
	private int LastIndexOfAnyUnchecked(char[] anyOf, int startIndex, int count);
	internal static int nativeCompareOrdinalEx(string strA, int indexA, string strB, int indexB, int count);
	private string ReplaceInternal(char oldChar, char newChar);
	internal string ReplaceInternal(string oldValue, string newValue);
	private string ReplaceUnchecked(string oldValue, string newValue);
	private string ReplaceFallback(string oldValue, string newValue, int testedCount);
	private string PadHelper(int totalWidth, char paddingChar, bool isRightPadded);
	internal bool StartsWithOrdinalUnchecked(string value);
	internal bool IsAscii();
	internal static void CharCopy(char* dest, char* src, int count);
	private static void memset(byte* dest, int val, int len);
	private static void memcpy(byte* dest, byte* src, int size);
	internal static void bzero(byte* dest, int len);
	internal static void bzero_aligned_1(byte* dest, int len);
	internal static void bzero_aligned_2(byte* dest, int len);
	internal static void bzero_aligned_4(byte* dest, int len);
	internal static void bzero_aligned_8(byte* dest, int len);
	internal static void memcpy_aligned_1(byte* dest, byte* src, int size);
	internal static void memcpy_aligned_2(byte* dest, byte* src, int size);
	internal static void memcpy_aligned_4(byte* dest, byte* src, int size);
	internal static void memcpy_aligned_8(byte* dest, byte* src, int size);
	private string CreateString(sbyte* value);
	private string CreateString(sbyte* value, int startIndex, int length);
	private string CreateString(char* value);
	private string CreateString(char* value, int startIndex, int length);
	private string CreateString(char[] val, int startIndex, int length);
	private string CreateString(char[] val);
	private string CreateString(char c, int count);
	private string CreateString(sbyte* value, int startIndex, int length, Encoding enc);

}
//NameSpace:System
public enum StringSplitOptions
{
	// Fields
	public int value__;
	public const StringSplitOptions None;
	public const StringSplitOptions RemoveEmptyEntries;

}
//NameSpace:System
public abstract class StringComparer : IComparer, IEqualityComparer, IComparer`1<string>, IEqualityComparer`1<string>
{
	// Fields
	private static readonly StringComparer _invariantCulture;
	private static readonly StringComparer _invariantCultureIgnoreCase;
	private static readonly StringComparer _ordinal;
	private static readonly StringComparer _ordinalIgnoreCase;

	// Properties
	public static StringComparer InvariantCultureIgnoreCase { get; }
	public static StringComparer CurrentCultureIgnoreCase { get; }
	public static StringComparer Ordinal { get; }
	public static StringComparer OrdinalIgnoreCase { get; }

	// Methods
	public static StringComparer get_InvariantCultureIgnoreCase();
	public static StringComparer get_CurrentCultureIgnoreCase();
	public static StringComparer get_Ordinal();
	public static StringComparer get_OrdinalIgnoreCase();
	public int Compare(object x, object y);
	public bool Equals(object x, object y);
	public int GetHashCode(object obj);
	public abstract int Compare(string x, string y);
	public abstract bool Equals(string x, string y);
	public abstract int GetHashCode(string obj);
	protected void .ctor();
	private static void .cctor();

}
//NameSpace:System
internal sealed class CultureAwareComparer : StringComparer
{
	// Fields
	private CompareInfo _compareInfo;
	private bool _ignoreCase;
	private CompareOptions _options;

	// Methods
	internal void .ctor(CultureInfo culture, bool ignoreCase);
	public override int Compare(string x, string y);
	public override bool Equals(string x, string y);
	public override int GetHashCode(string obj);
	public override bool Equals(object obj);
	public override int GetHashCode();

}
//NameSpace:System
internal sealed class OrdinalComparer : StringComparer
{
	// Fields
	private bool _ignoreCase;

	// Methods
	internal void .ctor(bool ignoreCase);
	public override int Compare(string x, string y);
	public override bool Equals(string x, string y);
	public override int GetHashCode(string obj);
	public override bool Equals(object obj);
	public override int GetHashCode();

}
//NameSpace:System
public class SystemException : Exception
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	public void .ctor(string message, Exception innerException);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public sealed class STAThreadAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System
public class ThreadStaticAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System
internal enum ExceptionArgument
{
	// Fields
	public int value__;
	public const ExceptionArgument obj;
	public const ExceptionArgument dictionary;
	public const ExceptionArgument dictionaryCreationThreshold;
	public const ExceptionArgument array;
	public const ExceptionArgument info;
	public const ExceptionArgument key;
	public const ExceptionArgument collection;
	public const ExceptionArgument list;
	public const ExceptionArgument match;
	public const ExceptionArgument converter;
	public const ExceptionArgument queue;
	public const ExceptionArgument stack;
	public const ExceptionArgument capacity;
	public const ExceptionArgument index;
	public const ExceptionArgument startIndex;
	public const ExceptionArgument value;
	public const ExceptionArgument count;
	public const ExceptionArgument arrayIndex;
	public const ExceptionArgument name;
	public const ExceptionArgument mode;
	public const ExceptionArgument item;
	public const ExceptionArgument options;
	public const ExceptionArgument view;
	public const ExceptionArgument sourceBytesToCopy;
	public const ExceptionArgument start;
	public const ExceptionArgument pointer;
	public const ExceptionArgument ownedMemory;
	public const ExceptionArgument text;

}
//NameSpace:System
internal enum ExceptionResource
{
	// Fields
	public int value__;
	public const ExceptionResource Argument_ImplementIComparable;
	public const ExceptionResource Argument_InvalidType;
	public const ExceptionResource Argument_InvalidArgumentForComparison;
	public const ExceptionResource Argument_InvalidRegistryKeyPermissionCheck;
	public const ExceptionResource ArgumentOutOfRange_NeedNonNegNum;
	public const ExceptionResource Arg_ArrayPlusOffTooSmall;
	public const ExceptionResource Arg_NonZeroLowerBound;
	public const ExceptionResource Arg_RankMultiDimNotSupported;
	public const ExceptionResource Arg_RegKeyDelHive;
	public const ExceptionResource Arg_RegKeyStrLenBug;
	public const ExceptionResource Arg_RegSetStrArrNull;
	public const ExceptionResource Arg_RegSetMismatchedKind;
	public const ExceptionResource Arg_RegSubKeyAbsent;
	public const ExceptionResource Arg_RegSubKeyValueAbsent;
	public const ExceptionResource Argument_AddingDuplicate;
	public const ExceptionResource Serialization_InvalidOnDeser;
	public const ExceptionResource Serialization_MissingKeys;
	public const ExceptionResource Serialization_NullKey;
	public const ExceptionResource Argument_InvalidArrayType;
	public const ExceptionResource NotSupported_KeyCollectionSet;
	public const ExceptionResource NotSupported_ValueCollectionSet;
	public const ExceptionResource ArgumentOutOfRange_SmallCapacity;
	public const ExceptionResource ArgumentOutOfRange_Index;
	public const ExceptionResource Argument_InvalidOffLen;
	public const ExceptionResource Argument_ItemNotExist;
	public const ExceptionResource ArgumentOutOfRange_Count;
	public const ExceptionResource ArgumentOutOfRange_InvalidThreshold;
	public const ExceptionResource ArgumentOutOfRange_ListInsert;
	public const ExceptionResource NotSupported_ReadOnlyCollection;
	public const ExceptionResource InvalidOperation_CannotRemoveFromStackOrQueue;
	public const ExceptionResource InvalidOperation_EmptyQueue;
	public const ExceptionResource InvalidOperation_EnumOpCantHappen;
	public const ExceptionResource InvalidOperation_EnumFailedVersion;
	public const ExceptionResource InvalidOperation_EmptyStack;
	public const ExceptionResource ArgumentOutOfRange_BiggerThanCollection;
	public const ExceptionResource InvalidOperation_EnumNotStarted;
	public const ExceptionResource InvalidOperation_EnumEnded;
	public const ExceptionResource NotSupported_SortedListNestedWrite;
	public const ExceptionResource InvalidOperation_NoValue;
	public const ExceptionResource InvalidOperation_RegRemoveSubKey;
	public const ExceptionResource Security_RegistryPermission;
	public const ExceptionResource UnauthorizedAccess_RegistryNoWrite;
	public const ExceptionResource ObjectDisposed_RegKeyClosed;
	public const ExceptionResource NotSupported_InComparableType;
	public const ExceptionResource Argument_InvalidRegistryOptionsCheck;
	public const ExceptionResource Argument_InvalidRegistryViewCheck;

}
//NameSpace:System
public struct TimeSpan : IComparable, IComparable`1<TimeSpan>, IEquatable`1<TimeSpan>, IFormattable
{
	// Fields
	public static readonly TimeSpan Zero;
	public static readonly TimeSpan MaxValue;
	public static readonly TimeSpan MinValue;
	internal long _ticks;
	private static bool _legacyConfigChecked;
	private static bool _legacyMode;

	// Properties
	public long Ticks { get; }
	public int Hours { get; }
	public int Minutes { get; }
	public double TotalHours { get; }
	public double TotalMilliseconds { get; }
	public double TotalMinutes { get; }
	public double TotalSeconds { get; }
	private static bool LegacyMode { get; }

	// Methods
	public void .ctor(long ticks);
	public void .ctor(int hours, int minutes, int seconds);
	public void .ctor(int days, int hours, int minutes, int seconds, int milliseconds);
	public long get_Ticks();
	public int get_Hours();
	public int get_Minutes();
	public double get_TotalHours();
	public double get_TotalMilliseconds();
	public double get_TotalMinutes();
	public double get_TotalSeconds();
	public TimeSpan Add(TimeSpan ts);
	public int CompareTo(object value);
	public int CompareTo(TimeSpan value);
	public static TimeSpan FromDays(double value);
	public override bool Equals(object value);
	public bool Equals(TimeSpan obj);
	public override int GetHashCode();
	public static TimeSpan FromHours(double value);
	private static TimeSpan Interval(double value, int scale);
	public static TimeSpan FromMilliseconds(double value);
	public static TimeSpan FromMinutes(double value);
	public TimeSpan Negate();
	public static TimeSpan FromSeconds(double value);
	public TimeSpan Subtract(TimeSpan ts);
	public static TimeSpan FromTicks(long value);
	internal static long TimeToTicks(int hour, int minute, int second);
	public override string ToString();
	public string ToString(string format);
	public string ToString(string format, IFormatProvider formatProvider);
	public static TimeSpan op_Subtraction(TimeSpan t1, TimeSpan t2);
	public static TimeSpan op_Addition(TimeSpan t1, TimeSpan t2);
	public static bool op_Equality(TimeSpan t1, TimeSpan t2);
	public static bool op_Inequality(TimeSpan t1, TimeSpan t2);
	public static bool op_LessThan(TimeSpan t1, TimeSpan t2);
	public static bool op_LessThanOrEqual(TimeSpan t1, TimeSpan t2);
	public static bool op_GreaterThan(TimeSpan t1, TimeSpan t2);
	public static bool op_GreaterThanOrEqual(TimeSpan t1, TimeSpan t2);
	private static bool GetLegacyFormatMode();
	private static bool get_LegacyMode();
	private static void .cctor();

}
//NameSpace:System
internal enum TimeZoneInfoOptions
{
	// Fields
	public int value__;
	public const TimeZoneInfoOptions None;
	public const TimeZoneInfoOptions NoThrowOnInvalidTime;

}
//NameSpace:System
public sealed class TimeZoneInfo : IEquatable`1<TimeZoneInfo>, ISerializable, IDeserializationCallback
{
	// Fields
	private TimeSpan baseUtcOffset;
	private string daylightDisplayName;
	private string displayName;
	private string id;
	private static TimeZoneInfo local;
	private List`1<KeyValuePair`2<DateTimeTimeType>> transitions;
	private static bool readlinkNotFound;
	private string standardDisplayName;
	private bool supportsDaylightSavingTime;
	private static TimeZoneInfo utc;
	private static string timeZoneDirectory;
	private TimeZoneInfo.AdjustmentRule[] adjustmentRules;
	private static RegistryKey timeZoneKey;
	private static RegistryKey localZoneKey;
	private static ReadOnlyCollection`1<TimeZoneInfo> systemTimeZones;

	// Properties
	public TimeSpan BaseUtcOffset { get; }
	public string DisplayName { get; }
	public string Id { get; }
	public static TimeZoneInfo Local { get; }
	public bool SupportsDaylightSavingTime { get; }
	public static TimeZoneInfo Utc { get; }
	private static string TimeZoneDirectory { get; }
	private static bool IsWindows { get; }
	private static RegistryKey TimeZoneKey { get; }
	private static RegistryKey LocalZoneKey { get; }

	// Methods
	internal static bool UtcOffsetOutOfRange(TimeSpan offset);
	private static List`1<TimeZoneInfo.AdjustmentRule> CreateAdjustmentRule(int year, out long[] data, out string[] names, string standardNameCurrentYear, string daylightNameCurrentYear);
	private static TimeZoneInfo CreateLocalUnity();
	internal static extern uint EnumDynamicTimeZoneInformation(uint dwIndex, out TimeZoneInfo.DYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation);
	internal static extern uint GetDynamicTimeZoneInformation(out TimeZoneInfo.DYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation);
	internal static extern uint GetDynamicTimeZoneInformationWin32(out TimeZoneInfo.DYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation);
	internal static extern uint GetDynamicTimeZoneInformationEffectiveYears(TimeZoneInfo.DYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation, out uint FirstYear, out uint LastYear);
	internal static extern bool GetTimeZoneInformationForYear(ushort wYear, TimeZoneInfo.DYNAMIC_TIME_ZONE_INFORMATION pdtzi, out TimeZoneInfo.TIME_ZONE_INFORMATION ptzi);
	internal static TimeZoneInfo.AdjustmentRule CreateAdjustmentRuleFromTimeZoneInformation(TimeZoneInfo.DYNAMIC_TIME_ZONE_INFORMATION timeZoneInformation, DateTime startDate, DateTime endDate, int defaultBaseUtcOffset);
	private static bool TransitionTimeFromTimeZoneInformation(TimeZoneInfo.DYNAMIC_TIME_ZONE_INFORMATION timeZoneInformation, out TimeZoneInfo.TransitionTime transitionTime, bool readStartDate);
	internal static TimeZoneInfo TryCreateTimeZone(TimeZoneInfo.DYNAMIC_TIME_ZONE_INFORMATION timeZoneInformation);
	internal static TimeZoneInfo GetLocalTimeZoneInfoWinRTFallback();
	internal static string GetLocalTimeZoneKeyNameWin32Fallback();
	internal static TimeZoneInfo FindSystemTimeZoneByIdWinRTFallback(string id);
	internal static List`1<TimeZoneInfo> GetSystemTimeZonesWinRTFallback();
	public TimeSpan get_BaseUtcOffset();
	public string get_DisplayName();
	public string get_Id();
	public static TimeZoneInfo get_Local();
	private static extern int readlink(string path, byte[] buffer, int buflen);
	private static string readlink(string path);
	private static bool TryGetNameFromPath(string path, out string name);
	private static TimeZoneInfo CreateLocal();
	private static TimeZoneInfo FindSystemTimeZoneByIdCore(string id);
	private static void GetSystemTimeZonesCore(List`1<TimeZoneInfo> systemTimeZones);
	public bool get_SupportsDaylightSavingTime();
	public static TimeZoneInfo get_Utc();
	private static string get_TimeZoneDirectory();
	private static bool get_IsWindows();
	private static string TrimSpecial(string str);
	private static RegistryKey get_TimeZoneKey();
	private static RegistryKey get_LocalZoneKey();
	private static bool TryAddTicks(DateTime date, long ticks, out DateTime result, optional DateTimeKind kind);
	public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone);
	private DateTime ConvertTimeFromUtc(DateTime dateTime);
	public static DateTime ConvertTimeFromUtc(DateTime dateTime, TimeZoneInfo destinationTimeZone);
	internal static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfoOptions flags);
	public static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfo sourceTimeZone);
	private static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfoOptions flags);
	internal static TimeSpan GetDateTimeNowUtcOffsetFromUtc(DateTime time, out bool isAmbiguousLocalDst);
	public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName);
	public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, TimeZoneInfo.AdjustmentRule[] adjustmentRules);
	public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, TimeZoneInfo.AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
	public override bool Equals(object obj);
	public bool Equals(TimeZoneInfo other);
	public static TimeZoneInfo FindSystemTimeZoneById(string id);
	private static TimeZoneInfo FindSystemTimeZoneByFileName(string id, string filepath);
	private static TimeZoneInfo FromRegistryKey(string id, RegistryKey key);
	private static void ParseRegTzi(List`1<TimeZoneInfo.AdjustmentRule> adjustmentRules, int start_year, int end_year, byte[] buffer);
	public TimeZoneInfo.AdjustmentRule[] GetAdjustmentRules();
	public override int GetHashCode();
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	public static ReadOnlyCollection`1<TimeZoneInfo> GetSystemTimeZones();
	public TimeSpan GetUtcOffset(DateTime dateTime);
	private TimeSpan GetUtcOffset(DateTime dateTime, out bool isDST);
	private static TimeSpan GetUtcOffsetHelper(DateTime dateTime, TimeZoneInfo tz, out bool isDST);
	public bool HasSameRules(TimeZoneInfo other);
	public bool IsAmbiguousTime(DateTime dateTime);
	private bool IsInDST(TimeZoneInfo.AdjustmentRule rule, DateTime dateTime);
	private bool IsInDSTForYear(TimeZoneInfo.AdjustmentRule rule, DateTime dateTime, int year);
	public bool IsInvalidTime(DateTime dateTime);
	private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
	private static void Validate(string id, TimeSpan baseUtcOffset, TimeZoneInfo.AdjustmentRule[] adjustmentRules);
	public override string ToString();
	private void .ctor(SerializationInfo info, StreamingContext context);
	private void .ctor(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, TimeZoneInfo.AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
	private TimeZoneInfo.AdjustmentRule GetApplicableRule(DateTime dateTime);
	private bool TryGetTransitionOffset(DateTime dateTime, out TimeSpan offset, out bool isDst);
	private static DateTime TransitionPoint(TimeZoneInfo.TransitionTime transition, int year);
	private static TimeZoneInfo.AdjustmentRule[] ValidateRules(List`1<TimeZoneInfo.AdjustmentRule> adjustmentRules);
	private static TimeZoneInfo BuildFromStream(string id, Stream stream);
	private static bool ValidTZFile(byte[] buffer, int length);
	private static int SwapInt32(int i);
	private static int ReadBigEndianInt32(byte[] buffer, int start);
	private static TimeZoneInfo ParseTZBuffer(string id, byte[] buffer, int length);
	private static Dictionary`2<intstring> ParseAbbreviations(byte[] buffer, int index, int count);
	private static Dictionary`2<intTimeType> ParseTimesTypes(byte[] buffer, int index, int count, Dictionary`2<intstring> abbreviations);
	private static List`1<KeyValuePair`2<DateTimeTimeType>> ParseTransitions(byte[] buffer, int index, int count, Dictionary`2<intTimeType> time_types);
	private static DateTime DateTimeFromUnixTime(long unix_time);
	internal static TimeSpan GetLocalUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags);
	internal TimeSpan GetUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags);
	internal static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone, out bool isDaylightSavings, out bool isAmbiguousLocalDst);
	internal void .ctor();

}
//NameSpace:
public sealed class TimeZoneInfo.AdjustmentRule : IEquatable`1<TimeZoneInfo.AdjustmentRule>, ISerializable, IDeserializationCallback
{
	// Fields
	private DateTime m_dateStart;
	private DateTime m_dateEnd;
	private TimeSpan m_daylightDelta;
	private TimeZoneInfo.TransitionTime m_daylightTransitionStart;
	private TimeZoneInfo.TransitionTime m_daylightTransitionEnd;
	private TimeSpan m_baseUtcOffsetDelta;

	// Properties
	public DateTime DateStart { get; }
	public DateTime DateEnd { get; }
	public TimeSpan DaylightDelta { get; }
	public TimeZoneInfo.TransitionTime DaylightTransitionStart { get; }
	public TimeZoneInfo.TransitionTime DaylightTransitionEnd { get; }

	// Methods
	public DateTime get_DateStart();
	public DateTime get_DateEnd();
	public TimeSpan get_DaylightDelta();
	public TimeZoneInfo.TransitionTime get_DaylightTransitionStart();
	public TimeZoneInfo.TransitionTime get_DaylightTransitionEnd();
	public bool Equals(TimeZoneInfo.AdjustmentRule other);
	public override int GetHashCode();
	private void .ctor();
	public static TimeZoneInfo.AdjustmentRule CreateAdjustmentRule(DateTime dateStart, DateTime dateEnd, TimeSpan daylightDelta, TimeZoneInfo.TransitionTime daylightTransitionStart, TimeZoneInfo.TransitionTime daylightTransitionEnd);
	internal static TimeZoneInfo.AdjustmentRule CreateAdjustmentRule(DateTime dateStart, DateTime dateEnd, TimeSpan daylightDelta, TimeZoneInfo.TransitionTime daylightTransitionStart, TimeZoneInfo.TransitionTime daylightTransitionEnd, TimeSpan baseUtcOffsetDelta);
	private static void ValidateAdjustmentRule(DateTime dateStart, DateTime dateEnd, TimeSpan daylightDelta, TimeZoneInfo.TransitionTime daylightTransitionStart, TimeZoneInfo.TransitionTime daylightTransitionEnd);
	private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	private void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:
public struct TimeZoneInfo.TransitionTime : IEquatable`1<TimeZoneInfo.TransitionTime>, ISerializable, IDeserializationCallback
{
	// Fields
	private DateTime m_timeOfDay;
	private byte m_month;
	private byte m_week;
	private byte m_day;
	private DayOfWeek m_dayOfWeek;
	private bool m_isFixedDateRule;

	// Properties
	public DateTime TimeOfDay { get; }
	public int Month { get; }
	public int Week { get; }
	public int Day { get; }
	public DayOfWeek DayOfWeek { get; }
	public bool IsFixedDateRule { get; }

	// Methods
	public DateTime get_TimeOfDay();
	public int get_Month();
	public int get_Week();
	public int get_Day();
	public DayOfWeek get_DayOfWeek();
	public bool get_IsFixedDateRule();
	public override bool Equals(object obj);
	public static bool op_Inequality(TimeZoneInfo.TransitionTime t1, TimeZoneInfo.TransitionTime t2);
	public bool Equals(TimeZoneInfo.TransitionTime other);
	public override int GetHashCode();
	public static TimeZoneInfo.TransitionTime CreateFixedDateRule(DateTime timeOfDay, int month, int day);
	public static TimeZoneInfo.TransitionTime CreateFloatingDateRule(DateTime timeOfDay, int month, int week, DayOfWeek dayOfWeek);
	private static TimeZoneInfo.TransitionTime CreateTransitionTime(DateTime timeOfDay, int month, int week, int day, DayOfWeek dayOfWeek, bool isFixedDateRule);
	private static void ValidateTransitionTime(DateTime timeOfDay, int month, int week, int day, DayOfWeek dayOfWeek);
	private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	private void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:
internal struct TimeZoneInfo.SYSTEMTIME
{
	// Fields
	internal ushort wYear;
	internal ushort wMonth;
	internal ushort wDayOfWeek;
	internal ushort wDay;
	internal ushort wHour;
	internal ushort wMinute;
	internal ushort wSecond;
	internal ushort wMilliseconds;

}
//NameSpace:
internal struct TimeZoneInfo.TIME_ZONE_INFORMATION
{
	// Fields
	internal int Bias;
	internal string StandardName;
	internal TimeZoneInfo.SYSTEMTIME StandardDate;
	internal int StandardBias;
	internal string DaylightName;
	internal TimeZoneInfo.SYSTEMTIME DaylightDate;
	internal int DaylightBias;

}
//NameSpace:
internal struct TimeZoneInfo.DYNAMIC_TIME_ZONE_INFORMATION
{
	// Fields
	internal TimeZoneInfo.TIME_ZONE_INFORMATION TZI;
	internal string TimeZoneKeyName;
	internal byte DynamicDaylightTimeDisabled;

}
//NameSpace:
private sealed class TimeZoneInfo.<>c
{
	// Fields
	public static readonly TimeZoneInfo.<>c <>9;
	public static Comparison`1<TimeZoneInfo.AdjustmentRule> <>9__19_0;

	// Methods
	private static void .cctor();
	public void .ctor();
	internal int <CreateLocalUnity>b__19_0(TimeZoneInfo.AdjustmentRule rule1, TimeZoneInfo.AdjustmentRule rule2);

}
//NameSpace:System
public class TimeZoneNotFoundException : Exception
{
	// Methods
	public void .ctor(string message, Exception innerException);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public void .ctor();

}
//NameSpace:System
public abstract class Type : MemberInfo, _Type, IReflect
{
	// Fields
	public static readonly MemberFilter FilterAttribute;
	public static readonly MemberFilter FilterName;
	public static readonly MemberFilter FilterNameIgnoreCase;
	public static readonly object Missing;
	public static readonly char Delimiter;
	public static readonly Type[] EmptyTypes;
	private static Binder defaultBinder;
	private const BindingFlags DefaultLookup;
	internal const BindingFlags DeclaredOnlyLookup;
	internal RuntimeTypeHandle _impl;

	// Properties
	public override MemberTypes MemberType { get; }
	public override Type DeclaringType { get; }
	public virtual MethodBase DeclaringMethod { get; }
	public override Type ReflectedType { get; }
	public static Binder DefaultBinder { get; }
	public abstract override Module Module { get; }
	public abstract Assembly Assembly { get; }
	public virtual RuntimeTypeHandle TypeHandle { get; }
	public abstract string FullName { get; }
	public abstract string Namespace { get; }
	public abstract string AssemblyQualifiedName { get; }
	public abstract Type BaseType { get; }
	public bool IsNested { get; }
	public TypeAttributes Attributes { get; }
	public virtual GenericParameterAttributes GenericParameterAttributes { get; }
	public bool IsNotPublic { get; }
	public bool IsPublic { get; }
	public bool IsNestedPublic { get; }
	public bool IsNestedAssembly { get; }
	public bool IsExplicitLayout { get; }
	public bool IsClass { get; }
	public bool IsInterface { get; }
	public bool IsValueType { get; }
	public bool IsAbstract { get; }
	public bool IsSealed { get; }
	public virtual bool IsEnum { get; }
	public virtual bool IsSerializable { get; }
	public bool IsArray { get; }
	internal virtual bool IsSzArray { get; }
	public virtual bool IsGenericType { get; }
	public virtual bool IsGenericTypeDefinition { get; }
	public virtual bool IsGenericParameter { get; }
	public virtual int GenericParameterPosition { get; }
	public virtual bool ContainsGenericParameters { get; }
	public bool IsByRef { get; }
	public bool IsPointer { get; }
	public bool IsPrimitive { get; }
	public bool IsCOMObject { get; }
	public bool HasElementType { get; }
	public bool IsContextful { get; }
	public bool IsMarshalByRef { get; }
	public abstract Type UnderlyingSystemType { get; }

	// Methods
	protected void .ctor();
	public override MemberTypes get_MemberType();
	public override Type get_DeclaringType();
	public virtual MethodBase get_DeclaringMethod();
	public override Type get_ReflectedType();
	public static Type GetType(string typeName, Func`2<AssemblyNameAssembly> assemblyResolver, Func`4<AssemblystringboolType> typeResolver, bool throwOnError);
	public virtual Type MakePointerType();
	public virtual Type MakeByRefType();
	public virtual Type MakeArrayType();
	public virtual Type MakeArrayType(int rank);
	public static TypeCode GetTypeCode(Type type);
	protected virtual TypeCode GetTypeCodeImpl();
	public static Binder get_DefaultBinder();
	private static void CreateBinder();
	public abstract object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);
	public abstract override Module get_Module();
	public abstract Assembly get_Assembly();
	public virtual RuntimeTypeHandle get_TypeHandle();
	public static RuntimeTypeHandle GetTypeHandle(object o);
	public abstract string get_FullName();
	public abstract string get_Namespace();
	public abstract string get_AssemblyQualifiedName();
	public virtual int GetArrayRank();
	public abstract Type get_BaseType();
	public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
	public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
	public ConstructorInfo GetConstructor(Type[] types);
	protected abstract ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
	public abstract ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
	public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
	public MethodInfo GetMethod(string name, Type[] types);
	public MethodInfo GetMethod(string name, BindingFlags bindingAttr);
	public MethodInfo GetMethod(string name);
	protected abstract MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
	public MethodInfo[] GetMethods();
	public abstract MethodInfo[] GetMethods(BindingFlags bindingAttr);
	public abstract FieldInfo GetField(string name, BindingFlags bindingAttr);
	public abstract FieldInfo[] GetFields(BindingFlags bindingAttr);
	public abstract Type[] GetInterfaces();
	public abstract EventInfo GetEvent(string name, BindingFlags bindingAttr);
	public PropertyInfo GetProperty(string name, Type returnType, Type[] types);
	public PropertyInfo GetProperty(string name, Type returnType);
	protected abstract PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
	public abstract Type GetNestedType(string name, BindingFlags bindingAttr);
	public MemberInfo[] GetMember(string name);
	public virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
	public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
	public bool get_IsNested();
	public TypeAttributes get_Attributes();
	public virtual GenericParameterAttributes get_GenericParameterAttributes();
	public bool get_IsNotPublic();
	public bool get_IsPublic();
	public bool get_IsNestedPublic();
	public bool get_IsNestedAssembly();
	public bool get_IsExplicitLayout();
	public bool get_IsClass();
	public bool get_IsInterface();
	public bool get_IsValueType();
	public bool get_IsAbstract();
	public bool get_IsSealed();
	public virtual bool get_IsEnum();
	public virtual bool get_IsSerializable();
	public bool get_IsArray();
	internal virtual bool get_IsSzArray();
	public virtual bool get_IsGenericType();
	public virtual bool get_IsGenericTypeDefinition();
	public virtual bool get_IsGenericParameter();
	public virtual int get_GenericParameterPosition();
	public virtual bool get_ContainsGenericParameters();
	public virtual Type[] GetGenericParameterConstraints();
	public bool get_IsByRef();
	public bool get_IsPointer();
	public bool get_IsPrimitive();
	public bool get_IsCOMObject();
	public bool get_HasElementType();
	public bool get_IsContextful();
	public bool get_IsMarshalByRef();
	protected virtual bool IsValueTypeImpl();
	protected abstract TypeAttributes GetAttributeFlagsImpl();
	protected abstract bool IsArrayImpl();
	protected abstract bool IsByRefImpl();
	protected abstract bool IsPointerImpl();
	protected abstract bool IsPrimitiveImpl();
	protected abstract bool IsCOMObjectImpl();
	public virtual Type MakeGenericType(Type[] typeArguments);
	protected virtual bool IsContextfulImpl();
	protected virtual bool IsMarshalByRefImpl();
	public abstract Type GetElementType();
	public virtual Type[] GetGenericArguments();
	public virtual Type GetGenericTypeDefinition();
	protected abstract bool HasElementTypeImpl();
	internal Type GetRootElementType();
	public virtual string[] GetEnumNames();
	private Array GetEnumRawConstantValues();
	private void GetEnumData(out string[] enumNames, out Array enumValues);
	public virtual Type GetEnumUnderlyingType();
	public virtual bool IsEnumDefined(object value);
	public virtual string GetEnumName(object value);
	private static int BinarySearch(Array array, object value);
	internal static bool IsIntegerType(Type t);
	public abstract Type get_UnderlyingSystemType();
	public virtual bool IsSubclassOf(Type c);
	public virtual bool IsInstanceOfType(object o);
	public virtual bool IsAssignableFrom(Type c);
	public virtual bool IsEquivalentTo(Type other);
	internal bool ImplementInterface(Type ifaceType);
	internal string FormatTypeName();
	internal virtual string FormatTypeName(bool serialization);
	public override string ToString();
	public override bool Equals(object o);
	public virtual bool Equals(Type o);
	public static bool op_Equality(Type left, Type right);
	public static bool op_Inequality(Type left, Type right);
	public override int GetHashCode();
	public Type GetType();
	private static Type internal_from_name(string name, bool throwOnError, bool ignoreCase);
	public static Type GetType(string typeName);
	public static Type GetType(string typeName, bool throwOnError);
	public static Type GetType(string typeName, bool throwOnError, bool ignoreCase);
	public static Type GetTypeFromHandle(RuntimeTypeHandle handle);
	private static Type internal_from_handle(IntPtr handle);
	private static void .cctor();

}
//NameSpace:System
public struct TypedReference
{
	// Fields
	private RuntimeTypeHandle type;
	private IntPtr Value;
	private IntPtr Type;

	// Properties
	internal bool IsNull { get; }

	// Methods
	public static System.TypedReference MakeTypedReference(object target, FieldInfo[] flds);
	private static System.TypedReference MakeTypedReferenceInternal(object target, FieldInfo[] fields);
	public override int GetHashCode();
	public override bool Equals(object o);
	internal bool get_IsNull();
	public static void SetTypedReference(System.TypedReference target, object value);

}
//NameSpace:System
public sealed class TypeInitializationException : SystemException
{
	// Fields
	private string _typeName;

	// Properties
	public string TypeName { get; }

	// Methods
	private void .ctor();
	public void .ctor(string fullTypeName, Exception innerException);
	internal void .ctor(SerializationInfo info, StreamingContext context);
	public string get_TypeName();
	public override void GetObjectData(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class TypeLoadException : SystemException, ISerializable
{
	// Fields
	private string ClassName;
	private string AssemblyName;
	private string MessageArg;
	internal int ResourceId;

	// Properties
	public override string Message { get; }

	// Methods
	public void .ctor();
	public void .ctor(string message);
	public override string get_Message();
	private void SetMessageField();
	private void .ctor(string className, string assemblyName);
	private void .ctor(string className, string assemblyName, string messageArg, int resourceId);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public override void GetObjectData(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public struct UInt16 : IComparable, IFormattable, IConvertible, IComparable`1<ushort>, IEquatable`1<ushort>
{
	// Fields
	private ushort m_value;
	public const ushort MaxValue;
	public const ushort MinValue;

	// Methods
	public int CompareTo(object value);
	public int CompareTo(ushort value);
	public override bool Equals(object obj);
	public bool Equals(ushort obj);
	public override int GetHashCode();
	public override string ToString();
	public string ToString(IFormatProvider provider);
	public string ToString(string format, IFormatProvider provider);
	public static ushort Parse(string s, IFormatProvider provider);
	public static ushort Parse(string s, NumberStyles style, IFormatProvider provider);
	private static ushort Parse(string s, NumberStyles style, NumberFormatInfo info);
	public TypeCode GetTypeCode();
	private bool System.IConvertible.ToBoolean(IFormatProvider provider);
	private char System.IConvertible.ToChar(IFormatProvider provider);
	private sbyte System.IConvertible.ToSByte(IFormatProvider provider);
	private byte System.IConvertible.ToByte(IFormatProvider provider);
	private short System.IConvertible.ToInt16(IFormatProvider provider);
	private ushort System.IConvertible.ToUInt16(IFormatProvider provider);
	private int System.IConvertible.ToInt32(IFormatProvider provider);
	private uint System.IConvertible.ToUInt32(IFormatProvider provider);
	private long System.IConvertible.ToInt64(IFormatProvider provider);
	private ulong System.IConvertible.ToUInt64(IFormatProvider provider);
	private float System.IConvertible.ToSingle(IFormatProvider provider);
	private double System.IConvertible.ToDouble(IFormatProvider provider);
	private Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
	private DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
	private object System.IConvertible.ToType(Type type, IFormatProvider provider);

}
//NameSpace:System
public struct UInt32 : IComparable, IFormattable, IConvertible, IComparable`1<uint>, IEquatable`1<uint>
{
	// Fields
	private uint m_value;
	public const uint MaxValue;
	public const uint MinValue;

	// Methods
	public int CompareTo(object value);
	public int CompareTo(uint value);
	public override bool Equals(object obj);
	public bool Equals(uint obj);
	public override int GetHashCode();
	public override string ToString();
	public string ToString(IFormatProvider provider);
	public string ToString(string format, IFormatProvider provider);
	public static uint Parse(string s, IFormatProvider provider);
	public static uint Parse(string s, NumberStyles style, IFormatProvider provider);
	public TypeCode GetTypeCode();
	private bool System.IConvertible.ToBoolean(IFormatProvider provider);
	private char System.IConvertible.ToChar(IFormatProvider provider);
	private sbyte System.IConvertible.ToSByte(IFormatProvider provider);
	private byte System.IConvertible.ToByte(IFormatProvider provider);
	private short System.IConvertible.ToInt16(IFormatProvider provider);
	private ushort System.IConvertible.ToUInt16(IFormatProvider provider);
	private int System.IConvertible.ToInt32(IFormatProvider provider);
	private uint System.IConvertible.ToUInt32(IFormatProvider provider);
	private long System.IConvertible.ToInt64(IFormatProvider provider);
	private ulong System.IConvertible.ToUInt64(IFormatProvider provider);
	private float System.IConvertible.ToSingle(IFormatProvider provider);
	private double System.IConvertible.ToDouble(IFormatProvider provider);
	private Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
	private DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
	private object System.IConvertible.ToType(Type type, IFormatProvider provider);

}
//NameSpace:System
public struct UInt64 : IComparable, IFormattable, IConvertible, IComparable`1<ulong>, IEquatable`1<ulong>
{
	// Fields
	private ulong m_value;
	public const ulong MaxValue;
	public const ulong MinValue;

	// Methods
	public int CompareTo(object value);
	public int CompareTo(ulong value);
	public override bool Equals(object obj);
	public bool Equals(ulong obj);
	public override int GetHashCode();
	public override string ToString();
	public string ToString(IFormatProvider provider);
	public string ToString(string format, IFormatProvider provider);
	public static ulong Parse(string s, IFormatProvider provider);
	public static ulong Parse(string s, NumberStyles style, IFormatProvider provider);
	public TypeCode GetTypeCode();
	private bool System.IConvertible.ToBoolean(IFormatProvider provider);
	private char System.IConvertible.ToChar(IFormatProvider provider);
	private sbyte System.IConvertible.ToSByte(IFormatProvider provider);
	private byte System.IConvertible.ToByte(IFormatProvider provider);
	private short System.IConvertible.ToInt16(IFormatProvider provider);
	private ushort System.IConvertible.ToUInt16(IFormatProvider provider);
	private int System.IConvertible.ToInt32(IFormatProvider provider);
	private uint System.IConvertible.ToUInt32(IFormatProvider provider);
	private long System.IConvertible.ToInt64(IFormatProvider provider);
	private ulong System.IConvertible.ToUInt64(IFormatProvider provider);
	private float System.IConvertible.ToSingle(IFormatProvider provider);
	private double System.IConvertible.ToDouble(IFormatProvider provider);
	private Decimal System.IConvertible.ToDecimal(IFormatProvider provider);
	private DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
	private object System.IConvertible.ToType(Type type, IFormatProvider provider);

}
//NameSpace:System
public class UnauthorizedAccessException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
public class UnhandledExceptionEventArgs : EventArgs
{
	// Fields
	private object _Exception;
	private bool _IsTerminating;

	// Properties
	public object ExceptionObject { get; }
	public bool IsTerminating { get; }

	// Methods
	public void .ctor(object exception, bool isTerminating);
	public object get_ExceptionObject();
	public bool get_IsTerminating();

}
//NameSpace:System
public sealed class UnhandledExceptionEventHandler : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(object sender, UnhandledExceptionEventArgs e);
	public virtual IAsyncResult BeginInvoke(object sender, UnhandledExceptionEventArgs e, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System
internal class UnitySerializationHolder : ISerializable, IObjectReference
{
	// Fields
	private Type[] m_instantiation;
	private int[] m_elementTypes;
	private int m_genericParameterPosition;
	private Type m_declaringType;
	private MethodBase m_declaringMethod;
	private string m_data;
	private string m_assemblyName;
	private int m_unityType;

	// Methods
	internal static void GetUnitySerializationInfo(SerializationInfo info, Missing missing);
	internal static RuntimeType AddElementTypes(SerializationInfo info, RuntimeType type);
	internal Type MakeElementTypes(Type type);
	internal static void GetUnitySerializationInfo(SerializationInfo info, RuntimeType type);
	internal static void GetUnitySerializationInfo(SerializationInfo info, int unityType, string data, RuntimeAssembly assembly);
	internal void .ctor(SerializationInfo info, StreamingContext context);
	private void ThrowInsufficientInformation(string field);
	public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
	public virtual object GetRealObject(StreamingContext context);

}
//NameSpace:System
internal struct UnSafeCharBuffer
{
	// Fields
	private char* m_buffer;
	private int m_totalSize;
	private int m_length;

	// Methods
	public void .ctor(char* buffer, int bufferSize);
	public void AppendString(string stringToAppend);

}
//NameSpace:System
public sealed class Version : ICloneable, IComparable, IComparable`1<Version>, IEquatable`1<Version>
{
	// Fields
	private int _Major;
	private int _Minor;
	private int _Build;
	private int _Revision;
	private static readonly char[] SeparatorsArray;
	private const int ZERO_CHAR_VALUE;

	// Properties
	public int Major { get; }
	public int Minor { get; }
	public int Build { get; }
	public int Revision { get; }

	// Methods
	public void .ctor(int major, int minor, int build, int revision);
	public void .ctor();
	public int get_Major();
	public int get_Minor();
	public int get_Build();
	public int get_Revision();
	public object Clone();
	public int CompareTo(object version);
	public int CompareTo(Version value);
	public override bool Equals(object obj);
	public bool Equals(Version obj);
	public override int GetHashCode();
	public override string ToString();
	public string ToString(int fieldCount);
	private static void AppendPositiveNumber(int num, StringBuilder sb);
	public static bool op_Equality(Version v1, Version v2);
	public static bool op_Inequality(Version v1, Version v2);
	private static void .cctor();

}
//NameSpace:System
public sealed class AppDomain : MarshalByRefObject, IEvidenceFactory, _AppDomain
{
	// Fields
	private IntPtr _mono_app_domain;
	private static string _process_guid;
	private static Dictionary`2<stringobject> type_resolve_in_progress;
	private static Dictionary`2<stringobject> assembly_resolve_in_progress;
	private static Dictionary`2<stringobject> assembly_resolve_in_progress_refonly;
	private object _evidence;
	private object _granted;
	private int _principalPolicy;
	private static object _principal;
	private static AppDomain default_domain;
	private AssemblyLoadEventHandler AssemblyLoad;
	private ResolveEventHandler AssemblyResolve;
	private EventHandler DomainUnload;
	private EventHandler ProcessExit;
	private ResolveEventHandler ResourceResolve;
	private ResolveEventHandler TypeResolve;
	private UnhandledExceptionEventHandler UnhandledException;
	private EventHandler`1<FirstChanceExceptionEventArgs> FirstChanceException;
	private object _domain_manager;
	private ResolveEventHandler ReflectionOnlyAssemblyResolve;
	private object _activation;
	private object _applicationIdentity;
	private List`1<string> compatibility_switch;

	// Properties
	public static AppDomain CurrentDomain { get; }

	// Methods
	private void .ctor();
	private string getFriendlyName();
	private static AppDomain getCurDomain();
	public static AppDomain get_CurrentDomain();
	public object GetData(string name);
	public override object InitializeLifetimeService();
	internal Assembly LoadAssembly(string assemblyRef, Evidence securityEvidence, bool refOnly);
	public Assembly Load(string assemblyString);
	internal Assembly Load(string assemblyString, Evidence assemblySecurity, bool refonly);
	private static AppDomain InternalSetDomainByID(int domain_id);
	private static AppDomain InternalSetDomain(AppDomain context);
	internal static void InternalPushDomainRefByID(int domain_id);
	internal static void InternalPopDomainRef();
	internal static Context InternalSetContext(Context context);
	internal static Context InternalGetContext();
	internal static Context InternalGetDefaultContext();
	internal static string InternalGetProcessGuid(string newguid);
	internal static object InvokeInDomainByID(int domain_id, MethodInfo method, object obj, object[] args);
	internal static string GetProcessGuid();
	private static bool InternalIsFinalizingForUnload(int domain_id);
	public bool IsFinalizingForUnload();
	private int getDomainID();
	public override string ToString();
	private void DoAssemblyLoad(Assembly assembly);
	private Assembly DoAssemblyResolve(string name, Assembly requestingAssembly, bool refonly);
	internal Assembly DoTypeResolve(object name_or_tb);
	private void DoDomainUnload();
	internal byte[] GetMarshalledDomainObjRef();
	internal void ProcessMessageInDomain(byte[] arrRequest, CADMethodCallMessage cadMsg, out byte[] arrResponse, out CADMethodReturnMessage cadMrm);
	public void add_DomainUnload(EventHandler value);
	public void remove_DomainUnload(EventHandler value);
	public void add_UnhandledException(UnhandledExceptionEventHandler value);
	public void remove_UnhandledException(UnhandledExceptionEventHandler value);

}
//NameSpace:System
internal class CLRConfig
{
	// Methods
	internal static bool CheckThrowUnobservedTaskExceptions();

}
//NameSpace:System
internal static class CompatibilitySwitches
{
	// Fields
	public static readonly bool IsAppEarlierThanSilverlight4;
	public static readonly bool IsAppEarlierThanWindowsPhone8;

	// Methods
	private static void .cctor();

}
//NameSpace:System
public static class Environment
{
	// Fields
	private const int mono_corlib_version;
	private static string nl;
	private static OperatingSystem os;

	// Properties
	public static bool HasShutdownStarted { get; }
	public static string NewLine { get; }
	private static PlatformID Platform { get; }
	public static OperatingSystem OSVersion { get; }
	public static string StackTrace { get; }
	public static int TickCount { get; }
	public static bool Is64BitProcess { get; }
	public static int ProcessorCount { get; }
	internal static bool IsRunningOnWindows { get; }

	// Methods
	internal static string GetResourceString(string key);
	internal static string GetResourceString(string key, object[] values);
	internal static string GetResourceStringEncodingName(int codePage);
	public static bool get_HasShutdownStarted();
	private static string GetNewLine();
	public static string get_NewLine();
	private static PlatformID get_Platform();
	internal static string GetOSVersionString();
	public static OperatingSystem get_OSVersion();
	internal static Version CreateVersionFromString(string info);
	public static string get_StackTrace();
	public static int get_TickCount();
	public static void Exit(int exitCode);
	public static string ExpandEnvironmentVariables(string name);
	internal static string internalGetEnvironmentVariable_native(IntPtr variable);
	internal static string internalGetEnvironmentVariable(string variable);
	public static string GetEnvironmentVariable(string variable);
	private static Hashtable GetEnvironmentVariablesNoCase();
	public static string GetFolderPath(Environment.SpecialFolder folder);
	private static string GetWindowsFolderPath(int folder);
	public static string GetFolderPath(Environment.SpecialFolder folder, Environment.SpecialFolderOption option);
	private static string ReadXdgUserDir(string config_dir, string home_dir, string key, string fallback);
	internal static string UnixGetFolderPath(Environment.SpecialFolder folder, Environment.SpecialFolderOption option);
	public static void FailFast(string message, Exception exception);
	public static bool get_Is64BitProcess();
	public static int get_ProcessorCount();
	internal static bool get_IsRunningOnWindows();
	private static string[] GetEnvironmentVariableNames();
	internal static string GetMachineConfigPath();
	internal static string internalGetHome();
	internal static int GetPageSize();
	internal static string GetStackTrace(Exception e, bool needFileInfo);

}
//NameSpace:
public enum Environment.SpecialFolder
{
	// Fields
	public int value__;
	public const Environment.SpecialFolder MyDocuments;
	public const Environment.SpecialFolder Desktop;
	public const Environment.SpecialFolder MyComputer;
	public const Environment.SpecialFolder Programs;
	public const Environment.SpecialFolder Personal;
	public const Environment.SpecialFolder Favorites;
	public const Environment.SpecialFolder Startup;
	public const Environment.SpecialFolder Recent;
	public const Environment.SpecialFolder SendTo;
	public const Environment.SpecialFolder StartMenu;
	public const Environment.SpecialFolder MyMusic;
	public const Environment.SpecialFolder DesktopDirectory;
	public const Environment.SpecialFolder Templates;
	public const Environment.SpecialFolder ApplicationData;
	public const Environment.SpecialFolder LocalApplicationData;
	public const Environment.SpecialFolder InternetCache;
	public const Environment.SpecialFolder Cookies;
	public const Environment.SpecialFolder History;
	public const Environment.SpecialFolder CommonApplicationData;
	public const Environment.SpecialFolder System;
	public const Environment.SpecialFolder ProgramFiles;
	public const Environment.SpecialFolder MyPictures;
	public const Environment.SpecialFolder CommonProgramFiles;
	public const Environment.SpecialFolder MyVideos;
	public const Environment.SpecialFolder NetworkShortcuts;
	public const Environment.SpecialFolder Fonts;
	public const Environment.SpecialFolder CommonStartMenu;
	public const Environment.SpecialFolder CommonPrograms;
	public const Environment.SpecialFolder CommonStartup;
	public const Environment.SpecialFolder CommonDesktopDirectory;
	public const Environment.SpecialFolder PrinterShortcuts;
	public const Environment.SpecialFolder Windows;
	public const Environment.SpecialFolder UserProfile;
	public const Environment.SpecialFolder SystemX86;
	public const Environment.SpecialFolder ProgramFilesX86;
	public const Environment.SpecialFolder CommonProgramFilesX86;
	public const Environment.SpecialFolder CommonTemplates;
	public const Environment.SpecialFolder CommonDocuments;
	public const Environment.SpecialFolder CommonAdminTools;
	public const Environment.SpecialFolder AdminTools;
	public const Environment.SpecialFolder CommonMusic;
	public const Environment.SpecialFolder CommonPictures;
	public const Environment.SpecialFolder CommonVideos;
	public const Environment.SpecialFolder Resources;
	public const Environment.SpecialFolder LocalizedResources;
	public const Environment.SpecialFolder CommonOemLinks;
	public const Environment.SpecialFolder CDBurning;

}
//NameSpace:
public enum Environment.SpecialFolderOption
{
	// Fields
	public int value__;
	public const Environment.SpecialFolderOption None;
	public const Environment.SpecialFolderOption DoNotVerify;
	public const Environment.SpecialFolderOption Create;

}
//NameSpace:System
internal static class ParseNumbers
{
	// Methods
	public static int StringToInt(string value, int fromBase, int flags);
	public static int StringToInt(string value, int fromBase, int flags, int* parsePos);
	public static long StringToLong(string value, int fromBase, int flags, int* parsePos);
	public static string IntToString(int value, int toBase, int width, char paddingChar, int flags);
	private static void EndianSwap(byte[] value);
	private static StringBuilder ConvertToBase2(byte[] value);
	private static StringBuilder ConvertToBase8(byte[] value);
	private static StringBuilder ConvertToBase16(byte[] value);

}
//NameSpace:System
internal class MonoTypeInfo
{
	// Fields
	public string full_name;
	public MonoCMethod default_ctor;

	// Methods
	public void .ctor();

}
//NameSpace:System
internal sealed class TypeNameParser
{
	// Methods
	internal static Type GetType(string typeName, Func`2<AssemblyNameAssembly> assemblyResolver, Func`4<AssemblystringboolType> typeResolver, bool throwOnError, bool ignoreCase, StackCrawlMark stackMark);

}
//NameSpace:System
public sealed class AppDomainSetup : IAppDomainSetup
{
	// Fields
	private string application_base;
	private string application_name;
	private string cache_path;
	private string configuration_file;
	private string dynamic_base;
	private string license_file;
	private string private_bin_path;
	private string private_bin_path_probe;
	private string shadow_copy_directories;
	private string shadow_copy_files;
	private bool publisher_policy;
	private bool path_changed;
	private int loader_optimization;
	private bool disallow_binding_redirects;
	private bool disallow_code_downloads;
	private object _activationArguments;
	private object domain_initializer;
	private object application_trust;
	private string[] domain_initializer_args;
	private bool disallow_appbase_probe;
	private byte[] configuration_bytes;
	private byte[] serialized_non_primitives;
	private string <TargetFrameworkName>k__BackingField;

	// Methods
	public void .ctor();

}
//NameSpace:System
public struct ArgIterator
{
	// Fields
	private IntPtr sig;
	private IntPtr args;
	private int next_arg;
	private int num_args;

	// Methods
	public override bool Equals(object o);
	public override int GetHashCode();

}
//NameSpace:System
public class AssemblyLoadEventArgs : EventArgs
{
	// Fields
	private Assembly m_loadedAssembly;

	// Methods
	public void .ctor(Assembly loadedAssembly);

}
//NameSpace:System
public sealed class AssemblyLoadEventHandler : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(object sender, AssemblyLoadEventArgs args);
	public virtual IAsyncResult BeginInvoke(object sender, AssemblyLoadEventArgs args, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System
public static class Console
{
	// Fields
	internal static TextWriter stdout;
	private static TextWriter stderr;
	private static TextReader stdin;
	private static Encoding inputEncoding;
	private static Encoding outputEncoding;
	private static ConsoleCancelEventHandler cancel_event;
	private static readonly Console.InternalCancelHandler cancel_handler;

	// Properties
	public static TextWriter Error { get; }
	public static Encoding InputEncoding { get; }
	public static Encoding OutputEncoding { get; }

	// Methods
	private static void .cctor();
	private static void SetupStreams(Encoding inputEncoding, Encoding outputEncoding);
	public static TextWriter get_Error();
	private static Stream Open(IntPtr handle, FileAccess access, int bufferSize);
	public static Stream OpenStandardError(int bufferSize);
	public static Stream OpenStandardInput(int bufferSize);
	public static Stream OpenStandardOutput(int bufferSize);
	public static void SetOut(TextWriter newOut);
	public static Encoding get_InputEncoding();
	public static Encoding get_OutputEncoding();
	public static ConsoleKeyInfo ReadKey();
	public static ConsoleKeyInfo ReadKey(bool intercept);
	internal static void DoConsoleCancelEvent();

}
//NameSpace:
private class Console.WindowsConsole
{
	// Fields
	public static bool ctrlHandlerAdded;
	private static Console.WindowsConsole.WindowsCancelHandler cancelHandler;

	// Methods
	private static extern int GetConsoleCP();
	private static extern int GetConsoleOutputCP();
	private static bool DoWindowsConsoleCancelEvent(int keyCode);
	public static int GetInputCodePage();
	public static int GetOutputCodePage();
	private static void .cctor();

}
//NameSpace:
private sealed class Console.WindowsConsole.WindowsCancelHandler : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual bool Invoke(int keyCode);
	public virtual IAsyncResult BeginInvoke(int keyCode, AsyncCallback callback, object object);
	public virtual bool EndInvoke(IAsyncResult result);

}
//NameSpace:
private sealed class Console.InternalCancelHandler : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke();
	public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System
internal static class ConsoleDriver
{
	// Fields
	internal static IConsoleDriver driver;
	private static bool is_console;
	private static bool called_isatty;

	// Properties
	public static bool IsConsole { get; }

	// Methods
	private static void .cctor();
	private static IConsoleDriver CreateNullConsoleDriver();
	private static IConsoleDriver CreateWindowsConsoleDriver();
	private static IConsoleDriver CreateTermInfoDriver(string term);
	public static ConsoleKeyInfo ReadKey(bool intercept);
	public static bool get_IsConsole();
	private static bool Isatty(IntPtr handle);
	internal static int InternalKeyAvailable(int ms_timeout);
	internal static bool TtySetup(string keypadXmit, string teardown, out byte[] control_characters, out int* address);
	internal static bool SetEcho(bool wantEcho);

}
//NameSpace:System
internal sealed class DelegateData
{
	// Fields
	public Type target_type;
	public string method_name;
	public bool curried_first_arg;

	// Methods
	public void .ctor();

}
//NameSpace:System
public abstract class Delegate : ICloneable, ISerializable
{
	// Fields
	private IntPtr method_ptr;
	private IntPtr invoke_impl;
	private object m_target;
	private IntPtr method;
	private IntPtr delegate_trampoline;
	private IntPtr extra_arg;
	private IntPtr method_code;
	private MethodInfo method_info;
	private MethodInfo original_method_info;
	private DelegateData data;
	private bool method_is_virtual;

	// Properties
	public MethodInfo Method { get; }
	public object Target { get; }

	// Methods
	public MethodInfo get_Method();
	private MethodInfo GetVirtualMethod_internal();
	public object get_Target();
	internal static Delegate CreateDelegate_internal(Type type, object target, MethodInfo info, bool throwOnBindFailure);
	private static bool arg_type_match(Type delArgType, Type argType);
	private static bool arg_type_match_this(Type delArgType, Type argType, bool boxedThis);
	private static bool return_type_match(Type delReturnType, Type returnType);
	public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure);
	private static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure, bool allowClosed);
	public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method);
	public static Delegate CreateDelegate(Type type, MethodInfo method, bool throwOnBindFailure);
	public static Delegate CreateDelegate(Type type, MethodInfo method);
	public static Delegate CreateDelegate(Type type, object target, string method);
	private static MethodInfo GetCandidateMethod(Type type, Type target, string method, BindingFlags bflags, bool ignoreCase, bool throwOnBindFailure);
	public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);
	public static Delegate CreateDelegate(Type type, Type target, string method);
	public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);
	public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase);
	public virtual object Clone();
	public override bool Equals(object obj);
	public override int GetHashCode();
	protected virtual MethodInfo GetMethodImpl();
	public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
	public virtual Delegate[] GetInvocationList();
	public static Delegate Combine(Delegate a, Delegate b);
	public static Delegate Combine(Delegate[] delegates);
	protected virtual Delegate CombineImpl(Delegate d);
	public static Delegate Remove(Delegate source, Delegate value);
	protected virtual Delegate RemoveImpl(Delegate d);
	internal static Delegate CreateDelegateNoSecurityCheck(RuntimeType type, object firstArgument, MethodInfo method);
	internal static MulticastDelegate AllocDelegateLike_internal(Delegate d);

}
//NameSpace:System
internal class DelegateSerializationHolder : ISerializable, IObjectReference
{
	// Fields
	private Delegate _delegate;

	// Methods
	private void .ctor(SerializationInfo info, StreamingContext ctx);
	public static void GetDelegateData(Delegate instance, SerializationInfo info, StreamingContext ctx);
	public void GetObjectData(SerializationInfo info, StreamingContext context);
	public object GetRealObject(StreamingContext context);

}
//NameSpace:
private class DelegateSerializationHolder.DelegateEntry
{
	// Fields
	private string type;
	private string assembly;
	private object target;
	private string targetTypeAssembly;
	private string targetTypeName;
	private string methodName;
	public DelegateSerializationHolder.DelegateEntry delegateEntry;

	// Methods
	public void .ctor(Delegate del, string targetLabel);
	public Delegate DeserializeDelegate(SerializationInfo info, int index);

}
//NameSpace:System
internal static class EmptyArray`1
{
	// Fields
	public static readonly T[] Value;

	// Methods
	private static void .cctor();

}
//NameSpace:System
internal enum SByteEnum
{
	// Fields
	public sbyte value__;

}
//NameSpace:System
internal enum Int16Enum
{
	// Fields
	public short value__;

}
//NameSpace:System
internal enum Int32Enum
{
	// Fields
	public int value__;

}
//NameSpace:System
internal enum Int64Enum
{
	// Fields
	public long value__;

}
//NameSpace:System
internal enum ByteEnum
{
	// Fields
	public byte value__;

}
//NameSpace:System
internal enum UInt16Enum
{
	// Fields
	public ushort value__;

}
//NameSpace:System
internal enum UInt32Enum
{
	// Fields
	public uint value__;

}
//NameSpace:System
internal enum UInt64Enum
{
	// Fields
	public ulong value__;

}
//NameSpace:System
internal interface IConsoleDriver
{
	// Methods
	public abstract ConsoleKeyInfo ReadKey(bool intercept);

}
//NameSpace:System
public struct IntPtr : ISerializable
{
	// Fields
	private void* m_value;
	public static readonly IntPtr Zero;

	// Properties
	public static int Size { get; }

	// Methods
	public void .ctor(int value);
	public void .ctor(long value);
	public void .ctor(void* value);
	private void .ctor(SerializationInfo info, StreamingContext context);
	public static int get_Size();
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	public override bool Equals(object obj);
	public override int GetHashCode();
	public long ToInt64();
	public void* ToPointer();
	public override string ToString();
	public string ToString(string format);
	public static bool op_Equality(IntPtr value1, IntPtr value2);
	public static bool op_Inequality(IntPtr value1, IntPtr value2);
	public static IntPtr op_Explicit(int value);
	public static IntPtr op_Explicit(long value);
	public static IntPtr op_Explicit(void* value);
	public static int op_Explicit(IntPtr value);
	public static void* op_Explicit(IntPtr value);
	internal bool IsNull();

}
//NameSpace:System
internal static class KnownTerminals
{
	// Properties
	public static byte[] linux { get; }
	public static byte[] xterm { get; }
	public static byte[] ansi { get; }

	// Methods
	public static byte[] get_linux();
	public static byte[] get_xterm();
	public static byte[] get_ansi();

}
//NameSpace:System
public abstract class MarshalByRefObject
{
	// Fields
	private object _identity;

	// Properties
	internal ServerIdentity ObjectIdentity { get; set; }

	// Methods
	protected void .ctor();
	internal ServerIdentity get_ObjectIdentity();
	internal void set_ObjectIdentity(ServerIdentity value);
	public virtual ObjRef CreateObjRef(Type requestedType);
	public virtual object InitializeLifetimeService();

}
//NameSpace:System
internal class MonoAsyncCall
{
	// Fields
	private object msg;
	private IntPtr cb_method;
	private object cb_target;
	private object state;
	private object res;
	private object out_args;

	// Methods
	public void .ctor();

}
//NameSpace:System
internal static class MonoCustomAttrs
{
	// Fields
	private static Assembly corlib;
	private static Dictionary`2<TypeAttributeUsageAttribute> usage_cache;
	private static readonly AttributeUsageAttribute DefaultAttributeUsage;

	// Methods
	private static bool IsUserCattrProvider(object obj);
	internal static object[] GetCustomAttributesInternal(ICustomAttributeProvider obj, Type attributeType, bool pseudoAttrs);
	internal static object[] GetPseudoCustomAttributes(ICustomAttributeProvider obj, Type attributeType);
	private static object[] GetPseudoCustomAttributes(Type type);
	internal static object[] GetCustomAttributesBase(ICustomAttributeProvider obj, Type attributeType, bool inheritedOnly);
	internal static object[] GetCustomAttributes(ICustomAttributeProvider obj, Type attributeType, bool inherit);
	internal static object[] GetCustomAttributes(ICustomAttributeProvider obj, bool inherit);
	private static CustomAttributeData[] GetCustomAttributesDataInternal(ICustomAttributeProvider obj);
	internal static IList`1<CustomAttributeData> GetCustomAttributesData(ICustomAttributeProvider obj);
	internal static bool IsDefined(ICustomAttributeProvider obj, Type attributeType, bool inherit);
	internal static bool IsDefinedInternal(ICustomAttributeProvider obj, Type AttributeType);
	private static PropertyInfo GetBasePropertyDefinition(MonoProperty property);
	private static EventInfo GetBaseEventDefinition(MonoEvent evt);
	private static ICustomAttributeProvider GetBase(ICustomAttributeProvider obj);
	private static AttributeUsageAttribute RetrieveAttributeUsageNoCache(Type attributeType);
	private static AttributeUsageAttribute RetrieveAttributeUsage(Type attributeType);
	private static void .cctor();

}
//NameSpace:
private class MonoCustomAttrs.AttributeInfo
{
	// Fields
	private AttributeUsageAttribute _usage;
	private int _inheritanceLevel;

	// Properties
	public AttributeUsageAttribute Usage { get; }
	public int InheritanceLevel { get; }

	// Methods
	public void .ctor(AttributeUsageAttribute usage, int inheritanceLevel);
	public AttributeUsageAttribute get_Usage();
	public int get_InheritanceLevel();

}
//NameSpace:System
internal sealed class MonoListItem
{
	// Fields
	private MonoListItem next;
	private object data;

}
//NameSpace:System
internal sealed class MonoType : RuntimeType
{
}
//NameSpace:System
public abstract class MulticastDelegate : Delegate
{
	// Fields
	private Delegate[] delegates;

	// Methods
	public override void GetObjectData(SerializationInfo info, StreamingContext context);
	public sealed override bool Equals(object obj);
	public sealed override int GetHashCode();
	protected override MethodInfo GetMethodImpl();
	public sealed override Delegate[] GetInvocationList();
	protected sealed override Delegate CombineImpl(Delegate follow);
	private int LastIndexOf(Delegate[] haystack, Delegate[] needle);
	protected sealed override Delegate RemoveImpl(Delegate value);

}
//NameSpace:System
internal class NullConsoleDriver : IConsoleDriver
{
	// Fields
	private static readonly ConsoleKeyInfo EmptyConsoleKeyInfo;

	// Methods
	public ConsoleKeyInfo ReadKey(bool intercept);
	public void .ctor();
	private static void .cctor();

}
//NameSpace:System
public static class Nullable
{
	// Methods
	public static Type GetUnderlyingType(Type nullableType);

}
//NameSpace:System
public struct Nullable`1
{
	// Fields
	internal T value;
	internal bool has_value;

	// Properties
	public bool HasValue { get; }
	public T Value { get; }

	// Methods
	public void .ctor(T value);
	public bool get_HasValue();
	public T get_Value();
	public override bool Equals(object other);
	private bool Equals(Nullable`1<T> other);
	public override int GetHashCode();
	public T GetValueOrDefault();
	public override string ToString();
	private static object Box(Nullable`1<T> o);
	private static Nullable`1<T> Unbox(object o);

}
//NameSpace:System
internal sealed class NumberFormatter
{
	// Fields
	private static readonly ulong* MantissaBitsTable;
	private static readonly int* TensExponentTable;
	private static readonly char* DigitLowerTable;
	private static readonly char* DigitUpperTable;
	private static readonly long* TenPowersList;
	private static readonly int* DecHexDigits;
	private NumberFormatInfo _nfi;
	private char[] _cbuf;
	private bool _NaN;
	private bool _infinity;
	private bool _isCustomFormat;
	private bool _specifierIsUpper;
	private bool _positive;
	private char _specifier;
	private int _precision;
	private int _defPrecision;
	private int _digitsLen;
	private int _offset;
	private int _decPointPos;
	private uint _val1;
	private uint _val2;
	private uint _val3;
	private uint _val4;
	private int _ind;
	private static NumberFormatter threadNumberFormatter;
	private static NumberFormatter userFormatProvider;

	// Properties
	private void CurrentCulture { set; }
	private int IntegerDigits { get; }
	private int DecimalDigits { get; }
	private bool IsFloatingSource { get; }
	private bool IsZero { get; }
	private bool IsZeroInteger { get; }

	// Methods
	private static void GetFormatterTables(out ulong* MantissaBitsTable, out int* TensExponentTable, out char* DigitLowerTable, out char* DigitUpperTable, out long* TenPowersList, out int* DecHexDigits);
	private static void .cctor();
	private static long GetTenPowerOf(int i);
	private void InitDecHexDigits(uint value);
	private void InitDecHexDigits(ulong value);
	private void InitDecHexDigits(uint hi, ulong lo);
	private static uint FastToDecHex(int val);
	private static uint ToDecHex(int val);
	private static int FastDecHexLen(int val);
	private static int DecHexLen(uint val);
	private int DecHexLen();
	private static int ScaleOrder(long hi);
	private int InitialFloatingPrecision();
	private static int ParsePrecision(string format);
	private void .ctor(Thread current);
	private void Init(string format);
	private void InitHex(ulong value);
	private void Init(string format, int value, int defPrecision);
	private void Init(string format, uint value, int defPrecision);
	private void Init(string format, long value);
	private void Init(string format, ulong value);
	private void Init(string format, double value, int defPrecision);
	private void Init(string format, Decimal value);
	private void ResetCharBuf(int size);
	private void Resize(int len);
	private void Append(char c);
	private void Append(char c, int cnt);
	private void Append(string s);
	private NumberFormatInfo GetNumberFormatInstance(IFormatProvider fp);
	private void set_CurrentCulture(CultureInfo value);
	private int get_IntegerDigits();
	private int get_DecimalDigits();
	private bool get_IsFloatingSource();
	private bool get_IsZero();
	private bool get_IsZeroInteger();
	private void RoundPos(int pos);
	private bool RoundDecimal(int decimals);
	private bool RoundBits(int shift);
	private void RemoveTrailingZeros();
	private void AddOneToDecHex();
	private static uint AddOneToDecHex(uint val);
	private int CountTrailingZeros();
	private static int CountTrailingZeros(uint val);
	private static NumberFormatter GetInstance(IFormatProvider fp);
	private void Release();
	public static string NumberToString(string format, uint value, IFormatProvider fp);
	public static string NumberToString(string format, int value, IFormatProvider fp);
	public static string NumberToString(string format, ulong value, IFormatProvider fp);
	public static string NumberToString(string format, long value, IFormatProvider fp);
	public static string NumberToString(string format, float value, IFormatProvider fp);
	public static string NumberToString(string format, double value, IFormatProvider fp);
	public static string NumberToString(string format, Decimal value, IFormatProvider fp);
	private string IntegerToString(string format, IFormatProvider fp);
	private string NumberToString(string format, NumberFormatInfo nfi);
	private string FormatCurrency(int precision, NumberFormatInfo nfi);
	private string FormatDecimal(int precision, NumberFormatInfo nfi);
	private string FormatHexadecimal(int precision);
	private string FormatFixedPoint(int precision, NumberFormatInfo nfi);
	private string FormatRoundtrip(double origval, NumberFormatInfo nfi);
	private string FormatRoundtrip(float origval, NumberFormatInfo nfi);
	private string FormatGeneral(int precision, NumberFormatInfo nfi);
	private string FormatNumber(int precision, NumberFormatInfo nfi);
	private string FormatPercent(int precision, NumberFormatInfo nfi);
	private string FormatExponential(int precision, NumberFormatInfo nfi);
	private string FormatExponential(int precision, NumberFormatInfo nfi, int expDigits);
	private string FormatCustom(string format, NumberFormatInfo nfi);
	private static void ZeroTrimEnd(StringBuilder sb, bool canEmpty);
	private static bool IsZeroOnly(StringBuilder sb);
	private static void AppendNonNegativeNumber(StringBuilder sb, int v);
	private void AppendIntegerString(int minLength, StringBuilder sb);
	private void AppendIntegerString(int minLength);
	private void AppendDecimalString(int precision, StringBuilder sb);
	private void AppendDecimalString(int precision);
	private void AppendIntegerStringWithGroupSeparator(int[] groups, string groupSeparator);
	private void AppendExponent(NumberFormatInfo nfi, int exponent, int minDigits);
	private void AppendOneDigit(int start);
	private void AppendDigits(int start, int end);
	private void AppendDigits(int start, int end, StringBuilder sb);
	private void Multiply10(int count);
	private void Divide10(int count);
	private NumberFormatter GetClone();

}
//NameSpace:
private class NumberFormatter.CustomInfo
{
	// Fields
	public bool UseGroup;
	public int DecimalDigits;
	public int DecimalPointPos;
	public int DecimalTailSharpDigits;
	public int IntegerDigits;
	public int IntegerHeadSharpDigits;
	public int IntegerHeadPos;
	public bool UseExponent;
	public int ExponentDigits;
	public int ExponentTailSharpDigits;
	public bool ExponentNegativeSignOnly;
	public int DividePlaces;
	public int Percents;
	public int Permilles;

	// Methods
	public static void GetActiveSection(string format, bool positive, bool zero, int offset, int length);
	public static NumberFormatter.CustomInfo Parse(string format, int offset, int length, NumberFormatInfo nfi);
	public string Format(string format, int offset, int length, NumberFormatInfo nfi, bool positive, StringBuilder sb_int, StringBuilder sb_dec, StringBuilder sb_exp);
	public void .ctor();

}
//NameSpace:System
public class Object
{
	// Methods
	public virtual bool Equals(object obj);
	public static bool Equals(object objA, object objB);
	public void .ctor();
	protected virtual void Finalize();
	public virtual int GetHashCode();
	public Type GetType();
	protected object MemberwiseClone();
	public virtual string ToString();
	public static bool ReferenceEquals(object objA, object objB);
	internal static int InternalGetHashCode(object o);
	private void FieldGetter(string typeName, string fieldName, object val);
	private void FieldSetter(string typeName, string fieldName, object val);

}
//NameSpace:System
public sealed class OperatingSystem : ICloneable, ISerializable
{
	// Fields
	private PlatformID _platform;
	private Version _version;
	private string _servicePack;

	// Properties
	public PlatformID Platform { get; }
	public string ServicePack { get; }

	// Methods
	public void .ctor(PlatformID platform, Version version);
	private void .ctor(SerializationInfo information, StreamingContext context);
	public PlatformID get_Platform();
	public string get_ServicePack();
	public object Clone();
	public void GetObjectData(SerializationInfo info, StreamingContext context);
	public override string ToString();

}
//NameSpace:System
public enum PlatformID
{
	// Fields
	public int value__;
	public const PlatformID Win32S;
	public const PlatformID Win32Windows;
	public const PlatformID Win32NT;
	public const PlatformID WinCE;
	public const PlatformID Unix;
	public const PlatformID Xbox;
	public const PlatformID MacOSX;

}
//NameSpace:System
public class ResolveEventArgs : EventArgs
{
	// Fields
	private string m_Name;
	private Assembly m_Requesting;

	// Methods
	public void .ctor(string name);
	public void .ctor(string name, Assembly requestingAssembly);

}
//NameSpace:System
public sealed class ResolveEventHandler : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual Assembly Invoke(object sender, ResolveEventArgs args);
	public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs args, AsyncCallback callback, object object);
	public virtual Assembly EndInvoke(IAsyncResult result);

}
//NameSpace:System
public struct RuntimeArgumentHandle
{
	// Fields
	internal IntPtr args;

}
//NameSpace:System
public struct RuntimeFieldHandle : ISerializable
{
	// Fields
	private IntPtr value;

	// Properties
	public IntPtr Value { get; }

	// Methods
	internal void .ctor(IntPtr v);
	private void .ctor(SerializationInfo info, StreamingContext context);
	public IntPtr get_Value();
	public void GetObjectData(SerializationInfo info, StreamingContext context);
	public override bool Equals(object obj);
	public override int GetHashCode();
	private static void SetValueInternal(FieldInfo fi, object obj, object value);
	internal static void SetValue(RtFieldInfo field, object obj, object value, RuntimeType fieldType, FieldAttributes fieldAttr, RuntimeType declaringType, bool domainInitialized);
	internal static void SetValueDirect(RtFieldInfo field, RuntimeType fieldType, void* pTypedRef, object value, RuntimeType contextType);

}
//NameSpace:System
public struct RuntimeMethodHandle : ISerializable
{
	// Fields
	private IntPtr value;

	// Properties
	public IntPtr Value { get; }

	// Methods
	internal void .ctor(IntPtr v);
	private void .ctor(SerializationInfo info, StreamingContext context);
	public IntPtr get_Value();
	public void GetObjectData(SerializationInfo info, StreamingContext context);
	public override bool Equals(object obj);
	public override int GetHashCode();
	internal static string ConstructInstantiation(RuntimeMethodInfo method, TypeNameFormatFlags format);
	internal bool IsNullHandle();

}
//NameSpace:System
public struct RuntimeTypeHandle : ISerializable
{
	// Fields
	private IntPtr value;

	// Properties
	public IntPtr Value { get; }

	// Methods
	internal void .ctor(IntPtr val);
	internal void .ctor(RuntimeType type);
	private void .ctor(SerializationInfo info, StreamingContext context);
	public IntPtr get_Value();
	public void GetObjectData(SerializationInfo info, StreamingContext context);
	public override bool Equals(object obj);
	public override int GetHashCode();
	internal static TypeAttributes GetAttributes(RuntimeType type);
	private static int GetMetadataToken(RuntimeType type);
	internal static int GetToken(RuntimeType type);
	private static Type GetGenericTypeDefinition_impl(RuntimeType type);
	internal static Type GetGenericTypeDefinition(RuntimeType type);
	internal static bool HasElementType(RuntimeType type);
	internal static bool HasInstantiation(RuntimeType type);
	internal static bool IsArray(RuntimeType type);
	internal static bool IsByRef(RuntimeType type);
	internal static bool IsComObject(RuntimeType type);
	internal static bool IsInstanceOfType(RuntimeType type, object o);
	internal static bool IsPointer(RuntimeType type);
	internal static bool IsPrimitive(RuntimeType type);
	internal static bool HasReferences(RuntimeType type);
	internal static bool IsComObject(RuntimeType type, bool isGenericCOM);
	internal static bool IsContextful(RuntimeType type);
	internal static bool IsEquivalentTo(RuntimeType rtType1, RuntimeType rtType2);
	internal static bool IsSzArray(RuntimeType type);
	internal static bool IsInterface(RuntimeType type);
	internal static int GetArrayRank(RuntimeType type);
	internal static RuntimeAssembly GetAssembly(RuntimeType type);
	internal static RuntimeType GetElementType(RuntimeType type);
	internal static RuntimeModule GetModule(RuntimeType type);
	internal static bool IsGenericVariable(RuntimeType type);
	internal static RuntimeType GetBaseType(RuntimeType type);
	internal static bool CanCastTo(RuntimeType type, RuntimeType target);
	private static bool type_is_assignable_from(Type a, Type b);
	internal static bool IsGenericTypeDefinition(RuntimeType type);
	internal static IntPtr GetGenericParameterInfo(RuntimeType type);

}
//NameSpace:System
public enum StringComparison
{
	// Fields
	public int value__;
	public const StringComparison CurrentCulture;
	public const StringComparison CurrentCultureIgnoreCase;
	public const StringComparison InvariantCulture;
	public const StringComparison InvariantCultureIgnoreCase;
	public const StringComparison Ordinal;
	public const StringComparison OrdinalIgnoreCase;

}
//NameSpace:System
internal class TermInfoDriver : IConsoleDriver
{
	// Fields
	private static int* native_terminal_size;
	private static int terminal_size;
	private static readonly string[] locations;
	private TermInfoReader reader;
	private int cursorLeft;
	private int cursorTop;
	private string title;
	private string titleFormat;
	private bool cursorVisible;
	private string csrVisible;
	private string csrInvisible;
	private string clear;
	private string bell;
	private string term;
	private StreamReader stdin;
	private CStreamWriter stdout;
	private int windowWidth;
	private int windowHeight;
	private int bufferHeight;
	private int bufferWidth;
	private char[] buffer;
	private int readpos;
	private int writepos;
	private string keypadXmit;
	private string keypadLocal;
	private bool inited;
	private object initLock;
	private bool initKeys;
	private string origPair;
	private string origColors;
	private string cursorAddress;
	private ConsoleColor fgcolor;
	private string setfgcolor;
	private string setbgcolor;
	private int maxColors;
	private bool noGetPosition;
	private Hashtable keymap;
	private ByteMatcher rootmap;
	private int rl_startx;
	private int rl_starty;
	private byte[] control_characters;
	private static readonly int[] _consoleColorToAnsiCode;
	private char[] echobuf;
	private int echon;

	// Properties
	public bool Initialized { get; }
	public int WindowHeight { get; }
	public int WindowWidth { get; }

	// Methods
	private static string TryTermInfoDir(string dir, string term);
	private static string SearchTerminfo(string term);
	private void WriteConsole(string str);
	public void .ctor(string term);
	public bool get_Initialized();
	public void Init();
	private void IncrementX();
	public void WriteSpecialKey(ConsoleKeyInfo key);
	public void WriteSpecialKey(char c);
	public bool IsSpecialKey(ConsoleKeyInfo key);
	public bool IsSpecialKey(char c);
	private void GetCursorPosition();
	private void CheckWindowDimensions();
	public int get_WindowHeight();
	public int get_WindowWidth();
	private void AddToBuffer(int b);
	private void AdjustBuffer();
	private ConsoleKeyInfo CreateKeyInfoFromInt(int n, bool alt);
	private object GetKeyFromBuffer(bool cooked);
	private ConsoleKeyInfo ReadKeyInternal(out bool fresh);
	private bool InputPending();
	private void QueueEcho(char c);
	private void Echo(ConsoleKeyInfo key);
	private void EchoFlush();
	public int Read(out char[] dest, int index, int count);
	public ConsoleKeyInfo ReadKey(bool intercept);
	public string ReadLine();
	public string ReadToEnd();
	private string ReadUntilConditionInternal(bool haltOnNewLine);
	public void SetCursorPosition(int left, int top);
	private void CreateKeyMap();
	private void InitKeys();
	private void AddStringMapping(TermInfoStrings s);
	private static void .cctor();

}
//NameSpace:System
internal static class ParameterizedStrings
{
	// Fields
	private static ParameterizedStrings.LowLevelStack _cachedStack;

	// Methods
	public static string Evaluate(string format, ParameterizedStrings.FormatParam[] args);
	private static string EvaluateInternal(string format, int pos, ParameterizedStrings.FormatParam[] args, ParameterizedStrings.LowLevelStack stack, ParameterizedStrings.FormatParam[] dynamicVars, ParameterizedStrings.FormatParam[] staticVars);
	private static bool AsBool(int i);
	private static int AsInt(bool b);
	private static string StringFromAsciiBytes(byte[] buffer, int offset, int length);
	private static extern int snprintf(byte* str, IntPtr size, string format, string arg1);
	private static extern int snprintf(byte* str, IntPtr size, string format, int arg1);
	private static string FormatPrintF(string format, object arg);
	private static ParameterizedStrings.FormatParam[] GetDynamicOrStaticVariables(char c, ParameterizedStrings.FormatParam[] dynamicVars, ParameterizedStrings.FormatParam[] staticVars, out int index);

}
//NameSpace:
public struct ParameterizedStrings.FormatParam
{
	// Fields
	private readonly int _int32;
	private readonly string _string;

	// Properties
	public int Int32 { get; }
	public string String { get; }
	public object Object { get; }

	// Methods
	public void .ctor(int value);
	private void .ctor(int intValue, string stringValue);
	public static ParameterizedStrings.FormatParam op_Implicit(int value);
	public int get_Int32();
	public string get_String();
	public object get_Object();

}
//NameSpace:
private sealed class ParameterizedStrings.LowLevelStack
{
	// Fields
	private ParameterizedStrings.FormatParam[] _arr;
	private int _count;

	// Methods
	public void .ctor();
	public ParameterizedStrings.FormatParam Pop();
	public void Push(ParameterizedStrings.FormatParam item);
	public void Clear();

}
//NameSpace:System
internal class ByteMatcher
{
	// Fields
	private Hashtable map;
	private Hashtable starts;

	// Methods
	public void AddMapping(TermInfoStrings key, byte[] val);
	public void Sort();
	public bool StartsWith(int c);
	public TermInfoStrings Match(char[] buffer, int offset, int length, out int used);
	public void .ctor();

}
//NameSpace:System
internal enum TermInfoNumbers
{
	// Fields
	public int value__;
	public const TermInfoNumbers Columns;
	public const TermInfoNumbers InitTabs;
	public const TermInfoNumbers Lines;
	public const TermInfoNumbers LinesOfMemory;
	public const TermInfoNumbers MagicCookieGlitch;
	public const TermInfoNumbers PaddingBaudRate;
	public const TermInfoNumbers VirtualTerminal;
	public const TermInfoNumbers WidthStatusLine;
	public const TermInfoNumbers NumLabels;
	public const TermInfoNumbers LabelHeight;
	public const TermInfoNumbers LabelWidth;
	public const TermInfoNumbers MaxAttributes;
	public const TermInfoNumbers MaximumWindows;
	public const TermInfoNumbers MaxColors;
	public const TermInfoNumbers MaxPairs;
	public const TermInfoNumbers NoColorVideo;
	public const TermInfoNumbers BufferCapacity;
	public const TermInfoNumbers DotVertSpacing;
	public const TermInfoNumbers DotHorzSpacing;
	public const TermInfoNumbers MaxMicroAddress;
	public const TermInfoNumbers MaxMicroJump;
	public const TermInfoNumbers MicroColSize;
	public const TermInfoNumbers MicroLineSize;
	public const TermInfoNumbers NumberOfPins;
	public const TermInfoNumbers OutputResChar;
	public const TermInfoNumbers OutputResLine;
	public const TermInfoNumbers OutputResHorzInch;
	public const TermInfoNumbers OutputResVertInch;
	public const TermInfoNumbers PrintRate;
	public const TermInfoNumbers WideCharSize;
	public const TermInfoNumbers Buttons;
	public const TermInfoNumbers BitImageEntwining;
	public const TermInfoNumbers BitImageType;
	public const TermInfoNumbers Last;

}
//NameSpace:System
internal class TermInfoReader
{
	// Fields
	private short boolSize;
	private short numSize;
	private short strOffsets;
	private byte[] buffer;
	private int booleansOffset;

	// Methods
	public void .ctor(string term, string filename);
	public void .ctor(string term, byte[] buffer);
	private void ReadHeader(byte[] buffer, int position);
	private void ReadNames(byte[] buffer, int position);
	public int Get(TermInfoNumbers number);
	public string Get(TermInfoStrings tstr);
	public byte[] GetStringBytes(TermInfoStrings tstr);
	private short GetInt16(byte[] buffer, int offset);
	private string GetString(byte[] buffer, int offset);
	private byte[] GetStringBytes(byte[] buffer, int offset);

}
//NameSpace:System
internal enum TermInfoStrings
{
	// Fields
	public int value__;
	public const TermInfoStrings BackTab;
	public const TermInfoStrings Bell;
	public const TermInfoStrings CarriageReturn;
	public const TermInfoStrings ChangeScrollRegion;
	public const TermInfoStrings ClearAllTabs;
	public const TermInfoStrings ClearScreen;
	public const TermInfoStrings ClrEol;
	public const TermInfoStrings ClrEos;
	public const TermInfoStrings ColumnAddress;
	public const TermInfoStrings CommandCharacter;
	public const TermInfoStrings CursorAddress;
	public const TermInfoStrings CursorDown;
	public const TermInfoStrings CursorHome;
	public const TermInfoStrings CursorInvisible;
	public const TermInfoStrings CursorLeft;
	public const TermInfoStrings CursorMemAddress;
	public const TermInfoStrings CursorNormal;
	public const TermInfoStrings CursorRight;
	public const TermInfoStrings CursorToLl;
	public const TermInfoStrings CursorUp;
	public const TermInfoStrings CursorVisible;
	public const TermInfoStrings DeleteCharacter;
	public const TermInfoStrings DeleteLine;
	public const TermInfoStrings DisStatusLine;
	public const TermInfoStrings DownHalfLine;
	public const TermInfoStrings EnterAltCharsetMode;
	public const TermInfoStrings EnterBlinkMode;
	public const TermInfoStrings EnterBoldMode;
	public const TermInfoStrings EnterCaMode;
	public const TermInfoStrings EnterDeleteMode;
	public const TermInfoStrings EnterDimMode;
	public const TermInfoStrings EnterInsertMode;
	public const TermInfoStrings EnterSecureMode;
	public const TermInfoStrings EnterProtectedMode;
	public const TermInfoStrings EnterReverseMode;
	public const TermInfoStrings EnterStandoutMode;
	public const TermInfoStrings EnterUnderlineMode;
	public const TermInfoStrings EraseChars;
	public const TermInfoStrings ExitAltCharsetMode;
	public const TermInfoStrings ExitAttributeMode;
	public const TermInfoStrings ExitCaMode;
	public const TermInfoStrings ExitDeleteMode;
	public const TermInfoStrings ExitInsertMode;
	public const TermInfoStrings ExitStandoutMode;
	public const TermInfoStrings ExitUnderlineMode;
	public const TermInfoStrings FlashScreen;
	public const TermInfoStrings FormFeed;
	public const TermInfoStrings FromStatusLine;
	public const TermInfoStrings Init1string;
	public const TermInfoStrings Init2string;
	public const TermInfoStrings Init3string;
	public const TermInfoStrings InitFile;
	public const TermInfoStrings InsertCharacter;
	public const TermInfoStrings InsertLine;
	public const TermInfoStrings InsertPadding;
	public const TermInfoStrings KeyBackspace;
	public const TermInfoStrings KeyCatab;
	public const TermInfoStrings KeyClear;
	public const TermInfoStrings KeyCtab;
	public const TermInfoStrings KeyDc;
	public const TermInfoStrings KeyDl;
	public const TermInfoStrings KeyDown;
	public const TermInfoStrings KeyEic;
	public const TermInfoStrings KeyEol;
	public const TermInfoStrings KeyEos;
	public const TermInfoStrings KeyF0;
	public const TermInfoStrings KeyF1;
	public const TermInfoStrings KeyF10;
	public const TermInfoStrings KeyF2;
	public const TermInfoStrings KeyF3;
	public const TermInfoStrings KeyF4;
	public const TermInfoStrings KeyF5;
	public const TermInfoStrings KeyF6;
	public const TermInfoStrings KeyF7;
	public const TermInfoStrings KeyF8;
	public const TermInfoStrings KeyF9;
	public const TermInfoStrings KeyHome;
	public const TermInfoStrings KeyIc;
	public const TermInfoStrings KeyIl;
	public const TermInfoStrings KeyLeft;
	public const TermInfoStrings KeyLl;
	public const TermInfoStrings KeyNpage;
	public const TermInfoStrings KeyPpage;
	public const TermInfoStrings KeyRight;
	public const TermInfoStrings KeySf;
	public const TermInfoStrings KeySr;
	public const TermInfoStrings KeyStab;
	public const TermInfoStrings KeyUp;
	public const TermInfoStrings KeypadLocal;
	public const TermInfoStrings KeypadXmit;
	public const TermInfoStrings LabF0;
	public const TermInfoStrings LabF1;
	public const TermInfoStrings LabF10;
	public const TermInfoStrings LabF2;
	public const TermInfoStrings LabF3;
	public const TermInfoStrings LabF4;
	public const TermInfoStrings LabF5;
	public const TermInfoStrings LabF6;
	public const TermInfoStrings LabF7;
	public const TermInfoStrings LabF8;
	public const TermInfoStrings LabF9;
	public const TermInfoStrings MetaOff;
	public const TermInfoStrings MetaOn;
	public const TermInfoStrings Newline;
	public const TermInfoStrings PadChar;
	public const TermInfoStrings ParmDch;
	public const TermInfoStrings ParmDeleteLine;
	public const TermInfoStrings ParmDownCursor;
	public const TermInfoStrings ParmIch;
	public const TermInfoStrings ParmIndex;
	public const TermInfoStrings ParmInsertLine;
	public const TermInfoStrings ParmLeftCursor;
	public const TermInfoStrings ParmRightCursor;
	public const TermInfoStrings ParmRindex;
	public const TermInfoStrings ParmUpCursor;
	public const TermInfoStrings PkeyKey;
	public const TermInfoStrings PkeyLocal;
	public const TermInfoStrings PkeyXmit;
	public const TermInfoStrings PrintScreen;
	public const TermInfoStrings PrtrOff;
	public const TermInfoStrings PrtrOn;
	public const TermInfoStrings RepeatChar;
	public const TermInfoStrings Reset1string;
	public const TermInfoStrings Reset2string;
	public const TermInfoStrings Reset3string;
	public const TermInfoStrings ResetFile;
	public const TermInfoStrings RestoreCursor;
	public const TermInfoStrings RowAddress;
	public const TermInfoStrings SaveCursor;
	public const TermInfoStrings ScrollForward;
	public const TermInfoStrings ScrollReverse;
	public const TermInfoStrings SetAttributes;
	public const TermInfoStrings SetTab;
	public const TermInfoStrings SetWindow;
	public const TermInfoStrings Tab;
	public const TermInfoStrings ToStatusLine;
	public const TermInfoStrings UnderlineChar;
	public const TermInfoStrings UpHalfLine;
	public const TermInfoStrings InitProg;
	public const TermInfoStrings KeyA1;
	public const TermInfoStrings KeyA3;
	public const TermInfoStrings KeyB2;
	public const TermInfoStrings KeyC1;
	public const TermInfoStrings KeyC3;
	public const TermInfoStrings PrtrNon;
	public const TermInfoStrings CharPadding;
	public const TermInfoStrings AcsChars;
	public const TermInfoStrings PlabNorm;
	public const TermInfoStrings KeyBtab;
	public const TermInfoStrings EnterXonMode;
	public const TermInfoStrings ExitXonMode;
	public const TermInfoStrings EnterAmMode;
	public const TermInfoStrings ExitAmMode;
	public const TermInfoStrings XonCharacter;
	public const TermInfoStrings XoffCharacter;
	public const TermInfoStrings EnaAcs;
	public const TermInfoStrings LabelOn;
	public const TermInfoStrings LabelOff;
	public const TermInfoStrings KeyBeg;
	public const TermInfoStrings KeyCancel;
	public const TermInfoStrings KeyClose;
	public const TermInfoStrings KeyCommand;
	public const TermInfoStrings KeyCopy;
	public const TermInfoStrings KeyCreate;
	public const TermInfoStrings KeyEnd;
	public const TermInfoStrings KeyEnter;
	public const TermInfoStrings KeyExit;
	public const TermInfoStrings KeyFind;
	public const TermInfoStrings KeyHelp;
	public const TermInfoStrings KeyMark;
	public const TermInfoStrings KeyMessage;
	public const TermInfoStrings KeyMove;
	public const TermInfoStrings KeyNext;
	public const TermInfoStrings KeyOpen;
	public const TermInfoStrings KeyOptions;
	public const TermInfoStrings KeyPrevious;
	public const TermInfoStrings KeyPrint;
	public const TermInfoStrings KeyRedo;
	public const TermInfoStrings KeyReference;
	public const TermInfoStrings KeyRefresh;
	public const TermInfoStrings KeyReplace;
	public const TermInfoStrings KeyRestart;
	public const TermInfoStrings KeyResume;
	public const TermInfoStrings KeySave;
	public const TermInfoStrings KeySuspend;
	public const TermInfoStrings KeyUndo;
	public const TermInfoStrings KeySbeg;
	public const TermInfoStrings KeyScancel;
	public const TermInfoStrings KeyScommand;
	public const TermInfoStrings KeyScopy;
	public const TermInfoStrings KeyScreate;
	public const TermInfoStrings KeySdc;
	public const TermInfoStrings KeySdl;
	public const TermInfoStrings KeySelect;
	public const TermInfoStrings KeySend;
	public const TermInfoStrings KeySeol;
	public const TermInfoStrings KeySexit;
	public const TermInfoStrings KeySfind;
	public const TermInfoStrings KeyShelp;
	public const TermInfoStrings KeyShome;
	public const TermInfoStrings KeySic;
	public const TermInfoStrings KeySleft;
	public const TermInfoStrings KeySmessage;
	public const TermInfoStrings KeySmove;
	public const TermInfoStrings KeySnext;
	public const TermInfoStrings KeySoptions;
	public const TermInfoStrings KeySprevious;
	public const TermInfoStrings KeySprint;
	public const TermInfoStrings KeySredo;
	public const TermInfoStrings KeySreplace;
	public const TermInfoStrings KeySright;
	public const TermInfoStrings KeySrsume;
	public const TermInfoStrings KeySsave;
	public const TermInfoStrings KeySsuspend;
	public const TermInfoStrings KeySundo;
	public const TermInfoStrings ReqForInput;
	public const TermInfoStrings KeyF11;
	public const TermInfoStrings KeyF12;
	public const TermInfoStrings KeyF13;
	public const TermInfoStrings KeyF14;
	public const TermInfoStrings KeyF15;
	public const TermInfoStrings KeyF16;
	public const TermInfoStrings KeyF17;
	public const TermInfoStrings KeyF18;
	public const TermInfoStrings KeyF19;
	public const TermInfoStrings KeyF20;
	public const TermInfoStrings KeyF21;
	public const TermInfoStrings KeyF22;
	public const TermInfoStrings KeyF23;
	public const TermInfoStrings KeyF24;
	public const TermInfoStrings KeyF25;
	public const TermInfoStrings KeyF26;
	public const TermInfoStrings KeyF27;
	public const TermInfoStrings KeyF28;
	public const TermInfoStrings KeyF29;
	public const TermInfoStrings KeyF30;
	public const TermInfoStrings KeyF31;
	public const TermInfoStrings KeyF32;
	public const TermInfoStrings KeyF33;
	public const TermInfoStrings KeyF34;
	public const TermInfoStrings KeyF35;
	public const TermInfoStrings KeyF36;
	public const TermInfoStrings KeyF37;
	public const TermInfoStrings KeyF38;
	public const TermInfoStrings KeyF39;
	public const TermInfoStrings KeyF40;
	public const TermInfoStrings KeyF41;
	public const TermInfoStrings KeyF42;
	public const TermInfoStrings KeyF43;
	public const TermInfoStrings KeyF44;
	public const TermInfoStrings KeyF45;
	public const TermInfoStrings KeyF46;
	public const TermInfoStrings KeyF47;
	public const TermInfoStrings KeyF48;
	public const TermInfoStrings KeyF49;
	public const TermInfoStrings KeyF50;
	public const TermInfoStrings KeyF51;
	public const TermInfoStrings KeyF52;
	public const TermInfoStrings KeyF53;
	public const TermInfoStrings KeyF54;
	public const TermInfoStrings KeyF55;
	public const TermInfoStrings KeyF56;
	public const TermInfoStrings KeyF57;
	public const TermInfoStrings KeyF58;
	public const TermInfoStrings KeyF59;
	public const TermInfoStrings KeyF60;
	public const TermInfoStrings KeyF61;
	public const TermInfoStrings KeyF62;
	public const TermInfoStrings KeyF63;
	public const TermInfoStrings ClrBol;
	public const TermInfoStrings ClearMargins;
	public const TermInfoStrings SetLeftMargin;
	public const TermInfoStrings SetRightMargin;
	public const TermInfoStrings LabelFormat;
	public const TermInfoStrings SetClock;
	public const TermInfoStrings DisplayClock;
	public const TermInfoStrings RemoveClock;
	public const TermInfoStrings CreateWindow;
	public const TermInfoStrings GotoWindow;
	public const TermInfoStrings Hangup;
	public const TermInfoStrings DialPhone;
	public const TermInfoStrings QuickDial;
	public const TermInfoStrings Tone;
	public const TermInfoStrings Pulse;
	public const TermInfoStrings FlashHook;
	public const TermInfoStrings FixedPause;
	public const TermInfoStrings WaitTone;
	public const TermInfoStrings User0;
	public const TermInfoStrings User1;
	public const TermInfoStrings User2;
	public const TermInfoStrings User3;
	public const TermInfoStrings User4;
	public const TermInfoStrings User5;
	public const TermInfoStrings User6;
	public const TermInfoStrings User7;
	public const TermInfoStrings User8;
	public const TermInfoStrings User9;
	public const TermInfoStrings OrigPair;
	public const TermInfoStrings OrigColors;
	public const TermInfoStrings InitializeColor;
	public const TermInfoStrings InitializePair;
	public const TermInfoStrings SetColorPair;
	public const TermInfoStrings SetForeground;
	public const TermInfoStrings SetBackground;
	public const TermInfoStrings ChangeCharPitch;
	public const TermInfoStrings ChangeLinePitch;
	public const TermInfoStrings ChangeResHorz;
	public const TermInfoStrings ChangeResVert;
	public const TermInfoStrings DefineChar;
	public const TermInfoStrings EnterDoublewideMode;
	public const TermInfoStrings EnterDraftQuality;
	public const TermInfoStrings EnterItalicsMode;
	public const TermInfoStrings EnterLeftwardMode;
	public const TermInfoStrings EnterMicroMode;
	public const TermInfoStrings EnterNearLetterQuality;
	public const TermInfoStrings EnterNormalQuality;
	public const TermInfoStrings EnterShadowMode;
	public const TermInfoStrings EnterSubscriptMode;
	public const TermInfoStrings EnterSuperscriptMode;
	public const TermInfoStrings EnterUpwardMode;
	public const TermInfoStrings ExitDoublewideMode;
	public const TermInfoStrings ExitItalicsMode;
	public const TermInfoStrings ExitLeftwardMode;
	public const TermInfoStrings ExitMicroMode;
	public const TermInfoStrings ExitShadowMode;
	public const TermInfoStrings ExitSubscriptMode;
	public const TermInfoStrings ExitSuperscriptMode;
	public const TermInfoStrings ExitUpwardMode;
	public const TermInfoStrings MicroColumnAddress;
	public const TermInfoStrings MicroDown;
	public const TermInfoStrings MicroLeft;
	public const TermInfoStrings MicroRight;
	public const TermInfoStrings MicroRowAddress;
	public const TermInfoStrings MicroUp;
	public const TermInfoStrings OrderOfPins;
	public const TermInfoStrings ParmDownMicro;
	public const TermInfoStrings ParmLeftMicro;
	public const TermInfoStrings ParmRightMicro;
	public const TermInfoStrings ParmUpMicro;
	public const TermInfoStrings SelectCharSet;
	public const TermInfoStrings SetBottomMargin;
	public const TermInfoStrings SetBottomMarginParm;
	public const TermInfoStrings SetLeftMarginParm;
	public const TermInfoStrings SetRightMarginParm;
	public const TermInfoStrings SetTopMargin;
	public const TermInfoStrings SetTopMarginParm;
	public const TermInfoStrings StartBitImage;
	public const TermInfoStrings StartCharSetDef;
	public const TermInfoStrings StopBitImage;
	public const TermInfoStrings StopCharSetDef;
	public const TermInfoStrings SubscriptCharacters;
	public const TermInfoStrings SuperscriptCharacters;
	public const TermInfoStrings TheseCauseCr;
	public const TermInfoStrings ZeroMotion;
	public const TermInfoStrings CharSetNames;
	public const TermInfoStrings KeyMouse;
	public const TermInfoStrings MouseInfo;
	public const TermInfoStrings ReqMousePos;
	public const TermInfoStrings GetMouse;
	public const TermInfoStrings SetAForeground;
	public const TermInfoStrings SetABackground;
	public const TermInfoStrings PkeyPlab;
	public const TermInfoStrings DeviceType;
	public const TermInfoStrings CodeSetInit;
	public const TermInfoStrings Set0DesSeq;
	public const TermInfoStrings Set1DesSeq;
	public const TermInfoStrings Set2DesSeq;
	public const TermInfoStrings Set3DesSeq;
	public const TermInfoStrings SetLrMargin;
	public const TermInfoStrings SetTbMargin;
	public const TermInfoStrings BitImageRepeat;
	public const TermInfoStrings BitImageNewline;
	public const TermInfoStrings BitImageCarriageReturn;
	public const TermInfoStrings ColorNames;
	public const TermInfoStrings DefineBitImageRegion;
	public const TermInfoStrings EndBitImageRegion;
	public const TermInfoStrings SetColorBand;
	public const TermInfoStrings SetPageLength;
	public const TermInfoStrings DisplayPcChar;
	public const TermInfoStrings EnterPcCharsetMode;
	public const TermInfoStrings ExitPcCharsetMode;
	public const TermInfoStrings EnterScancodeMode;
	public const TermInfoStrings ExitScancodeMode;
	public const TermInfoStrings PcTermOptions;
	public const TermInfoStrings ScancodeEscape;
	public const TermInfoStrings AltScancodeEsc;
	public const TermInfoStrings EnterHorizontalHlMode;
	public const TermInfoStrings EnterLeftHlMode;
	public const TermInfoStrings EnterLowHlMode;
	public const TermInfoStrings EnterRightHlMode;
	public const TermInfoStrings EnterTopHlMode;
	public const TermInfoStrings EnterVerticalHlMode;
	public const TermInfoStrings SetAAttributes;
	public const TermInfoStrings SetPglenInch;
	public const TermInfoStrings Last;

}
//NameSpace:System
public abstract class TimeZone
{
	// Fields
	private static object tz_lock;

	// Methods
	protected void .ctor();
	private static void .cctor();

}
//NameSpace:System
internal class CurrentSystemTimeZone : TimeZone
{
	// Fields
	private readonly TimeZoneInfo LocalTimeZone;

	// Methods
	internal void .ctor();
	public static bool GetTimeZoneData(int year, out long[] data, out string[] names, out bool daylight_inverted);

}
//NameSpace:System
internal class TimeType
{
	// Fields
	public readonly int Offset;
	public readonly bool IsDst;
	public string Name;

	// Methods
	public void .ctor(int offset, bool is_dst, string abbrev);
	public override string ToString();

}
//NameSpace:System
public enum TypeCode
{
	// Fields
	public int value__;
	public const TypeCode Empty;
	public const TypeCode Object;
	public const TypeCode DBNull;
	public const TypeCode Boolean;
	public const TypeCode Char;
	public const TypeCode SByte;
	public const TypeCode Byte;
	public const TypeCode Int16;
	public const TypeCode UInt16;
	public const TypeCode Int32;
	public const TypeCode UInt32;
	public const TypeCode Int64;
	public const TypeCode UInt64;
	public const TypeCode Single;
	public const TypeCode Double;
	public const TypeCode Decimal;
	public const TypeCode DateTime;
	public const TypeCode String;

}
//NameSpace:System
internal interface TypeName : IEquatable`1<TypeName>
{
	// Properties
	public abstract string DisplayName { get; }

	// Methods
	public abstract string get_DisplayName();

}
//NameSpace:System
internal interface TypeIdentifier : TypeName, IEquatable`1<TypeName>
{
	// Properties
	public abstract string InternalName { get; }

	// Methods
	public abstract string get_InternalName();

}
//NameSpace:System
internal class TypeNames
{
}
//NameSpace:
internal abstract class TypeNames.ATypeName : TypeName, IEquatable`1<TypeName>
{
	// Properties
	public abstract string DisplayName { get; }

	// Methods
	public abstract string get_DisplayName();
	public bool Equals(TypeName other);
	public override int GetHashCode();
	public override bool Equals(object other);
	protected void .ctor();

}
//NameSpace:System
internal class TypeIdentifiers
{
	// Methods
	internal static TypeIdentifier FromDisplay(string displayName);

}
//NameSpace:
private class TypeIdentifiers.Display : TypeNames.ATypeName, TypeIdentifier, TypeName, IEquatable`1<TypeName>
{
	// Fields
	private string displayName;
	private string internal_name;

	// Properties
	public override string DisplayName { get; }
	public string InternalName { get; }

	// Methods
	internal void .ctor(string displayName);
	public override string get_DisplayName();
	public string get_InternalName();
	private string GetInternalName();

}
//NameSpace:System
internal interface ModifierSpec
{
	// Methods
	public abstract Type Resolve(Type type);
	public abstract StringBuilder Append(StringBuilder sb);

}
//NameSpace:System
internal class ArraySpec : ModifierSpec
{
	// Fields
	private int dimensions;
	private bool bound;

	// Methods
	internal void .ctor(int dimensions, bool bound);
	public Type Resolve(Type type);
	public StringBuilder Append(StringBuilder sb);
	public override string ToString();

}
//NameSpace:System
internal class PointerSpec : ModifierSpec
{
	// Fields
	private int pointer_level;

	// Methods
	internal void .ctor(int pointer_level);
	public Type Resolve(Type type);
	public StringBuilder Append(StringBuilder sb);
	public override string ToString();

}
//NameSpace:System
internal class TypeSpec
{
	// Fields
	private TypeIdentifier name;
	private string assembly_name;
	private List`1<TypeIdentifier> nested;
	private List`1<TypeSpec> generic_params;
	private List`1<ModifierSpec> modifier_spec;
	private bool is_byref;
	private string display_fullname;

	// Properties
	internal bool HasModifiers { get; }
	internal string DisplayFullName { get; }

	// Methods
	internal bool get_HasModifiers();
	private string GetDisplayFullName(TypeSpec.DisplayNameFormat flags);
	private StringBuilder GetModifierString(StringBuilder sb);
	internal string get_DisplayFullName();
	internal static TypeSpec Parse(string typeName);
	internal static string UnescapeInternalName(string displayName);
	internal Type Resolve(Func`2<AssemblyNameAssembly> assemblyResolver, Func`4<AssemblystringboolType> typeResolver, bool throwOnError, bool ignoreCase);
	private void AddName(string type_name);
	private void AddModifier(ModifierSpec md);
	private static void SkipSpace(string name, int pos);
	private static void BoundCheck(int idx, string s);
	private static TypeIdentifier ParsedTypeIdentifier(string displayName);
	private static TypeSpec Parse(string name, int p, bool is_recurse, bool allow_aqn);
	public void .ctor();

}
//NameSpace:
internal enum TypeSpec.DisplayNameFormat
{
	// Fields
	public int value__;
	public const TypeSpec.DisplayNameFormat Default;
	public const TypeSpec.DisplayNameFormat WANT_ASSEMBLY;
	public const TypeSpec.DisplayNameFormat NO_MODIFIERS;

}
//NameSpace:System
public struct UIntPtr : ISerializable
{
	// Fields
	public static readonly UIntPtr Zero;
	private void* _pointer;

	// Properties
	public static int Size { get; }

	// Methods
	public void .ctor(uint value);
	public override bool Equals(object obj);
	public override int GetHashCode();
	public override string ToString();
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	public static bool op_Equality(UIntPtr value1, UIntPtr value2);
	public static int get_Size();
	private static void .cctor();

}
//NameSpace:System
public abstract class ValueType
{
	// Methods
	protected void .ctor();
	private static bool InternalEquals(object o1, object o2, out object[] fields);
	internal static bool DefaultEquals(object o1, object o2);
	public override bool Equals(object obj);
	internal static int InternalGetHashCode(object o, out object[] fields);
	public override int GetHashCode();
	public override string ToString();

}
//NameSpace:System
internal struct Variant
{
	// Fields
	public short vt;
	public ushort wReserved1;
	public ushort wReserved2;
	public ushort wReserved3;
	public long llVal;
	public int lVal;
	public byte bVal;
	public short iVal;
	public float fltVal;
	public double dblVal;
	public short boolVal;
	public IntPtr bstrVal;
	public sbyte cVal;
	public ushort uiVal;
	public uint ulVal;
	public ulong ullVal;
	public int intVal;
	public uint uintVal;
	public IntPtr pdispVal;
	public BRECORD bRecord;

	// Methods
	public void Clear();

}
//NameSpace:System
internal struct BRECORD
{
	// Fields
	private IntPtr pvRecord;
	private IntPtr pRecInfo;

}
//NameSpace:System
public struct Void
{
}
//NameSpace:System
public class WeakReference : ISerializable
{
	// Fields
	private bool isLongReference;
	private GCHandle gcHandle;

	// Properties
	public virtual object Target { get; }
	public virtual bool TrackResurrection { get; }

	// Methods
	private void AllocateHandle(object target);
	protected void .ctor();
	public void .ctor(object target);
	public void .ctor(object target, bool trackResurrection);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public virtual object get_Target();
	public virtual bool get_TrackResurrection();
	protected override void Finalize();
	public virtual void GetObjectData(SerializationInfo info, StreamingContext context);

}
//NameSpace:System
internal struct InputRecord
{
	// Fields
	public short EventType;
	public bool KeyDown;
	public short RepeatCount;
	public short VirtualKeyCode;
	public short VirtualScanCode;
	public char Character;
	public int ControlKeyState;
	private int pad1;
	private bool pad2;

}
//NameSpace:System
internal struct Coord
{
	// Fields
	public short X;
	public short Y;

}
//NameSpace:System
internal struct SmallRect
{
	// Fields
	public short Left;
	public short Top;
	public short Right;
	public short Bottom;

}
//NameSpace:System
internal struct ConsoleScreenBufferInfo
{
	// Fields
	public Coord Size;
	public Coord CursorPosition;
	public short Attribute;
	public SmallRect Window;
	public Coord MaxWindowSize;

}
//NameSpace:System
internal enum Handles
{
	// Fields
	public int value__;
	public const Handles STD_INPUT;
	public const Handles STD_OUTPUT;
	public const Handles STD_ERROR;

}
//NameSpace:System
internal class WindowsConsoleDriver : IConsoleDriver
{
	// Fields
	private IntPtr inputHandle;
	private IntPtr outputHandle;
	private short defaultAttribute;

	// Methods
	public void .ctor();
	public ConsoleKeyInfo ReadKey(bool intercept);
	private static bool IsModifierKey(short virtualKeyCode);
	private static extern IntPtr GetStdHandle(Handles handle);
	private static extern bool GetConsoleScreenBufferInfo(IntPtr handle, out ConsoleScreenBufferInfo info);
	private static extern bool ReadConsoleInput(IntPtr handle, out InputRecord record, int length, out int nread);

}
//NameSpace:System
internal class __ComObject
{
	// Methods
	private void .ctor();

}
//NameSpace:System.Configuration.Assemblies
public enum AssemblyHashAlgorithm
{
	// Fields
	public int value__;
	public const AssemblyHashAlgorithm None;
	public const AssemblyHashAlgorithm MD5;
	public const AssemblyHashAlgorithm SHA1;
	public const AssemblyHashAlgorithm SHA256;
	public const AssemblyHashAlgorithm SHA384;
	public const AssemblyHashAlgorithm SHA512;

}
//NameSpace:System.Configuration.Assemblies
public enum AssemblyVersionCompatibility
{
	// Fields
	public int value__;
	public const AssemblyVersionCompatibility SameMachine;
	public const AssemblyVersionCompatibility SameProcess;
	public const AssemblyVersionCompatibility SameDomain;

}
//NameSpace:System.Text
public class ASCIIEncoding : Encoding
{
	// Methods
	public void .ctor();
	internal override void SetDefaultFallbacks();
	public override int GetByteCount(char[] chars, int index, int count);
	public override int GetByteCount(string chars);
	public override int GetByteCount(char* chars, int count);
	public override int GetBytes(string chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
	public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
	public override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
	public override int GetCharCount(byte[] bytes, int index, int count);
	public override int GetCharCount(byte* bytes, int count);
	public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
	public override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
	public override string GetString(byte[] bytes, int byteIndex, int byteCount);
	internal override int GetByteCount(char* chars, int charCount, EncoderNLS encoder);
	internal override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, EncoderNLS encoder);
	internal override int GetCharCount(byte* bytes, int count, DecoderNLS decoder);
	internal override int GetChars(byte* bytes, int byteCount, char* chars, int charCount, DecoderNLS decoder);
	public override int GetMaxByteCount(int charCount);
	public override int GetMaxCharCount(int byteCount);
	public override Decoder GetDecoder();
	public override Encoder GetEncoder();

}
//NameSpace:System.Text
public abstract class Decoder
{
	// Fields
	internal DecoderFallback m_fallback;
	internal DecoderFallbackBuffer m_fallbackBuffer;

	// Properties
	public DecoderFallback Fallback { get; }
	public DecoderFallbackBuffer FallbackBuffer { get; }
	internal bool InternalHasFallbackBuffer { get; }

	// Methods
	internal void SerializeDecoder(SerializationInfo info);
	protected void .ctor();
	public DecoderFallback get_Fallback();
	public DecoderFallbackBuffer get_FallbackBuffer();
	internal bool get_InternalHasFallbackBuffer();
	public virtual void Reset();
	public abstract int GetCharCount(byte[] bytes, int index, int count);
	public virtual int GetCharCount(byte[] bytes, int index, int count, bool flush);
	public virtual int GetCharCount(byte* bytes, int count, bool flush);
	public abstract int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
	public virtual int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, bool flush);
	public virtual int GetChars(byte* bytes, int byteCount, char* chars, int charCount, bool flush);

}
//NameSpace:System.Text
internal sealed class InternalDecoderBestFitFallback : DecoderFallback
{
	// Fields
	internal Encoding encoding;
	internal char[] arrayBestFit;
	internal char cReplacement;

	// Properties
	public override int MaxCharCount { get; }

	// Methods
	internal void .ctor(Encoding encoding);
	public override DecoderFallbackBuffer CreateFallbackBuffer();
	public override int get_MaxCharCount();
	public override bool Equals(object value);
	public override int GetHashCode();

}
//NameSpace:System.Text
internal sealed class InternalDecoderBestFitFallbackBuffer : DecoderFallbackBuffer
{
	// Fields
	internal char cBestFit;
	internal int iCount;
	internal int iSize;
	private InternalDecoderBestFitFallback oFallback;
	private static object s_InternalSyncObject;

	// Properties
	private static object InternalSyncObject { get; }

	// Methods
	private static object get_InternalSyncObject();
	public void .ctor(InternalDecoderBestFitFallback fallback);
	public override bool Fallback(byte[] bytesUnknown, int index);
	public override char GetNextChar();
	public override void Reset();
	internal override int InternalFallback(byte[] bytes, byte* pBytes);
	private char TryBestFit(byte[] bytesCheck);

}
//NameSpace:System.Text
public sealed class DecoderExceptionFallback : DecoderFallback
{
	// Properties
	public override int MaxCharCount { get; }

	// Methods
	public void .ctor();
	public override DecoderFallbackBuffer CreateFallbackBuffer();
	public override int get_MaxCharCount();
	public override bool Equals(object value);
	public override int GetHashCode();

}
//NameSpace:System.Text
public sealed class DecoderExceptionFallbackBuffer : DecoderFallbackBuffer
{
	// Methods
	public override bool Fallback(byte[] bytesUnknown, int index);
	public override char GetNextChar();
	private void Throw(byte[] bytesUnknown, int index);
	public void .ctor();

}
//NameSpace:System.Text
public sealed class DecoderFallbackException : ArgumentException
{
	// Fields
	private byte[] bytesUnknown;
	private int index;

	// Methods
	public void .ctor();
	internal void .ctor(SerializationInfo info, StreamingContext context);
	public void .ctor(string message, byte[] bytesUnknown, int index);

}
//NameSpace:System.Text
public abstract class DecoderFallback
{
	// Fields
	internal bool bIsMicrosoftBestFitFallback;
	private static DecoderFallback replacementFallback;
	private static DecoderFallback exceptionFallback;
	private static object s_InternalSyncObject;

	// Properties
	private static object InternalSyncObject { get; }
	public static DecoderFallback ReplacementFallback { get; }
	public static DecoderFallback ExceptionFallback { get; }
	public abstract int MaxCharCount { get; }

	// Methods
	private static object get_InternalSyncObject();
	public static DecoderFallback get_ReplacementFallback();
	public static DecoderFallback get_ExceptionFallback();
	public abstract DecoderFallbackBuffer CreateFallbackBuffer();
	public abstract int get_MaxCharCount();
	protected void .ctor();

}
//NameSpace:System.Text
public abstract class DecoderFallbackBuffer
{
	// Fields
	internal byte* byteStart;
	internal char* charEnd;

	// Methods
	public abstract bool Fallback(byte[] bytesUnknown, int index);
	public abstract char GetNextChar();
	public virtual void Reset();
	internal void InternalReset();
	internal void InternalInitialize(byte* byteStart, char* charEnd);
	internal virtual bool InternalFallback(byte[] bytes, byte* pBytes, char* chars);
	internal virtual int InternalFallback(byte[] bytes, byte* pBytes);
	internal void ThrowLastBytesRecursive(byte[] bytesUnknown);
	protected void .ctor();

}
//NameSpace:System.Text
internal class DecoderNLS : Decoder, ISerializable
{
	// Fields
	protected Encoding m_encoding;
	protected bool m_mustFlush;
	internal bool m_throwOnOverflow;
	internal int m_bytesUsed;

	// Properties
	public bool MustFlush { get; }
	internal virtual bool HasState { get; }

	// Methods
	internal void .ctor(SerializationInfo info, StreamingContext context);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	internal void .ctor(Encoding encoding);
	internal void .ctor();
	public override void Reset();
	public override int GetCharCount(byte[] bytes, int index, int count);
	public override int GetCharCount(byte[] bytes, int index, int count, bool flush);
	public override int GetCharCount(byte* bytes, int count, bool flush);
	public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
	public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, bool flush);
	public override int GetChars(byte* bytes, int byteCount, char* chars, int charCount, bool flush);
	public bool get_MustFlush();
	internal virtual bool get_HasState();
	internal void ClearMustFlush();

}
//NameSpace:System.Text
public sealed class DecoderReplacementFallback : DecoderFallback
{
	// Fields
	private string strDefault;

	// Properties
	public string DefaultString { get; }
	public override int MaxCharCount { get; }

	// Methods
	public void .ctor();
	public void .ctor(string replacement);
	public string get_DefaultString();
	public override DecoderFallbackBuffer CreateFallbackBuffer();
	public override int get_MaxCharCount();
	public override bool Equals(object value);
	public override int GetHashCode();

}
//NameSpace:System.Text
public sealed class DecoderReplacementFallbackBuffer : DecoderFallbackBuffer
{
	// Fields
	private string strDefault;
	private int fallbackCount;
	private int fallbackIndex;

	// Methods
	public void .ctor(DecoderReplacementFallback fallback);
	public override bool Fallback(byte[] bytesUnknown, int index);
	public override char GetNextChar();
	public override void Reset();
	internal override int InternalFallback(byte[] bytes, byte* pBytes);

}
//NameSpace:System.Text
public abstract class Encoder
{
	// Fields
	internal EncoderFallback m_fallback;
	internal EncoderFallbackBuffer m_fallbackBuffer;

	// Properties
	public EncoderFallback Fallback { get; }
	public EncoderFallbackBuffer FallbackBuffer { get; }
	internal bool InternalHasFallbackBuffer { get; }

	// Methods
	internal void SerializeEncoder(SerializationInfo info);
	protected void .ctor();
	public EncoderFallback get_Fallback();
	public EncoderFallbackBuffer get_FallbackBuffer();
	internal bool get_InternalHasFallbackBuffer();
	public virtual void Reset();
	public abstract int GetByteCount(char[] chars, int index, int count, bool flush);
	public virtual int GetByteCount(char* chars, int count, bool flush);
	public abstract int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, bool flush);
	public virtual int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, bool flush);

}
//NameSpace:System.Text
internal class InternalEncoderBestFitFallback : EncoderFallback
{
	// Fields
	internal Encoding encoding;
	internal char[] arrayBestFit;

	// Properties
	public override int MaxCharCount { get; }

	// Methods
	internal void .ctor(Encoding encoding);
	public override EncoderFallbackBuffer CreateFallbackBuffer();
	public override int get_MaxCharCount();
	public override bool Equals(object value);
	public override int GetHashCode();

}
//NameSpace:System.Text
internal sealed class InternalEncoderBestFitFallbackBuffer : EncoderFallbackBuffer
{
	// Fields
	private char cBestFit;
	private InternalEncoderBestFitFallback oFallback;
	private int iCount;
	private int iSize;
	private static object s_InternalSyncObject;

	// Properties
	private static object InternalSyncObject { get; }
	public override int Remaining { get; }

	// Methods
	private static object get_InternalSyncObject();
	public void .ctor(InternalEncoderBestFitFallback fallback);
	public override bool Fallback(char charUnknown, int index);
	public override bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
	public override char GetNextChar();
	public override bool MovePrevious();
	public override int get_Remaining();
	public override void Reset();
	private char TryBestFit(char cUnknown);

}
//NameSpace:System.Text
public sealed class EncoderExceptionFallback : EncoderFallback
{
	// Properties
	public override int MaxCharCount { get; }

	// Methods
	public void .ctor();
	public override EncoderFallbackBuffer CreateFallbackBuffer();
	public override int get_MaxCharCount();
	public override bool Equals(object value);
	public override int GetHashCode();

}
//NameSpace:System.Text
public sealed class EncoderExceptionFallbackBuffer : EncoderFallbackBuffer
{
	// Properties
	public override int Remaining { get; }

	// Methods
	public void .ctor();
	public override bool Fallback(char charUnknown, int index);
	public override bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
	public override char GetNextChar();
	public override bool MovePrevious();
	public override int get_Remaining();

}
//NameSpace:System.Text
public sealed class EncoderFallbackException : ArgumentException
{
	// Fields
	private char charUnknown;
	private char charUnknownHigh;
	private char charUnknownLow;
	private int index;

	// Methods
	public void .ctor();
	internal void .ctor(SerializationInfo info, StreamingContext context);
	internal void .ctor(string message, char charUnknown, int index);
	internal void .ctor(string message, char charUnknownHigh, char charUnknownLow, int index);

}
//NameSpace:System.Text
public abstract class EncoderFallback
{
	// Fields
	internal bool bIsMicrosoftBestFitFallback;
	private static EncoderFallback replacementFallback;
	private static EncoderFallback exceptionFallback;
	private static object s_InternalSyncObject;

	// Properties
	private static object InternalSyncObject { get; }
	public static EncoderFallback ReplacementFallback { get; }
	public static EncoderFallback ExceptionFallback { get; }
	public abstract int MaxCharCount { get; }

	// Methods
	private static object get_InternalSyncObject();
	public static EncoderFallback get_ReplacementFallback();
	public static EncoderFallback get_ExceptionFallback();
	public abstract EncoderFallbackBuffer CreateFallbackBuffer();
	public abstract int get_MaxCharCount();
	protected void .ctor();

}
//NameSpace:System.Text
public abstract class EncoderFallbackBuffer
{
	// Fields
	internal char* charStart;
	internal char* charEnd;
	internal EncoderNLS encoder;
	internal bool setEncoder;
	internal bool bUsedEncoder;
	internal bool bFallingBack;
	internal int iRecursionCount;

	// Properties
	public abstract int Remaining { get; }

	// Methods
	public abstract bool Fallback(char charUnknown, int index);
	public abstract bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
	public abstract char GetNextChar();
	public abstract bool MovePrevious();
	public abstract int get_Remaining();
	public virtual void Reset();
	internal void InternalReset();
	internal void InternalInitialize(char* charStart, char* charEnd, EncoderNLS encoder, bool setEncoder);
	internal char InternalGetNextChar();
	internal virtual bool InternalFallback(char ch, char* chars);
	internal void ThrowLastCharRecursive(int charRecursive);
	protected void .ctor();

}
//NameSpace:System.Text
internal class EncoderNLS : Encoder, ISerializable
{
	// Fields
	internal char charLeftOver;
	protected Encoding m_encoding;
	protected bool m_mustFlush;
	internal bool m_throwOnOverflow;
	internal int m_charsUsed;

	// Properties
	public Encoding Encoding { get; }
	public bool MustFlush { get; }

	// Methods
	internal void .ctor(SerializationInfo info, StreamingContext context);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	internal void .ctor(Encoding encoding);
	internal void .ctor();
	public override void Reset();
	public override int GetByteCount(char[] chars, int index, int count, bool flush);
	public override int GetByteCount(char* chars, int count, bool flush);
	public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, bool flush);
	public override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, bool flush);
	public Encoding get_Encoding();
	public bool get_MustFlush();
	internal void ClearMustFlush();

}
//NameSpace:System.Text
public sealed class EncoderReplacementFallback : EncoderFallback
{
	// Fields
	private string strDefault;

	// Properties
	public string DefaultString { get; }
	public override int MaxCharCount { get; }

	// Methods
	public void .ctor();
	public void .ctor(string replacement);
	public string get_DefaultString();
	public override EncoderFallbackBuffer CreateFallbackBuffer();
	public override int get_MaxCharCount();
	public override bool Equals(object value);
	public override int GetHashCode();

}
//NameSpace:System.Text
public sealed class EncoderReplacementFallbackBuffer : EncoderFallbackBuffer
{
	// Fields
	private string strDefault;
	private int fallbackCount;
	private int fallbackIndex;

	// Properties
	public override int Remaining { get; }

	// Methods
	public void .ctor(EncoderReplacementFallback fallback);
	public override bool Fallback(char charUnknown, int index);
	public override bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
	public override char GetNextChar();
	public override bool MovePrevious();
	public override int get_Remaining();
	public override void Reset();

}
//NameSpace:System.Text
public abstract class Encoding : ICloneable
{
	// Fields
	private static Encoding defaultEncoding;
	private static Encoding unicodeEncoding;
	private static Encoding bigEndianUnicode;
	private static Encoding utf7Encoding;
	private static Encoding utf8Encoding;
	private static Encoding utf32Encoding;
	private static Encoding asciiEncoding;
	private static Encoding latin1Encoding;
	private static Hashtable encodings;
	internal int m_codePage;
	internal CodePageDataItem dataItem;
	internal bool m_deserializedFromEverett;
	private bool m_isReadOnly;
	internal EncoderFallback encoderFallback;
	internal DecoderFallback decoderFallback;
	private static object s_InternalSyncObject;

	// Properties
	private static object InternalSyncObject { get; }
	public virtual string EncodingName { get; }
	public EncoderFallback EncoderFallback { get; set; }
	public DecoderFallback DecoderFallback { get; set; }
	public bool IsReadOnly { get; }
	public static Encoding ASCII { get; }
	private static Encoding Latin1 { get; }
	public virtual int CodePage { get; }
	public static Encoding Default { get; }
	public static Encoding Unicode { get; }
	public static Encoding BigEndianUnicode { get; }
	public static Encoding UTF7 { get; }
	public static Encoding UTF8 { get; }
	public static Encoding UTF32 { get; }

	// Methods
	protected void .ctor();
	protected void .ctor(int codePage);
	internal virtual void SetDefaultFallbacks();
	internal void OnDeserializing();
	internal void OnDeserialized();
	private void OnDeserializing(StreamingContext ctx);
	private void OnDeserialized(StreamingContext ctx);
	private void OnSerializing(StreamingContext ctx);
	internal void DeserializeEncoding(SerializationInfo info, StreamingContext context);
	internal void SerializeEncoding(SerializationInfo info, StreamingContext context);
	private static object get_InternalSyncObject();
	public static Encoding GetEncoding(int codepage);
	public static Encoding GetEncoding(string name);
	public virtual byte[] GetPreamble();
	public virtual string get_EncodingName();
	public EncoderFallback get_EncoderFallback();
	public void set_EncoderFallback(EncoderFallback value);
	public DecoderFallback get_DecoderFallback();
	public void set_DecoderFallback(DecoderFallback value);
	public virtual object Clone();
	public bool get_IsReadOnly();
	public static Encoding get_ASCII();
	private static Encoding get_Latin1();
	public virtual int GetByteCount(string s);
	public abstract int GetByteCount(char[] chars, int index, int count);
	public virtual int GetByteCount(char* chars, int count);
	internal virtual int GetByteCount(char* chars, int count, EncoderNLS encoder);
	public virtual byte[] GetBytes(char[] chars, int index, int count);
	public abstract int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
	public virtual byte[] GetBytes(string s);
	public virtual int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
	internal virtual int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, EncoderNLS encoder);
	public virtual int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
	public abstract int GetCharCount(byte[] bytes, int index, int count);
	public virtual int GetCharCount(byte* bytes, int count);
	internal virtual int GetCharCount(byte* bytes, int count, DecoderNLS decoder);
	public virtual char[] GetChars(byte[] bytes, int index, int count);
	public abstract int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
	public virtual int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
	internal virtual int GetChars(byte* bytes, int byteCount, char* chars, int charCount, DecoderNLS decoder);
	public virtual int get_CodePage();
	public virtual Decoder GetDecoder();
	private static Encoding CreateDefaultEncoding();
	internal void setReadOnly(optional bool value);
	public static Encoding get_Default();
	public virtual Encoder GetEncoder();
	public abstract int GetMaxByteCount(int charCount);
	public abstract int GetMaxCharCount(int byteCount);
	public virtual string GetString(byte[] bytes);
	public virtual string GetString(byte[] bytes, int index, int count);
	public static Encoding get_Unicode();
	public static Encoding get_BigEndianUnicode();
	public static Encoding get_UTF7();
	public static Encoding get_UTF8();
	public static Encoding get_UTF32();
	public override bool Equals(object value);
	public override int GetHashCode();
	internal virtual char[] GetBestFitUnicodeToBytesData();
	internal virtual char[] GetBestFitBytesToUnicodeData();
	internal void ThrowBytesOverflow();
	internal void ThrowBytesOverflow(EncoderNLS encoder, bool nothingEncoded);
	internal void ThrowCharsOverflow();
	internal void ThrowCharsOverflow(DecoderNLS decoder, bool nothingDecoded);

}
//NameSpace:
internal class Encoding.DefaultEncoder : Encoder, ISerializable, IObjectReference
{
	// Fields
	private Encoding m_encoding;
	private bool m_hasInitializedEncoding;
	internal char charLeftOver;

	// Methods
	public void .ctor(Encoding encoding);
	internal void .ctor(SerializationInfo info, StreamingContext context);
	public object GetRealObject(StreamingContext context);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	public override int GetByteCount(char[] chars, int index, int count, bool flush);
	public override int GetByteCount(char* chars, int count, bool flush);
	public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, bool flush);
	public override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, bool flush);

}
//NameSpace:
internal class Encoding.DefaultDecoder : Decoder, ISerializable, IObjectReference
{
	// Fields
	private Encoding m_encoding;
	private bool m_hasInitializedEncoding;

	// Methods
	public void .ctor(Encoding encoding);
	internal void .ctor(SerializationInfo info, StreamingContext context);
	public object GetRealObject(StreamingContext context);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	public override int GetCharCount(byte[] bytes, int index, int count);
	public override int GetCharCount(byte[] bytes, int index, int count, bool flush);
	public override int GetCharCount(byte* bytes, int count, bool flush);
	public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
	public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, bool flush);
	public override int GetChars(byte* bytes, int byteCount, char* chars, int charCount, bool flush);

}
//NameSpace:
internal class Encoding.EncodingCharBuffer
{
	// Fields
	private char* chars;
	private char* charStart;
	private char* charEnd;
	private int charCountResult;
	private Encoding enc;
	private DecoderNLS decoder;
	private byte* byteStart;
	private byte* byteEnd;
	private byte* bytes;
	private DecoderFallbackBuffer fallbackBuffer;

	// Properties
	internal bool MoreData { get; }
	internal int BytesUsed { get; }
	internal int Count { get; }

	// Methods
	internal void .ctor(Encoding enc, DecoderNLS decoder, char* charStart, int charCount, byte* byteStart, int byteCount);
	internal bool AddChar(char ch, int numBytes);
	internal bool AddChar(char ch);
	internal void AdjustBytes(int count);
	internal bool get_MoreData();
	internal byte GetNextByte();
	internal int get_BytesUsed();
	internal bool Fallback(byte fallbackByte);
	internal bool Fallback(byte[] byteBuffer);
	internal int get_Count();

}
//NameSpace:
internal class Encoding.EncodingByteBuffer
{
	// Fields
	private byte* bytes;
	private byte* byteStart;
	private byte* byteEnd;
	private char* chars;
	private char* charStart;
	private char* charEnd;
	private int byteCountResult;
	private Encoding enc;
	private EncoderNLS encoder;
	internal EncoderFallbackBuffer fallbackBuffer;

	// Properties
	internal bool MoreData { get; }
	internal int CharsUsed { get; }
	internal int Count { get; }

	// Methods
	internal void .ctor(Encoding inEncoding, EncoderNLS inEncoder, byte* inByteStart, int inByteCount, char* inCharStart, int inCharCount);
	internal bool AddByte(byte b, int moreBytesExpected);
	internal bool AddByte(byte b1);
	internal bool AddByte(byte b1, byte b2);
	internal bool AddByte(byte b1, byte b2, int moreBytesExpected);
	internal void MovePrevious(bool bThrow);
	internal bool get_MoreData();
	internal char GetNextChar();
	internal int get_CharsUsed();
	internal int get_Count();

}
//NameSpace:System.Text
internal abstract class EncodingNLS : Encoding
{
	// Methods
	protected void .ctor(int codePage);
	public override int GetByteCount(char[] chars, int index, int count);
	public override int GetByteCount(string s);
	public override int GetByteCount(char* chars, int count);
	public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
	public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
	public override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
	public override int GetCharCount(byte[] bytes, int index, int count);
	public override int GetCharCount(byte* bytes, int count);
	public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
	public override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
	public override string GetString(byte[] bytes, int index, int count);
	public override Decoder GetDecoder();
	public override Encoder GetEncoder();

}
//NameSpace:System.Text
public abstract class EncodingProvider
{
	// Fields
	private static object s_InternalSyncObject;
	private static EncodingProvider[] s_providers;

	// Methods
	public abstract Encoding GetEncoding(string name);
	public abstract Encoding GetEncoding(int codepage);
	internal static Encoding GetEncodingFromProvider(int codepage);
	internal static Encoding GetEncodingFromProvider(string encodingName);
	private static void .cctor();

}
//NameSpace:System.Text
internal class Latin1Encoding : EncodingNLS, ISerializable
{
	// Fields
	private static readonly char[] arrayCharBestFit;

	// Methods
	public void .ctor();
	internal void .ctor(SerializationInfo info, StreamingContext context);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	internal override int GetByteCount(char* chars, int charCount, EncoderNLS encoder);
	internal override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, EncoderNLS encoder);
	internal override int GetCharCount(byte* bytes, int count, DecoderNLS decoder);
	internal override int GetChars(byte* bytes, int byteCount, char* chars, int charCount, DecoderNLS decoder);
	public override int GetMaxByteCount(int charCount);
	public override int GetMaxCharCount(int byteCount);
	internal override char[] GetBestFitUnicodeToBytesData();
	private static void .cctor();

}
//NameSpace:System.Text
public sealed class StringBuilder : ISerializable
{
	// Fields
	internal char[] m_ChunkChars;
	internal StringBuilder m_ChunkPrevious;
	internal int m_ChunkLength;
	internal int m_ChunkOffset;
	internal int m_MaxCapacity;
	internal const int DefaultCapacity;
	private const string CapacityField;
	private const string MaxCapacityField;
	private const string StringValueField;
	private const string ThreadIDField;
	internal const int MaxChunkSize;

	// Properties
	public int Capacity { get; }
	public int MaxCapacity { get; }
	public int Length { get; set; }
	public char Chars { get; set; }

	// Methods
	public void .ctor();
	public void .ctor(int capacity);
	public void .ctor(string value);
	public void .ctor(string value, int capacity);
	public void .ctor(string value, int startIndex, int length, int capacity);
	private void .ctor(SerializationInfo info, StreamingContext context);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	public int get_Capacity();
	public int get_MaxCapacity();
	public override string ToString();
	public string ToString(int startIndex, int length);
	public StringBuilder Clear();
	public int get_Length();
	public void set_Length(int value);
	public char get_Chars(int index);
	public void set_Chars(int index, char value);
	public StringBuilder Append(char value, int repeatCount);
	public StringBuilder Append(char[] value, int startIndex, int charCount);
	public StringBuilder Append(string value);
	private void AppendHelper(string value);
	public StringBuilder Append(string value, int startIndex, int count);
	public StringBuilder AppendLine();
	public StringBuilder AppendLine(string value);
	public StringBuilder Insert(int index, string value, int count);
	public StringBuilder Remove(int startIndex, int length);
	public StringBuilder Append(char value);
	public StringBuilder Append(int value);
	public StringBuilder Append(long value);
	public StringBuilder Append(object value);
	public StringBuilder Insert(int index, string value);
	public StringBuilder Insert(int index, char value);
	public StringBuilder AppendFormat(string format, object arg0);
	public StringBuilder AppendFormat(string format, object arg0, object arg1);
	public StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2);
	public StringBuilder AppendFormat(string format, object[] args);
	public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0);
	public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1);
	private static void FormatError();
	internal StringBuilder AppendFormatHelper(IFormatProvider provider, string format, ParamsArray args);
	public StringBuilder Replace(string oldValue, string newValue);
	public StringBuilder Replace(string oldValue, string newValue, int startIndex, int count);
	public StringBuilder Append(char* value, int valueCount);
	private void Insert(int index, char* value, int valueCount);
	private void ReplaceAllInChunk(int[] replacements, int replacementsCount, StringBuilder sourceChunk, int removeCount, string value);
	private bool StartsWith(StringBuilder chunk, int indexInChunk, int count, string value);
	private void ReplaceInPlaceAtChunk(StringBuilder chunk, int indexInChunk, char* value, int count);
	private static void ThreadSafeCopy(char* sourcePtr, char[] destination, int destinationIndex, int count);
	private static void ThreadSafeCopy(char[] source, int sourceIndex, char[] destination, int destinationIndex, int count);
	private StringBuilder FindChunkForIndex(int index);
	private StringBuilder Next(StringBuilder chunk);
	private void ExpandByABlock(int minBlockCharCount);
	private void .ctor(StringBuilder from);
	private void MakeRoom(int index, int count, out StringBuilder chunk, out int indexInChunk, bool doneMoveFollowingChars);
	private void .ctor(int size, int maxCapacity, StringBuilder previousBlock);
	private void Remove(int startIndex, int count, out StringBuilder chunk, out int indexInChunk);

}
//NameSpace:System.Text
internal static class StringBuilderCache
{
	// Fields
	private static StringBuilder CachedInstance;

	// Methods
	public static StringBuilder Acquire(optional int capacity);
	public static void Release(StringBuilder sb);
	public static string GetStringAndRelease(StringBuilder sb);

}
//NameSpace:System.Text
public class UnicodeEncoding : Encoding
{
	// Fields
	internal bool isThrowException;
	internal bool bigEndian;
	internal bool byteOrderMark;
	private static readonly ulong highLowPatternMask;

	// Methods
	public void .ctor();
	public void .ctor(bool bigEndian, bool byteOrderMark);
	public void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);
	private void OnDeserializing(StreamingContext ctx);
	internal override void SetDefaultFallbacks();
	public override int GetByteCount(char[] chars, int index, int count);
	public override int GetByteCount(string s);
	public override int GetByteCount(char* chars, int count);
	public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
	public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
	public override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
	public override int GetCharCount(byte[] bytes, int index, int count);
	public override int GetCharCount(byte* bytes, int count);
	public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
	public override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
	public override string GetString(byte[] bytes, int index, int count);
	internal override int GetByteCount(char* chars, int count, EncoderNLS encoder);
	internal override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, EncoderNLS encoder);
	internal override int GetCharCount(byte* bytes, int count, DecoderNLS baseDecoder);
	internal override int GetChars(byte* bytes, int byteCount, char* chars, int charCount, DecoderNLS baseDecoder);
	public override Encoder GetEncoder();
	public override Decoder GetDecoder();
	public override byte[] GetPreamble();
	public override int GetMaxByteCount(int charCount);
	public override int GetMaxCharCount(int byteCount);
	public override bool Equals(object value);
	public override int GetHashCode();
	private static void .cctor();

}
//NameSpace:
private class UnicodeEncoding.Decoder : DecoderNLS, ISerializable
{
	// Fields
	internal int lastByte;
	internal char lastChar;

	// Properties
	internal override bool HasState { get; }

	// Methods
	public void .ctor(UnicodeEncoding encoding);
	internal void .ctor(SerializationInfo info, StreamingContext context);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	public override void Reset();
	internal override bool get_HasState();

}
//NameSpace:System.Text
public sealed class UTF32Encoding : Encoding
{
	// Fields
	private bool emitUTF32ByteOrderMark;
	private bool isThrowException;
	private bool bigEndian;

	// Methods
	public void .ctor();
	public void .ctor(bool bigEndian, bool byteOrderMark);
	public void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);
	internal override void SetDefaultFallbacks();
	public override int GetByteCount(char[] chars, int index, int count);
	public override int GetByteCount(string s);
	public override int GetByteCount(char* chars, int count);
	public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
	public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
	public override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
	public override int GetCharCount(byte[] bytes, int index, int count);
	public override int GetCharCount(byte* bytes, int count);
	public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
	public override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
	public override string GetString(byte[] bytes, int index, int count);
	internal override int GetByteCount(char* chars, int count, EncoderNLS encoder);
	internal override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, EncoderNLS encoder);
	internal override int GetCharCount(byte* bytes, int count, DecoderNLS baseDecoder);
	internal override int GetChars(byte* bytes, int byteCount, char* chars, int charCount, DecoderNLS baseDecoder);
	private uint GetSurrogate(char cHigh, char cLow);
	private char GetHighSurrogate(uint iChar);
	private char GetLowSurrogate(uint iChar);
	public override Decoder GetDecoder();
	public override Encoder GetEncoder();
	public override int GetMaxByteCount(int charCount);
	public override int GetMaxCharCount(int byteCount);
	public override byte[] GetPreamble();
	public override bool Equals(object value);
	public override int GetHashCode();

}
//NameSpace:
internal class UTF32Encoding.UTF32Decoder : DecoderNLS
{
	// Fields
	internal int iChar;
	internal int readByteCount;

	// Properties
	internal override bool HasState { get; }

	// Methods
	public void .ctor(UTF32Encoding encoding);
	public override void Reset();
	internal override bool get_HasState();

}
//NameSpace:System.Text
public class UTF7Encoding : Encoding
{
	// Fields
	private byte[] base64Bytes;
	private sbyte[] base64Values;
	private bool[] directEncode;
	private bool m_allowOptionals;

	// Methods
	public void .ctor();
	public void .ctor(bool allowOptionals);
	private void MakeTables();
	internal override void SetDefaultFallbacks();
	private void OnDeserializing(StreamingContext ctx);
	private void OnDeserialized(StreamingContext ctx);
	public override bool Equals(object value);
	public override int GetHashCode();
	public override int GetByteCount(char[] chars, int index, int count);
	public override int GetByteCount(string s);
	public override int GetByteCount(char* chars, int count);
	public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
	public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
	public override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
	public override int GetCharCount(byte[] bytes, int index, int count);
	public override int GetCharCount(byte* bytes, int count);
	public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
	public override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
	public override string GetString(byte[] bytes, int index, int count);
	internal override int GetByteCount(char* chars, int count, EncoderNLS baseEncoder);
	internal override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, EncoderNLS baseEncoder);
	internal override int GetCharCount(byte* bytes, int count, DecoderNLS baseDecoder);
	internal override int GetChars(byte* bytes, int byteCount, char* chars, int charCount, DecoderNLS baseDecoder);
	public override Decoder GetDecoder();
	public override Encoder GetEncoder();
	public override int GetMaxByteCount(int charCount);
	public override int GetMaxCharCount(int byteCount);

}
//NameSpace:
private class UTF7Encoding.Decoder : DecoderNLS, ISerializable
{
	// Fields
	internal int bits;
	internal int bitCount;
	internal bool firstByte;

	// Properties
	internal override bool HasState { get; }

	// Methods
	public void .ctor(UTF7Encoding encoding);
	internal void .ctor(SerializationInfo info, StreamingContext context);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	public override void Reset();
	internal override bool get_HasState();

}
//NameSpace:
private class UTF7Encoding.Encoder : EncoderNLS, ISerializable
{
	// Fields
	internal int bits;
	internal int bitCount;

	// Methods
	public void .ctor(UTF7Encoding encoding);
	internal void .ctor(SerializationInfo info, StreamingContext context);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	public override void Reset();

}
//NameSpace:
internal sealed class UTF7Encoding.DecoderUTF7Fallback : DecoderFallback
{
	// Properties
	public override int MaxCharCount { get; }

	// Methods
	public void .ctor();
	public override DecoderFallbackBuffer CreateFallbackBuffer();
	public override int get_MaxCharCount();
	public override bool Equals(object value);
	public override int GetHashCode();

}
//NameSpace:
internal sealed class UTF7Encoding.DecoderUTF7FallbackBuffer : DecoderFallbackBuffer
{
	// Fields
	private char cFallback;
	private int iCount;
	private int iSize;

	// Methods
	public void .ctor(UTF7Encoding.DecoderUTF7Fallback fallback);
	public override bool Fallback(byte[] bytesUnknown, int index);
	public override char GetNextChar();
	public override void Reset();
	internal override int InternalFallback(byte[] bytes, byte* pBytes);

}
//NameSpace:System.Text
public class UTF8Encoding : Encoding
{
	// Fields
	private bool emitUTF8Identifier;
	private bool isThrowException;

	// Methods
	public void .ctor();
	public void .ctor(bool encoderShouldEmitUTF8Identifier);
	public void .ctor(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);
	internal override void SetDefaultFallbacks();
	public override int GetByteCount(char[] chars, int index, int count);
	public override int GetByteCount(string chars);
	public override int GetByteCount(char* chars, int count);
	public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
	public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
	public override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
	public override int GetCharCount(byte[] bytes, int index, int count);
	public override int GetCharCount(byte* bytes, int count);
	public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
	public override int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
	public override string GetString(byte[] bytes, int index, int count);
	internal override int GetByteCount(char* chars, int count, EncoderNLS baseEncoder);
	private static int PtrDiff(char* a, char* b);
	private static int PtrDiff(byte* a, byte* b);
	private static bool InRange(int ch, int start, int end);
	internal override int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, EncoderNLS baseEncoder);
	internal override int GetCharCount(byte* bytes, int count, DecoderNLS baseDecoder);
	internal override int GetChars(byte* bytes, int byteCount, char* chars, int charCount, DecoderNLS baseDecoder);
	private bool FallbackInvalidByteSequence(byte* pSrc, int ch, DecoderFallbackBuffer fallback, char* pTarget);
	private int FallbackInvalidByteSequence(byte* pSrc, int ch, DecoderFallbackBuffer fallback);
	private byte[] GetBytesUnknown(byte* pSrc, int ch);
	public override Decoder GetDecoder();
	public override Encoder GetEncoder();
	public override int GetMaxByteCount(int charCount);
	public override int GetMaxCharCount(int byteCount);
	public override byte[] GetPreamble();
	public override bool Equals(object value);
	public override int GetHashCode();

}
//NameSpace:
internal class UTF8Encoding.UTF8Encoder : EncoderNLS, ISerializable
{
	// Fields
	internal int surrogateChar;

	// Methods
	public void .ctor(UTF8Encoding encoding);
	internal void .ctor(SerializationInfo info, StreamingContext context);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	public override void Reset();

}
//NameSpace:
internal class UTF8Encoding.UTF8Decoder : DecoderNLS, ISerializable
{
	// Fields
	internal int bits;

	// Properties
	internal override bool HasState { get; }

	// Methods
	public void .ctor(UTF8Encoding encoding);
	internal void .ctor(SerializationInfo info, StreamingContext context);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	public override void Reset();
	internal override bool get_HasState();

}
//NameSpace:System.Text
internal enum NormalizationCheck
{
	// Fields
	public int value__;
	public const NormalizationCheck Yes;
	public const NormalizationCheck No;
	public const NormalizationCheck Maybe;

}
//NameSpace:System.Text
internal class Normalization
{
	// Fields
	private static byte* props;
	private static int* mappedChars;
	private static short* charMapIndex;
	private static short* helperIndex;
	private static ushort* mapIdxToComposite;
	private static byte* combiningClass;
	private static object forLock;
	public static readonly bool isReady;

	// Methods
	private static uint PropValue(int cp);
	private static int CharMapIdx(int cp);
	private static byte GetCombiningClass(int c);
	private static int GetPrimaryCompositeFromMapIndex(int src);
	private static int GetPrimaryCompositeHelperIndex(int cp);
	private static string Compose(string source, int checkType);
	private static StringBuilder Combine(string source, int start, int checkType);
	private static void Combine(StringBuilder sb, int i, int checkType);
	private static int CombineHangul(StringBuilder sb, string s, int current);
	private static int Fetch(StringBuilder sb, string s, int i);
	private static int TryComposeWithPreviousStarter(StringBuilder sb, string s, int current);
	private static int TryCompose(int i, int starter, int candidate);
	private static string Decompose(string source, int checkType);
	private static void Decompose(string source, StringBuilder sb, int checkType);
	private static void ReorderCanonical(string src, StringBuilder sb, int start);
	private static void DecomposeChar(StringBuilder sb, int[] buf, string s, int i, int checkType, int start);
	public static NormalizationCheck QuickCheck(char c, int type);
	private static int GetCanonicalHangul(int s, int[] buf, int bufIdx);
	private static int GetCanonical(int c, int[] buf, int bufIdx, int checkType);
	public static string Normalize(string source, NormalizationForm normalizationForm);
	public static string Normalize(string source, int type);
	private static void load_normalization_resource(out IntPtr props, out IntPtr mappedChars, out IntPtr charMapIndex, out IntPtr helperIndex, out IntPtr mapIdxToComposite, out IntPtr combiningClass);
	private static void .cctor();

}
//NameSpace:System.Text
internal static class EncodingHelper
{
	// Fields
	private static Encoding utf8EncodingWithoutMarkers;
	private static readonly object lockobj;
	private static Assembly i18nAssembly;
	private static bool i18nDisabled;

	// Properties
	internal static Encoding UTF8Unmarked { get; }

	// Methods
	internal static Encoding get_UTF8Unmarked();
	internal static string InternalCodePage(int code_page);
	internal static Encoding GetDefaultEncoding();
	internal static object InvokeI18N(string name, object[] args);
	private static void .cctor();

}
//NameSpace:System.Text
public enum NormalizationForm
{
	// Fields
	public int value__;
	public const NormalizationForm FormC;
	public const NormalizationForm FormD;
	public const NormalizationForm FormKC;
	public const NormalizationForm FormKD;

}
//NameSpace:System.Resources
internal sealed class FastResourceComparer : IComparer, IEqualityComparer, IComparer`1<string>, IEqualityComparer`1<string>
{
	// Fields
	internal static readonly FastResourceComparer Default;

	// Methods
	public int GetHashCode(object key);
	public int GetHashCode(string key);
	internal static int HashFunction(string key);
	public int Compare(object a, object b);
	public int Compare(string a, string b);
	public bool Equals(string a, string b);
	public bool Equals(object a, object b);
	public static int CompareOrdinal(string a, byte[] bytes, int bCharLength);
	public static int CompareOrdinal(byte[] bytes, int aCharLength, string b);
	internal static int CompareOrdinal(byte* a, int byteLen, string b);
	public void .ctor();
	private static void .cctor();

}
//NameSpace:System.Resources
internal class FileBasedResourceGroveler : IResourceGroveler
{
	// Fields
	private ResourceManager.ResourceManagerMediator _mediator;

	// Methods
	public void .ctor(ResourceManager.ResourceManagerMediator mediator);

}
//NameSpace:System.Resources
internal interface IResourceGroveler
{
}
//NameSpace:System.Resources
public interface IResourceReader : IEnumerable, IDisposable
{
	// Methods
	public abstract void Close();
	public abstract IDictionaryEnumerator GetEnumerator();

}
//NameSpace:System.Resources
internal class ManifestBasedResourceGroveler : IResourceGroveler
{
	// Fields
	private ResourceManager.ResourceManagerMediator _mediator;

	// Methods
	public void .ctor(ResourceManager.ResourceManagerMediator mediator);
	internal static CultureInfo GetNeutralResourcesLanguage(Assembly a, UltimateResourceFallbackLocation fallbackLocation);
	private static bool GetNeutralResourcesLanguageAttribute(Assembly assembly, string cultureName, short fallbackLocation);

}
//NameSpace:System.Resources
public sealed class NeutralResourcesLanguageAttribute : Attribute
{
	// Fields
	private string _culture;
	private UltimateResourceFallbackLocation _fallbackLoc;

	// Properties
	public string CultureName { get; }
	public UltimateResourceFallbackLocation Location { get; }

	// Methods
	public void .ctor(string cultureName);
	public string get_CultureName();
	public UltimateResourceFallbackLocation get_Location();

}
//NameSpace:System.Resources
public class ResourceManager
{
	// Fields
	protected Hashtable ResourceSets;
	private Dictionary`2<stringResourceSet> _resourceSets;
	protected Assembly MainAssembly;
	private CultureInfo _neutralResourcesCulture;
	private ResourceManager.CultureNameResourceSetPair _lastUsedResourceCache;
	private bool UseManifest;
	private bool UseSatelliteAssem;
	private UltimateResourceFallbackLocation _fallbackLoc;
	private Assembly _callingAssembly;
	private RuntimeAssembly m_callingAssembly;
	private IResourceGroveler resourceGroveler;
	public static readonly int MagicNumber;
	public static readonly int HeaderVersionNumber;
	private static readonly Type _minResourceSet;
	internal static readonly string ResReaderTypeName;
	internal static readonly string ResSetTypeName;
	internal static readonly string MscorlibName;
	internal static readonly int DEBUG;

	// Methods
	private void Init();
	protected void .ctor();
	private void OnDeserializing(StreamingContext ctx);
	private void OnDeserialized(StreamingContext ctx);
	private void OnSerializing(StreamingContext ctx);
	internal static bool CompareNames(string asmTypeName1, string typeName2, AssemblyName asmName2);
	private static void .cctor();

}
//NameSpace:
internal class ResourceManager.CultureNameResourceSetPair
{
	// Methods
	public void .ctor();

}
//NameSpace:
internal class ResourceManager.ResourceManagerMediator
{
	// Fields
	private ResourceManager _rm;

	// Methods
	internal void .ctor(ResourceManager rm);

}
//NameSpace:System.Resources
internal struct ResourceLocator
{
	// Fields
	internal object _value;
	internal int _dataPos;

	// Properties
	internal int DataPosition { get; }
	internal object Value { get; set; }

	// Methods
	internal void .ctor(int dataPos, object value);
	internal int get_DataPosition();
	internal object get_Value();
	internal void set_Value(object value);
	internal static bool CanCache(ResourceTypeCode value);

}
//NameSpace:System.Resources
public sealed class ResourceReader : IResourceReader, IEnumerable, IDisposable
{
	// Fields
	private BinaryReader _store;
	internal Dictionary`2<stringResourceLocator> _resCache;
	private long _nameSectionOffset;
	private long _dataSectionOffset;
	private int[] _nameHashes;
	private int* _nameHashesPtr;
	private int[] _namePositions;
	private int* _namePositionsPtr;
	private RuntimeType[] _typeTable;
	private int[] _typeNamePositions;
	private BinaryFormatter _objFormatter;
	private int _numResources;
	private UnmanagedMemoryStream _ums;
	private int _version;

	// Methods
	internal void .ctor(Stream stream, Dictionary`2<stringResourceLocator> resCache);
	public void Close();
	public void Dispose();
	private void Dispose(bool disposing);
	internal static int ReadUnalignedI4(int* p);
	private void SkipString();
	private int GetNameHash(int index);
	private int GetNamePosition(int index);
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();
	public IDictionaryEnumerator GetEnumerator();
	internal ResourceReader.ResourceEnumerator GetEnumeratorInternal();
	internal int FindPosForResource(string name);
	private bool CompareStringEqualsName(string name);
	private string AllocateStringForNameIndex(int index, out int dataOffset);
	private object GetValueForNameIndex(int index);
	internal string LoadString(int pos);
	internal object LoadObject(int pos);
	internal object LoadObject(int pos, out ResourceTypeCode typeCode);
	internal object LoadObjectV1(int pos);
	private object _LoadObjectV1(int pos);
	internal object LoadObjectV2(int pos, out ResourceTypeCode typeCode);
	private object _LoadObjectV2(int pos, out ResourceTypeCode typeCode);
	private object DeserializeObject(int typeIndex);
	private void ReadResources();
	private void _ReadResources();
	private RuntimeType FindType(int typeIndex);

}
//NameSpace:
internal sealed class ResourceReader.ResourceEnumerator : IDictionaryEnumerator, IEnumerator
{
	// Fields
	private ResourceReader _reader;
	private bool _currentIsValid;
	private int _currentName;
	private int _dataPosition;

	// Properties
	public object Key { get; }
	public object Current { get; }
	internal int DataPosition { get; }
	public DictionaryEntry Entry { get; }
	public object Value { get; }

	// Methods
	internal void .ctor(ResourceReader reader);
	public bool MoveNext();
	public object get_Key();
	public object get_Current();
	internal int get_DataPosition();
	public DictionaryEntry get_Entry();
	public object get_Value();

}
//NameSpace:System.Resources
public class ResourceSet : IDisposable, IEnumerable
{
	// Fields
	protected IResourceReader Reader;
	protected Hashtable Table;
	private Hashtable _caseInsensitiveTable;

	// Methods
	protected void .ctor();
	internal void .ctor(bool junk);
	private void CommonInit();
	protected virtual void Dispose(bool disposing);
	public void Dispose();
	public virtual IDictionaryEnumerator GetEnumerator();
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();
	private IDictionaryEnumerator GetEnumeratorHelper();
	public virtual string GetString(string name);
	public virtual string GetString(string name, bool ignoreCase);
	public virtual object GetObject(string name);
	public virtual object GetObject(string name, bool ignoreCase);
	private object GetObjectInternal(string name);
	private object GetCaseInsensitiveObjectInternal(string name);

}
//NameSpace:System.Resources
internal enum ResourceTypeCode
{
	// Fields
	public int value__;
	public const ResourceTypeCode Null;
	public const ResourceTypeCode String;
	public const ResourceTypeCode Boolean;
	public const ResourceTypeCode Char;
	public const ResourceTypeCode Byte;
	public const ResourceTypeCode SByte;
	public const ResourceTypeCode Int16;
	public const ResourceTypeCode UInt16;
	public const ResourceTypeCode Int32;
	public const ResourceTypeCode UInt32;
	public const ResourceTypeCode Int64;
	public const ResourceTypeCode UInt64;
	public const ResourceTypeCode Single;
	public const ResourceTypeCode Double;
	public const ResourceTypeCode Decimal;
	public const ResourceTypeCode DateTime;
	public const ResourceTypeCode TimeSpan;
	public const ResourceTypeCode LastPrimitive;
	public const ResourceTypeCode ByteArray;
	public const ResourceTypeCode Stream;
	public const ResourceTypeCode StartOfUserTypes;

}
//NameSpace:System.Resources
internal sealed class RuntimeResourceSet : ResourceSet, IEnumerable
{
	// Fields
	internal const int Version;
	private Dictionary`2<stringResourceLocator> _resCache;
	private ResourceReader _defaultReader;
	private Dictionary`2<stringResourceLocator> _caseInsensitiveTable;
	private bool _haveReadFromReader;

	// Methods
	internal void .ctor(string fileName);
	internal void .ctor(Stream stream);
	protected override void Dispose(bool disposing);
	public override IDictionaryEnumerator GetEnumerator();
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();
	private IDictionaryEnumerator GetEnumeratorHelper();
	public override string GetString(string key);
	public override string GetString(string key, bool ignoreCase);
	public override object GetObject(string key);
	public override object GetObject(string key, bool ignoreCase);
	private object GetObject(string key, bool ignoreCase, bool isString);
	private object ResolveResourceLocator(ResourceLocator resLocation, string key, Dictionary`2<stringResourceLocator> copyOfCache, bool keyInWrongCase);

}
//NameSpace:System.Resources
public sealed class SatelliteContractVersionAttribute : Attribute
{
	// Fields
	private string _version;

	// Methods
	public void .ctor(string version);

}
//NameSpace:System.Resources
public enum UltimateResourceFallbackLocation
{
	// Fields
	public int value__;
	public const UltimateResourceFallbackLocation MainAssembly;
	public const UltimateResourceFallbackLocation Satellite;

}
//NameSpace:System.Reflection
public static class CustomAttributeExtensions
{
	// Methods
	public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
	public static T GetCustomAttribute(Assembly element);

}
//NameSpace:System.Reflection
public sealed class AmbiguousMatchException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	internal void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Reflection
public sealed class AssemblyCopyrightAttribute : Attribute
{
	// Fields
	private string m_copyright;

	// Methods
	public void .ctor(string copyright);

}
//NameSpace:System.Reflection
public sealed class AssemblyTrademarkAttribute : Attribute
{
	// Fields
	private string m_trademark;

	// Methods
	public void .ctor(string trademark);

}
//NameSpace:System.Reflection
public sealed class AssemblyProductAttribute : Attribute
{
	// Fields
	private string m_product;

	// Methods
	public void .ctor(string product);

}
//NameSpace:System.Reflection
public sealed class AssemblyCompanyAttribute : Attribute
{
	// Fields
	private string m_company;

	// Methods
	public void .ctor(string company);

}
//NameSpace:System.Reflection
public sealed class AssemblyDescriptionAttribute : Attribute
{
	// Fields
	private string m_description;

	// Methods
	public void .ctor(string description);

}
//NameSpace:System.Reflection
public sealed class AssemblyTitleAttribute : Attribute
{
	// Fields
	private string m_title;

	// Methods
	public void .ctor(string title);

}
//NameSpace:System.Reflection
public sealed class AssemblyConfigurationAttribute : Attribute
{
	// Fields
	private string m_configuration;

	// Methods
	public void .ctor(string configuration);

}
//NameSpace:System.Reflection
public sealed class AssemblyDefaultAliasAttribute : Attribute
{
	// Fields
	private string m_defaultAlias;

	// Methods
	public void .ctor(string defaultAlias);

}
//NameSpace:System.Reflection
public sealed class AssemblyInformationalVersionAttribute : Attribute
{
	// Fields
	private string m_informationalVersion;

	// Methods
	public void .ctor(string informationalVersion);

}
//NameSpace:System.Reflection
public sealed class AssemblyFileVersionAttribute : Attribute
{
	// Fields
	private string _version;

	// Methods
	public void .ctor(string version);

}
//NameSpace:System.Reflection
public sealed class AssemblyKeyFileAttribute : Attribute
{
	// Fields
	private string m_keyFile;

	// Methods
	public void .ctor(string keyFile);

}
//NameSpace:System.Reflection
public sealed class AssemblyDelaySignAttribute : Attribute
{
	// Fields
	private bool m_delaySign;

	// Methods
	public void .ctor(bool delaySign);

}
//NameSpace:System.Reflection
public enum AssemblyNameFlags
{
	// Fields
	public int value__;
	public const AssemblyNameFlags None;
	public const AssemblyNameFlags PublicKey;
	public const AssemblyNameFlags EnableJITcompileOptimizer;
	public const AssemblyNameFlags EnableJITcompileTracking;
	public const AssemblyNameFlags Retargetable;

}
//NameSpace:System.Reflection
public enum AssemblyContentType
{
	// Fields
	public int value__;
	public const AssemblyContentType Default;
	public const AssemblyContentType WindowsRuntime;

}
//NameSpace:System.Reflection
public enum ProcessorArchitecture
{
	// Fields
	public int value__;
	public const ProcessorArchitecture None;
	public const ProcessorArchitecture MSIL;
	public const ProcessorArchitecture X86;
	public const ProcessorArchitecture IA64;
	public const ProcessorArchitecture Amd64;
	public const ProcessorArchitecture Arm;

}
//NameSpace:System.Reflection
public abstract class Binder
{
	// Methods
	public abstract MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] names, out object state);
	public abstract FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo culture);
	public abstract MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
	public abstract PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
	public abstract object ChangeType(object value, Type type, CultureInfo culture);
	public abstract void ReorderArgumentArray(object[] args, object state);
	protected void .ctor();

}
//NameSpace:System.Reflection
public enum BindingFlags
{
	// Fields
	public int value__;
	public const BindingFlags Default;
	public const BindingFlags IgnoreCase;
	public const BindingFlags DeclaredOnly;
	public const BindingFlags Instance;
	public const BindingFlags Static;
	public const BindingFlags Public;
	public const BindingFlags NonPublic;
	public const BindingFlags FlattenHierarchy;
	public const BindingFlags InvokeMethod;
	public const BindingFlags CreateInstance;
	public const BindingFlags GetField;
	public const BindingFlags SetField;
	public const BindingFlags GetProperty;
	public const BindingFlags SetProperty;
	public const BindingFlags PutDispProperty;
	public const BindingFlags PutRefDispProperty;
	public const BindingFlags ExactBinding;
	public const BindingFlags SuppressChangeType;
	public const BindingFlags OptionalParamBinding;
	public const BindingFlags IgnoreReturn;

}
//NameSpace:System.Reflection
public enum CallingConventions
{
	// Fields
	public int value__;
	public const CallingConventions Standard;
	public const CallingConventions VarArgs;
	public const CallingConventions Any;
	public const CallingConventions HasThis;
	public const CallingConventions ExplicitThis;

}
//NameSpace:System.Reflection
public sealed class DefaultMemberAttribute : Attribute
{
	// Fields
	private string m_memberName;

	// Properties
	public string MemberName { get; }

	// Methods
	public void .ctor(string memberName);
	public string get_MemberName();

}
//NameSpace:System.Reflection
public enum EventAttributes
{
	// Fields
	public int value__;
	public const EventAttributes None;
	public const EventAttributes SpecialName;
	public const EventAttributes ReservedMask;
	public const EventAttributes RTSpecialName;

}
//NameSpace:System.Reflection
public enum FieldAttributes
{
	// Fields
	public int value__;
	public const FieldAttributes FieldAccessMask;
	public const FieldAttributes PrivateScope;
	public const FieldAttributes Private;
	public const FieldAttributes FamANDAssem;
	public const FieldAttributes Assembly;
	public const FieldAttributes Family;
	public const FieldAttributes FamORAssem;
	public const FieldAttributes Public;
	public const FieldAttributes Static;
	public const FieldAttributes InitOnly;
	public const FieldAttributes Literal;
	public const FieldAttributes NotSerialized;
	public const FieldAttributes SpecialName;
	public const FieldAttributes PinvokeImpl;
	public const FieldAttributes ReservedMask;
	public const FieldAttributes RTSpecialName;
	public const FieldAttributes HasFieldMarshal;
	public const FieldAttributes HasDefault;
	public const FieldAttributes HasFieldRVA;

}
//NameSpace:System.Reflection
public enum GenericParameterAttributes
{
	// Fields
	public int value__;
	public const GenericParameterAttributes None;
	public const GenericParameterAttributes VarianceMask;
	public const GenericParameterAttributes Covariant;
	public const GenericParameterAttributes Contravariant;
	public const GenericParameterAttributes SpecialConstraintMask;
	public const GenericParameterAttributes ReferenceTypeConstraint;
	public const GenericParameterAttributes NotNullableValueTypeConstraint;
	public const GenericParameterAttributes DefaultConstructorConstraint;

}
//NameSpace:System.Reflection
public interface ICustomAttributeProvider
{
	// Methods
	public abstract object[] GetCustomAttributes(Type attributeType, bool inherit);
	public abstract bool IsDefined(Type attributeType, bool inherit);

}
//NameSpace:System.Reflection
public class InvalidFilterCriteriaException : ApplicationException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Reflection
public interface IReflect
{
}
//NameSpace:System.Reflection
public interface IReflectableType
{
}
//NameSpace:System.Reflection
internal enum PInvokeAttributes
{
	// Fields
	public int value__;
	public const PInvokeAttributes NoMangle;
	public const PInvokeAttributes CharSetMask;
	public const PInvokeAttributes CharSetNotSpec;
	public const PInvokeAttributes CharSetAnsi;
	public const PInvokeAttributes CharSetUnicode;
	public const PInvokeAttributes CharSetAuto;
	public const PInvokeAttributes BestFitUseAssem;
	public const PInvokeAttributes BestFitEnabled;
	public const PInvokeAttributes BestFitDisabled;
	public const PInvokeAttributes BestFitMask;
	public const PInvokeAttributes ThrowOnUnmappableCharUseAssem;
	public const PInvokeAttributes ThrowOnUnmappableCharEnabled;
	public const PInvokeAttributes ThrowOnUnmappableCharDisabled;
	public const PInvokeAttributes ThrowOnUnmappableCharMask;
	public const PInvokeAttributes SupportsLastError;
	public const PInvokeAttributes CallConvMask;
	public const PInvokeAttributes CallConvWinapi;
	public const PInvokeAttributes CallConvCdecl;
	public const PInvokeAttributes CallConvStdcall;
	public const PInvokeAttributes CallConvThiscall;
	public const PInvokeAttributes CallConvFastcall;
	public const PInvokeAttributes MaxValue;

}
//NameSpace:System.Reflection
public sealed class MemberFilter : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual bool Invoke(MemberInfo m, object filterCriteria);
	public virtual IAsyncResult BeginInvoke(MemberInfo m, object filterCriteria, AsyncCallback callback, object object);
	public virtual bool EndInvoke(IAsyncResult result);

}
//NameSpace:System.Reflection
public abstract class MemberInfo : ICustomAttributeProvider, _MemberInfo
{
	// Properties
	public abstract MemberTypes MemberType { get; }
	public abstract string Name { get; }
	public abstract Type DeclaringType { get; }
	public abstract Type ReflectedType { get; }
	public virtual int MetadataToken { get; }
	public virtual Module Module { get; }

	// Methods
	protected void .ctor();
	public abstract MemberTypes get_MemberType();
	public abstract string get_Name();
	public abstract Type get_DeclaringType();
	public abstract Type get_ReflectedType();
	public abstract object[] GetCustomAttributes(bool inherit);
	public abstract object[] GetCustomAttributes(Type attributeType, bool inherit);
	public abstract bool IsDefined(Type attributeType, bool inherit);
	public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
	public virtual int get_MetadataToken();
	public virtual Module get_Module();
	public static bool op_Equality(MemberInfo left, MemberInfo right);
	public static bool op_Inequality(MemberInfo left, MemberInfo right);
	public override bool Equals(object obj);
	public override int GetHashCode();

}
//NameSpace:System.Reflection
internal class MemberInfoSerializationHolder : ISerializable, IObjectReference
{
	// Fields
	private string m_memberName;
	private RuntimeType m_reflectedType;
	private string m_signature;
	private string m_signature2;
	private MemberTypes m_memberType;
	private SerializationInfo m_info;

	// Methods
	public static void GetSerializationInfo(SerializationInfo info, string name, RuntimeType reflectedClass, string signature, MemberTypes type);
	public static void GetSerializationInfo(SerializationInfo info, string name, RuntimeType reflectedClass, string signature, string signature2, MemberTypes type, Type[] genericArguments);
	internal void .ctor(SerializationInfo info, StreamingContext context);
	public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
	public virtual object GetRealObject(StreamingContext context);

}
//NameSpace:System.Reflection
public enum MemberTypes
{
	// Fields
	public int value__;
	public const MemberTypes Constructor;
	public const MemberTypes Event;
	public const MemberTypes Field;
	public const MemberTypes Method;
	public const MemberTypes Property;
	public const MemberTypes TypeInfo;
	public const MemberTypes Custom;
	public const MemberTypes NestedType;
	public const MemberTypes All;

}
//NameSpace:System.Reflection
public enum MethodAttributes
{
	// Fields
	public int value__;
	public const MethodAttributes MemberAccessMask;
	public const MethodAttributes PrivateScope;
	public const MethodAttributes Private;
	public const MethodAttributes FamANDAssem;
	public const MethodAttributes Assembly;
	public const MethodAttributes Family;
	public const MethodAttributes FamORAssem;
	public const MethodAttributes Public;
	public const MethodAttributes Static;
	public const MethodAttributes Final;
	public const MethodAttributes Virtual;
	public const MethodAttributes HideBySig;
	public const MethodAttributes CheckAccessOnOverride;
	public const MethodAttributes VtableLayoutMask;
	public const MethodAttributes ReuseSlot;
	public const MethodAttributes NewSlot;
	public const MethodAttributes Abstract;
	public const MethodAttributes SpecialName;
	public const MethodAttributes PinvokeImpl;
	public const MethodAttributes UnmanagedExport;
	public const MethodAttributes RTSpecialName;
	public const MethodAttributes ReservedMask;
	public const MethodAttributes HasSecurity;
	public const MethodAttributes RequireSecObject;

}
//NameSpace:System.Reflection
public abstract class MethodBase : MemberInfo, _MethodBase
{
	// Properties
	public abstract RuntimeMethodHandle MethodHandle { get; }
	public abstract MethodAttributes Attributes { get; }
	public virtual CallingConventions CallingConvention { get; }
	public virtual bool IsGenericMethodDefinition { get; }
	public virtual bool ContainsGenericParameters { get; }
	public virtual bool IsGenericMethod { get; }
	public virtual bool IsSecurityCritical { get; }
	public bool IsPublic { get; }
	public bool IsStatic { get; }
	public bool IsVirtual { get; }
	public bool IsAbstract { get; }
	public bool IsConstructor { get; }

	// Methods
	public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle);
	protected void .ctor();
	public static bool op_Equality(MethodBase left, MethodBase right);
	public static bool op_Inequality(MethodBase left, MethodBase right);
	public override bool Equals(object obj);
	public override int GetHashCode();
	internal virtual ParameterInfo[] GetParametersNoCopy();
	public abstract ParameterInfo[] GetParameters();
	public abstract MethodImplAttributes GetMethodImplementationFlags();
	public abstract RuntimeMethodHandle get_MethodHandle();
	public abstract MethodAttributes get_Attributes();
	public abstract object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
	public virtual CallingConventions get_CallingConvention();
	public virtual Type[] GetGenericArguments();
	public virtual bool get_IsGenericMethodDefinition();
	public virtual bool get_ContainsGenericParameters();
	public virtual bool get_IsGenericMethod();
	public virtual bool get_IsSecurityCritical();
	public object Invoke(object obj, object[] parameters);
	public bool get_IsPublic();
	public bool get_IsStatic();
	public bool get_IsVirtual();
	public bool get_IsAbstract();
	public bool get_IsConstructor();
	internal static string ConstructParameters(Type[] parameterTypes, CallingConventions callingConvention, bool serialization);
	internal virtual string FormatNameAndSig(bool serialization);
	internal virtual Type[] GetParameterTypes();
	internal virtual ParameterInfo[] GetParametersInternal();
	internal virtual int GetParametersCount();
	internal static MethodBase GetMethodFromHandleNoGenericCheck(RuntimeMethodHandle handle);
	internal static MethodBase GetMethodFromHandleNoGenericCheck(RuntimeMethodHandle handle, RuntimeTypeHandle reflectedType);
	private static MethodBase GetMethodFromHandleInternalType(IntPtr method_handle, IntPtr type_handle);
	internal static MethodBase GetMethodFromHandleInternalType_native(IntPtr method_handle, IntPtr type_handle, bool genericCheck);

}
//NameSpace:System.Reflection
public enum ExceptionHandlingClauseOptions
{
	// Fields
	public int value__;
	public const ExceptionHandlingClauseOptions Clause;
	public const ExceptionHandlingClauseOptions Filter;
	public const ExceptionHandlingClauseOptions Finally;
	public const ExceptionHandlingClauseOptions Fault;

}
//NameSpace:System.Reflection
public enum MethodImplAttributes
{
	// Fields
	public int value__;
	public const MethodImplAttributes CodeTypeMask;
	public const MethodImplAttributes IL;
	public const MethodImplAttributes Native;
	public const MethodImplAttributes OPTIL;
	public const MethodImplAttributes Runtime;
	public const MethodImplAttributes ManagedMask;
	public const MethodImplAttributes Unmanaged;
	public const MethodImplAttributes Managed;
	public const MethodImplAttributes ForwardRef;
	public const MethodImplAttributes PreserveSig;
	public const MethodImplAttributes InternalCall;
	public const MethodImplAttributes Synchronized;
	public const MethodImplAttributes NoInlining;
	public const MethodImplAttributes AggressiveInlining;
	public const MethodImplAttributes NoOptimization;
	public const MethodImplAttributes MaxMethodImplVal;

}
//NameSpace:System.Reflection
public abstract class MethodInfo : MethodBase, _MethodInfo
{
	// Properties
	public override MemberTypes MemberType { get; }
	public virtual Type ReturnType { get; }

	// Methods
	protected void .ctor();
	public static bool op_Equality(MethodInfo left, MethodInfo right);
	public static bool op_Inequality(MethodInfo left, MethodInfo right);
	public override bool Equals(object obj);
	public override int GetHashCode();
	public override MemberTypes get_MemberType();
	public virtual Type get_ReturnType();
	public override Type[] GetGenericArguments();
	public virtual MethodInfo GetGenericMethodDefinition();
	public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
	internal virtual MethodInfo GetBaseMethod();

}
//NameSpace:System.Reflection
public sealed class Missing : ISerializable
{
	// Fields
	public static readonly Missing Value;

	// Methods
	private void .ctor();
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	private static void .cctor();

}
//NameSpace:System.Reflection
public enum ParameterAttributes
{
	// Fields
	public int value__;
	public const ParameterAttributes None;
	public const ParameterAttributes In;
	public const ParameterAttributes Out;
	public const ParameterAttributes Lcid;
	public const ParameterAttributes Retval;
	public const ParameterAttributes Optional;
	public const ParameterAttributes ReservedMask;
	public const ParameterAttributes HasDefault;
	public const ParameterAttributes HasFieldMarshal;
	public const ParameterAttributes Reserved3;
	public const ParameterAttributes Reserved4;

}
//NameSpace:System.Reflection
public struct ParameterModifier
{
	// Fields
	private bool[] _byRef;

}
//NameSpace:System.Reflection
public sealed class Pointer : ISerializable
{
	// Fields
	private void* _ptr;
	private RuntimeType _ptrType;

	// Methods
	private void .ctor();
	private void .ctor(SerializationInfo info, StreamingContext context);
	public static object Box(void* ptr, Type type);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Reflection
public enum PropertyAttributes
{
	// Fields
	public int value__;
	public const PropertyAttributes None;
	public const PropertyAttributes SpecialName;
	public const PropertyAttributes ReservedMask;
	public const PropertyAttributes RTSpecialName;
	public const PropertyAttributes HasDefault;
	public const PropertyAttributes Reserved2;
	public const PropertyAttributes Reserved3;
	public const PropertyAttributes Reserved4;

}
//NameSpace:System.Reflection
public sealed class ReflectionTypeLoadException : SystemException, ISerializable
{
	// Fields
	private Type[] _classes;
	private Exception[] _exceptions;

	// Methods
	private void .ctor();
	public void .ctor(Type[] classes, Exception[] exceptions);
	internal void .ctor(SerializationInfo info, StreamingContext context);
	public override void GetObjectData(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Reflection
public class TargetException : ApplicationException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Reflection
public sealed class TargetInvocationException : ApplicationException
{
	// Methods
	private void .ctor();
	public void .ctor(Exception inner);
	internal void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Reflection
public sealed class TargetParameterCountException : ApplicationException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	internal void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Reflection
public enum TypeAttributes
{
	// Fields
	public int value__;
	public const TypeAttributes VisibilityMask;
	public const TypeAttributes NotPublic;
	public const TypeAttributes Public;
	public const TypeAttributes NestedPublic;
	public const TypeAttributes NestedPrivate;
	public const TypeAttributes NestedFamily;
	public const TypeAttributes NestedAssembly;
	public const TypeAttributes NestedFamANDAssem;
	public const TypeAttributes NestedFamORAssem;
	public const TypeAttributes LayoutMask;
	public const TypeAttributes AutoLayout;
	public const TypeAttributes SequentialLayout;
	public const TypeAttributes ExplicitLayout;
	public const TypeAttributes ClassSemanticsMask;
	public const TypeAttributes Class;
	public const TypeAttributes Interface;
	public const TypeAttributes Abstract;
	public const TypeAttributes Sealed;
	public const TypeAttributes SpecialName;
	public const TypeAttributes Import;
	public const TypeAttributes Serializable;
	public const TypeAttributes WindowsRuntime;
	public const TypeAttributes StringFormatMask;
	public const TypeAttributes AnsiClass;
	public const TypeAttributes UnicodeClass;
	public const TypeAttributes AutoClass;
	public const TypeAttributes CustomFormatClass;
	public const TypeAttributes CustomFormatMask;
	public const TypeAttributes BeforeFieldInit;
	public const TypeAttributes ReservedMask;
	public const TypeAttributes RTSpecialName;
	public const TypeAttributes HasSecurity;

}
//NameSpace:System.Reflection
public sealed class TypeFilter : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual bool Invoke(Type m, object filterCriteria);
	public virtual IAsyncResult BeginInvoke(Type m, object filterCriteria, AsyncCallback callback, object object);
	public virtual bool EndInvoke(IAsyncResult result);

}
//NameSpace:System.Reflection
public abstract class TypeInfo : Type, IReflectableType
{
	// Methods
	internal void .ctor();

}
//NameSpace:System.Reflection
public class Assembly : ICustomAttributeProvider, ISerializable, _Assembly, IEvidenceFactory
{
	// Fields
	internal IntPtr _mono_assembly;
	private Assembly.ResolveEventHolder resolve_event_holder;
	private object _evidence;
	private object _minimum;
	private object _optional;
	private object _refuse;
	private object _granted;
	private object _denied;
	private bool fromByteArray;
	private string assemblyName;

	// Properties
	public virtual string CodeBase { get; }
	public virtual string FullName { get; }
	public bool IsFullyTrusted { get; }

	// Methods
	protected void .ctor();
	private string get_code_base(bool escaped);
	private string get_fullname();
	internal static string GetAotId();
	private string GetCodeBase(bool escaped);
	public virtual string get_CodeBase();
	public virtual string get_FullName();
	public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
	public virtual bool IsDefined(Type attributeType, bool inherit);
	public virtual object[] GetCustomAttributes(Type attributeType, bool inherit);
	internal IntPtr GetManifestResourceInternal(string name, out int size, out Module module);
	internal virtual Type[] GetTypes(bool exportedOnly);
	public virtual Type[] GetTypes();
	public virtual Type GetType(string name);
	internal Type InternalGetType(Module module, string name, bool throwOnError, bool ignoreCase);
	public virtual AssemblyName GetName(bool copiedName);
	public virtual AssemblyName GetName();
	public override string ToString();
	public static Assembly GetAssembly(Type type);
	public static Assembly Load(string assemblyString);
	private static Assembly load_with_partial_name(string name, Evidence e);
	public static Assembly LoadWithPartialName(string partialName, Evidence securityEvidence);
	internal static Assembly LoadWithPartialName(string partialName, Evidence securityEvidence, bool oldBehavior);
	internal virtual Module[] GetModulesInternal();
	public static Assembly GetExecutingAssembly();
	public static Assembly GetCallingAssembly();
	public override int GetHashCode();
	public override bool Equals(object o);
	private static Exception CreateNIE();
	public bool get_IsFullyTrusted();
	public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
	public virtual Module GetModule(string name);
	public virtual Module[] GetModules(bool getResourceModules);
	public static bool op_Equality(Assembly left, Assembly right);
	public static bool op_Inequality(Assembly left, Assembly right);

}
//NameSpace:
internal class Assembly.ResolveEventHolder
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Reflection
public sealed class AssemblyName : ICloneable, ISerializable, IDeserializationCallback, _AssemblyName
{
	// Fields
	private string name;
	private string codebase;
	private int major;
	private int minor;
	private int build;
	private int revision;
	private CultureInfo cultureinfo;
	private AssemblyNameFlags flags;
	private AssemblyHashAlgorithm hashalg;
	private StrongNameKeyPair keypair;
	private byte[] publicKey;
	private byte[] keyToken;
	private AssemblyVersionCompatibility versioncompat;
	private Version version;
	private ProcessorArchitecture processor_architecture;
	private AssemblyContentType contentType;

	// Properties
	public string Name { get; }
	public CultureInfo CultureInfo { get; }
	public AssemblyNameFlags Flags { get; }
	public string FullName { get; }
	public Version Version { get; set; }
	private bool IsPublicKeyValid { get; }

	// Methods
	public void .ctor();
	private static bool ParseAssemblyName(IntPtr name, out MonoAssemblyName aname, out bool is_version_definited, out bool is_token_defined);
	public void .ctor(string assemblyName);
	internal void .ctor(SerializationInfo si, StreamingContext sc);
	public string get_Name();
	public CultureInfo get_CultureInfo();
	public AssemblyNameFlags get_Flags();
	public string get_FullName();
	public Version get_Version();
	public void set_Version(Version value);
	public override string ToString();
	public byte[] GetPublicKeyToken();
	private bool get_IsPublicKeyValid();
	private byte[] InternalGetPublicKeyToken();
	private static void get_public_token(byte* token, byte* pubkey, int len);
	private byte[] ComputePublicKeyToken();
	public void GetObjectData(SerializationInfo info, StreamingContext context);
	public object Clone();
	public void OnDeserialization(object sender);
	private static MonoAssemblyName* GetNativeName(IntPtr assembly_ptr);
	internal void FillName(MonoAssemblyName* native, string codeBase, bool addVersion, bool addPublickey, bool defaultToken, bool assemblyRef);
	internal static AssemblyName Create(Assembly assembly, bool fillCodebase);

}
//NameSpace:System.Reflection
public abstract class ConstructorInfo : MethodBase, _ConstructorInfo
{
	// Fields
	public static readonly string ConstructorName;
	public static readonly string TypeConstructorName;

	// Properties
	public override MemberTypes MemberType { get; }

	// Methods
	protected void .ctor();
	public override MemberTypes get_MemberType();
	public object Invoke(object[] parameters);
	public abstract object Invoke(BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
	public override bool Equals(object obj);
	public override int GetHashCode();
	public static bool op_Equality(ConstructorInfo left, ConstructorInfo right);
	public static bool op_Inequality(ConstructorInfo left, ConstructorInfo right);
	private static void .cctor();

}
//NameSpace:System.Reflection
public class CustomAttributeData
{
	// Fields
	private ConstructorInfo ctorInfo;
	private IList`1<CustomAttributeTypedArgument> ctorArgs;
	private IList`1<CustomAttributeNamedArgument> namedArgs;
	private CustomAttributeData.LazyCAttrData lazyData;

	// Properties
	public virtual ConstructorInfo Constructor { get; }
	public virtual IList`1<CustomAttributeTypedArgument> ConstructorArguments { get; }
	public virtual IList`1<CustomAttributeNamedArgument> NamedArguments { get; }
	public Type AttributeType { get; }

	// Methods
	protected void .ctor();
	internal void .ctor(ConstructorInfo ctorInfo, Assembly assembly, IntPtr data, uint data_length);
	private static void ResolveArgumentsInternal(ConstructorInfo ctor, Assembly assembly, IntPtr data, uint data_length, out object[] ctorArgs, out object[] namedArgs);
	private void ResolveArguments();
	public virtual ConstructorInfo get_Constructor();
	public virtual IList`1<CustomAttributeTypedArgument> get_ConstructorArguments();
	public virtual IList`1<CustomAttributeNamedArgument> get_NamedArguments();
	public static IList`1<CustomAttributeData> GetCustomAttributes(Assembly target);
	public static IList`1<CustomAttributeData> GetCustomAttributes(MemberInfo target);
	internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeType target);
	public static IList`1<CustomAttributeData> GetCustomAttributes(Module target);
	public static IList`1<CustomAttributeData> GetCustomAttributes(ParameterInfo target);
	public Type get_AttributeType();
	public override string ToString();
	private static T[] UnboxValues(object[] values);
	public override bool Equals(object obj);
	public override int GetHashCode();

}
//NameSpace:
private class CustomAttributeData.LazyCAttrData
{
	// Fields
	internal Assembly assembly;
	internal IntPtr data;
	internal uint data_length;

	// Methods
	public void .ctor();

}
//NameSpace:System.Reflection
public class CustomAttributeFormatException : FormatException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Reflection
public struct CustomAttributeNamedArgument
{
	// Fields
	private CustomAttributeTypedArgument typedArgument;
	private MemberInfo memberInfo;

	// Methods
	public void .ctor(MemberInfo memberInfo, object value);
	public override string ToString();
	public override bool Equals(object obj);
	public override int GetHashCode();

}
//NameSpace:System.Reflection
public struct CustomAttributeTypedArgument
{
	// Fields
	private Type argumentType;
	private object value;

	// Methods
	public void .ctor(Type argumentType, object value);
	public override string ToString();
	public override bool Equals(object obj);
	public override int GetHashCode();

}
//NameSpace:System.Reflection
public abstract class EventInfo : MemberInfo, _EventInfo
{
	// Fields
	private EventInfo.AddEventAdapter cached_add_event;

	// Properties
	public virtual Type EventHandlerType { get; }
	public override MemberTypes MemberType { get; }

	// Methods
	public virtual Type get_EventHandlerType();
	public override MemberTypes get_MemberType();
	protected void .ctor();
	public abstract MethodInfo GetAddMethod(bool nonPublic);
	public abstract MethodInfo GetRaiseMethod(bool nonPublic);
	public abstract MethodInfo GetRemoveMethod(bool nonPublic);
	public override bool Equals(object obj);
	public override int GetHashCode();
	public static bool op_Equality(EventInfo left, EventInfo right);
	public static bool op_Inequality(EventInfo left, EventInfo right);
	private static EventInfo internal_from_handle_type(IntPtr event_handle, IntPtr type_handle);
	internal static EventInfo GetEventFromHandle(RuntimeEventHandle handle, RuntimeTypeHandle reflectedType);

}
//NameSpace:
private sealed class EventInfo.AddEventAdapter : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(object _this, Delegate dele);
	public virtual IAsyncResult BeginInvoke(object _this, Delegate dele, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System.Reflection
public class ExceptionHandlingClause
{
	// Fields
	internal Type catch_type;
	internal int filter_offset;
	internal ExceptionHandlingClauseOptions flags;
	internal int try_offset;
	internal int try_length;
	internal int handler_offset;
	internal int handler_length;

	// Methods
	public override string ToString();

}
//NameSpace:System.Reflection
public abstract class FieldInfo : MemberInfo, _FieldInfo
{
	// Properties
	public abstract FieldAttributes Attributes { get; }
	public abstract RuntimeFieldHandle FieldHandle { get; }
	public abstract Type FieldType { get; }
	public override MemberTypes MemberType { get; }
	public bool IsLiteral { get; }
	public bool IsStatic { get; }
	public bool IsInitOnly { get; }
	public bool IsNotSerialized { get; }

	// Methods
	public abstract FieldAttributes get_Attributes();
	public abstract RuntimeFieldHandle get_FieldHandle();
	protected void .ctor();
	public abstract Type get_FieldType();
	public abstract object GetValue(object obj);
	public override MemberTypes get_MemberType();
	public bool get_IsLiteral();
	public bool get_IsStatic();
	public bool get_IsInitOnly();
	public bool get_IsNotSerialized();
	public abstract void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
	public void SetValue(object obj, object value);
	private static FieldInfo internal_from_handle_type(IntPtr field_handle, IntPtr type_handle);
	public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle);
	public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle, RuntimeTypeHandle declaringType);
	internal virtual int GetFieldOffset();
	public virtual void SetValueDirect(System.TypedReference obj, object value);
	private MarshalAsAttribute get_marshal_info();
	internal object[] GetPseudoCustomAttributes();
	public virtual object GetRawConstantValue();
	public override bool Equals(object obj);
	public override int GetHashCode();
	public static bool op_Equality(FieldInfo left, FieldInfo right);
	public static bool op_Inequality(FieldInfo left, FieldInfo right);

}
//NameSpace:System.Reflection
public class LocalVariableInfo
{
	// Fields
	internal Type type;
	internal bool is_pinned;
	internal ushort position;

	// Methods
	public override string ToString();

}
//NameSpace:System.Reflection
public class MethodBody
{
	// Fields
	private ExceptionHandlingClause[] clauses;
	private LocalVariableInfo[] locals;
	private byte[] il;
	private bool init_locals;
	private int sig_token;
	private int max_stack;

}
//NameSpace:System.Reflection
public abstract class Module : ISerializable, ICustomAttributeProvider, _Module
{
	// Fields
	public static readonly TypeFilter FilterTypeName;
	public static readonly TypeFilter FilterTypeNameIgnoreCase;
	internal IntPtr _impl;
	internal Assembly assembly;
	internal string fqname;
	internal string name;
	internal string scopename;
	internal bool is_resource;
	internal int token;
	private const BindingFlags defaultBindingFlags;

	// Properties
	public virtual Assembly Assembly { get; }
	public virtual string ScopeName { get; }
	public virtual Guid ModuleVersionId { get; }

	// Methods
	protected void .ctor();
	public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
	public override string ToString();
	internal virtual Guid GetModuleVersionId();
	private static bool filter_by_type_name(Type m, object filterCriteria);
	private static bool filter_by_type_name_ignore_case(Type m, object filterCriteria);
	private string GetGuidInternal();
	public override bool Equals(object o);
	public override int GetHashCode();
	public static bool op_Equality(Module left, Module right);
	public virtual Assembly get_Assembly();
	public virtual string get_ScopeName();
	public virtual Guid get_ModuleVersionId();
	private static Exception CreateNIE();
	public virtual bool IsResource();
	public virtual object[] GetCustomAttributes(Type attributeType, bool inherit);
	public virtual bool IsDefined(Type attributeType, bool inherit);
	private static void .cctor();

}
//NameSpace:System.Reflection
internal abstract class RuntimeAssembly : Assembly
{
	// Methods
	public override void GetObjectData(SerializationInfo info, StreamingContext context);
	internal static RuntimeAssembly LoadWithPartialNameInternal(string partialName, Evidence securityEvidence, StackCrawlMark stackMark);
	internal static RuntimeAssembly LoadWithPartialNameInternal(AssemblyName an, Evidence securityEvidence, StackCrawlMark stackMark);
	public override AssemblyName GetName(bool copiedName);
	protected void .ctor();

}
//NameSpace:System.Reflection
internal class MonoAssembly : RuntimeAssembly
{
	// Methods
	public override Type GetType(string name, bool throwOnError, bool ignoreCase);
	public override Module GetModule(string name);
	public override Module[] GetModules(bool getResourceModules);
	public void .ctor();

}
//NameSpace:System.Reflection
internal struct MonoEventInfo
{
	// Fields
	public Type declaring_type;
	public Type reflected_type;
	public string name;
	public MethodInfo add_method;
	public MethodInfo remove_method;
	public MethodInfo raise_method;
	public EventAttributes attrs;
	public MethodInfo[] other_methods;

	// Methods
	private static void get_event_info(MonoEvent ev, out MonoEventInfo info);
	internal static MonoEventInfo GetEventInfo(MonoEvent ev);

}
//NameSpace:System.Reflection
internal abstract class RuntimeEventInfo : EventInfo, ISerializable
{
	// Properties
	internal BindingFlags BindingFlags { get; }
	public override Module Module { get; }
	private RuntimeType ReflectedTypeInternal { get; }

	// Methods
	internal BindingFlags get_BindingFlags();
	public override Module get_Module();
	internal RuntimeType GetDeclaringTypeInternal();
	private RuntimeType get_ReflectedTypeInternal();
	internal RuntimeModule GetRuntimeModule();
	public void GetObjectData(SerializationInfo info, StreamingContext context);
	protected void .ctor();

}
//NameSpace:System.Reflection
internal sealed class MonoEvent : RuntimeEventInfo
{
	// Fields
	private IntPtr klass;
	private IntPtr handle;

	// Properties
	public override Type DeclaringType { get; }
	public override Type ReflectedType { get; }
	public override string Name { get; }

	// Methods
	public override MethodInfo GetAddMethod(bool nonPublic);
	public override MethodInfo GetRaiseMethod(bool nonPublic);
	public override MethodInfo GetRemoveMethod(bool nonPublic);
	public override Type get_DeclaringType();
	public override Type get_ReflectedType();
	public override string get_Name();
	public override string ToString();
	public override bool IsDefined(Type attributeType, bool inherit);
	public override object[] GetCustomAttributes(bool inherit);
	public override object[] GetCustomAttributes(Type attributeType, bool inherit);
	public override IList`1<CustomAttributeData> GetCustomAttributesData();
	public void .ctor();

}
//NameSpace:System.Reflection
internal abstract class RuntimeFieldInfo : FieldInfo, ISerializable
{
	// Properties
	internal BindingFlags BindingFlags { get; }
	public override Module Module { get; }
	private RuntimeType ReflectedTypeInternal { get; }

	// Methods
	internal BindingFlags get_BindingFlags();
	public override Module get_Module();
	internal RuntimeType GetDeclaringTypeInternal();
	private RuntimeType get_ReflectedTypeInternal();
	internal RuntimeModule GetRuntimeModule();
	public void GetObjectData(SerializationInfo info, StreamingContext context);
	protected void .ctor();

}
//NameSpace:System.Reflection
internal abstract class RtFieldInfo : RuntimeFieldInfo
{
	// Methods
	internal object UnsafeGetValue(object obj);
	internal void CheckConsistency(object target);
	internal void UnsafeSetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
	public override void SetValueDirect(System.TypedReference obj, object value);
	protected void .ctor();

}
//NameSpace:System.Reflection
internal class MonoField : RtFieldInfo
{
	// Fields
	internal IntPtr klass;
	internal RuntimeFieldHandle fhandle;
	private string name;
	private Type type;
	private FieldAttributes attrs;

	// Properties
	public override FieldAttributes Attributes { get; }
	public override RuntimeFieldHandle FieldHandle { get; }
	public override Type FieldType { get; }
	public override Type ReflectedType { get; }
	public override Type DeclaringType { get; }
	public override string Name { get; }

	// Methods
	public override FieldAttributes get_Attributes();
	public override RuntimeFieldHandle get_FieldHandle();
	private Type ResolveType();
	public override Type get_FieldType();
	private Type GetParentType(bool declaring);
	public override Type get_ReflectedType();
	public override Type get_DeclaringType();
	public override string get_Name();
	public override bool IsDefined(Type attributeType, bool inherit);
	public override object[] GetCustomAttributes(bool inherit);
	public override object[] GetCustomAttributes(Type attributeType, bool inherit);
	internal override int GetFieldOffset();
	private object GetValueInternal(object obj);
	public override object GetValue(object obj);
	public override string ToString();
	private static void SetValueInternal(FieldInfo fi, object obj, object value);
	public override void SetValue(object obj, object val, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
	public override object GetRawConstantValue();
	public override IList`1<CustomAttributeData> GetCustomAttributesData();
	private void CheckGeneric();
	public void .ctor();

}
//NameSpace:System.Reflection
internal struct MonoMethodInfo
{
	// Fields
	private Type parent;
	private Type ret;
	internal MethodAttributes attrs;
	internal MethodImplAttributes iattrs;
	private CallingConventions callconv;

	// Methods
	private static void get_method_info(IntPtr handle, out MonoMethodInfo info);
	private static int get_method_attributes(IntPtr handle);
	internal static MonoMethodInfo GetMethodInfo(IntPtr handle);
	internal static Type GetDeclaringType(IntPtr handle);
	internal static Type GetReturnType(IntPtr handle);
	internal static MethodAttributes GetAttributes(IntPtr handle);
	internal static CallingConventions GetCallingConvention(IntPtr handle);
	internal static MethodImplAttributes GetMethodImplementationFlags(IntPtr handle);
	private static ParameterInfo[] get_parameter_info(IntPtr handle, MemberInfo member);
	internal static ParameterInfo[] GetParametersInfo(IntPtr handle, MemberInfo member);

}
//NameSpace:System.Reflection
internal abstract class RuntimeMethodInfo : MethodInfo, ISerializable
{
	// Properties
	internal BindingFlags BindingFlags { get; }
	public override Module Module { get; }
	private RuntimeType ReflectedTypeInternal { get; }

	// Methods
	internal BindingFlags get_BindingFlags();
	public override Module get_Module();
	private RuntimeType get_ReflectedTypeInternal();
	internal override string FormatNameAndSig(bool serialization);
	public override string ToString();
	internal RuntimeModule GetRuntimeModule();
	public void GetObjectData(SerializationInfo info, StreamingContext context);
	internal string SerializationToString();
	protected void .ctor();

}
//NameSpace:System.Reflection
internal class MonoMethod : RuntimeMethodInfo
{
	// Fields
	internal IntPtr mhandle;
	private string name;
	private Type reftype;

	// Properties
	public override Type ReturnType { get; }
	public override RuntimeMethodHandle MethodHandle { get; }
	public override MethodAttributes Attributes { get; }
	public override CallingConventions CallingConvention { get; }
	public override Type ReflectedType { get; }
	public override Type DeclaringType { get; }
	public override string Name { get; }
	public override bool IsGenericMethodDefinition { get; }
	public override bool IsGenericMethod { get; }
	public override bool ContainsGenericParameters { get; }
	public override bool IsSecurityCritical { get; }

	// Methods
	internal void .ctor();
	internal static string get_name(MethodBase method);
	internal static MonoMethod get_base_method(MonoMethod method, bool definition);
	internal override MethodInfo GetBaseMethod();
	public override Type get_ReturnType();
	public override MethodImplAttributes GetMethodImplementationFlags();
	public override ParameterInfo[] GetParameters();
	internal override ParameterInfo[] GetParametersInternal();
	internal override int GetParametersCount();
	internal object InternalInvoke(object obj, object[] parameters, out Exception exc);
	public override object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
	internal static void ConvertValues(Binder binder, object[] args, ParameterInfo[] pinfo, CultureInfo culture, BindingFlags invokeAttr);
	public override RuntimeMethodHandle get_MethodHandle();
	public override MethodAttributes get_Attributes();
	public override CallingConventions get_CallingConvention();
	public override Type get_ReflectedType();
	public override Type get_DeclaringType();
	public override string get_Name();
	public override bool IsDefined(Type attributeType, bool inherit);
	public override object[] GetCustomAttributes(bool inherit);
	public override object[] GetCustomAttributes(Type attributeType, bool inherit);
	internal void GetPInvoke(out PInvokeAttributes flags, out string entryPoint, out string dllName);
	internal object[] GetPseudoCustomAttributes();
	public override MethodInfo MakeGenericMethod(Type[] methodInstantiation);
	private MethodInfo MakeGenericMethod_impl(Type[] types);
	public override Type[] GetGenericArguments();
	private MethodInfo GetGenericMethodDefinition_impl();
	public override MethodInfo GetGenericMethodDefinition();
	public override bool get_IsGenericMethodDefinition();
	public override bool get_IsGenericMethod();
	public override bool get_ContainsGenericParameters();
	public override IList`1<CustomAttributeData> GetCustomAttributesData();
	private static int get_core_clr_security_level();
	public override bool get_IsSecurityCritical();

}
//NameSpace:System.Reflection
internal abstract class RuntimeConstructorInfo : ConstructorInfo, ISerializable
{
	// Properties
	public override Module Module { get; }
	internal BindingFlags BindingFlags { get; }
	private RuntimeType ReflectedTypeInternal { get; }

	// Methods
	public override Module get_Module();
	internal RuntimeModule GetRuntimeModule();
	internal BindingFlags get_BindingFlags();
	private RuntimeType get_ReflectedTypeInternal();
	public void GetObjectData(SerializationInfo info, StreamingContext context);
	internal string SerializationToString();
	internal void SerializationInvoke(object target, SerializationInfo info, StreamingContext context);
	protected void .ctor();

}
//NameSpace:System.Reflection
internal class MonoCMethod : RuntimeConstructorInfo
{
	// Fields
	internal IntPtr mhandle;
	private string name;
	private Type reftype;

	// Properties
	public override RuntimeMethodHandle MethodHandle { get; }
	public override MethodAttributes Attributes { get; }
	public override CallingConventions CallingConvention { get; }
	public override bool ContainsGenericParameters { get; }
	public override Type ReflectedType { get; }
	public override Type DeclaringType { get; }
	public override string Name { get; }
	public override bool IsSecurityCritical { get; }

	// Methods
	public override MethodImplAttributes GetMethodImplementationFlags();
	public override ParameterInfo[] GetParameters();
	internal override ParameterInfo[] GetParametersInternal();
	internal override int GetParametersCount();
	internal object InternalInvoke(object obj, object[] parameters, out Exception exc);
	public override object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
	private object DoInvoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
	public object InternalInvoke(object obj, object[] parameters);
	public override object Invoke(BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
	public override RuntimeMethodHandle get_MethodHandle();
	public override MethodAttributes get_Attributes();
	public override CallingConventions get_CallingConvention();
	public override bool get_ContainsGenericParameters();
	public override Type get_ReflectedType();
	public override Type get_DeclaringType();
	public override string get_Name();
	public override bool IsDefined(Type attributeType, bool inherit);
	public override object[] GetCustomAttributes(bool inherit);
	public override object[] GetCustomAttributes(Type attributeType, bool inherit);
	public override string ToString();
	public override IList`1<CustomAttributeData> GetCustomAttributesData();
	private static int get_core_clr_security_level();
	public override bool get_IsSecurityCritical();
	public void .ctor();

}
//NameSpace:System.Reflection
internal abstract class RuntimeModule : Module
{
	// Methods
	protected void .ctor();

}
//NameSpace:System.Reflection
internal class MonoModule : RuntimeModule
{
	// Properties
	public override Assembly Assembly { get; }
	public override string ScopeName { get; }
	public override Guid ModuleVersionId { get; }

	// Methods
	public override Assembly get_Assembly();
	public override string get_ScopeName();
	public override Guid get_ModuleVersionId();
	public override bool IsResource();
	public override object[] GetCustomAttributes(Type attributeType, bool inherit);
	public override bool IsDefined(Type attributeType, bool inherit);
	public override void GetObjectData(SerializationInfo info, StreamingContext context);
	internal RuntimeAssembly GetRuntimeAssembly();
	public void .ctor();

}
//NameSpace:System.Reflection
internal abstract class RuntimeParameterInfo : ParameterInfo
{
	// Methods
	protected void .ctor();

}
//NameSpace:System.Reflection
internal class MonoParameterInfo : RuntimeParameterInfo
{
	// Properties
	public override object DefaultValue { get; }

	// Methods
	internal void .ctor(ParameterInfo pinfo, MemberInfo member);
	public override object get_DefaultValue();
	public override object[] GetCustomAttributes(Type attributeType, bool inherit);
	public override bool IsDefined(Type attributeType, bool inherit);

}
//NameSpace:System.Reflection
internal struct MonoPropertyInfo
{
	// Fields
	public Type parent;
	public Type declaring_type;
	public string name;
	public MethodInfo get_method;
	public MethodInfo set_method;
	public PropertyAttributes attrs;

	// Methods
	internal static void get_property_info(MonoProperty prop, MonoPropertyInfo info, PInfo req_info);
	internal static Type[] GetTypeModifiers(MonoProperty prop, bool optional);
	internal static object get_default_value(MonoProperty prop);

}
//NameSpace:System.Reflection
internal enum PInfo
{
	// Fields
	public int value__;
	public const PInfo Attributes;
	public const PInfo GetMethod;
	public const PInfo SetMethod;
	public const PInfo ReflectedType;
	public const PInfo DeclaringType;
	public const PInfo Name;

}
//NameSpace:System.Reflection
internal abstract class RuntimePropertyInfo : PropertyInfo, ISerializable
{
	// Properties
	internal BindingFlags BindingFlags { get; }
	public override Module Module { get; }
	private RuntimeType ReflectedTypeInternal { get; }

	// Methods
	internal BindingFlags get_BindingFlags();
	public override Module get_Module();
	internal RuntimeType GetDeclaringTypeInternal();
	private RuntimeType get_ReflectedTypeInternal();
	internal RuntimeModule GetRuntimeModule();
	public override string ToString();
	private string FormatNameAndSig(bool serialization);
	public void GetObjectData(SerializationInfo info, StreamingContext context);
	internal string SerializationToString();
	protected void .ctor();

}
//NameSpace:System.Reflection
internal class MonoProperty : RuntimePropertyInfo
{
	// Fields
	internal IntPtr klass;
	internal IntPtr prop;
	private MonoPropertyInfo info;
	private PInfo cached;
	private MonoProperty.GetterAdapter cached_getter;

	// Properties
	public override PropertyAttributes Attributes { get; }
	public override bool CanRead { get; }
	public override bool CanWrite { get; }
	public override Type PropertyType { get; }
	public override Type ReflectedType { get; }
	public override Type DeclaringType { get; }
	public override string Name { get; }

	// Methods
	private void CachePropertyInfo(PInfo flags);
	public override PropertyAttributes get_Attributes();
	public override bool get_CanRead();
	public override bool get_CanWrite();
	public override Type get_PropertyType();
	public override Type get_ReflectedType();
	public override Type get_DeclaringType();
	public override string get_Name();
	public override MethodInfo[] GetAccessors(bool nonPublic);
	public override MethodInfo GetGetMethod(bool nonPublic);
	public override ParameterInfo[] GetIndexParameters();
	public override MethodInfo GetSetMethod(bool nonPublic);
	public override object GetConstantValue();
	public override object GetRawConstantValue();
	public override bool IsDefined(Type attributeType, bool inherit);
	public override object[] GetCustomAttributes(bool inherit);
	public override object[] GetCustomAttributes(Type attributeType, bool inherit);
	private static object GetterAdapterFrame(Getter`2<TT> getter, object obj);
	private static object StaticGetterAdapterFrame(StaticGetter`1<T> getter, object obj);
	private static MonoProperty.GetterAdapter CreateGetterDelegate(MethodInfo method);
	public override object GetValue(object obj, object[] index);
	public override object GetValue(object obj, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture);
	public override void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture);
	public override Type[] GetOptionalCustomModifiers();
	public override Type[] GetRequiredCustomModifiers();
	public override IList`1<CustomAttributeData> GetCustomAttributesData();
	public void .ctor();

}
//NameSpace:
private sealed class MonoProperty.GetterAdapter : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual object Invoke(object _this);
	public virtual IAsyncResult BeginInvoke(object _this, AsyncCallback callback, object object);
	public virtual object EndInvoke(IAsyncResult result);

}
//NameSpace:
private sealed class MonoProperty.Getter`2 : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual T Invoke(T _this);
	public virtual IAsyncResult BeginInvoke(T _this, AsyncCallback callback, object object);
	public virtual T EndInvoke(IAsyncResult result);

}
//NameSpace:
private sealed class MonoProperty.StaticGetter`1 : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual T Invoke();
	public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
	public virtual T EndInvoke(IAsyncResult result);

}
//NameSpace:System.Reflection
public class ParameterInfo : ICustomAttributeProvider, IObjectReference, _ParameterInfo
{
	// Fields
	protected Type ClassImpl;
	protected object DefaultValueImpl;
	protected MemberInfo MemberImpl;
	protected string NameImpl;
	protected int PositionImpl;
	protected ParameterAttributes AttrsImpl;
	internal MarshalAsAttribute marshalAs;

	// Properties
	public virtual Type ParameterType { get; }
	public virtual ParameterAttributes Attributes { get; }
	public bool IsIn { get; }
	public bool IsOptional { get; }
	public bool IsOut { get; }
	public bool IsRetval { get; }
	public virtual string Name { get; }
	public virtual int Position { get; }
	public virtual object DefaultValue { get; }

	// Methods
	protected void .ctor();
	public override string ToString();
	internal static void FormatParameters(StringBuilder sb, ParameterInfo[] p, CallingConventions callingConvention, bool serialization);
	public virtual Type get_ParameterType();
	public virtual ParameterAttributes get_Attributes();
	public bool get_IsIn();
	public bool get_IsOptional();
	public bool get_IsOut();
	public bool get_IsRetval();
	public virtual string get_Name();
	public virtual int get_Position();
	internal object[] GetPseudoCustomAttributes();
	internal object GetDefaultValueImpl();
	public virtual object get_DefaultValue();
	public virtual object[] GetCustomAttributes(Type attributeType, bool inherit);
	public object GetRealObject(StreamingContext context);
	public virtual bool IsDefined(Type attributeType, bool inherit);
	internal static ParameterInfo New(ParameterInfo pinfo, MemberInfo member);

}
//NameSpace:System.Reflection
public abstract class PropertyInfo : MemberInfo, _PropertyInfo
{
	// Properties
	public abstract PropertyAttributes Attributes { get; }
	public abstract bool CanRead { get; }
	public abstract bool CanWrite { get; }
	public override MemberTypes MemberType { get; }
	public abstract Type PropertyType { get; }

	// Methods
	public abstract PropertyAttributes get_Attributes();
	public abstract bool get_CanRead();
	public abstract bool get_CanWrite();
	public override MemberTypes get_MemberType();
	public abstract Type get_PropertyType();
	protected void .ctor();
	public abstract MethodInfo[] GetAccessors(bool nonPublic);
	public abstract MethodInfo GetGetMethod(bool nonPublic);
	public abstract ParameterInfo[] GetIndexParameters();
	public abstract MethodInfo GetSetMethod(bool nonPublic);
	public virtual object GetValue(object obj, object[] index);
	public abstract object GetValue(object obj, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture);
	public abstract void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture);
	public virtual Type[] GetOptionalCustomModifiers();
	public virtual Type[] GetRequiredCustomModifiers();
	private static NotImplementedException CreateNIE();
	public virtual object GetConstantValue();
	public virtual object GetRawConstantValue();
	public override bool Equals(object obj);
	public override int GetHashCode();
	public static bool op_Equality(PropertyInfo left, PropertyInfo right);
	public static bool op_Inequality(PropertyInfo left, PropertyInfo right);
	private static PropertyInfo internal_from_handle_type(IntPtr event_handle, IntPtr type_handle);
	internal static PropertyInfo GetPropertyFromHandle(RuntimePropertyHandle handle, RuntimeTypeHandle reflectedType);

}
//NameSpace:System.Reflection
public class StrongNameKeyPair : ISerializable, IDeserializationCallback
{
	// Fields
	private byte[] _publicKey;
	private string _keyPairContainer;
	private bool _keyPairExported;
	private byte[] _keyPairArray;

	// Methods
	protected void .ctor(SerializationInfo info, StreamingContext context);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);

}
//NameSpace:System.Reflection.Emit
public class AssemblyBuilder : Assembly, _AssemblyBuilder
{
}
//NameSpace:System.Reflection.Emit
public abstract class ConstructorBuilder : ConstructorInfo, _ConstructorBuilder
{
	// Properties
	public override MethodAttributes Attributes { get; }
	public override Type DeclaringType { get; }
	public override string Name { get; }
	public override RuntimeMethodHandle MethodHandle { get; }
	public override Type ReflectedType { get; }

	// Methods
	public override MethodAttributes get_Attributes();
	public override Type get_DeclaringType();
	public override string get_Name();
	public override ParameterInfo[] GetParameters();
	public override RuntimeMethodHandle get_MethodHandle();
	public override Type get_ReflectedType();
	public override object[] GetCustomAttributes(bool inherit);
	public override object[] GetCustomAttributes(Type attributeType, bool inherit);
	public override MethodImplAttributes GetMethodImplementationFlags();
	public override object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
	public override object Invoke(BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
	public override bool IsDefined(Type attributeType, bool inherit);

}
//NameSpace:System.Reflection.Emit
public class CustomAttributeBuilder : _CustomAttributeBuilder
{
}
//NameSpace:System.Reflection.Emit
public abstract class EnumBuilder : TypeInfo, _EnumBuilder
{
	// Properties
	public override Assembly Assembly { get; }
	public override string AssemblyQualifiedName { get; }
	public override Type BaseType { get; }
	public override string FullName { get; }
	public override Module Module { get; }
	public override string Name { get; }
	public override string Namespace { get; }
	public override Type UnderlyingSystemType { get; }

	// Methods
	public override Assembly get_Assembly();
	public override string get_AssemblyQualifiedName();
	public override Type get_BaseType();
	public override string get_FullName();
	public override Module get_Module();
	public override string get_Name();
	public override string get_Namespace();
	public override Type GetElementType();
	public override Type get_UnderlyingSystemType();
	protected override TypeAttributes GetAttributeFlagsImpl();
	protected override ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
	public override ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
	public override object[] GetCustomAttributes(bool inherit);
	public override object[] GetCustomAttributes(Type attributeType, bool inherit);
	public override EventInfo GetEvent(string name, BindingFlags bindingAttr);
	public override FieldInfo GetField(string name, BindingFlags bindingAttr);
	public override FieldInfo[] GetFields(BindingFlags bindingAttr);
	public override Type[] GetInterfaces();
	protected override MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
	public override MethodInfo[] GetMethods(BindingFlags bindingAttr);
	public override Type GetNestedType(string name, BindingFlags bindingAttr);
	protected override PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
	protected override bool HasElementTypeImpl();
	public override object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);
	protected override bool IsArrayImpl();
	protected override bool IsByRefImpl();
	protected override bool IsCOMObjectImpl();
	public override bool IsDefined(Type attributeType, bool inherit);
	protected override bool IsPointerImpl();
	protected override bool IsPrimitiveImpl();

}
//NameSpace:System.Reflection.Emit
public class EventBuilder : _EventBuilder
{
}
//NameSpace:System.Reflection.Emit
public abstract class FieldBuilder : FieldInfo, _FieldBuilder
{
	// Properties
	public override FieldAttributes Attributes { get; }
	public override Type DeclaringType { get; }
	public override Type FieldType { get; }
	public override string Name { get; }
	public override RuntimeFieldHandle FieldHandle { get; }
	public override Type ReflectedType { get; }

	// Methods
	public override FieldAttributes get_Attributes();
	public override Type get_DeclaringType();
	public override Type get_FieldType();
	public override string get_Name();
	public override object GetValue(object obj);
	public override RuntimeFieldHandle get_FieldHandle();
	public override Type get_ReflectedType();
	public override object[] GetCustomAttributes(bool inherit);
	public override object[] GetCustomAttributes(Type attributeType, bool inherit);
	public override bool IsDefined(Type attributeType, bool inherit);
	public override void SetValue(object obj, object val, BindingFlags invokeAttr, Binder binder, CultureInfo culture);

}
//NameSpace:System.Reflection.Emit
public abstract class GenericTypeParameterBuilder : TypeInfo
{
	// Properties
	public override Assembly Assembly { get; }
	public override string AssemblyQualifiedName { get; }
	public override Type BaseType { get; }
	public override string FullName { get; }
	public override Module Module { get; }
	public override string Name { get; }
	public override string Namespace { get; }
	public override Type UnderlyingSystemType { get; }

	// Methods
	public override Assembly get_Assembly();
	public override string get_AssemblyQualifiedName();
	public override Type get_BaseType();
	public override string get_FullName();
	public override Module get_Module();
	public override string get_Name();
	public override string get_Namespace();
	public override Type GetElementType();
	public override Type get_UnderlyingSystemType();
	protected override TypeAttributes GetAttributeFlagsImpl();
	protected override ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
	public override ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
	public override object[] GetCustomAttributes(bool inherit);
	public override object[] GetCustomAttributes(Type attributeType, bool inherit);
	public override EventInfo GetEvent(string name, BindingFlags bindingAttr);
	public override FieldInfo GetField(string name, BindingFlags bindingAttr);
	public override FieldInfo[] GetFields(BindingFlags bindingAttr);
	public override Type[] GetInterfaces();
	protected override MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
	public override MethodInfo[] GetMethods(BindingFlags bindingAttr);
	public override Type GetNestedType(string name, BindingFlags bindingAttr);
	protected override PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
	protected override bool HasElementTypeImpl();
	public override object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);
	protected override bool IsArrayImpl();
	protected override bool IsByRefImpl();
	protected override bool IsCOMObjectImpl();
	public override bool IsDefined(Type attributeType, bool inherit);
	protected override bool IsPointerImpl();
	protected override bool IsPrimitiveImpl();

}
//NameSpace:System.Reflection.Emit
public class ILGenerator : _ILGenerator
{
}
//NameSpace:System.Reflection.Emit
public sealed class LocalBuilder : LocalVariableInfo, _LocalBuilder
{
	// Fields
	private string name;
	internal ILGenerator ilgen;
	private int startOffset;
	private int endOffset;

}
//NameSpace:System.Reflection.Emit
public abstract class MethodBuilder : MethodInfo, _MethodBuilder
{
	// Properties
	public override MethodAttributes Attributes { get; }
	public override Type DeclaringType { get; }
	public override string Name { get; }
	public override RuntimeMethodHandle MethodHandle { get; }
	public override Type ReflectedType { get; }

	// Methods
	public override MethodAttributes get_Attributes();
	public override Type get_DeclaringType();
	public override string get_Name();
	public override ParameterInfo[] GetParameters();
	public override RuntimeMethodHandle get_MethodHandle();
	public override Type get_ReflectedType();
	public override object[] GetCustomAttributes(bool inherit);
	public override object[] GetCustomAttributes(Type attributeType, bool inherit);
	public override MethodImplAttributes GetMethodImplementationFlags();
	public override object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
	public override bool IsDefined(Type attributeType, bool inherit);

}
//NameSpace:System.Reflection.Emit
public abstract class ModuleBuilder : Module, _ModuleBuilder
{
}
//NameSpace:System.Reflection.Emit
public class ParameterBuilder : _ParameterBuilder
{
}
//NameSpace:System.Reflection.Emit
public abstract class PropertyBuilder : PropertyInfo, _PropertyBuilder
{
	// Properties
	public override PropertyAttributes Attributes { get; }
	public override bool CanRead { get; }
	public override bool CanWrite { get; }
	public override Type DeclaringType { get; }
	public override string Name { get; }
	public override Type PropertyType { get; }
	public override Type ReflectedType { get; }

	// Methods
	public override PropertyAttributes get_Attributes();
	public override bool get_CanRead();
	public override bool get_CanWrite();
	public override Type get_DeclaringType();
	public override string get_Name();
	public override Type get_PropertyType();
	public override ParameterInfo[] GetIndexParameters();
	public override Type get_ReflectedType();
	public override MethodInfo[] GetAccessors(bool nonPublic);
	public override object[] GetCustomAttributes(bool inherit);
	public override object[] GetCustomAttributes(Type attributeType, bool inherit);
	public override MethodInfo GetGetMethod(bool nonPublic);
	public override MethodInfo GetSetMethod(bool nonPublic);
	public override object GetValue(object obj, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture);
	public override bool IsDefined(Type attributeType, bool inherit);
	public override void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, object[] index, CultureInfo culture);

}
//NameSpace:System.Reflection.Emit
public class SignatureHelper : _SignatureHelper
{
}
//NameSpace:System.Reflection.Emit
public abstract class TypeBuilder : TypeInfo, _TypeBuilder
{
	// Fields
	public const int UnspecifiedTypeSize;

	// Properties
	public override Assembly Assembly { get; }
	public override string AssemblyQualifiedName { get; }
	public override Type BaseType { get; }
	public override string FullName { get; }
	public override Module Module { get; }
	public override string Name { get; }
	public override string Namespace { get; }
	public override Type UnderlyingSystemType { get; }

	// Methods
	public override Assembly get_Assembly();
	public override string get_AssemblyQualifiedName();
	public override Type get_BaseType();
	public override string get_FullName();
	public override Module get_Module();
	public override string get_Name();
	public override string get_Namespace();
	public override Type GetElementType();
	public override Type get_UnderlyingSystemType();
	protected override TypeAttributes GetAttributeFlagsImpl();
	protected override ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
	public override ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
	public override object[] GetCustomAttributes(bool inherit);
	public override object[] GetCustomAttributes(Type attributeType, bool inherit);
	public override EventInfo GetEvent(string name, BindingFlags bindingAttr);
	public override FieldInfo GetField(string name, BindingFlags bindingAttr);
	public override FieldInfo[] GetFields(BindingFlags bindingAttr);
	public override Type[] GetInterfaces();
	protected override MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
	public override MethodInfo[] GetMethods(BindingFlags bindingAttr);
	public override Type GetNestedType(string name, BindingFlags bindingAttr);
	protected override PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
	protected override bool HasElementTypeImpl();
	public override object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);
	protected override bool IsArrayImpl();
	protected override bool IsByRefImpl();
	protected override bool IsCOMObjectImpl();
	public override bool IsDefined(Type attributeType, bool inherit);
	protected override bool IsPointerImpl();
	protected override bool IsPrimitiveImpl();

}
//NameSpace:System.Reflection.Emit
internal abstract class TypeBuilderInstantiation : TypeInfo
{
	// Methods
	internal static Type MakeGenericType(Type type, Type[] typeArguments);

}
//NameSpace:System.IO
internal static class __Error
{
	// Methods
	internal static void EndOfFile();
	internal static void FileNotOpen();
	internal static void StreamIsClosed();
	internal static void MemoryStreamNotExpandable();
	internal static void ReaderClosed();
	internal static void ReadNotSupported();
	internal static void WrongAsyncResult();
	internal static void EndReadCalledTwice();
	internal static void EndWriteCalledTwice();
	internal static string GetDisplayablePath(string path, bool isInvalidPath);
	internal static void WinIOError(int errorCode, string maybeFullPath);
	internal static void WriteNotSupported();
	internal static void WriterClosed();

}
//NameSpace:System.IO
public class BinaryReader : IDisposable
{
	// Fields
	private Stream m_stream;
	private byte[] m_buffer;
	private Decoder m_decoder;
	private byte[] m_charBytes;
	private char[] m_singleChar;
	private char[] m_charBuffer;
	private int m_maxCharsSize;
	private bool m_2BytesPerChar;
	private bool m_isMemoryStream;
	private bool m_leaveOpen;

	// Properties
	public virtual Stream BaseStream { get; }

	// Methods
	public void .ctor(Stream input, Encoding encoding);
	public void .ctor(Stream input, Encoding encoding, bool leaveOpen);
	public virtual Stream get_BaseStream();
	public virtual void Close();
	protected virtual void Dispose(bool disposing);
	public void Dispose();
	public virtual int Read();
	public virtual bool ReadBoolean();
	public virtual byte ReadByte();
	public virtual sbyte ReadSByte();
	public virtual char ReadChar();
	public virtual short ReadInt16();
	public virtual ushort ReadUInt16();
	public virtual int ReadInt32();
	public virtual uint ReadUInt32();
	public virtual long ReadInt64();
	public virtual ulong ReadUInt64();
	public virtual float ReadSingle();
	public virtual double ReadDouble();
	public virtual Decimal ReadDecimal();
	public virtual string ReadString();
	private int InternalReadChars(char[] buffer, int index, int count);
	private int InternalReadOneChar();
	public virtual char[] ReadChars(int count);
	public virtual int Read(byte[] buffer, int index, int count);
	public virtual byte[] ReadBytes(int count);
	protected virtual void FillBuffer(int numBytes);
	protected internal int Read7BitEncodedInt();

}
//NameSpace:System.IO
public class BinaryWriter : IDisposable
{
	// Fields
	public static readonly BinaryWriter Null;
	protected Stream OutStream;
	private byte[] _buffer;
	private Encoding _encoding;
	private Encoder _encoder;
	private bool _leaveOpen;
	private byte[] _largeByteBuffer;
	private int _maxChars;

	// Methods
	protected void .ctor();
	public void .ctor(Stream output, Encoding encoding);
	public void .ctor(Stream output, Encoding encoding, bool leaveOpen);
	protected virtual void Dispose(bool disposing);
	public void Dispose();
	public virtual void Flush();
	public virtual void Write(bool value);
	public virtual void Write(byte value);
	public virtual void Write(byte[] buffer);
	public virtual void Write(byte[] buffer, int index, int count);
	public virtual void Write(char ch);
	public virtual void Write(char[] chars);
	public virtual void Write(double value);
	public virtual void Write(short value);
	public virtual void Write(ushort value);
	public virtual void Write(int value);
	public virtual void Write(uint value);
	public virtual void Write(long value);
	public virtual void Write(ulong value);
	public virtual void Write(float value);
	public virtual void Write(string value);
	protected void Write7BitEncodedInt(int value);
	private static void .cctor();

}
//NameSpace:System.IO
public static class Directory
{
	// Methods
	public static string[] GetFiles(string path);
	private static string[] InternalGetFiles(string path, string searchPattern, SearchOption searchOption);
	public static string[] GetDirectories(string path);
	public static string[] GetDirectories(string path, string searchPattern);
	private static string[] InternalGetDirectories(string path, string searchPattern, SearchOption searchOption);
	internal static string[] InternalGetFileDirectoryNames(string path, string userPathOriginal, string searchPattern, bool includeFiles, bool includeDirs, SearchOption searchOption, bool checkHost);
	public static DirectoryInfo CreateDirectory(string path);
	private static DirectoryInfo CreateDirectoriesInternal(string path);
	public static void Delete(string path);
	private static void RecursiveDelete(string path);
	public static void Delete(string path, bool recursive);
	public static bool Exists(string path);
	public static string GetCurrentDirectory();
	internal static string InsecureGetCurrentDirectory();
	internal static string GetDemandDir(string fullPath, bool thisDirOnly);

}
//NameSpace:
internal sealed class Directory.SearchData
{
	// Fields
	public readonly string fullPath;
	public readonly string userPath;
	public readonly SearchOption searchOption;

	// Methods
	public void .ctor(string fullPath, string userPath, SearchOption searchOption);

}
//NameSpace:System.IO
public class DirectoryNotFoundException : IOException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.IO
public class DriveNotFoundException : IOException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.IO
public class EndOfStreamException : IOException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.IO
public class FileLoadException : IOException
{
	// Fields
	private string _fileName;
	private string _fusionLog;

	// Properties
	public override string Message { get; }
	public string FusionLog { get; }

	// Methods
	public void .ctor();
	public void .ctor(string message);
	public override string get_Message();
	private void SetMessageField();
	public override string ToString();
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public string get_FusionLog();
	public override void GetObjectData(SerializationInfo info, StreamingContext context);
	internal static string FormatFileLoadExceptionMessage(string fileName, int hResult);

}
//NameSpace:System.IO
public class FileNotFoundException : IOException
{
	// Fields
	private string _fileName;
	private string _fusionLog;

	// Properties
	public override string Message { get; }
	public string FusionLog { get; }

	// Methods
	public void .ctor();
	public void .ctor(string message);
	public void .ctor(string message, string fileName);
	public override string get_Message();
	private void SetMessageField();
	public override string ToString();
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public string get_FusionLog();
	public override void GetObjectData(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.IO
internal static class FileSystemEnumerableFactory
{
	// Methods
	internal static IEnumerable`1<string> CreateFileNameIterator(string path, string originalUserPath, string searchPattern, bool includeFiles, bool includeDirs, SearchOption searchOption, bool checkHost);

}
//NameSpace:System.IO
internal abstract class Iterator`1 : IEnumerable`1<T>, IEnumerable, IEnumerator`1<T>, IDisposable, IEnumerator
{
	// Fields
	private int threadId;
	internal int state;
	internal T current;

	// Properties
	public T Current { get; }
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	public void .ctor();
	public T get_Current();
	protected abstract Iterator`1<T> Clone();
	public void Dispose();
	protected virtual void Dispose(bool disposing);
	public IEnumerator`1<T> GetEnumerator();
	public abstract bool MoveNext();
	private object System.Collections.IEnumerator.get_Current();
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();

}
//NameSpace:System.IO
internal class FileSystemEnumerableIterator`1 : Iterator`1<T>
{
	// Fields
	private SearchResultHandler`1<T> _resultHandler;
	private List`1<Directory.SearchData> searchStack;
	private Directory.SearchData searchData;
	private string searchCriteria;
	private SafeFindHandle _hnd;
	private bool needsParentPathDiscoveryDemand;
	private bool empty;
	private string userPath;
	private SearchOption searchOption;
	private string fullPath;
	private string normalizedSearchPath;
	private bool _checkHost;

	// Methods
	internal void .ctor(string path, string originalUserPath, string searchPattern, SearchOption searchOption, SearchResultHandler`1<T> resultHandler, bool checkHost);
	private void CommonInit();
	private void .ctor(string fullPath, string normalizedSearchPath, string searchCriteria, string userPath, SearchOption searchOption, SearchResultHandler`1<T> resultHandler, bool checkHost);
	protected override Iterator`1<T> Clone();
	protected override void Dispose(bool disposing);
	public override bool MoveNext();
	private SearchResult CreateSearchResult(Directory.SearchData localSearchData, Win32Native.WIN32_FIND_DATA findData);
	private void HandleError(int hr, string path);
	private void AddSearchableDirsToStack(Directory.SearchData localSearchData);
	internal void DoDemand(string fullPathToDemand);
	private static string NormalizeSearchPattern(string searchPattern);
	private static string GetNormalizedSearchCriteria(string fullSearchString, string fullPathMod);
	private static string GetFullSearchString(string fullPath, string searchPattern);

}
//NameSpace:System.IO
internal abstract class SearchResultHandler`1
{
	// Methods
	internal abstract bool IsResultIncluded(SearchResult result);
	internal abstract T CreateObject(SearchResult result);
	protected void .ctor();

}
//NameSpace:System.IO
internal class StringResultHandler : SearchResultHandler`1<string>
{
	// Fields
	private bool _includeFiles;
	private bool _includeDirs;

	// Methods
	internal void .ctor(bool includeFiles, bool includeDirs);
	internal override bool IsResultIncluded(SearchResult result);
	internal override string CreateObject(SearchResult result);

}
//NameSpace:System.IO
internal sealed class SearchResult
{
	// Fields
	private string fullPath;
	private string userPath;
	private Win32Native.WIN32_FIND_DATA findData;

	// Properties
	internal string UserPath { get; }
	internal Win32Native.WIN32_FIND_DATA FindData { get; }

	// Methods
	internal void .ctor(string fullPath, string userPath, Win32Native.WIN32_FIND_DATA findData);
	internal string get_UserPath();
	internal Win32Native.WIN32_FIND_DATA get_FindData();

}
//NameSpace:System.IO
internal static class FileSystemEnumerableHelpers
{
	// Methods
	internal static bool IsDir(Win32Native.WIN32_FIND_DATA data);
	internal static bool IsFile(Win32Native.WIN32_FIND_DATA data);

}
//NameSpace:System.IO
public abstract class FileSystemInfo : MarshalByRefObject, ISerializable
{
	// Fields
	internal MonoIOStat _data;
	internal int _dataInitialised;
	protected string FullPath;
	protected string OriginalPath;
	private string _displayPath;

	// Properties
	public virtual string FullName { get; }
	public abstract string Name { get; }
	public abstract bool Exists { get; }

	// Methods
	protected void .ctor();
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public virtual string get_FullName();
	public abstract string get_Name();
	public abstract bool get_Exists();
	public void Refresh();
	public virtual void GetObjectData(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.IO
public class IOException : SystemException
{
	// Fields
	private string _maybeFullPath;

	// Methods
	public void .ctor();
	public void .ctor(string message);
	public void .ctor(string message, int hresult);
	internal void .ctor(string message, int hresult, string maybeFullPath);
	public void .ctor(string message, Exception innerException);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.IO
public class MemoryStream : Stream
{
	// Fields
	private byte[] _buffer;
	private int _origin;
	private int _position;
	private int _length;
	private int _capacity;
	private bool _expandable;
	private bool _writable;
	private bool _exposable;
	private bool _isOpen;
	private Task`1<int> _lastReadTask;

	// Properties
	public override bool CanRead { get; }
	public override bool CanSeek { get; }
	public override bool CanWrite { get; }
	public virtual int Capacity { get; set; }
	public override long Length { get; }
	public override long Position { get; set; }

	// Methods
	public void .ctor();
	public void .ctor(int capacity);
	public void .ctor(byte[] buffer);
	public void .ctor(byte[] buffer, bool writable);
	public void .ctor(byte[] buffer, int index, int count);
	public void .ctor(byte[] buffer, int index, int count, bool writable, bool publiclyVisible);
	public override bool get_CanRead();
	public override bool get_CanSeek();
	public override bool get_CanWrite();
	private void EnsureWriteable();
	protected override void Dispose(bool disposing);
	private bool EnsureCapacity(int value);
	public override void Flush();
	public virtual byte[] GetBuffer();
	internal byte[] InternalGetBuffer();
	internal int InternalGetPosition();
	internal int InternalReadInt32();
	internal int InternalEmulateRead(int count);
	public virtual int get_Capacity();
	public virtual void set_Capacity(int value);
	public override long get_Length();
	public override long get_Position();
	public override void set_Position(long value);
	public override int Read(out byte[] buffer, int offset, int count);
	public override Task`1<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
	public override int ReadByte();
	public override long Seek(long offset, SeekOrigin loc);
	public virtual byte[] ToArray();
	public override void Write(byte[] buffer, int offset, int count);
	public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
	public override void WriteByte(byte value);

}
//NameSpace:System.IO
public class PathTooLongException : IOException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.IO
internal sealed class PinnedBufferMemoryStream : UnmanagedMemoryStream
{
	// Fields
	private byte[] _array;
	private GCHandle _pinningHandle;

	// Methods
	internal void .ctor(byte[] array);
	protected override void Finalize();
	protected override void Dispose(bool disposing);

}
//NameSpace:System.IO
public abstract class Stream : MarshalByRefObject, IDisposable
{
	// Fields
	public static readonly Stream Null;
	private Stream.ReadWriteTask _activeReadWriteTask;
	private SemaphoreSlim _asyncActiveSemaphore;

	// Properties
	public abstract bool CanRead { get; }
	public abstract bool CanSeek { get; }
	public abstract bool CanWrite { get; }
	public abstract long Length { get; }
	public abstract long Position { get; set; }

	// Methods
	internal SemaphoreSlim EnsureAsyncActiveSemaphoreInitialized();
	public abstract bool get_CanRead();
	public abstract bool get_CanSeek();
	public abstract bool get_CanWrite();
	public abstract long get_Length();
	public abstract long get_Position();
	public abstract void set_Position(long value);
	public virtual void Close();
	public void Dispose();
	protected virtual void Dispose(bool disposing);
	public abstract void Flush();
	public virtual IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state);
	internal IAsyncResult BeginReadInternal(byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool serializeAsynchronously);
	public virtual int EndRead(IAsyncResult asyncResult);
	public virtual Task`1<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
	private Task`1<int> BeginEndReadAsync(byte[] buffer, int offset, int count);
	public virtual IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state);
	internal IAsyncResult BeginWriteInternal(byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool serializeAsynchronously);
	private void RunReadWriteTaskWhenReady(Task asyncWaiter, Stream.ReadWriteTask readWriteTask);
	private void RunReadWriteTask(Stream.ReadWriteTask readWriteTask);
	public virtual void EndWrite(IAsyncResult asyncResult);
	public Task WriteAsync(byte[] buffer, int offset, int count);
	public virtual Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
	private Task BeginEndWriteAsync(byte[] buffer, int offset, int count);
	public abstract long Seek(long offset, SeekOrigin origin);
	public abstract int Read(out byte[] buffer, int offset, int count);
	public virtual int ReadByte();
	public abstract void Write(byte[] buffer, int offset, int count);
	public virtual void WriteByte(byte value);
	internal IAsyncResult BlockingBeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state);
	internal static int BlockingEndRead(IAsyncResult asyncResult);
	internal IAsyncResult BlockingBeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state);
	internal static void BlockingEndWrite(IAsyncResult asyncResult);
	protected void .ctor();
	private static void .cctor();

}
//NameSpace:
private struct Stream.ReadWriteParameters
{
	// Fields
	internal byte[] Buffer;
	internal int Offset;
	internal int Count;

}
//NameSpace:
private sealed class Stream.ReadWriteTask : Task`1<int>, ITaskCompletionAction
{
	// Fields
	internal readonly bool _isRead;
	internal Stream _stream;
	internal byte[] _buffer;
	internal int _offset;
	internal int _count;
	private AsyncCallback _callback;
	private ExecutionContext _context;
	private static ContextCallback s_invokeAsyncCallback;

	// Methods
	internal void ClearBeginState();
	public void .ctor(bool isRead, Func`2<objectint> function, object state, Stream stream, byte[] buffer, int offset, int count, AsyncCallback callback);
	private static void InvokeAsyncCallback(object completedTask);
	private void System.Threading.Tasks.ITaskCompletionAction.Invoke(Task completingTask);

}
//NameSpace:
private sealed class Stream.NullStream : Stream
{
	// Fields
	private static Task`1<int> s_nullReadTask;

	// Properties
	public override bool CanRead { get; }
	public override bool CanWrite { get; }
	public override bool CanSeek { get; }
	public override long Length { get; }
	public override long Position { get; set; }

	// Methods
	internal void .ctor();
	public override bool get_CanRead();
	public override bool get_CanWrite();
	public override bool get_CanSeek();
	public override long get_Length();
	public override long get_Position();
	public override void set_Position(long value);
	protected override void Dispose(bool disposing);
	public override void Flush();
	public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state);
	public override int EndRead(IAsyncResult asyncResult);
	public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state);
	public override void EndWrite(IAsyncResult asyncResult);
	public override int Read(out byte[] buffer, int offset, int count);
	public override Task`1<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
	public override int ReadByte();
	public override void Write(byte[] buffer, int offset, int count);
	public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
	public override void WriteByte(byte value);
	public override long Seek(long offset, SeekOrigin origin);

}
//NameSpace:
internal sealed class Stream.SynchronousAsyncResult : IAsyncResult
{
	// Fields
	private readonly object _stateObject;
	private readonly bool _isWrite;
	private ManualResetEvent _waitHandle;
	private ExceptionDispatchInfo _exceptionInfo;
	private bool _endXxxCalled;
	private int _bytesRead;

	// Properties
	public WaitHandle AsyncWaitHandle { get; }
	public object AsyncState { get; }
	public bool CompletedSynchronously { get; }

	// Methods
	internal void .ctor(int bytesRead, object asyncStateObject);
	internal void .ctor(object asyncStateObject);
	internal void .ctor(Exception ex, object asyncStateObject, bool isWrite);
	public WaitHandle get_AsyncWaitHandle();
	public object get_AsyncState();
	public bool get_CompletedSynchronously();
	internal void ThrowIfError();
	internal static int EndRead(IAsyncResult asyncResult);
	internal static void EndWrite(IAsyncResult asyncResult);

}
//NameSpace:
private sealed class Stream.SynchronousAsyncResult.<>c
{
	// Fields
	public static readonly Stream.SynchronousAsyncResult.<>c <>9;
	public static Func`1<ManualResetEvent> <>9__12_0;

	// Methods
	private static void .cctor();
	public void .ctor();
	internal ManualResetEvent <get_AsyncWaitHandle>b__12_0();

}
//NameSpace:
private sealed class Stream.<>c
{
	// Fields
	public static readonly Stream.<>c <>9;
	public static Func`1<SemaphoreSlim> <>9__4_0;
	public static Func`2<objectint> <>9__39_0;
	public static Func`5<StreamStream.ReadWriteParametersAsyncCallbackobjectIAsyncResult> <>9__43_0;
	public static Func`3<StreamIAsyncResultint> <>9__43_1;
	public static Func`2<objectint> <>9__46_0;
	public static Action`2<Taskobject> <>9__47_0;
	public static Func`5<StreamStream.ReadWriteParametersAsyncCallbackobjectIAsyncResult> <>9__53_0;
	public static Func`3<StreamIAsyncResultVoidTaskResult> <>9__53_1;

	// Methods
	private static void .cctor();
	public void .ctor();
	internal SemaphoreSlim <EnsureAsyncActiveSemaphoreInitialized>b__4_0();
	internal int <BeginReadInternal>b__39_0(object <p0>);
	internal IAsyncResult <BeginEndReadAsync>b__43_0(Stream stream, Stream.ReadWriteParameters args, AsyncCallback callback, object state);
	internal int <BeginEndReadAsync>b__43_1(Stream stream, IAsyncResult asyncResult);
	internal int <BeginWriteInternal>b__46_0(object <p0>);
	internal void <RunReadWriteTaskWhenReady>b__47_0(Task t, object state);
	internal IAsyncResult <BeginEndWriteAsync>b__53_0(Stream stream, Stream.ReadWriteParameters args, AsyncCallback callback, object state);
	internal VoidTaskResult <BeginEndWriteAsync>b__53_1(Stream stream, IAsyncResult asyncResult);

}
//NameSpace:System.IO
public class StreamReader : TextReader
{
	// Fields
	public static readonly StreamReader Null;
	private Stream stream;
	private Encoding encoding;
	private Decoder decoder;
	private byte[] byteBuffer;
	private char[] charBuffer;
	private byte[] _preamble;
	private int charPos;
	private int charLen;
	private int byteLen;
	private int bytePos;
	private int _maxCharsPerBuffer;
	private bool _detectEncoding;
	private bool _checkPreamble;
	private bool _isBlocked;
	private bool _closable;
	private Task _asyncReadTask;

	// Properties
	internal static int DefaultBufferSize { get; }
	public virtual Encoding CurrentEncoding { get; }
	public virtual Stream BaseStream { get; }
	internal bool LeaveOpen { get; }

	// Methods
	internal static int get_DefaultBufferSize();
	private void CheckAsyncTaskInProgress();
	internal void .ctor();
	public void .ctor(Stream stream);
	public void .ctor(Stream stream, bool detectEncodingFromByteOrderMarks);
	public void .ctor(Stream stream, Encoding encoding);
	public void .ctor(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);
	public void .ctor(string path);
	public void .ctor(string path, bool detectEncodingFromByteOrderMarks);
	public void .ctor(string path, Encoding encoding);
	public void .ctor(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
	internal void .ctor(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool checkHost);
	private void Init(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);
	internal void Init(Stream stream);
	protected override void Dispose(bool disposing);
	public virtual Encoding get_CurrentEncoding();
	public virtual Stream get_BaseStream();
	internal bool get_LeaveOpen();
	public override int Peek();
	internal bool DataAvailable();
	public override int Read();
	public override int Read(out char[] buffer, int index, int count);
	public override string ReadToEnd();
	private void CompressBuffer(int n);
	private void DetectEncoding();
	private bool IsPreamble();
	internal virtual int ReadBuffer();
	private int ReadBuffer(char[] userBuffer, int userOffset, int desiredChars, out bool readToUserBuffer);
	public override string ReadLine();
	private static void .cctor();

}
//NameSpace:
private class StreamReader.NullStreamReader : StreamReader
{
	// Properties
	public override Stream BaseStream { get; }
	public override Encoding CurrentEncoding { get; }

	// Methods
	internal void .ctor();
	public override Stream get_BaseStream();
	public override Encoding get_CurrentEncoding();
	protected override void Dispose(bool disposing);
	public override int Peek();
	public override int Read();
	public override int Read(char[] buffer, int index, int count);
	public override string ReadLine();
	public override string ReadToEnd();
	internal override int ReadBuffer();

}
//NameSpace:System.IO
public class StreamWriter : TextWriter
{
	// Fields
	public static readonly StreamWriter Null;
	private Stream stream;
	private Encoding encoding;
	private Encoder encoder;
	private byte[] byteBuffer;
	private char[] charBuffer;
	private int charPos;
	private int charLen;
	private bool autoFlush;
	private bool haveWrittenPreamble;
	private bool closable;
	private Task _asyncWriteTask;
	private static Encoding _UTF8NoBOM;

	// Properties
	internal static Encoding UTF8NoBOM { get; }
	public virtual void AutoFlush { set; }
	internal bool LeaveOpen { get; }

	// Methods
	private void CheckAsyncTaskInProgress();
	internal static Encoding get_UTF8NoBOM();
	internal void .ctor();
	public void .ctor(Stream stream);
	public void .ctor(Stream stream, Encoding encoding);
	public void .ctor(Stream stream, Encoding encoding, int bufferSize, bool leaveOpen);
	public void .ctor(string path, bool append, Encoding encoding);
	public void .ctor(string path, bool append, Encoding encoding, int bufferSize);
	internal void .ctor(string path, bool append, Encoding encoding, int bufferSize, bool checkHost);
	private void Init(Stream streamArg, Encoding encodingArg, int bufferSize, bool shouldLeaveOpen);
	private static Stream CreateFile(string path, bool append, bool checkHost);
	public override void Close();
	protected override void Dispose(bool disposing);
	public override void Flush();
	private void Flush(bool flushStream, bool flushEncoder);
	public virtual void set_AutoFlush(bool value);
	internal bool get_LeaveOpen();
	public override void Write(char value);
	public override void Write(char[] buffer);
	public override void Write(char[] buffer, int index, int count);
	public override void Write(string value);
	private static void .cctor();

}
//NameSpace:System.IO
public class StringReader : TextReader
{
	// Fields
	private string _s;
	private int _pos;
	private int _length;

	// Methods
	public void .ctor(string s);
	protected override void Dispose(bool disposing);
	public override int Peek();
	public override int Read();
	public override int Read(out char[] buffer, int index, int count);
	public override string ReadToEnd();
	public override string ReadLine();

}
//NameSpace:System.IO
public abstract class TextReader : MarshalByRefObject, IDisposable
{
	// Fields
	private static Func`2<objectstring> _ReadLineDelegate;
	private static Func`2<objectint> _ReadDelegate;
	public static readonly TextReader Null;

	// Methods
	protected void .ctor();
	public void Dispose();
	protected virtual void Dispose(bool disposing);
	public virtual int Peek();
	public virtual int Read();
	public virtual int Read(out char[] buffer, int index, int count);
	public virtual string ReadToEnd();
	public virtual string ReadLine();
	public static TextReader Synchronized(TextReader reader);
	private static void .cctor();

}
//NameSpace:
private sealed class TextReader.NullTextReader : TextReader
{
	// Methods
	public void .ctor();
	public override int Read(char[] buffer, int index, int count);
	public override string ReadLine();

}
//NameSpace:
internal sealed class TextReader.SyncTextReader : TextReader
{
	// Fields
	internal TextReader _in;

	// Methods
	internal void .ctor(TextReader t);
	protected override void Dispose(bool disposing);
	public override int Peek();
	public override int Read();
	public override int Read(out char[] buffer, int index, int count);
	public override string ReadLine();
	public override string ReadToEnd();

}
//NameSpace:
private sealed class TextReader.<>c
{
	// Fields
	public static readonly TextReader.<>c <>9;

	// Methods
	private static void .cctor();
	public void .ctor();
	internal string <.cctor>b__22_0(object state);
	internal int <.cctor>b__22_1(object state);

}
//NameSpace:System.IO
public abstract class TextWriter : MarshalByRefObject, IDisposable
{
	// Fields
	public static readonly TextWriter Null;
	private static Action`1<object> _WriteCharDelegate;
	private static Action`1<object> _WriteStringDelegate;
	private static Action`1<object> _WriteCharArrayRangeDelegate;
	private static Action`1<object> _WriteLineCharDelegate;
	private static Action`1<object> _WriteLineStringDelegate;
	private static Action`1<object> _WriteLineCharArrayRangeDelegate;
	private static Action`1<object> _FlushDelegate;
	protected char[] CoreNewLine;
	private IFormatProvider InternalFormatProvider;

	// Properties
	private static string InitialNewLine { get; }
	public virtual IFormatProvider FormatProvider { get; }

	// Methods
	private static string get_InitialNewLine();
	protected void .ctor();
	protected void .ctor(IFormatProvider formatProvider);
	public virtual IFormatProvider get_FormatProvider();
	public virtual void Close();
	protected virtual void Dispose(bool disposing);
	public void Dispose();
	public virtual void Flush();
	public static TextWriter Synchronized(TextWriter writer);
	public virtual void Write(char value);
	public virtual void Write(char[] buffer);
	public virtual void Write(char[] buffer, int index, int count);
	public virtual void Write(string value);
	public virtual void WriteLine();
	public virtual void WriteLine(char value);
	public virtual void WriteLine(char[] buffer, int index, int count);
	public virtual void WriteLine(string value);
	public virtual void WriteLine(string format, object arg0);
	public virtual void WriteLine(string format, object arg0, object arg1);
	private static void .cctor();

}
//NameSpace:
private sealed class TextWriter.NullTextWriter : TextWriter
{
	// Methods
	internal void .ctor();
	public override void Write(char[] buffer, int index, int count);
	public override void Write(string value);
	public override void WriteLine();
	public override void WriteLine(string value);

}
//NameSpace:
internal sealed class TextWriter.SyncTextWriter : TextWriter, IDisposable
{
	// Fields
	private TextWriter _out;

	// Properties
	public override IFormatProvider FormatProvider { get; }

	// Methods
	internal void .ctor(TextWriter t);
	public override IFormatProvider get_FormatProvider();
	public override void Close();
	protected override void Dispose(bool disposing);
	public override void Flush();
	public override void Write(char value);
	public override void Write(char[] buffer);
	public override void Write(char[] buffer, int index, int count);
	public override void Write(string value);
	public override void WriteLine();
	public override void WriteLine(char value);
	public override void WriteLine(char[] buffer, int index, int count);
	public override void WriteLine(string value);
	public override void WriteLine(string format, object arg0);
	public override void WriteLine(string format, object arg0, object arg1);

}
//NameSpace:
private sealed class TextWriter.<>c
{
	// Fields
	public static readonly TextWriter.<>c <>9;

	// Methods
	private static void .cctor();
	public void .ctor();
	internal void <.cctor>b__73_0(object state);
	internal void <.cctor>b__73_1(object state);
	internal void <.cctor>b__73_2(object state);
	internal void <.cctor>b__73_3(object state);
	internal void <.cctor>b__73_4(object state);
	internal void <.cctor>b__73_5(object state);
	internal void <.cctor>b__73_6(object state);

}
//NameSpace:System.IO
public class UnmanagedMemoryStream : Stream
{
	// Fields
	private SafeBuffer _buffer;
	private byte* _mem;
	private long _length;
	private long _capacity;
	private long _position;
	private long _offset;
	private FileAccess _access;
	internal bool _isOpen;
	private Task`1<int> _lastReadTask;

	// Properties
	public override bool CanRead { get; }
	public override bool CanSeek { get; }
	public override bool CanWrite { get; }
	public override long Length { get; }
	public override long Position { get; set; }
	public byte* PositionPointer { get; }

	// Methods
	protected void .ctor();
	internal void .ctor(byte* pointer, long length, long capacity, FileAccess access, bool skipSecurityCheck);
	internal void Initialize(byte* pointer, long length, long capacity, FileAccess access, bool skipSecurityCheck);
	public override bool get_CanRead();
	public override bool get_CanSeek();
	public override bool get_CanWrite();
	protected override void Dispose(bool disposing);
	public override void Flush();
	public override long get_Length();
	public override long get_Position();
	public override void set_Position(long value);
	public byte* get_PositionPointer();
	public override int Read(out byte[] buffer, int offset, int count);
	public override Task`1<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
	public override int ReadByte();
	public override long Seek(long offset, SeekOrigin loc);
	public override void Write(byte[] buffer, int offset, int count);
	public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
	public override void WriteByte(byte value);

}
//NameSpace:System.IO
internal static class PathInternal
{
	// Methods
	public static bool IsPartiallyQualified(string path);
	public static bool HasIllegalCharacters(string path, bool checkAdditional);

}
//NameSpace:System.IO
public sealed class DirectoryInfo : FileSystemInfo
{
	// Fields
	private string current;
	private string parent;

	// Properties
	public override bool Exists { get; }
	public override string Name { get; }
	public DirectoryInfo Parent { get; }

	// Methods
	public void .ctor(string path);
	internal void .ctor(string path, bool simpleOriginalPath);
	private void .ctor(SerializationInfo info, StreamingContext context);
	private void Initialize();
	public override bool get_Exists();
	public override string get_Name();
	public DirectoryInfo get_Parent();
	public void Create();
	public DirectoryInfo[] GetDirectories();
	public DirectoryInfo[] GetDirectories(string searchPattern);
	public override string ToString();
	internal void CheckPath(string path);

}
//NameSpace:System.IO
public static class File
{
	// Methods
	public static FileStream Create(string path);
	public static FileStream Create(string path, int bufferSize);
	public static void Delete(string path);
	public static bool Exists(string path);
	public static FileStream Open(string path, FileMode mode);
	public static FileStream OpenRead(string path);
	public static StreamReader OpenText(string path);
	internal static int FillAttributeInfo(string path, MonoIOStat data, bool tryagain, bool returnErrorOnNotFound);

}
//NameSpace:System.IO
public enum FileAccess
{
	// Fields
	public int value__;
	public const FileAccess Read;
	public const FileAccess Write;
	public const FileAccess ReadWrite;

}
//NameSpace:System.IO
public enum FileAttributes
{
	// Fields
	public int value__;
	public const FileAttributes Archive;
	public const FileAttributes Compressed;
	public const FileAttributes Device;
	public const FileAttributes Directory;
	public const FileAttributes Encrypted;
	public const FileAttributes Hidden;
	public const FileAttributes Normal;
	public const FileAttributes NotContentIndexed;
	public const FileAttributes Offline;
	public const FileAttributes ReadOnly;
	public const FileAttributes ReparsePoint;
	public const FileAttributes SparseFile;
	public const FileAttributes System;
	public const FileAttributes Temporary;
	public const FileAttributes IntegrityStream;
	public const FileAttributes NoScrubData;

}
//NameSpace:System.IO
public enum FileMode
{
	// Fields
	public int value__;
	public const FileMode CreateNew;
	public const FileMode Create;
	public const FileMode Open;
	public const FileMode OpenOrCreate;
	public const FileMode Truncate;
	public const FileMode Append;

}
//NameSpace:System.IO
public enum FileOptions
{
	// Fields
	public int value__;
	public const FileOptions None;
	public const FileOptions Encrypted;
	public const FileOptions DeleteOnClose;
	public const FileOptions SequentialScan;
	public const FileOptions RandomAccess;
	public const FileOptions Asynchronous;
	public const FileOptions WriteThrough;

}
//NameSpace:System.IO
public enum FileShare
{
	// Fields
	public int value__;
	public const FileShare None;
	public const FileShare Read;
	public const FileShare Write;
	public const FileShare ReadWrite;
	public const FileShare Delete;
	public const FileShare Inheritable;

}
//NameSpace:System.IO
public class FileStream : Stream
{
	// Fields
	private static byte[] buf_recycle;
	private static readonly object buf_recycle_lock;
	private byte[] buf;
	private string name;
	private SafeFileHandle safeHandle;
	private bool isExposed;
	private long append_startpos;
	private FileAccess access;
	private bool owner;
	private bool async;
	private bool canseek;
	private bool anonymous;
	private bool buf_dirty;
	private int buf_size;
	private int buf_length;
	private int buf_offset;
	private long buf_start;

	// Properties
	public override bool CanRead { get; }
	public override bool CanWrite { get; }
	public override bool CanSeek { get; }
	public override long Length { get; }
	public override long Position { get; set; }

	// Methods
	internal void .ctor(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync, bool isConsoleWrapper);
	public void .ctor(string path, FileMode mode, FileAccess access, FileShare share);
	public void .ctor(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
	internal void .ctor(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options, string msgPath, bool bFromProxy, optional bool useLongPath, optional bool checkHost);
	internal void .ctor(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool anonymous, FileOptions options);
	private void Init(SafeFileHandle safeHandle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync, bool isConsoleWrapper);
	public override bool get_CanRead();
	public override bool get_CanWrite();
	public override bool get_CanSeek();
	public override long get_Length();
	public override long get_Position();
	public override void set_Position(long value);
	private void ExposeHandle();
	public override int ReadByte();
	public override void WriteByte(byte value);
	public override int Read(out byte[] array, int offset, int count);
	private int ReadInternal(byte[] dest, int offset, int count);
	public override IAsyncResult BeginRead(byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
	public override int EndRead(IAsyncResult asyncResult);
	public override void Write(byte[] array, int offset, int count);
	private void WriteInternal(byte[] src, int offset, int count);
	public override IAsyncResult BeginWrite(byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);
	public override void EndWrite(IAsyncResult asyncResult);
	public override long Seek(long offset, SeekOrigin origin);
	public override void Flush();
	protected override void Finalize();
	protected override void Dispose(bool disposing);
	public override Task`1<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
	public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
	private int ReadSegment(byte[] dest, int dest_offset, int count);
	private int WriteSegment(byte[] src, int src_offset, int count);
	private void FlushBuffer();
	private void FlushBufferIfDirty();
	private void RefillBuffer();
	private int ReadData(SafeHandle safeHandle, byte[] buf, int offset, int count);
	private void InitBuffer(int size, bool isZeroSize);
	private string GetSecureFileName(string filename);
	private string GetSecureFileName(string filename, bool full);
	private static void .cctor();

}
//NameSpace:
private sealed class FileStream.ReadDelegate : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual int Invoke(byte[] buffer, int offset, int count);
	public virtual IAsyncResult BeginInvoke(byte[] buffer, int offset, int count, AsyncCallback callback, object object);
	public virtual int EndInvoke(IAsyncResult result);

}
//NameSpace:
private sealed class FileStream.WriteDelegate : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(byte[] buffer, int offset, int count);
	public virtual IAsyncResult BeginInvoke(byte[] buffer, int offset, int count, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System.IO
internal class FileStreamAsyncResult : IAsyncResult
{
	// Fields
	private object state;
	private ManualResetEvent wh;
	private AsyncCallback cb;
	private bool completedSynch;
	public int Count;
	public int OriginalCount;
	public int BytesRead;
	private AsyncCallback realcb;

	// Properties
	public object AsyncState { get; }
	public bool CompletedSynchronously { get; }
	public WaitHandle AsyncWaitHandle { get; }

	// Methods
	public void .ctor(AsyncCallback cb, object state);
	private static void CBWrapper(IAsyncResult ares);
	public object get_AsyncState();
	public bool get_CompletedSynchronously();
	public WaitHandle get_AsyncWaitHandle();

}
//NameSpace:System.IO
internal enum MonoFileType
{
	// Fields
	public int value__;
	public const MonoFileType Unknown;
	public const MonoFileType Disk;
	public const MonoFileType Char;
	public const MonoFileType Pipe;
	public const MonoFileType Remote;

}
//NameSpace:System.IO
internal static class MonoIO
{
	// Fields
	public static readonly IntPtr InvalidHandle;
	private static bool dump_handles;

	// Properties
	public static IntPtr ConsoleOutput { get; }
	public static IntPtr ConsoleInput { get; }
	public static IntPtr ConsoleError { get; }
	public static char VolumeSeparatorChar { get; }
	public static char DirectorySeparatorChar { get; }
	public static char AltDirectorySeparatorChar { get; }
	public static char PathSeparator { get; }

	// Methods
	public static Exception GetException(MonoIOError error);
	public static Exception GetException(string path, MonoIOError error);
	private static bool CreateDirectory(char* path, out MonoIOError error);
	public static bool CreateDirectory(string path, out MonoIOError error);
	private static bool RemoveDirectory(char* path, out MonoIOError error);
	public static bool RemoveDirectory(string path, out MonoIOError error);
	public static string GetCurrentDirectory(out MonoIOError error);
	private static bool DeleteFile(char* path, out MonoIOError error);
	public static bool DeleteFile(string path, out MonoIOError error);
	private static FileAttributes GetFileAttributes(char* path, out MonoIOError error);
	public static FileAttributes GetFileAttributes(string path, out MonoIOError error);
	private static MonoFileType GetFileType(IntPtr handle, out MonoIOError error);
	public static MonoFileType GetFileType(SafeHandle safeHandle, out MonoIOError error);
	private static IntPtr FindFirstFile(char* pathWithPattern, out string fileName, out int fileAttr, out int error);
	public static IntPtr FindFirstFile(string pathWithPattern, out string fileName, out int fileAttr, out int error);
	public static bool FindNextFile(IntPtr hnd, out string fileName, out int fileAttr, out int error);
	public static bool FindCloseFile(IntPtr hnd);
	public static bool ExistsFile(string path, out MonoIOError error);
	public static bool ExistsDirectory(string path, out MonoIOError error);
	public static bool ExistsSymlink(string path, out MonoIOError error);
	private static bool GetFileStat(char* path, out MonoIOStat stat, out MonoIOError error);
	public static bool GetFileStat(string path, out MonoIOStat stat, out MonoIOError error);
	private static IntPtr Open(char* filename, FileMode mode, FileAccess access, FileShare share, FileOptions options, out MonoIOError error);
	public static IntPtr Open(string filename, FileMode mode, FileAccess access, FileShare share, FileOptions options, out MonoIOError error);
	public static bool Close(IntPtr handle, out MonoIOError error);
	private static int Read(IntPtr handle, byte[] dest, int dest_offset, int count, out MonoIOError error);
	public static int Read(SafeHandle safeHandle, byte[] dest, int dest_offset, int count, out MonoIOError error);
	private static int Write(IntPtr handle, byte[] src, int src_offset, int count, out MonoIOError error);
	public static int Write(SafeHandle safeHandle, byte[] src, int src_offset, int count, out MonoIOError error);
	private static long Seek(IntPtr handle, long offset, SeekOrigin origin, out MonoIOError error);
	public static long Seek(SafeHandle safeHandle, long offset, SeekOrigin origin, out MonoIOError error);
	private static long GetLength(IntPtr handle, out MonoIOError error);
	public static long GetLength(SafeHandle safeHandle, out MonoIOError error);
	public static IntPtr get_ConsoleOutput();
	public static IntPtr get_ConsoleInput();
	public static IntPtr get_ConsoleError();
	public static char get_VolumeSeparatorChar();
	public static char get_DirectorySeparatorChar();
	public static char get_AltDirectorySeparatorChar();
	public static char get_PathSeparator();
	private static void DumpHandles();
	public static bool RemapPath(string path, out string newPath);
	private static void .cctor();

}
//NameSpace:System.IO
internal enum MonoIOError
{
	// Fields
	public int value__;
	public const MonoIOError ERROR_SUCCESS;
	public const MonoIOError ERROR_FILE_NOT_FOUND;
	public const MonoIOError ERROR_PATH_NOT_FOUND;
	public const MonoIOError ERROR_TOO_MANY_OPEN_FILES;
	public const MonoIOError ERROR_ACCESS_DENIED;
	public const MonoIOError ERROR_INVALID_HANDLE;
	public const MonoIOError ERROR_INVALID_DRIVE;
	public const MonoIOError ERROR_NOT_SAME_DEVICE;
	public const MonoIOError ERROR_NO_MORE_FILES;
	public const MonoIOError ERROR_NOT_READY;
	public const MonoIOError ERROR_WRITE_FAULT;
	public const MonoIOError ERROR_READ_FAULT;
	public const MonoIOError ERROR_GEN_FAILURE;
	public const MonoIOError ERROR_SHARING_VIOLATION;
	public const MonoIOError ERROR_LOCK_VIOLATION;
	public const MonoIOError ERROR_HANDLE_DISK_FULL;
	public const MonoIOError ERROR_FILE_EXISTS;
	public const MonoIOError ERROR_CANNOT_MAKE;
	public const MonoIOError ERROR_INVALID_PARAMETER;
	public const MonoIOError ERROR_BROKEN_PIPE;
	public const MonoIOError ERROR_INVALID_NAME;
	public const MonoIOError ERROR_DIR_NOT_EMPTY;
	public const MonoIOError ERROR_ALREADY_EXISTS;
	public const MonoIOError ERROR_FILENAME_EXCED_RANGE;
	public const MonoIOError ERROR_DIRECTORY;
	public const MonoIOError ERROR_ENCRYPTION_FAILED;

}
//NameSpace:System.IO
internal struct MonoIOStat
{
	// Fields
	public FileAttributes fileAttributes;
	public long Length;
	public long CreationTime;
	public long LastAccessTime;
	public long LastWriteTime;

}
//NameSpace:System.IO
public static class Path
{
	// Fields
	public static readonly char[] InvalidPathChars;
	public static readonly char AltDirectorySeparatorChar;
	public static readonly char DirectorySeparatorChar;
	public static readonly char PathSeparator;
	internal static readonly string DirectorySeparatorStr;
	public static readonly char VolumeSeparatorChar;
	internal static readonly char[] PathSeparatorChars;
	private static readonly bool dirEqualsVolume;
	internal static readonly char[] trimEndCharsWindows;
	internal static readonly char[] trimEndCharsUnix;

	// Properties
	internal static string DirectorySeparatorCharAsString { get; }
	internal static char[] TrimEndChars { get; }

	// Methods
	public static string Combine(string path1, string path2);
	internal static string CleanPath(string s);
	public static string GetDirectoryName(string path);
	public static string GetFileName(string path);
	public static string GetFullPath(string path);
	internal static string GetFullPathInternal(string path);
	private static extern int GetFullPathName(string path, int numBufferChars, StringBuilder buffer, IntPtr lpFilePartOrNull);
	internal static string GetFullPathName(string path);
	internal static string WindowsDriveAdjustment(string path);
	internal static string InsecureGetFullPath(string path);
	internal static bool IsDirectorySeparator(char c);
	public static string GetPathRoot(string path);
	public static bool IsPathRooted(string path);
	public static char[] GetInvalidPathChars();
	private static void .cctor();
	private static string GetServerAndShare(string path);
	private static bool SameRoot(string root, string path);
	private static string CanonicalizePath(string path);
	public static string Combine(string[] paths);
	public static string Combine(string path1, string path2, string path3);
	internal static void Validate(string path);
	internal static void Validate(string path, string parameterName);
	internal static string get_DirectorySeparatorCharAsString();
	internal static char[] get_TrimEndChars();
	internal static void CheckSearchPattern(string searchPattern);
	internal static void CheckInvalidPathChars(string path, optional bool checkAdditional);
	internal static string InternalCombine(string path1, string path2);

}
//NameSpace:System.IO
public enum SearchOption
{
	// Fields
	public int value__;
	public const SearchOption TopDirectoryOnly;
	public const SearchOption AllDirectories;

}
//NameSpace:System.IO
public enum SeekOrigin
{
	// Fields
	public int value__;
	public const SeekOrigin Begin;
	public const SeekOrigin Current;
	public const SeekOrigin End;

}
//NameSpace:System.IO
internal class UnexceptionalStreamReader : StreamReader
{
	// Fields
	private static bool[] newline;
	private static char newlineChar;

	// Methods
	private static void .cctor();
	public void .ctor(Stream stream, Encoding encoding);
	public override int Peek();
	public override int Read();
	public override int Read(out char[] dest_buffer, int index, int count);
	private bool CheckEOL(char current);
	public override string ReadLine();
	public override string ReadToEnd();

}
//NameSpace:System.IO
internal class UnexceptionalStreamWriter : StreamWriter
{
	// Methods
	public void .ctor(Stream stream, Encoding encoding);
	public override void Flush();
	public override void Write(char[] buffer, int index, int count);
	public override void Write(char value);
	public override void Write(char[] value);
	public override void Write(string value);

}
//NameSpace:System.IO
internal class CStreamReader : StreamReader
{
	// Fields
	private TermInfoDriver driver;

	// Methods
	public void .ctor(Stream stream, Encoding encoding);
	public override int Peek();
	public override int Read();
	public override int Read(out char[] dest, int index, int count);
	public override string ReadLine();
	public override string ReadToEnd();

}
//NameSpace:System.IO
internal class CStreamWriter : StreamWriter
{
	// Fields
	private TermInfoDriver driver;

	// Methods
	public void .ctor(Stream stream, Encoding encoding, bool leaveOpen);
	public override void Write(char[] buffer, int index, int count);
	public override void Write(char val);
	public void InternalWriteString(string val);
	public void InternalWriteChar(char val);
	public void InternalWriteChars(char[] buffer, int n);
	public override void Write(char[] val);
	public override void Write(string val);

}
//NameSpace:System.Globalization
public static class CharUnicodeInfo
{
	// Fields
	private static ushort[] s_pCategoryLevel1Index;
	private static byte[] s_pCategoriesValue;
	private static ushort[] s_pNumericLevel1Index;
	private static byte[] s_pNumericValues;
	private static ushort[] s_pDigitValues;

	// Methods
	internal static int InternalConvertToUtf32(string s, int index);
	internal static bool IsWhiteSpace(char c);
	public static UnicodeCategory GetUnicodeCategory(char ch);
	internal static UnicodeCategory InternalGetUnicodeCategory(int ch);
	internal static byte InternalGetCategoryValue(int ch, int offset);
	internal static UnicodeCategory InternalGetUnicodeCategory(string value, int index);
	private static void .cctor();

}
//NameSpace:
internal static class CharUnicodeInfo.Debug
{
	// Methods
	internal static void Assert(bool condition, string message);

}
//NameSpace:System.Globalization
public abstract class Calendar : ICloneable
{
	// Fields
	internal int m_currentEraValue;
	private bool m_isReadOnly;
	internal int twoDigitYearMax;

	// Properties
	public virtual DateTime MinSupportedDateTime { get; }
	public virtual DateTime MaxSupportedDateTime { get; }
	internal virtual int ID { get; }
	internal virtual int BaseCalendarID { get; }
	internal virtual int CurrentEraValue { get; }
	public abstract int[] Eras { get; }
	public virtual int TwoDigitYearMax { get; }

	// Methods
	public virtual DateTime get_MinSupportedDateTime();
	public virtual DateTime get_MaxSupportedDateTime();
	protected void .ctor();
	internal virtual int get_ID();
	internal virtual int get_BaseCalendarID();
	public virtual object Clone();
	internal void SetReadOnlyState(bool readOnly);
	internal virtual int get_CurrentEraValue();
	public abstract int GetDayOfMonth(DateTime time);
	public abstract DayOfWeek GetDayOfWeek(DateTime time);
	public abstract int GetDaysInMonth(int year, int month, int era);
	public abstract int GetEra(DateTime time);
	public abstract int[] get_Eras();
	public abstract int GetMonth(DateTime time);
	public abstract int GetMonthsInYear(int year, int era);
	public abstract int GetYear(DateTime time);
	public virtual bool IsLeapYear(int year);
	public abstract bool IsLeapYear(int year, int era);
	public abstract DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
	internal virtual bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, out DateTime result);
	internal virtual bool IsValidYear(int year, int era);
	internal virtual bool IsValidMonth(int year, int month, int era);
	internal virtual bool IsValidDay(int year, int month, int day, int era);
	public virtual int get_TwoDigitYearMax();
	public virtual int ToFourDigitYear(int year);
	internal static int GetSystemTwoDigitYearSetting(int CalID, int defaultYearValue);

}
//NameSpace:System.Globalization
internal class CalendarData
{
	// Fields
	internal const int MAX_CALENDARS;
	internal string sNativeName;
	internal string[] saShortDates;
	internal string[] saYearMonths;
	internal string[] saLongDates;
	internal string sMonthDay;
	internal string[] saEraNames;
	internal string[] saAbbrevEraNames;
	internal string[] saAbbrevEnglishEraNames;
	internal string[] saDayNames;
	internal string[] saAbbrevDayNames;
	internal string[] saSuperShortDayNames;
	internal string[] saMonthNames;
	internal string[] saAbbrevMonthNames;
	internal string[] saMonthGenitiveNames;
	internal string[] saAbbrevMonthGenitiveNames;
	internal string[] saLeapYearMonthNames;
	internal int iTwoDigitYearMax;
	internal int iCurrentEra;
	internal bool bUseUserOverrides;
	internal static CalendarData Invariant;

	// Methods
	private void .ctor();
	private static void .cctor();
	internal void .ctor(string localeName, int calendarId, bool bUseUserOverrides);
	private void InitializeEraNames(string localeName, int calendarId);
	private void InitializeAbbreviatedEraNames(string localeName, int calendarId);
	internal static CalendarData GetCalendarData(int calendarId);
	private static string CalendarIdToCultureName(int calendarId);
	public static int nativeGetTwoDigitYearMax(int calID);
	private static bool nativeGetCalendarData(CalendarData data, string localeName, int calendarId);
	private bool fill_calendar_data(string localeName, int datetimeIndex);

}
//NameSpace:System.Globalization
public enum CompareOptions
{
	// Fields
	public int value__;
	public const CompareOptions None;
	public const CompareOptions IgnoreCase;
	public const CompareOptions IgnoreNonSpace;
	public const CompareOptions IgnoreSymbols;
	public const CompareOptions IgnoreKanaType;
	public const CompareOptions IgnoreWidth;
	public const CompareOptions OrdinalIgnoreCase;
	public const CompareOptions StringSort;
	public const CompareOptions Ordinal;

}
//NameSpace:System.Globalization
public class CompareInfo : IDeserializationCallback
{
	// Fields
	private const CompareOptions ValidIndexMaskOffFlags;
	private const CompareOptions ValidCompareMaskOffFlags;
	private const CompareOptions ValidHashCodeOfStringMaskOffFlags;
	private string m_name;
	private string m_sortName;
	private int win32LCID;
	private int culture;
	private const int LINGUISTIC_IGNORECASE;
	private const int NORM_IGNORECASE;
	private const int NORM_IGNOREKANATYPE;
	private const int LINGUISTIC_IGNOREDIACRITIC;
	private const int NORM_IGNORENONSPACE;
	private const int NORM_IGNORESYMBOLS;
	private const int NORM_IGNOREWIDTH;
	private const int SORT_STRINGSORT;
	private const int COMPARE_OPTIONS_ORDINAL;
	internal const int NORM_LINGUISTIC_CASING;
	private const int RESERVED_FIND_ASCII_STRING;
	private const int SORT_VERSION_WHIDBEY;
	private const int SORT_VERSION_V4;
	private SortVersion m_SortVersion;
	private SimpleCollator collator;
	private static Dictionary`2<stringSimpleCollator> collators;
	private static bool managedCollation;
	private static bool managedCollationChecked;

	// Properties
	public virtual string Name { get; }
	private static bool UseManagedCollation { get; }

	// Methods
	internal void .ctor(CultureInfo culture);
	public static CompareInfo GetCompareInfo(string name);
	private void OnDeserializing(StreamingContext ctx);
	private void OnDeserialized();
	private void OnDeserialized(StreamingContext ctx);
	private void OnSerializing(StreamingContext ctx);
	private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
	public virtual string get_Name();
	public virtual int Compare(string string1, string string2);
	public virtual int Compare(string string1, string string2, CompareOptions options);
	public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2, CompareOptions options);
	private static int CompareOrdinal(string string1, int offset1, int length1, string string2, int offset2, int length2);
	public virtual bool IsPrefix(string source, string prefix, CompareOptions options);
	public virtual bool IsSuffix(string source, string suffix, CompareOptions options);
	public virtual int IndexOf(string source, string value, int startIndex, int count, CompareOptions options);
	public virtual int LastIndexOf(string source, string value, int startIndex, int count, CompareOptions options);
	public virtual SortKey GetSortKey(string source, CompareOptions options);
	private SortKey CreateSortKey(string source, CompareOptions options);
	public override bool Equals(object value);
	public override int GetHashCode();
	internal int GetHashCodeOfString(string source, CompareOptions options);
	internal int GetHashCodeOfString(string source, CompareOptions options, bool forceRandomizedHashing, long additionalEntropy);
	public override string ToString();
	private static bool get_UseManagedCollation();
	private SimpleCollator GetCollator();
	private SortKey CreateSortKeyCore(string source, CompareOptions options);
	private int internal_index_switch(string s1, int sindex, int count, string s2, CompareOptions opt, bool first);
	private int internal_compare_switch(string str1, int offset1, int length1, string str2, int offset2, int length2, CompareOptions options);
	private int internal_compare_managed(string str1, int offset1, int length1, string str2, int offset2, int length2, CompareOptions options);
	private int internal_index_managed(string s1, int sindex, int count, string s2, CompareOptions opt, bool first);
	private void assign_sortkey(object key, string source, CompareOptions options);
	private int internal_compare(string str1, int offset1, int length1, string str2, int offset2, int length2, CompareOptions options);
	private int internal_index(string source, int sindex, int count, string value, CompareOptions options, bool first);
	internal void .ctor();

}
//NameSpace:System.Globalization
public class CultureNotFoundException : ArgumentException, ISerializable
{
	// Fields
	private string m_invalidCultureName;
	private Nullable`1<int> m_invalidCultureId;

	// Properties
	public virtual Nullable`1<int> InvalidCultureId { get; }
	public virtual string InvalidCultureName { get; }
	private static string DefaultMessage { get; }
	private string FormatedInvalidCultureId { get; }
	public override string Message { get; }

	// Methods
	public void .ctor();
	public void .ctor(string paramName, string message);
	public void .ctor(string paramName, string invalidCultureName, string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public override void GetObjectData(SerializationInfo info, StreamingContext context);
	public virtual Nullable`1<int> get_InvalidCultureId();
	public virtual string get_InvalidCultureName();
	private static string get_DefaultMessage();
	private string get_FormatedInvalidCultureId();
	public override string get_Message();

}
//NameSpace:System.Globalization
internal enum MonthNameStyles
{
	// Fields
	public int value__;
	public const MonthNameStyles Regular;
	public const MonthNameStyles Genitive;
	public const MonthNameStyles LeapYear;

}
//NameSpace:System.Globalization
internal enum DateTimeFormatFlags
{
	// Fields
	public int value__;
	public const DateTimeFormatFlags None;
	public const DateTimeFormatFlags UseGenitiveMonth;
	public const DateTimeFormatFlags UseLeapYearMonth;
	public const DateTimeFormatFlags UseSpacesInMonthNames;
	public const DateTimeFormatFlags UseHebrewRule;
	public const DateTimeFormatFlags UseSpacesInDayNames;
	public const DateTimeFormatFlags UseDigitPrefixInTokens;
	public const DateTimeFormatFlags NotInitialized;

}
//NameSpace:System.Globalization
public sealed class DateTimeFormatInfo : ICloneable, IFormatProvider
{
	// Fields
	private static DateTimeFormatInfo invariantInfo;
	private CultureData m_cultureData;
	internal string m_name;
	private string m_langName;
	private CompareInfo m_compareInfo;
	private CultureInfo m_cultureInfo;
	internal string amDesignator;
	internal string pmDesignator;
	internal string dateSeparator;
	internal string generalShortTimePattern;
	internal string generalLongTimePattern;
	internal string timeSeparator;
	internal string monthDayPattern;
	internal string dateTimeOffsetPattern;
	internal const string rfc1123Pattern;
	internal const string sortableDateTimePattern;
	internal const string universalSortableDateTimePattern;
	internal Calendar calendar;
	internal int firstDayOfWeek;
	internal int calendarWeekRule;
	internal string fullDateTimePattern;
	internal string[] abbreviatedDayNames;
	internal string[] m_superShortDayNames;
	internal string[] dayNames;
	internal string[] abbreviatedMonthNames;
	internal string[] monthNames;
	internal string[] genitiveMonthNames;
	internal string[] m_genitiveAbbreviatedMonthNames;
	internal string[] leapYearMonthNames;
	internal string longDatePattern;
	internal string shortDatePattern;
	internal string yearMonthPattern;
	internal string longTimePattern;
	internal string shortTimePattern;
	private string[] allYearMonthPatterns;
	internal string[] allShortDatePatterns;
	internal string[] allLongDatePatterns;
	internal string[] allShortTimePatterns;
	internal string[] allLongTimePatterns;
	internal string[] m_eraNames;
	internal string[] m_abbrevEraNames;
	internal string[] m_abbrevEnglishEraNames;
	internal int[] optionalCalendars;
	private const int DEFAULT_ALL_DATETIMES_SIZE;
	internal bool m_isReadOnly;
	internal DateTimeFormatFlags formatFlags;
	internal static bool preferExistingTokens;
	private int CultureID;
	private bool m_useUserOverride;
	private bool bUseCalendarInfo;
	private int nDataItem;
	internal bool m_isDefaultCalendar;
	private static Hashtable s_calendarNativeNames;
	internal string[] m_dateWords;
	private string m_fullTimeSpanPositivePattern;
	private string m_fullTimeSpanNegativePattern;
	internal const DateTimeStyles InvalidDateTimeStyles;
	private TokenHashValue[] m_dtfiTokenHash;
	private const int TOKEN_HASH_SIZE;
	private const int SECOND_PRIME;
	private const string dateSeparatorOrTimeZoneOffset;
	private const string invariantDateSeparator;
	private const string invariantTimeSeparator;
	internal const string IgnorablePeriod;
	internal const string IgnorableComma;
	internal const string CJKYearSuff;
	internal const string CJKMonthSuff;
	internal const string CJKDaySuff;
	internal const string KoreanYearSuff;
	internal const string KoreanMonthSuff;
	internal const string KoreanDaySuff;
	internal const string KoreanHourSuff;
	internal const string KoreanMinuteSuff;
	internal const string KoreanSecondSuff;
	internal const string CJKHourSuff;
	internal const string ChineseHourSuff;
	internal const string CJKMinuteSuff;
	internal const string CJKSecondSuff;
	internal const string LocalTimeMark;
	internal const string KoreanLangName;
	internal const string JapaneseLangName;
	internal const string EnglishLangName;
	private static DateTimeFormatInfo s_jajpDTFI;
	private static DateTimeFormatInfo s_zhtwDTFI;

	// Properties
	private string CultureName { get; }
	private CultureInfo Culture { get; }
	private string LanguageName { get; }
	public static DateTimeFormatInfo InvariantInfo { get; }
	public static DateTimeFormatInfo CurrentInfo { get; }
	public string AMDesignator { get; }
	public Calendar Calendar { get; set; }
	private int[] OptionalCalendars { get; }
	internal string[] EraNames { get; }
	internal string[] AbbreviatedEraNames { get; }
	internal string[] AbbreviatedEnglishEraNames { get; }
	public string DateSeparator { get; }
	public string FullDateTimePattern { get; }
	public string LongDatePattern { get; set; }
	public string LongTimePattern { get; set; }
	public string MonthDayPattern { get; }
	public string PMDesignator { get; }
	public string RFC1123Pattern { get; }
	public string ShortDatePattern { get; set; }
	public string ShortTimePattern { get; set; }
	public string SortableDateTimePattern { get; }
	internal string GeneralShortTimePattern { get; }
	internal string GeneralLongTimePattern { get; }
	internal string DateTimeOffsetPattern { get; }
	public string TimeSeparator { get; }
	public string UniversalSortableDateTimePattern { get; }
	public string YearMonthPattern { get; set; }
	public string[] AbbreviatedDayNames { get; }
	public string[] DayNames { get; }
	public string[] AbbreviatedMonthNames { get; }
	public string[] MonthNames { get; }
	internal bool HasSpacesInMonthNames { get; }
	internal bool HasSpacesInDayNames { get; }
	private string[] AllYearMonthPatterns { get; }
	private string[] AllShortDatePatterns { get; }
	private string[] AllShortTimePatterns { get; }
	private string[] AllLongDatePatterns { get; }
	private string[] AllLongTimePatterns { get; }
	private string[] UnclonedYearMonthPatterns { get; }
	private string[] UnclonedShortDatePatterns { get; }
	private string[] UnclonedLongDatePatterns { get; }
	private string[] UnclonedShortTimePatterns { get; }
	private string[] UnclonedLongTimePatterns { get; }
	public bool IsReadOnly { get; }
	public string[] MonthGenitiveNames { get; }
	internal string FullTimeSpanPositivePattern { get; }
	internal string FullTimeSpanNegativePattern { get; }
	internal CompareInfo CompareInfo { get; }
	internal DateTimeFormatFlags FormatFlags { get; }
	internal bool HasForceTwoDigitYears { get; }
	internal bool HasYearMonthAdjustment { get; }

	// Methods
	private static bool InitPreferExistingTokens();
	private string get_CultureName();
	private CultureInfo get_Culture();
	private string get_LanguageName();
	private string[] internalGetAbbreviatedDayOfWeekNames();
	private string[] internalGetDayOfWeekNames();
	private string[] internalGetAbbreviatedMonthNames();
	private string[] internalGetMonthNames();
	public void .ctor();
	internal void .ctor(CultureData cultureData, Calendar cal);
	private void InitializeOverridableProperties(CultureData cultureData, int calendarID);
	private void OnDeserialized(StreamingContext ctx);
	private void OnSerializing(StreamingContext ctx);
	public static DateTimeFormatInfo get_InvariantInfo();
	public static DateTimeFormatInfo get_CurrentInfo();
	public static DateTimeFormatInfo GetInstance(IFormatProvider provider);
	public object GetFormat(Type formatType);
	public object Clone();
	public string get_AMDesignator();
	public Calendar get_Calendar();
	public void set_Calendar(Calendar value);
	private int[] get_OptionalCalendars();
	internal string[] get_EraNames();
	public string GetEraName(int era);
	internal string[] get_AbbreviatedEraNames();
	public string GetAbbreviatedEraName(int era);
	internal string[] get_AbbreviatedEnglishEraNames();
	public string get_DateSeparator();
	public string get_FullDateTimePattern();
	public string get_LongDatePattern();
	public void set_LongDatePattern(string value);
	public string get_LongTimePattern();
	public void set_LongTimePattern(string value);
	public string get_MonthDayPattern();
	public string get_PMDesignator();
	public string get_RFC1123Pattern();
	public string get_ShortDatePattern();
	public void set_ShortDatePattern(string value);
	public string get_ShortTimePattern();
	public void set_ShortTimePattern(string value);
	public string get_SortableDateTimePattern();
	internal string get_GeneralShortTimePattern();
	internal string get_GeneralLongTimePattern();
	internal string get_DateTimeOffsetPattern();
	public string get_TimeSeparator();
	public string get_UniversalSortableDateTimePattern();
	public string get_YearMonthPattern();
	public void set_YearMonthPattern(string value);
	public string[] get_AbbreviatedDayNames();
	public string[] get_DayNames();
	public string[] get_AbbreviatedMonthNames();
	public string[] get_MonthNames();
	internal bool get_HasSpacesInMonthNames();
	internal bool get_HasSpacesInDayNames();
	internal string internalGetMonthName(int month, MonthNameStyles style, bool abbreviated);
	private string[] internalGetGenitiveMonthNames(bool abbreviated);
	internal string[] internalGetLeapYearMonthNames();
	public string GetAbbreviatedDayName(DayOfWeek dayofweek);
	private static string[] GetCombinedPatterns(string[] patterns1, string[] patterns2, string connectString);
	public string[] GetAllDateTimePatterns(char format);
	public string GetDayName(DayOfWeek dayofweek);
	public string GetAbbreviatedMonthName(int month);
	public string GetMonthName(int month);
	private static string[] GetMergedPatterns(string[] patterns, string defaultPattern);
	private string[] get_AllYearMonthPatterns();
	private string[] get_AllShortDatePatterns();
	private string[] get_AllShortTimePatterns();
	private string[] get_AllLongDatePatterns();
	private string[] get_AllLongTimePatterns();
	private string[] get_UnclonedYearMonthPatterns();
	private string[] get_UnclonedShortDatePatterns();
	private string[] get_UnclonedLongDatePatterns();
	private string[] get_UnclonedShortTimePatterns();
	private string[] get_UnclonedLongTimePatterns();
	public bool get_IsReadOnly();
	public string[] get_MonthGenitiveNames();
	internal string get_FullTimeSpanPositivePattern();
	internal string get_FullTimeSpanNegativePattern();
	internal CompareInfo get_CompareInfo();
	internal static void ValidateStyles(DateTimeStyles style, string parameterName);
	internal DateTimeFormatFlags get_FormatFlags();
	internal bool get_HasForceTwoDigitYears();
	internal bool get_HasYearMonthAdjustment();
	internal bool YearMonthAdjustment(int year, int month, bool parsedMonthName);
	internal static DateTimeFormatInfo GetJapaneseCalendarDTFI();
	internal static DateTimeFormatInfo GetTaiwanCalendarDTFI();
	private void ClearTokenHashTable();
	internal TokenHashValue[] CreateTokenHashTable();
	private void AddMonthNames(TokenHashValue[] temp, string monthPostfix);
	private static bool TryParseHebrewNumber(__DTString str, out bool badFormat, out int number);
	private static bool IsHebrewChar(char ch);
	internal bool Tokenize(TokenType TokenMask, out TokenType tokenType, out int tokenValue, __DTString str);
	private void InsertAtCurrentHashNode(TokenHashValue[] hashTable, string str, char ch, TokenType tokenType, int tokenValue, int pos, int hashcode, int hashProbe);
	private void InsertHash(TokenHashValue[] hashTable, string str, TokenType tokenType, int tokenValue);
	private static void .cctor();

}
//NameSpace:System.Globalization
internal class TokenHashValue
{
	// Fields
	internal string tokenString;
	internal TokenType tokenType;
	internal int tokenValue;

	// Methods
	internal void .ctor(string tokenString, TokenType tokenType, int tokenValue);

}
//NameSpace:System.Globalization
internal enum FORMATFLAGS
{
	// Fields
	public int value__;
	public const FORMATFLAGS None;
	public const FORMATFLAGS UseGenitiveMonth;
	public const FORMATFLAGS UseLeapYearMonth;
	public const FORMATFLAGS UseSpacesInMonthNames;
	public const FORMATFLAGS UseHebrewParsing;
	public const FORMATFLAGS UseSpacesInDayNames;
	public const FORMATFLAGS UseDigitPrefixInTokens;

}
//NameSpace:System.Globalization
internal enum CalendarId
{
	// Fields
	public ushort value__;
	public const CalendarId GREGORIAN;
	public const CalendarId GREGORIAN_US;
	public const CalendarId JAPAN;
	public const CalendarId TAIWAN;
	public const CalendarId KOREA;
	public const CalendarId HIJRI;
	public const CalendarId THAI;
	public const CalendarId HEBREW;
	public const CalendarId GREGORIAN_ME_FRENCH;
	public const CalendarId GREGORIAN_ARABIC;
	public const CalendarId GREGORIAN_XLIT_ENGLISH;
	public const CalendarId GREGORIAN_XLIT_FRENCH;
	public const CalendarId JULIAN;
	public const CalendarId JAPANESELUNISOLAR;
	public const CalendarId CHINESELUNISOLAR;
	public const CalendarId SAKA;
	public const CalendarId LUNAR_ETO_CHN;
	public const CalendarId LUNAR_ETO_KOR;
	public const CalendarId LUNAR_ETO_ROKUYOU;
	public const CalendarId KOREANLUNISOLAR;
	public const CalendarId TAIWANLUNISOLAR;
	public const CalendarId PERSIAN;
	public const CalendarId UMALQURA;
	public const CalendarId LAST_CALENDAR;

}
//NameSpace:System.Globalization
internal class DateTimeFormatInfoScanner
{
	// Fields
	internal List`1<string> m_dateWords;
	private static Dictionary`2<stringstring> s_knownWords;
	private DateTimeFormatInfoScanner.FoundDatePattern m_ymdFlags;

	// Properties
	private static Dictionary`2<stringstring> KnownWords { get; }

	// Methods
	private static Dictionary`2<stringstring> get_KnownWords();
	internal static int SkipWhiteSpacesAndNonLetter(string pattern, int currentIndex);
	internal void AddDateWordOrPostfix(string formatPostfix, string str);
	internal int AddDateWords(string pattern, int index, string formatPostfix);
	internal static int ScanRepeatChar(string pattern, char ch, int index, out int count);
	internal void AddIgnorableSymbols(string text);
	internal void ScanDateWord(string pattern);
	internal string[] GetDateWordsOfDTFI(DateTimeFormatInfo dtfi);
	internal static FORMATFLAGS GetFormatFlagGenitiveMonth(string[] monthNames, string[] genitveMonthNames, string[] abbrevMonthNames, string[] genetiveAbbrevMonthNames);
	internal static FORMATFLAGS GetFormatFlagUseSpaceInMonthNames(string[] monthNames, string[] genitveMonthNames, string[] abbrevMonthNames, string[] genetiveAbbrevMonthNames);
	internal static FORMATFLAGS GetFormatFlagUseSpaceInDayNames(string[] dayNames, string[] abbrevDayNames);
	internal static FORMATFLAGS GetFormatFlagUseHebrewCalendar(int calID);
	private static bool EqualStringArrays(string[] array1, string[] array2);
	private static bool ArrayElementsHaveSpace(string[] array);
	private static bool ArrayElementsBeginWithDigit(string[] array);
	public void .ctor();

}
//NameSpace:
private enum DateTimeFormatInfoScanner.FoundDatePattern
{
	// Fields
	public int value__;
	public const DateTimeFormatInfoScanner.FoundDatePattern None;
	public const DateTimeFormatInfoScanner.FoundDatePattern FoundYearPatternFlag;
	public const DateTimeFormatInfoScanner.FoundDatePattern FoundMonthPatternFlag;
	public const DateTimeFormatInfoScanner.FoundDatePattern FoundDayPatternFlag;
	public const DateTimeFormatInfoScanner.FoundDatePattern FoundYMDPatternFlag;

}
//NameSpace:System.Globalization
public enum DateTimeStyles
{
	// Fields
	public int value__;
	public const DateTimeStyles None;
	public const DateTimeStyles AllowLeadingWhite;
	public const DateTimeStyles AllowTrailingWhite;
	public const DateTimeStyles AllowInnerWhite;
	public const DateTimeStyles AllowWhiteSpaces;
	public const DateTimeStyles NoCurrentDateDefault;
	public const DateTimeStyles AdjustToUniversal;
	public const DateTimeStyles AssumeLocal;
	public const DateTimeStyles AssumeUniversal;
	public const DateTimeStyles RoundtripKind;

}
//NameSpace:System.Globalization
public class GregorianCalendar : Calendar
{
	// Fields
	internal GregorianCalendarTypes m_type;
	internal static readonly int[] DaysToMonth365;
	internal static readonly int[] DaysToMonth366;
	private static Calendar s_defaultInstance;

	// Properties
	public override DateTime MinSupportedDateTime { get; }
	public override DateTime MaxSupportedDateTime { get; }
	internal override int ID { get; }
	public override int[] Eras { get; }
	public override int TwoDigitYearMax { get; }

	// Methods
	private void OnDeserialized(StreamingContext ctx);
	public override DateTime get_MinSupportedDateTime();
	public override DateTime get_MaxSupportedDateTime();
	internal static Calendar GetDefaultInstance();
	public void .ctor();
	public void .ctor(GregorianCalendarTypes type);
	internal override int get_ID();
	internal virtual int GetDatePart(long ticks, int part);
	public override int GetDayOfMonth(DateTime time);
	public override DayOfWeek GetDayOfWeek(DateTime time);
	public override int GetDaysInMonth(int year, int month, int era);
	public override int GetEra(DateTime time);
	public override int[] get_Eras();
	public override int GetMonth(DateTime time);
	public override int GetMonthsInYear(int year, int era);
	public override int GetYear(DateTime time);
	public override bool IsLeapYear(int year, int era);
	public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
	internal override bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, out DateTime result);
	public override int get_TwoDigitYearMax();
	public override int ToFourDigitYear(int year);
	private static void .cctor();

}
//NameSpace:System.Globalization
internal class EraInfo
{
	// Fields
	internal int era;
	internal long ticks;
	internal int yearOffset;
	internal int minEraYear;
	internal int maxEraYear;
	internal string eraName;
	internal string abbrevEraName;
	internal string englishEraName;

	// Methods
	internal void .ctor(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear);
	internal void .ctor(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear, string eraName, string abbrevEraName, string englishEraName);

}
//NameSpace:System.Globalization
internal class GregorianCalendarHelper
{
	// Fields
	internal static readonly int[] DaysToMonth365;
	internal static readonly int[] DaysToMonth366;
	internal int m_maxYear;
	internal int m_minYear;
	internal Calendar m_Cal;
	internal EraInfo[] m_EraInfo;
	internal int[] m_eras;
	internal DateTime m_minDate;

	// Properties
	internal int MaxYear { get; }
	public int[] Eras { get; }

	// Methods
	internal int get_MaxYear();
	internal void .ctor(Calendar cal, EraInfo[] eraInfo);
	internal int GetGregorianYear(int year, int era);
	internal bool IsValidYear(int year, int era);
	internal virtual int GetDatePart(long ticks, int part);
	internal static long GetAbsoluteDate(int year, int month, int day);
	internal static long DateToTicks(int year, int month, int day);
	internal static long TimeToTicks(int hour, int minute, int second, int millisecond);
	internal void CheckTicksRange(long ticks);
	public int GetDayOfMonth(DateTime time);
	public DayOfWeek GetDayOfWeek(DateTime time);
	public int GetDaysInMonth(int year, int month, int era);
	public int GetEra(DateTime time);
	public int[] get_Eras();
	public int GetMonth(DateTime time);
	public int GetMonthsInYear(int year, int era);
	public int GetYear(DateTime time);
	public bool IsLeapYear(int year, int era);
	public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
	private static void .cctor();

}
//NameSpace:System.Globalization
public enum GregorianCalendarTypes
{
	// Fields
	public int value__;
	public const GregorianCalendarTypes Localized;
	public const GregorianCalendarTypes USEnglish;
	public const GregorianCalendarTypes MiddleEastFrench;
	public const GregorianCalendarTypes Arabic;
	public const GregorianCalendarTypes TransliteratedEnglish;
	public const GregorianCalendarTypes TransliteratedFrench;

}
//NameSpace:System.Globalization
internal struct HebrewNumberParsingContext
{
	// Fields
	internal HebrewNumber.HS state;
	internal int result;

	// Methods
	public void .ctor(int result);

}
//NameSpace:System.Globalization
internal enum HebrewNumberParsingState
{
	// Fields
	public int value__;
	public const HebrewNumberParsingState InvalidHebrewNumber;
	public const HebrewNumberParsingState NotHebrewDigit;
	public const HebrewNumberParsingState FoundEndOfHebrewNumber;
	public const HebrewNumberParsingState ContinueParsing;

}
//NameSpace:System.Globalization
internal class HebrewNumber
{
	// Fields
	private static HebrewNumber.HebrewValue[] HebrewValues;
	private static char maxHebrewNumberCh;
	private static readonly HebrewNumber.HS[][] NumberPasingState;

	// Methods
	internal static string ToString(int Number);
	internal static HebrewNumberParsingState ParseByChar(char ch, HebrewNumberParsingContext context);
	internal static bool IsDigit(char ch);
	private static void .cctor();

}
//NameSpace:
private enum HebrewNumber.HebrewToken
{
	// Fields
	public int value__;
	public const HebrewNumber.HebrewToken Invalid;
	public const HebrewNumber.HebrewToken Digit400;
	public const HebrewNumber.HebrewToken Digit200_300;
	public const HebrewNumber.HebrewToken Digit100;
	public const HebrewNumber.HebrewToken Digit10;
	public const HebrewNumber.HebrewToken Digit1;
	public const HebrewNumber.HebrewToken Digit6_7;
	public const HebrewNumber.HebrewToken Digit7;
	public const HebrewNumber.HebrewToken Digit9;
	public const HebrewNumber.HebrewToken SingleQuote;
	public const HebrewNumber.HebrewToken DoubleQuote;

}
//NameSpace:
private class HebrewNumber.HebrewValue
{
	// Fields
	internal HebrewNumber.HebrewToken token;
	internal int value;

	// Methods
	internal void .ctor(HebrewNumber.HebrewToken token, int value);

}
//NameSpace:
internal enum HebrewNumber.HS
{
	// Fields
	public int value__;
	public const HebrewNumber.HS _err;
	public const HebrewNumber.HS Start;
	public const HebrewNumber.HS S400;
	public const HebrewNumber.HS S400_400;
	public const HebrewNumber.HS S400_X00;
	public const HebrewNumber.HS S400_X0;
	public const HebrewNumber.HS X00_DQ;
	public const HebrewNumber.HS S400_X00_X0;
	public const HebrewNumber.HS X0_DQ;
	public const HebrewNumber.HS X;
	public const HebrewNumber.HS X0;
	public const HebrewNumber.HS X00;
	public const HebrewNumber.HS S400_DQ;
	public const HebrewNumber.HS S400_400_DQ;
	public const HebrewNumber.HS S400_400_100;
	public const HebrewNumber.HS S9;
	public const HebrewNumber.HS X00_S9;
	public const HebrewNumber.HS S9_DQ;
	public const HebrewNumber.HS END;

}
//NameSpace:System.Globalization
public class JapaneseCalendar : Calendar
{
	// Fields
	internal static readonly DateTime calendarMinValue;
	internal static EraInfo[] japaneseEraInfo;
	internal static Calendar s_defaultInstance;
	internal GregorianCalendarHelper helper;

	// Properties
	public override DateTime MinSupportedDateTime { get; }
	public override DateTime MaxSupportedDateTime { get; }
	internal override int ID { get; }
	public override int[] Eras { get; }
	public override int TwoDigitYearMax { get; }

	// Methods
	public override DateTime get_MinSupportedDateTime();
	public override DateTime get_MaxSupportedDateTime();
	internal static EraInfo[] GetEraInfo();
	private static EraInfo[] GetErasFromRegistry();
	internal static Calendar GetDefaultInstance();
	public void .ctor();
	internal override int get_ID();
	public override int GetDaysInMonth(int year, int month, int era);
	public override int GetDayOfMonth(DateTime time);
	public override DayOfWeek GetDayOfWeek(DateTime time);
	public override int GetMonthsInYear(int year, int era);
	public override int GetEra(DateTime time);
	public override int GetMonth(DateTime time);
	public override int GetYear(DateTime time);
	public override bool IsLeapYear(int year, int era);
	public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
	public override int ToFourDigitYear(int year);
	public override int[] get_Eras();
	internal static string[] EraNames();
	internal static string[] AbbrevEraNames();
	internal static string[] EnglishEraNames();
	internal override bool IsValidYear(int year, int era);
	public override int get_TwoDigitYearMax();
	private static void .cctor();

}
//NameSpace:System.Globalization
public sealed class NumberFormatInfo : ICloneable, IFormatProvider
{
	// Fields
	private static NumberFormatInfo invariantInfo;
	internal int[] numberGroupSizes;
	internal int[] currencyGroupSizes;
	internal int[] percentGroupSizes;
	internal string positiveSign;
	internal string negativeSign;
	internal string numberDecimalSeparator;
	internal string numberGroupSeparator;
	internal string currencyGroupSeparator;
	internal string currencyDecimalSeparator;
	internal string currencySymbol;
	internal string ansiCurrencySymbol;
	internal string nanSymbol;
	internal string positiveInfinitySymbol;
	internal string negativeInfinitySymbol;
	internal string percentDecimalSeparator;
	internal string percentGroupSeparator;
	internal string percentSymbol;
	internal string perMilleSymbol;
	internal string[] nativeDigits;
	internal int m_dataItem;
	internal int numberDecimalDigits;
	internal int currencyDecimalDigits;
	internal int currencyPositivePattern;
	internal int currencyNegativePattern;
	internal int numberNegativePattern;
	internal int percentPositivePattern;
	internal int percentNegativePattern;
	internal int percentDecimalDigits;
	internal int digitSubstitution;
	internal bool isReadOnly;
	internal bool m_useUserOverride;
	internal bool m_isInvariant;
	internal bool validForParseAsNumber;
	internal bool validForParseAsCurrency;
	private const NumberStyles InvalidNumberStyles;

	// Properties
	public static NumberFormatInfo InvariantInfo { get; }
	public int CurrencyDecimalDigits { get; }
	public string CurrencyDecimalSeparator { get; }
	public bool IsReadOnly { get; }
	public int[] CurrencyGroupSizes { get; }
	public int[] NumberGroupSizes { get; }
	public int[] PercentGroupSizes { get; }
	public string CurrencyGroupSeparator { get; }
	public string CurrencySymbol { get; }
	public static NumberFormatInfo CurrentInfo { get; }
	public string NaNSymbol { get; }
	public int CurrencyNegativePattern { get; }
	public int NumberNegativePattern { get; }
	public int PercentPositivePattern { get; }
	public int PercentNegativePattern { get; }
	public string NegativeInfinitySymbol { get; }
	public string NegativeSign { get; }
	public int NumberDecimalDigits { get; }
	public string NumberDecimalSeparator { get; }
	public string NumberGroupSeparator { get; }
	public int CurrencyPositivePattern { get; }
	public string PositiveInfinitySymbol { get; }
	public string PositiveSign { get; }
	public int PercentDecimalDigits { get; }
	public string PercentDecimalSeparator { get; }
	public string PercentGroupSeparator { get; }
	public string PercentSymbol { get; }
	public string PerMilleSymbol { get; }

	// Methods
	public void .ctor();
	private void OnSerializing(StreamingContext ctx);
	private void OnDeserializing(StreamingContext ctx);
	private void OnDeserialized(StreamingContext ctx);
	internal void .ctor(CultureData cultureData);
	public static NumberFormatInfo get_InvariantInfo();
	public static NumberFormatInfo GetInstance(IFormatProvider formatProvider);
	public object Clone();
	public int get_CurrencyDecimalDigits();
	public string get_CurrencyDecimalSeparator();
	public bool get_IsReadOnly();
	public int[] get_CurrencyGroupSizes();
	public int[] get_NumberGroupSizes();
	public int[] get_PercentGroupSizes();
	public string get_CurrencyGroupSeparator();
	public string get_CurrencySymbol();
	public static NumberFormatInfo get_CurrentInfo();
	public string get_NaNSymbol();
	public int get_CurrencyNegativePattern();
	public int get_NumberNegativePattern();
	public int get_PercentPositivePattern();
	public int get_PercentNegativePattern();
	public string get_NegativeInfinitySymbol();
	public string get_NegativeSign();
	public int get_NumberDecimalDigits();
	public string get_NumberDecimalSeparator();
	public string get_NumberGroupSeparator();
	public int get_CurrencyPositivePattern();
	public string get_PositiveInfinitySymbol();
	public string get_PositiveSign();
	public int get_PercentDecimalDigits();
	public string get_PercentDecimalSeparator();
	public string get_PercentGroupSeparator();
	public string get_PercentSymbol();
	public string get_PerMilleSymbol();
	public object GetFormat(Type formatType);
	public static NumberFormatInfo ReadOnly(NumberFormatInfo nfi);
	internal static void ValidateParseStyleInteger(NumberStyles style);
	internal static void ValidateParseStyleFloatingPoint(NumberStyles style);

}
//NameSpace:System.Globalization
public enum NumberStyles
{
	// Fields
	public int value__;
	public const NumberStyles None;
	public const NumberStyles AllowLeadingWhite;
	public const NumberStyles AllowTrailingWhite;
	public const NumberStyles AllowLeadingSign;
	public const NumberStyles AllowTrailingSign;
	public const NumberStyles AllowParentheses;
	public const NumberStyles AllowDecimalPoint;
	public const NumberStyles AllowThousands;
	public const NumberStyles AllowExponent;
	public const NumberStyles AllowCurrencySymbol;
	public const NumberStyles AllowHexSpecifier;
	public const NumberStyles Integer;
	public const NumberStyles HexNumber;
	public const NumberStyles Number;
	public const NumberStyles Float;
	public const NumberStyles Currency;
	public const NumberStyles Any;

}
//NameSpace:System.Globalization
public sealed class SortVersion : IEquatable`1<SortVersion>
{
	// Fields
	private int m_NlsVersion;
	private Guid m_SortId;

	// Methods
	public override bool Equals(object obj);
	public bool Equals(SortVersion other);
	public override int GetHashCode();
	public static bool op_Equality(SortVersion left, SortVersion right);
	public static bool op_Inequality(SortVersion left, SortVersion right);

}
//NameSpace:System.Globalization
public class TaiwanCalendar : Calendar
{
	// Fields
	internal static EraInfo[] taiwanEraInfo;
	internal static Calendar s_defaultInstance;
	internal GregorianCalendarHelper helper;
	internal static readonly DateTime calendarMinValue;

	// Properties
	public override DateTime MinSupportedDateTime { get; }
	public override DateTime MaxSupportedDateTime { get; }
	internal override int ID { get; }
	public override int[] Eras { get; }
	public override int TwoDigitYearMax { get; }

	// Methods
	internal static Calendar GetDefaultInstance();
	public override DateTime get_MinSupportedDateTime();
	public override DateTime get_MaxSupportedDateTime();
	public void .ctor();
	internal override int get_ID();
	public override int GetDaysInMonth(int year, int month, int era);
	public override int GetDayOfMonth(DateTime time);
	public override DayOfWeek GetDayOfWeek(DateTime time);
	public override int GetMonthsInYear(int year, int era);
	public override int GetEra(DateTime time);
	public override int GetMonth(DateTime time);
	public override int GetYear(DateTime time);
	public override bool IsLeapYear(int year, int era);
	public override DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
	public override int[] get_Eras();
	public override int get_TwoDigitYearMax();
	public override int ToFourDigitYear(int year);
	private static void .cctor();

}
//NameSpace:System.Globalization
public class TextInfo : ICloneable, IDeserializationCallback
{
	// Fields
	private bool m_isReadOnly;
	private string m_cultureName;
	private CultureData m_cultureData;
	private string m_textInfoName;
	private Nullable`1<bool> m_IsAsciiCasingSameAsInvariant;
	internal static TextInfo s_Invariant;
	private string customCultureName;
	internal bool m_useUserOverride;
	internal int m_win32LangID;

	// Properties
	internal static TextInfo Invariant { get; }
	public string CultureName { get; }
	private bool IsAsciiCasingSameAsInvariant { get; }

	// Methods
	internal static TextInfo get_Invariant();
	internal void .ctor(CultureData cultureData);
	private void OnDeserializing(StreamingContext ctx);
	private void OnDeserialized();
	private void OnDeserialized(StreamingContext ctx);
	private void OnSerializing(StreamingContext ctx);
	internal static int GetHashCodeOrdinalIgnoreCase(string s);
	internal static int GetHashCodeOrdinalIgnoreCase(string s, bool forceRandomizedHashing, long additionalEntropy);
	internal static int CompareOrdinalIgnoreCase(string str1, string str2);
	internal static int CompareOrdinalIgnoreCaseEx(string strA, int indexA, string strB, int indexB, int lengthA, int lengthB);
	internal static int IndexOfStringOrdinalIgnoreCase(string source, string value, int startIndex, int count);
	internal static int LastIndexOfStringOrdinalIgnoreCase(string source, string value, int startIndex, int count);
	public string get_CultureName();
	public virtual object Clone();
	internal void SetReadOnlyState(bool readOnly);
	public virtual char ToLower(char c);
	public virtual string ToLower(string str);
	private static char ToLowerAsciiInvariant(char c);
	public virtual char ToUpper(char c);
	public virtual string ToUpper(string str);
	private static char ToUpperAsciiInvariant(char c);
	private static bool IsAscii(char c);
	private bool get_IsAsciiCasingSameAsInvariant();
	public override bool Equals(object obj);
	public override int GetHashCode();
	public override string ToString();
	private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
	internal int GetCaseInsensitiveHashCode(string str);
	internal int GetCaseInsensitiveHashCode(string str, bool forceRandomizedHashing, long additionalEntropy);
	private int GetInvariantCaseInsensitiveHashCode(string str);
	private string ToUpperInternal(string str);
	private string ToLowerInternal(string str);
	private char ToUpperInternal(char c);
	private char ToLowerInternal(char c);
	private static int InternalCompareStringOrdinalIgnoreCase(string strA, int indexA, string strB, int indexB, int lenA, int lenB);
	internal void .ctor();

}
//NameSpace:System.Globalization
internal static class TimeSpanFormat
{
	// Fields
	internal static readonly TimeSpanFormat.FormatLiterals PositiveInvariantFormatLiterals;
	internal static readonly TimeSpanFormat.FormatLiterals NegativeInvariantFormatLiterals;

	// Methods
	private static string IntToString(int n, int digits);
	internal static string Format(TimeSpan value, string format, IFormatProvider formatProvider);
	private static string FormatStandard(TimeSpan value, bool isInvariant, string format, TimeSpanFormat.Pattern pattern);
	internal static string FormatCustomized(TimeSpan value, string format, DateTimeFormatInfo dtfi);
	private static void .cctor();

}
//NameSpace:
internal enum TimeSpanFormat.Pattern
{
	// Fields
	public int value__;
	public const TimeSpanFormat.Pattern None;
	public const TimeSpanFormat.Pattern Minimum;
	public const TimeSpanFormat.Pattern Full;

}
//NameSpace:
internal struct TimeSpanFormat.FormatLiterals
{
	// Fields
	internal string AppCompatLiteral;
	internal int dd;
	internal int hh;
	internal int mm;
	internal int ss;
	internal int ff;
	private string[] literals;

	// Properties
	internal string Start { get; }
	internal string DayHourSep { get; }
	internal string HourMinuteSep { get; }
	internal string MinuteSecondSep { get; }
	internal string SecondFractionSep { get; }
	internal string End { get; }

	// Methods
	internal string get_Start();
	internal string get_DayHourSep();
	internal string get_HourMinuteSep();
	internal string get_MinuteSecondSep();
	internal string get_SecondFractionSep();
	internal string get_End();
	internal static TimeSpanFormat.FormatLiterals InitInvariant(bool isNegative);
	internal void Init(string format, bool useInvariantFieldLengths);

}
//NameSpace:System.Globalization
public enum UnicodeCategory
{
	// Fields
	public int value__;
	public const UnicodeCategory UppercaseLetter;
	public const UnicodeCategory LowercaseLetter;
	public const UnicodeCategory TitlecaseLetter;
	public const UnicodeCategory ModifierLetter;
	public const UnicodeCategory OtherLetter;
	public const UnicodeCategory NonSpacingMark;
	public const UnicodeCategory SpacingCombiningMark;
	public const UnicodeCategory EnclosingMark;
	public const UnicodeCategory DecimalDigitNumber;
	public const UnicodeCategory LetterNumber;
	public const UnicodeCategory OtherNumber;
	public const UnicodeCategory SpaceSeparator;
	public const UnicodeCategory LineSeparator;
	public const UnicodeCategory ParagraphSeparator;
	public const UnicodeCategory Control;
	public const UnicodeCategory Format;
	public const UnicodeCategory Surrogate;
	public const UnicodeCategory PrivateUse;
	public const UnicodeCategory ConnectorPunctuation;
	public const UnicodeCategory DashPunctuation;
	public const UnicodeCategory OpenPunctuation;
	public const UnicodeCategory ClosePunctuation;
	public const UnicodeCategory InitialQuotePunctuation;
	public const UnicodeCategory FinalQuotePunctuation;
	public const UnicodeCategory OtherPunctuation;
	public const UnicodeCategory MathSymbol;
	public const UnicodeCategory CurrencySymbol;
	public const UnicodeCategory ModifierSymbol;
	public const UnicodeCategory OtherSymbol;
	public const UnicodeCategory OtherNotAssigned;

}
//NameSpace:System.Globalization
public class SortKey
{
	// Fields
	private readonly string source;
	private readonly byte[] key;
	private readonly CompareOptions options;
	private readonly int lcid;

	// Properties
	public virtual string OriginalString { get; }
	public virtual byte[] KeyData { get; }

	// Methods
	public static int Compare(SortKey sortkey1, SortKey sortkey2);
	internal void .ctor(int lcid, string source, CompareOptions opt);
	internal void .ctor(int lcid, string source, byte[] buffer, CompareOptions opt, int lv1Length, int lv2Length, int lv3Length, int kanaSmallLength, int markTypeLength, int katakanaLength, int kanaWidthLength, int identLength);
	public virtual string get_OriginalString();
	public virtual byte[] get_KeyData();
	public override bool Equals(object value);
	public override int GetHashCode();
	public override string ToString();
	internal void .ctor();

}
//NameSpace:System.Globalization
internal class CultureData
{
	// Fields
	private string sAM1159;
	private string sPM2359;
	private string sTimeSeparator;
	private string[] saLongTimes;
	private string[] saShortTimes;
	private int iFirstDayOfWeek;
	private int iFirstWeekOfYear;
	private int[] waCalendars;
	private CalendarData[] calendars;
	private string sISO639Language;
	private readonly string sRealName;
	private bool bUseOverrides;
	private int calendarId;
	private int numberIndex;
	private int iDefaultAnsiCodePage;
	private int iDefaultOemCodePage;
	private int iDefaultMacCodePage;
	private int iDefaultEbcdicCodePage;
	private bool isRightToLeft;
	private string sListSeparator;
	private static CultureData s_Invariant;

	// Properties
	public static CultureData Invariant { get; }
	internal string[] LongTimes { get; }
	internal string[] ShortTimes { get; }
	internal string SISO639LANGNAME { get; }
	internal int IFIRSTDAYOFWEEK { get; }
	internal int IFIRSTWEEKOFYEAR { get; }
	internal string SAM1159 { get; }
	internal string SPM2359 { get; }
	internal string TimeSeparator { get; }
	internal int[] CalendarIds { get; }
	internal bool IsInvariantCulture { get; }
	internal string CultureName { get; }
	internal string SCOMPAREINFO { get; }
	internal string STEXTINFO { get; }
	internal int ILANGUAGE { get; }
	internal bool UseUserOverride { get; }

	// Methods
	private void .ctor(string name);
	public static CultureData get_Invariant();
	public static CultureData GetCultureData(string cultureName, bool useUserOverride);
	public static CultureData GetCultureData(string cultureName, bool useUserOverride, int datetimeIndex, int calendarId, int numberIndex, string iso2lang, int ansiCodePage, int oemCodePage, int macCodePage, int ebcdicCodePage, bool rightToLeft, string listSeparator);
	internal static CultureData GetCultureData(int culture, bool bUseUserOverride);
	private void fill_culture_data(int datetimeIndex);
	public CalendarData GetCalendar(int calendarId);
	internal string[] get_LongTimes();
	internal string[] get_ShortTimes();
	internal string get_SISO639LANGNAME();
	internal int get_IFIRSTDAYOFWEEK();
	internal int get_IFIRSTWEEKOFYEAR();
	internal string get_SAM1159();
	internal string get_SPM2359();
	internal string get_TimeSeparator();
	internal int[] get_CalendarIds();
	internal bool get_IsInvariantCulture();
	internal string get_CultureName();
	internal string get_SCOMPAREINFO();
	internal string get_STEXTINFO();
	internal int get_ILANGUAGE();
	internal bool get_UseUserOverride();
	internal string[] EraNames(int calendarId);
	internal string[] AbbrevEraNames(int calendarId);
	internal string[] AbbreviatedEnglishEraNames(int calendarId);
	internal string[] ShortDates(int calendarId);
	internal string[] LongDates(int calendarId);
	internal string[] YearMonths(int calendarId);
	internal string[] DayNames(int calendarId);
	internal string[] AbbreviatedDayNames(int calendarId);
	internal string[] MonthNames(int calendarId);
	internal string[] GenitiveMonthNames(int calendarId);
	internal string[] AbbreviatedMonthNames(int calendarId);
	internal string[] AbbreviatedGenitiveMonthNames(int calendarId);
	internal string[] LeapYearMonthNames(int calendarId);
	internal string MonthDay(int calendarId);
	internal string DateSeparator(int calendarId);
	private static string GetDateSeparator(string format);
	private static string GetSeparator(string format, string timeParts);
	private static int IndexOfTimePart(string format, int startIndex, string timeParts);
	private static string UnescapeNlsString(string str, int start, int end);
	internal static string[] ReescapeWin32Strings(string[] array);
	internal static string ReescapeWin32String(string str);
	internal void GetNFIValues(NumberFormatInfo nfi);
	private static void fill_number_data(NumberFormatInfo nfi, int numberIndex);

}
//NameSpace:System.Globalization
internal class CodePageDataItem
{
	// Fields
	internal int m_dataIndex;
	internal int m_uiFamilyCodePage;
	internal uint m_flags;
	private static readonly char[] sep;

	// Methods
	internal void .ctor(int dataIndex);
	private static void .cctor();

}
//NameSpace:System.Globalization
internal static class EncodingTable
{
	// Fields
	internal static InternalEncodingDataItem[] encodingDataPtr;
	internal static InternalCodePageDataItem[] codePageDataPtr;
	private static int lastEncodingItem;
	private static Hashtable hashByName;
	private static Hashtable hashByCodePage;

	// Methods
	private static int GetNumEncodingItems();
	private static InternalEncodingDataItem ENC(string name, ushort cp);
	private static InternalCodePageDataItem MapCodePageDataItem(ushort cp, ushort fcp, string names, uint flags);
	private static void .cctor();
	private static int internalGetCodePageFromName(string name);
	internal static int GetCodePageFromName(string name);
	internal static CodePageDataItem GetCodePageDataItem(int codepage);

}
//NameSpace:System.Globalization
internal struct InternalEncodingDataItem
{
	// Fields
	internal string webName;
	internal ushort codePage;

}
//NameSpace:System.Globalization
internal struct InternalCodePageDataItem
{
	// Fields
	internal ushort codePage;
	internal ushort uiFamilyCodePage;
	internal uint flags;
	internal string Names;

}
//NameSpace:System.Globalization
internal static class TextInfoToUpperData
{
	// Fields
	public static readonly char[] range_00e0_0586;
	public static readonly char[] range_1e01_1ff3;
	public static readonly char[] range_2170_2184;
	public static readonly char[] range_24d0_24e9;
	public static readonly char[] range_2c30_2ce3;
	public static readonly char[] range_2d00_2d25;
	public static readonly char[] range_a641_a697;
	public static readonly char[] range_a723_a78c;

	// Methods
	private static void .cctor();

}
//NameSpace:System.Globalization
internal static class TextInfoToLowerData
{
	// Fields
	public static readonly char[] range_00c0_0556;
	public static readonly char[] range_10a0_10c5;
	public static readonly char[] range_1e00_1ffc;
	public static readonly char[] range_2160_216f;
	public static readonly char[] range_24b6_24cf;
	public static readonly char[] range_2c00_2c2e;
	public static readonly char[] range_2c60_2ce2;
	public static readonly char[] range_a640_a696;
	public static readonly char[] range_a722_a78b;

	// Methods
	private static void .cctor();

}
//NameSpace:System.Globalization
public class CultureInfo : ICloneable, IFormatProvider
{
	// Fields
	private static CultureInfo invariant_culture_info;
	private static object shared_table_lock;
	private static CultureInfo default_current_culture;
	private bool m_isReadOnly;
	private int cultureID;
	private int parent_lcid;
	private int datetime_index;
	private int number_index;
	private int default_calendar_type;
	private bool m_useUserOverride;
	internal NumberFormatInfo numInfo;
	internal DateTimeFormatInfo dateTimeInfo;
	private TextInfo textInfo;
	internal string m_name;
	private string englishname;
	private string nativename;
	private string iso3lang;
	private string iso2lang;
	private string win3lang;
	private string territory;
	private string[] native_calendar_names;
	private CompareInfo compareInfo;
	private readonly void* textinfo_data;
	private int m_dataItem;
	private Calendar calendar;
	private CultureInfo parent_culture;
	private bool constructed;
	internal byte[] cached_serialized_form;
	internal CultureData m_cultureData;
	internal bool m_isInherited;
	internal const int InvariantCultureId;
	private const int CalendarTypeBits;
	private const string MSG_READONLY;
	private static CultureInfo s_DefaultThreadCurrentUICulture;
	private static CultureInfo s_DefaultThreadCurrentCulture;
	private static Dictionary`2<intCultureInfo> shared_by_number;
	private static Dictionary`2<stringCultureInfo> shared_by_name;
	internal static readonly bool IsTaiwanSku;

	// Properties
	public static CultureInfo InvariantCulture { get; }
	public static CultureInfo CurrentCulture { get; }
	public static CultureInfo CurrentUICulture { get; }
	internal string Territory { get; }
	public virtual int LCID { get; }
	public virtual string Name { get; }
	public virtual Calendar Calendar { get; }
	public virtual CultureInfo Parent { get; }
	public virtual TextInfo TextInfo { get; }
	public virtual CompareInfo CompareInfo { get; }
	public virtual bool IsNeutralCulture { get; }
	public virtual NumberFormatInfo NumberFormat { get; set; }
	public virtual DateTimeFormatInfo DateTimeFormat { get; set; }
	public virtual string EnglishName { get; }
	public bool IsReadOnly { get; }
	internal int CalendarType { get; }
	public static CultureInfo DefaultThreadCurrentCulture { get; }
	public static CultureInfo DefaultThreadCurrentUICulture { get; }
	internal string SortName { get; }
	internal static CultureInfo UserDefaultUICulture { get; }
	internal static CultureInfo UserDefaultCulture { get; }

	// Methods
	public static CultureInfo get_InvariantCulture();
	public static CultureInfo get_CurrentCulture();
	public static CultureInfo get_CurrentUICulture();
	internal static CultureInfo ConstructCurrentCulture();
	internal static CultureInfo ConstructCurrentUICulture();
	internal string get_Territory();
	public virtual int get_LCID();
	public virtual string get_Name();
	public virtual Calendar get_Calendar();
	public virtual CultureInfo get_Parent();
	public virtual TextInfo get_TextInfo();
	public virtual object Clone();
	public override bool Equals(object value);
	private CultureInfo.Data GetTextInfoData();
	public override int GetHashCode();
	public override string ToString();
	public virtual CompareInfo get_CompareInfo();
	public virtual bool get_IsNeutralCulture();
	private void CheckNeutral();
	public virtual NumberFormatInfo get_NumberFormat();
	public virtual void set_NumberFormat(NumberFormatInfo value);
	public virtual DateTimeFormatInfo get_DateTimeFormat();
	public virtual void set_DateTimeFormat(DateTimeFormatInfo value);
	public virtual string get_EnglishName();
	public bool get_IsReadOnly();
	public virtual object GetFormat(Type formatType);
	private void Construct();
	private bool construct_internal_locale_from_lcid(int lcid);
	private bool construct_internal_locale_from_name(string name);
	private static string get_current_locale_name();
	private void ConstructInvariant(bool read_only);
	private TextInfo CreateTextInfo(bool readOnly);
	public void .ctor(int culture);
	public void .ctor(int culture, bool useUserOverride);
	private void .ctor(int culture, bool useUserOverride, bool read_only);
	public void .ctor(string name);
	public void .ctor(string name, bool useUserOverride);
	private void .ctor(string name, bool useUserOverride, bool read_only);
	private void .ctor();
	private static void insert_into_shared_tables(CultureInfo c);
	public static CultureInfo GetCultureInfo(int culture);
	public static CultureInfo GetCultureInfo(string name);
	internal static CultureInfo CreateCulture(string name, bool reference);
	public static CultureInfo CreateSpecificCulture(string name);
	private static CultureInfo CreateSpecificCultureFromNeutral(string name);
	internal int get_CalendarType();
	private static Calendar CreateCalendar(int calendarType);
	private static Exception CreateNotFoundException(string name);
	public static CultureInfo get_DefaultThreadCurrentCulture();
	public static CultureInfo get_DefaultThreadCurrentUICulture();
	internal string get_SortName();
	internal static CultureInfo get_UserDefaultUICulture();
	internal static CultureInfo get_UserDefaultCulture();
	internal static void CheckDomainSafetyObject(object obj, object container);
	private static void .cctor();

}
//NameSpace:
private struct CultureInfo.Data
{
	// Fields
	public int ansi;
	public int ebcdic;
	public int mac;
	public int oem;
	public bool right_to_left;
	public byte list_sep;

}
//NameSpace:System.Globalization
public sealed class IdnMapping
{
	// Fields
	private bool allow_unassigned;
	private bool use_std3;
	private Punycode puny;

	// Methods
	public void .ctor();
	public override bool Equals(object obj);
	public override int GetHashCode();
	public string GetAscii(string unicode);
	public string GetAscii(string unicode, int index, int count);
	private string Convert(string input, int index, int count, bool toAscii);
	private string ToAscii(string s, int offset);
	private void VerifyLength(string s, int offset);
	private string NamePrep(string s, int offset);
	private void VerifyProhibitedCharacters(string s, int offset);
	private void VerifyStd3AsciiRules(string s, int offset);
	public string GetUnicode(string ascii);
	public string GetUnicode(string ascii, int index, int count);
	private string ToUnicode(string s, int offset);

}
//NameSpace:System.Globalization
internal class Bootstring
{
	// Fields
	private readonly char delimiter;
	private readonly int base_num;
	private readonly int tmin;
	private readonly int tmax;
	private readonly int skew;
	private readonly int damp;
	private readonly int initial_bias;
	private readonly int initial_n;

	// Methods
	public void .ctor(char delimiter, int baseNum, int tmin, int tmax, int skew, int damp, int initialBias, int initialN);
	public string Encode(string s, int offset);
	private char EncodeDigit(int d);
	private int DecodeDigit(char c);
	private int Adapt(int delta, int numPoints, bool firstTime);
	public string Decode(string s, int offset);

}
//NameSpace:System.Globalization
internal class Punycode : Bootstring
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Globalization
public class RegionInfo
{
	// Fields
	private static RegionInfo currentRegion;
	private int regionId;
	private string iso2Name;
	private string iso3Name;
	private string win3Name;
	private string englishName;
	private string nativeName;
	private string currencySymbol;
	private string isoCurrencySymbol;
	private string currencyEnglishName;
	private string currencyNativeName;

	// Properties
	public static RegionInfo CurrentRegion { get; }
	public virtual string CurrencyEnglishName { get; }
	public virtual string CurrencySymbol { get; }
	public virtual string DisplayName { get; }
	public virtual string EnglishName { get; }
	public virtual int GeoId { get; }
	public virtual bool IsMetric { get; }
	public virtual string ISOCurrencySymbol { get; }
	public virtual string NativeName { get; }
	public virtual string CurrencyNativeName { get; }
	public virtual string Name { get; }
	public virtual string ThreeLetterISORegionName { get; }
	public virtual string ThreeLetterWindowsRegionName { get; }
	public virtual string TwoLetterISORegionName { get; }

	// Methods
	public static RegionInfo get_CurrentRegion();
	public void .ctor(int culture);
	public void .ctor(string name);
	private void .ctor(CultureInfo ci);
	private bool GetByTerritory(CultureInfo ci);
	private bool construct_internal_region_from_name(string name);
	public virtual string get_CurrencyEnglishName();
	public virtual string get_CurrencySymbol();
	public virtual string get_DisplayName();
	public virtual string get_EnglishName();
	public virtual int get_GeoId();
	public virtual bool get_IsMetric();
	public virtual string get_ISOCurrencySymbol();
	public virtual string get_NativeName();
	public virtual string get_CurrencyNativeName();
	public virtual string get_Name();
	public virtual string get_ThreeLetterISORegionName();
	public virtual string get_ThreeLetterWindowsRegionName();
	public virtual string get_TwoLetterISORegionName();
	public override bool Equals(object value);
	public override int GetHashCode();
	public override string ToString();
	internal static void ClearCachedData();

}
//NameSpace:System.Diagnostics
public sealed class ConditionalAttribute : Attribute
{
	// Fields
	private string m_conditionString;

	// Methods
	public void .ctor(string conditionString);

}
//NameSpace:System.Diagnostics
public sealed class DebuggerStepThroughAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Diagnostics
public sealed class DebuggerHiddenAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Diagnostics
public sealed class DebuggerNonUserCodeAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Diagnostics
public sealed class DebuggableAttribute : Attribute
{
	// Fields
	private DebuggableAttribute.DebuggingModes m_debuggingModes;

	// Methods
	public void .ctor(DebuggableAttribute.DebuggingModes modes);

}
//NameSpace:
public enum DebuggableAttribute.DebuggingModes
{
	// Fields
	public int value__;
	public const DebuggableAttribute.DebuggingModes None;
	public const DebuggableAttribute.DebuggingModes Default;
	public const DebuggableAttribute.DebuggingModes DisableOptimizations;
	public const DebuggableAttribute.DebuggingModes IgnoreSymbolStoreSequencePoints;
	public const DebuggableAttribute.DebuggingModes EnableEditAndContinue;

}
//NameSpace:System.Diagnostics
public enum DebuggerBrowsableState
{
	// Fields
	public int value__;
	public const DebuggerBrowsableState Never;
	public const DebuggerBrowsableState Collapsed;
	public const DebuggerBrowsableState RootHidden;

}
//NameSpace:System.Diagnostics
public sealed class DebuggerBrowsableAttribute : Attribute
{
	// Fields
	private DebuggerBrowsableState state;

	// Methods
	public void .ctor(DebuggerBrowsableState state);

}
//NameSpace:System.Diagnostics
public sealed class DebuggerTypeProxyAttribute : Attribute
{
	// Fields
	private string typeName;

	// Methods
	public void .ctor(Type type);

}
//NameSpace:System.Diagnostics
public sealed class DebuggerDisplayAttribute : Attribute
{
	// Fields
	private string name;
	private string value;
	private string type;

	// Methods
	public void .ctor(string value);

}
//NameSpace:System.Diagnostics
public sealed class Debugger
{
	// Fields
	public static readonly string DefaultCategory;

	// Properties
	public static bool IsAttached { get; }

	// Methods
	public static bool get_IsAttached();
	private static bool IsAttached_internal();
	public static void NotifyOfCrossThreadDependency();
	private static void .cctor();

}
//NameSpace:System.Diagnostics
public class StackFrame
{
	// Fields
	public const int OFFSET_UNKNOWN;
	private int ilOffset;
	private int nativeOffset;
	private long methodAddress;
	private uint methodIndex;
	private MethodBase methodBase;
	private string fileName;
	private int lineNumber;
	private int columnNumber;
	private string internalMethodName;

	// Methods
	private static bool get_frame_info(int skip, bool needFileInfo, out MethodBase method, out int iloffset, out int native_offset, out string file, out int line, out int column);
	public void .ctor();
	public void .ctor(int skipFrames, bool fNeedFileInfo);
	public virtual int GetFileLineNumber();
	public virtual string GetFileName();
	internal string GetSecureFileName();
	public virtual int GetILOffset();
	public virtual MethodBase GetMethod();
	public virtual int GetNativeOffset();
	internal long GetMethodAddress();
	internal uint GetMethodIndex();
	internal string GetInternalMethodName();
	public override string ToString();

}
//NameSpace:System.Diagnostics
public class StackTrace
{
	// Fields
	public const int METHODS_TO_SKIP;
	private StackFrame[] frames;
	private readonly StackTrace[] captured_traces;
	private bool debug_info;
	private static bool isAotidSet;
	private static string aotid;

	// Properties
	public virtual int FrameCount { get; }

	// Methods
	public void .ctor();
	public void .ctor(bool fNeedFileInfo);
	public void .ctor(int skipFrames, bool fNeedFileInfo);
	private void init_frames(int skipFrames, bool fNeedFileInfo);
	private static StackFrame[] get_trace(Exception e, int skipFrames, bool fNeedFileInfo);
	public void .ctor(Exception e, bool fNeedFileInfo);
	public void .ctor(Exception e, int skipFrames, bool fNeedFileInfo);
	public virtual int get_FrameCount();
	public virtual StackFrame GetFrame(int index);
	private static string GetAotId();
	private bool AddFrames(StringBuilder sb);
	internal void GetFullNameForStackTrace(StringBuilder sb, MethodBase mi);
	public override string ToString();
	internal string ToString(StackTrace.TraceFormat traceFormat);

}
//NameSpace:
internal enum StackTrace.TraceFormat
{
	// Fields
	public int value__;
	public const StackTrace.TraceFormat Normal;
	public const StackTrace.TraceFormat TrailingNewLine;
	public const StackTrace.TraceFormat NoResourceLookup;

}
//NameSpace:System.Diagnostics.Tracing
public enum EventLevel
{
	// Fields
	public int value__;
	public const EventLevel LogAlways;
	public const EventLevel Critical;
	public const EventLevel Error;
	public const EventLevel Warning;
	public const EventLevel Informational;
	public const EventLevel Verbose;

}
//NameSpace:System.Diagnostics.Tracing
public enum EventKeywords
{
	// Fields
	public long value__;
	public const EventKeywords None;
	public const EventKeywords All;
	public const EventKeywords MicrosoftTelemetry;
	public const EventKeywords WdiContext;
	public const EventKeywords WdiDiagnostic;
	public const EventKeywords Sqm;
	public const EventKeywords AuditFailure;
	public const EventKeywords AuditSuccess;
	public const EventKeywords CorrelationHint;
	public const EventKeywords EventLogClassic;

}
//NameSpace:System.Diagnostics.Tracing
public sealed class EventAttribute : Attribute
{
	// Fields
	private int <EventId>k__BackingField;
	private EventLevel <Level>k__BackingField;

	// Properties
	private void EventId { set; }
	public void Level { set; }

	// Methods
	public void .ctor(int eventId);
	private void set_EventId(int value);
	public void set_Level(EventLevel value);

}
//NameSpace:System.Diagnostics.Tracing
public class EventSource : IDisposable
{
	// Fields
	private string <Name>k__BackingField;

	// Properties
	private void Name { set; }

	// Methods
	protected void .ctor();
	protected override void Finalize();
	private void set_Name(string value);
	public bool IsEnabled();
	public bool IsEnabled(EventLevel level, EventKeywords keywords);
	public void Dispose();
	protected virtual void Dispose(bool disposing);
	protected void WriteEvent(int eventId, int arg1);
	protected void WriteEvent(int eventId, object[] args);

}
//NameSpace:System.Diagnostics.Tracing
public sealed class EventSourceAttribute : Attribute
{
	// Fields
	private string <Guid>k__BackingField;
	private string <Name>k__BackingField;

	// Properties
	public void Guid { set; }
	public void Name { set; }

	// Methods
	public void set_Guid(string value);
	public void set_Name(string value);
	public void .ctor();

}
//NameSpace:System.Diagnostics.Contracts
public static class Contract
{
	// Methods
	public static bool ForAll(IEnumerable`1<T> collection, Predicate`1<T> predicate);

}
//NameSpace:System.Numerics.Hashing
internal static class HashHelpers
{
	// Fields
	public static readonly int RandomSeed;

	// Methods
	public static int Combine(int h1, int h2);
	private static void .cctor();

}
//NameSpace:System.Threading
public struct CancellationToken
{
	// Fields
	private CancellationTokenSource m_source;
	private static readonly Action`1<object> s_ActionToActionObjShunt;

	// Properties
	public static CancellationToken None { get; }
	public bool IsCancellationRequested { get; }
	public bool CanBeCanceled { get; }

	// Methods
	public static CancellationToken get_None();
	public bool get_IsCancellationRequested();
	public bool get_CanBeCanceled();
	internal void .ctor(CancellationTokenSource source);
	private static void ActionToActionObjShunt(object obj);
	internal CancellationTokenRegistration InternalRegisterWithoutEC(Action`1<object> callback, object state);
	private CancellationTokenRegistration Register(Action`1<object> callback, object state, bool useSynchronizationContext, bool useExecutionContext);
	public bool Equals(CancellationToken other);
	public override bool Equals(object other);
	public override int GetHashCode();
	public static bool op_Equality(CancellationToken left, CancellationToken right);
	public static bool op_Inequality(CancellationToken left, CancellationToken right);
	public void ThrowIfCancellationRequested();
	internal void ThrowIfSourceDisposed();
	private void ThrowOperationCanceledException();
	private static void ThrowObjectDisposedException();
	private static void .cctor();

}
//NameSpace:System.Threading
public struct CancellationTokenRegistration : IEquatable`1<CancellationTokenRegistration>, IDisposable
{
	// Fields
	private readonly CancellationCallbackInfo m_callbackInfo;
	private readonly SparselyPopulatedArrayAddInfo`1<CancellationCallbackInfo> m_registrationInfo;

	// Methods
	internal void .ctor(CancellationCallbackInfo callbackInfo, SparselyPopulatedArrayAddInfo`1<CancellationCallbackInfo> registrationInfo);
	internal bool TryDeregister();
	public void Dispose();
	public override bool Equals(object obj);
	public bool Equals(CancellationTokenRegistration other);
	public override int GetHashCode();

}
//NameSpace:System.Threading
public class CancellationTokenSource : IDisposable
{
	// Fields
	private static readonly CancellationTokenSource _staticSource_Set;
	private static readonly CancellationTokenSource _staticSource_NotCancelable;
	private static readonly int s_nLists;
	private ManualResetEvent m_kernelEvent;
	private SparselyPopulatedArray`1<CancellationCallbackInfo>[] m_registeredCallbacksLists;
	private int m_state;
	private int m_threadIDExecutingCallbacks;
	private bool m_disposed;
	private CancellationTokenRegistration[] m_linkingRegistrations;
	private static readonly Action`1<object> s_LinkedTokenCancelDelegate;
	private CancellationCallbackInfo m_executingCallback;
	private Timer m_timer;
	private static readonly TimerCallback s_timerCallback;

	// Properties
	public bool IsCancellationRequested { get; }
	internal bool IsCancellationCompleted { get; }
	internal bool IsDisposed { get; }
	internal int ThreadIDExecutingCallbacks { get; set; }
	public CancellationToken Token { get; }
	internal bool CanBeCanceled { get; }
	internal CancellationCallbackInfo ExecutingCallback { get; }

	// Methods
	private static void LinkedTokenCancelDelegate(object source);
	public bool get_IsCancellationRequested();
	internal bool get_IsCancellationCompleted();
	internal bool get_IsDisposed();
	internal void set_ThreadIDExecutingCallbacks(int value);
	internal int get_ThreadIDExecutingCallbacks();
	public CancellationToken get_Token();
	internal bool get_CanBeCanceled();
	internal CancellationCallbackInfo get_ExecutingCallback();
	public void .ctor();
	private void .ctor(bool set);
	public void Cancel();
	public void Cancel(bool throwOnFirstException);
	private static void TimerCallbackLogic(object obj);
	public void Dispose();
	protected virtual void Dispose(bool disposing);
	internal void ThrowIfDisposed();
	private static void ThrowObjectDisposedException();
	internal static CancellationTokenSource InternalGetStaticSource(bool set);
	internal CancellationTokenRegistration InternalRegister(Action`1<object> callback, object stateForCallback, SynchronizationContext targetSyncContext, ExecutionContext executionContext);
	private void NotifyCancellation(bool throwOnFirstException);
	private void ExecuteCallbackHandlers(bool throwOnFirstException);
	private void CancellationCallbackCoreWork_OnSyncContext(object obj);
	private void CancellationCallbackCoreWork(CancellationCallbackCoreWorkArguments args);
	public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token1, CancellationToken token2);
	internal void WaitForCallbackToComplete(CancellationCallbackInfo callbackInfo);
	private static void .cctor();

}
//NameSpace:System.Threading
internal struct CancellationCallbackCoreWorkArguments
{
	// Fields
	internal SparselyPopulatedArrayFragment`1<CancellationCallbackInfo> m_currArrayFragment;
	internal int m_currArrayIndex;

	// Methods
	public void .ctor(SparselyPopulatedArrayFragment`1<CancellationCallbackInfo> currArrayFragment, int currArrayIndex);

}
//NameSpace:System.Threading
internal class CancellationCallbackInfo
{
	// Fields
	internal readonly Action`1<object> Callback;
	internal readonly object StateForCallback;
	internal readonly SynchronizationContext TargetSyncContext;
	internal readonly ExecutionContext TargetExecutionContext;
	internal readonly CancellationTokenSource CancellationTokenSource;
	private static ContextCallback s_executionContextCallback;

	// Methods
	internal void .ctor(Action`1<object> callback, object stateForCallback, SynchronizationContext targetSyncContext, ExecutionContext targetExecutionContext, CancellationTokenSource cancellationTokenSource);
	internal void ExecuteCallback();
	private static void ExecutionContextCallback(object obj);

}
//NameSpace:System.Threading
internal class SparselyPopulatedArray`1
{
	// Fields
	private SparselyPopulatedArrayFragment`1<T> m_tail;

	// Properties
	internal SparselyPopulatedArrayFragment`1<T> Tail { get; }

	// Methods
	internal void .ctor(int initialSize);
	internal SparselyPopulatedArrayFragment`1<T> get_Tail();
	internal SparselyPopulatedArrayAddInfo`1<T> Add(T element);

}
//NameSpace:System.Threading
internal struct SparselyPopulatedArrayAddInfo`1
{
	// Fields
	private SparselyPopulatedArrayFragment`1<T> m_source;
	private int m_index;

	// Properties
	internal SparselyPopulatedArrayFragment`1<T> Source { get; }
	internal int Index { get; }

	// Methods
	internal void .ctor(SparselyPopulatedArrayFragment`1<T> source, int index);
	internal SparselyPopulatedArrayFragment`1<T> get_Source();
	internal int get_Index();

}
//NameSpace:System.Threading
internal class SparselyPopulatedArrayFragment`1
{
	// Fields
	internal readonly T[] m_elements;
	internal int m_freeCount;
	internal SparselyPopulatedArrayFragment`1<T> m_next;
	internal SparselyPopulatedArrayFragment`1<T> m_prev;

	// Properties
	internal T Item { get; }
	internal int Length { get; }
	internal SparselyPopulatedArrayFragment`1<T> Prev { get; }

	// Methods
	internal void .ctor(int size);
	internal void .ctor(int size, SparselyPopulatedArrayFragment`1<T> prev);
	internal T get_Item(int index);
	internal int get_Length();
	internal SparselyPopulatedArrayFragment`1<T> get_Prev();
	internal T SafeAtomicRemove(int index, T expectedElement);

}
//NameSpace:System.Threading
public static class LazyInitializer
{
	// Methods
	public static T EnsureInitialized(T target, Func`1<T> valueFactory);
	private static T EnsureInitializedCore(T target, Func`1<T> valueFactory);

}
//NameSpace:System.Threading
public class ManualResetEventSlim : IDisposable
{
	// Fields
	private object m_lock;
	private ManualResetEvent m_eventObj;
	private int m_combinedState;
	private static Action`1<object> s_cancellationTokenCallback;

	// Properties
	public WaitHandle WaitHandle { get; }
	public bool IsSet { get; set; }
	public int SpinCount { get; set; }
	private int Waiters { get; set; }

	// Methods
	public WaitHandle get_WaitHandle();
	public bool get_IsSet();
	private void set_IsSet(bool value);
	public int get_SpinCount();
	private void set_SpinCount(int value);
	private int get_Waiters();
	private void set_Waiters(int value);
	public void .ctor(bool initialState);
	public void .ctor(bool initialState, int spinCount);
	private void Initialize(bool initialState, int spinCount);
	private void EnsureLockObjectCreated();
	private bool LazyInitializeEvent();
	public void Set();
	private void Set(bool duringCancellation);
	public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
	public void Dispose();
	protected virtual void Dispose(bool disposing);
	private void ThrowIfDisposed();
	private static void CancellationTokenCallback(object obj);
	private void UpdateStateAtomically(int newBits, int updateBitsMask);
	private static int ExtractStatePortionAndShiftRight(int state, int mask, int rightBitShiftCount);
	private static int ExtractStatePortion(int state, int mask);
	private static void .cctor();

}
//NameSpace:System.Threading
public class SemaphoreSlim : IDisposable
{
	// Fields
	private int m_currentCount;
	private readonly int m_maxCount;
	private int m_waitCount;
	private object m_lockObj;
	private ManualResetEvent m_waitHandle;
	private SemaphoreSlim.TaskNode m_asyncHead;
	private SemaphoreSlim.TaskNode m_asyncTail;
	private static readonly Task`1<bool> s_trueTask;
	private static Action`1<object> s_cancellationTokenCanceledEventHandler;

	// Methods
	public void .ctor(int initialCount, int maxCount);
	public void Wait();
	public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
	private bool WaitUntilCountOrTimeout(int millisecondsTimeout, uint startTime, CancellationToken cancellationToken);
	public Task WaitAsync();
	public Task`1<bool> WaitAsync(int millisecondsTimeout, CancellationToken cancellationToken);
	private SemaphoreSlim.TaskNode CreateAndAddAsyncWaiter();
	private bool RemoveAsyncWaiter(SemaphoreSlim.TaskNode task);
	private Task`1<bool> WaitUntilCountOrTimeoutAsync(SemaphoreSlim.TaskNode asyncWaiter, int millisecondsTimeout, CancellationToken cancellationToken);
	public int Release();
	public int Release(int releaseCount);
	private static void QueueWaiterTask(SemaphoreSlim.TaskNode waiterTask);
	public void Dispose();
	protected virtual void Dispose(bool disposing);
	private static void CancellationTokenCanceledEventHandler(object obj);
	private void CheckDispose();
	private static string GetResourceString(string str);
	private static void .cctor();

}
//NameSpace:
private sealed class SemaphoreSlim.TaskNode : Task`1<bool>, IThreadPoolWorkItem
{
	// Fields
	internal SemaphoreSlim.TaskNode Prev;
	internal SemaphoreSlim.TaskNode Next;

	// Methods
	internal void .ctor();
	private void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
	private void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);

}
//NameSpace:
private struct SemaphoreSlim.<WaitUntilCountOrTimeoutAsync>d__31 : IAsyncStateMachine
{
	// Fields
	public int <>1__state;
	public AsyncTaskMethodBuilder`1<bool> <>t__builder;
	public CancellationToken cancellationToken;
	public SemaphoreSlim.TaskNode asyncWaiter;
	public int millisecondsTimeout;
	private CancellationTokenSource <cts>5__1;
	public SemaphoreSlim <>4__this;
	private object <>7__wrap1;
	private ConfiguredTaskAwaiter<Task> <>u__1;
	private ConfiguredTaskAwaiter<bool> <>u__2;

	// Methods
	private void MoveNext();
	private void SetStateMachine(IAsyncStateMachine stateMachine);

}
//NameSpace:System.Threading
public struct SpinLock
{
	// Fields
	private int m_owner;
	private static int MAXIMUM_WAITERS;

	// Properties
	public bool IsHeldByCurrentThread { get; }
	public bool IsThreadOwnerTrackingEnabled { get; }

	// Methods
	public void .ctor(bool enableThreadOwnerTracking);
	public void Enter(bool lockTaken);
	public void TryEnter(int millisecondsTimeout, bool lockTaken);
	private void ContinueTryEnter(int millisecondsTimeout, bool lockTaken);
	private void DecrementWaiters();
	private void ContinueTryEnterWithThreadTracking(int millisecondsTimeout, uint startTime, bool lockTaken);
	public void Exit(bool useMemoryBarrier);
	private void ExitSlowPath(bool useMemoryBarrier);
	public bool get_IsHeldByCurrentThread();
	public bool get_IsThreadOwnerTrackingEnabled();
	private static void .cctor();

}
//NameSpace:
internal class SpinLock.SystemThreading_SpinLockDebugView
{
}
//NameSpace:System.Threading
public struct SpinWait
{
	// Fields
	private int m_count;

	// Properties
	public bool NextSpinWillYield { get; }

	// Methods
	public bool get_NextSpinWillYield();
	public void SpinOnce();

}
//NameSpace:System.Threading
internal static class PlatformHelper
{
	// Fields
	private static int s_processorCount;
	private static int s_lastProcessorCountRefreshTicks;

	// Properties
	internal static int ProcessorCount { get; }
	internal static bool IsSingleProcessor { get; }

	// Methods
	internal static int get_ProcessorCount();
	internal static bool get_IsSingleProcessor();

}
//NameSpace:System.Threading
internal static class TimeoutHelper
{
	// Methods
	public static uint GetTime();
	public static int UpdateTimeOut(uint startTime, int originalWaitMillisecondsTimeout);

}
//NameSpace:System.Threading
public class AbandonedMutexException : SystemException
{
	// Fields
	private int m_MutexIndex;
	private Mutex m_Mutex;

	// Methods
	public void .ctor();
	public void .ctor(int location, WaitHandle handle);
	private void SetupException(int location, WaitHandle handle);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Threading
public sealed class AsyncLocal`1 : IAsyncLocal
{
	// Fields
	private readonly Action`1<AsyncLocalValueChangedArgs`1<T>> m_valueChangedHandler;

	// Methods
	private void System.Threading.IAsyncLocal.OnValueChanged(object previousValueObj, object currentValueObj, bool contextChanged);

}
//NameSpace:System.Threading
internal interface IAsyncLocal
{
	// Methods
	public abstract void OnValueChanged(object previousValue, object currentValue, bool contextChanged);

}
//NameSpace:System.Threading
public struct AsyncLocalValueChangedArgs`1
{
	// Fields
	private T <PreviousValue>k__BackingField;
	private T <CurrentValue>k__BackingField;
	private bool <ThreadContextChanged>k__BackingField;

	// Properties
	private void PreviousValue { set; }
	private void CurrentValue { set; }
	private void ThreadContextChanged { set; }

	// Methods
	private void set_PreviousValue(T value);
	private void set_CurrentValue(T value);
	private void set_ThreadContextChanged(bool value);
	internal void .ctor(T previousValue, T currentValue, bool contextChanged);

}
//NameSpace:System.Threading
public enum EventResetMode
{
	// Fields
	public int value__;
	public const EventResetMode AutoReset;
	public const EventResetMode ManualReset;

}
//NameSpace:System.Threading
public class EventWaitHandle : WaitHandle
{
	// Methods
	public void .ctor(bool initialState, EventResetMode mode);
	public void .ctor(bool initialState, EventResetMode mode, string name);
	public bool Reset();
	public bool Set();

}
//NameSpace:System.Threading
public sealed class ContextCallback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(object state);
	public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System.Threading
internal struct ExecutionContextSwitcher
{
	// Fields
	internal ExecutionContext.Reader outerEC;
	internal bool outerECBelongsToScope;
	internal object hecsw;
	internal Thread thread;

	// Methods
	internal bool UndoNoThrow();
	internal void Undo();

}
//NameSpace:System.Threading
public sealed class ExecutionContext : IDisposable, ISerializable
{
	// Fields
	private SynchronizationContext _syncContext;
	private SynchronizationContext _syncContextNoFlow;
	private LogicalCallContext _logicalCallContext;
	private IllogicalCallContext _illogicalCallContext;
	private ExecutionContext.Flags _flags;
	private Dictionary`2<IAsyncLocalobject> _localValues;
	private List`1<IAsyncLocal> _localChangeNotifications;
	private static readonly ExecutionContext s_dummyDefaultEC;

	// Properties
	internal bool isNewCapture { get; set; }
	internal bool isFlowSuppressed { get; set; }
	internal static ExecutionContext PreAllocatedDefault { get; }
	internal bool IsPreAllocatedDefault { get; }
	internal LogicalCallContext LogicalCallContext { get; set; }
	internal IllogicalCallContext IllogicalCallContext { get; set; }
	internal SynchronizationContext SynchronizationContext { get; set; }
	internal SynchronizationContext SynchronizationContextNoFlow { get; set; }

	// Methods
	internal bool get_isNewCapture();
	internal void set_isNewCapture(bool value);
	internal bool get_isFlowSuppressed();
	internal void set_isFlowSuppressed(bool value);
	internal static ExecutionContext get_PreAllocatedDefault();
	internal bool get_IsPreAllocatedDefault();
	internal void .ctor();
	internal void .ctor(bool isPreAllocatedDefault);
	internal static void OnAsyncLocalContextChanged(ExecutionContext previous, ExecutionContext current);
	internal LogicalCallContext get_LogicalCallContext();
	internal void set_LogicalCallContext(LogicalCallContext value);
	internal IllogicalCallContext get_IllogicalCallContext();
	internal void set_IllogicalCallContext(IllogicalCallContext value);
	internal SynchronizationContext get_SynchronizationContext();
	internal void set_SynchronizationContext(SynchronizationContext value);
	internal SynchronizationContext get_SynchronizationContextNoFlow();
	internal void set_SynchronizationContextNoFlow(SynchronizationContext value);
	public void Dispose();
	public static void Run(ExecutionContext executionContext, ContextCallback callback, object state);
	internal static void Run(ExecutionContext executionContext, ContextCallback callback, object state, bool preserveSyncCtx);
	internal static void RunInternal(ExecutionContext executionContext, ContextCallback callback, object state, bool preserveSyncCtx);
	internal static void EstablishCopyOnWriteScope(ExecutionContextSwitcher ecsw);
	private static void EstablishCopyOnWriteScope(Thread currentThread, bool knownNullWindowsIdentity, ExecutionContextSwitcher ecsw);
	internal static ExecutionContextSwitcher SetExecutionContext(ExecutionContext executionContext, bool preserveSyncCtx);
	public ExecutionContext CreateCopy();
	internal ExecutionContext CreateMutableCopy();
	public static bool IsFlowSuppressed();
	public static ExecutionContext Capture();
	internal static ExecutionContext FastCapture();
	internal static ExecutionContext Capture(StackCrawlMark stackMark, ExecutionContext.CaptureOptions options);
	public void GetObjectData(SerializationInfo info, StreamingContext context);
	private void .ctor(SerializationInfo info, StreamingContext context);
	internal bool IsDefaultFTContext(bool ignoreSyncCtx);
	private static void .cctor();

}
//NameSpace:
private enum ExecutionContext.Flags
{
	// Fields
	public int value__;
	public const ExecutionContext.Flags None;
	public const ExecutionContext.Flags IsNewCapture;
	public const ExecutionContext.Flags IsFlowSuppressed;
	public const ExecutionContext.Flags IsPreAllocatedDefault;

}
//NameSpace:
internal struct ExecutionContext.Reader
{
	// Fields
	private ExecutionContext m_ec;

	// Properties
	public bool IsNull { get; }
	public bool IsFlowSuppressed { get; }
	public SynchronizationContext SynchronizationContext { get; }
	public SynchronizationContext SynchronizationContextNoFlow { get; }
	public LogicalCallContext.Reader LogicalCallContext { get; }

	// Methods
	public void .ctor(ExecutionContext ec);
	public ExecutionContext DangerousGetRawExecutionContext();
	public bool get_IsNull();
	public bool IsDefaultFTContext(bool ignoreSyncCtx);
	public bool get_IsFlowSuppressed();
	public SynchronizationContext get_SynchronizationContext();
	public SynchronizationContext get_SynchronizationContextNoFlow();
	public LogicalCallContext.Reader get_LogicalCallContext();
	public bool HasSameLocalValues(ExecutionContext other);

}
//NameSpace:
internal enum ExecutionContext.CaptureOptions
{
	// Fields
	public int value__;
	public const ExecutionContext.CaptureOptions None;
	public const ExecutionContext.CaptureOptions IgnoreSyncCtx;
	public const ExecutionContext.CaptureOptions OptimizeDefaultCase;

}
//NameSpace:System.Threading
public class LockRecursionException : Exception
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Threading
public sealed class ManualResetEvent : EventWaitHandle
{
	// Methods
	public void .ctor(bool initialState);

}
//NameSpace:System.Threading
public static class Monitor
{
	// Methods
	public static void Enter(object obj);
	public static void Enter(object obj, bool lockTaken);
	private static void ThrowLockTakenException();
	public static void Exit(object obj);
	public static bool Wait(object obj, int millisecondsTimeout, bool exitContext);
	public static bool Wait(object obj, int millisecondsTimeout);
	public static void Pulse(object obj);
	public static void PulseAll(object obj);
	private static bool Monitor_test_synchronised(object obj);
	private static void Monitor_pulse(object obj);
	private static void ObjPulse(object obj);
	private static void Monitor_pulse_all(object obj);
	private static void ObjPulseAll(object obj);
	private static bool Monitor_wait(object obj, int ms);
	private static bool ObjWait(bool exitContext, int millisecondsTimeout, object obj);
	private static void try_enter_with_atomic_var(object obj, int millisecondsTimeout, bool lockTaken);
	private static void ReliableEnterTimeout(object obj, int timeout, bool lockTaken);
	private static void ReliableEnter(object obj, bool lockTaken);

}
//NameSpace:System.Threading
public sealed class ParameterizedThreadStart : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(object obj);
	public virtual IAsyncResult BeginInvoke(object obj, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System.Threading
public class SemaphoreFullException : SystemException
{
	// Methods
	public void .ctor();
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Threading
public sealed class SendOrPostCallback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(object state);
	public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System.Threading
public class SynchronizationContext
{
	// Properties
	public static SynchronizationContext Current { get; }
	internal static SynchronizationContext CurrentNoFlow { get; }

	// Methods
	public void .ctor();
	public virtual void Send(SendOrPostCallback d, object state);
	public virtual void Post(SendOrPostCallback d, object state);
	public static void SetSynchronizationContext(SynchronizationContext syncContext);
	public static SynchronizationContext get_Current();
	internal static SynchronizationContext get_CurrentNoFlow();
	private static SynchronizationContext GetThreadLocalContext();
	public virtual SynchronizationContext CreateCopy();

}
//NameSpace:System.Threading
public class SynchronizationLockException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Threading
internal class ThreadHelper
{
	// Fields
	private Delegate _start;
	private object _startArg;
	private ExecutionContext _executionContext;
	internal static ContextCallback _ccb;

	// Methods
	private static void .cctor();
	internal void .ctor(Delegate start);
	internal void SetExecutionContextHelper(ExecutionContext ec);
	private static void ThreadStart_Context(object state);
	internal void ThreadStart(object obj);
	internal void ThreadStart();

}
//NameSpace:System.Threading
public sealed class Thread : CriticalFinalizerObject, _Thread
{
	// Fields
	private static LocalDataStoreMgr s_LocalDataStoreMgr;
	private static LocalDataStoreHolder s_LocalDataStore;
	internal static CultureInfo m_CurrentCulture;
	internal static CultureInfo m_CurrentUICulture;
	private static AsyncLocal`1<CultureInfo> s_asyncLocalCurrentCulture;
	private static AsyncLocal`1<CultureInfo> s_asyncLocalCurrentUICulture;
	private InternalThread internal_thread;
	private object m_ThreadStartArg;
	private object pending_exception;
	private IPrincipal principal;
	private int principal_version;
	private static Thread current_thread;
	private MulticastDelegate m_Delegate;
	private ExecutionContext m_ExecutionContext;
	private bool m_ExecutionContextBelongsToOuterScope;

	// Properties
	internal bool ExecutionContextBelongsToCurrentScope { get; set; }
	public CultureInfo CurrentUICulture { get; }
	public CultureInfo CurrentCulture { get; }
	private InternalThread Internal { get; }
	public static Context CurrentContext { get; }
	public static Thread CurrentThread { get; }
	public bool IsThreadPoolThread { get; }
	internal bool IsThreadPoolThreadInternal { get; }
	public void IsBackground { set; }
	public void Name { set; }
	public ThreadState ThreadState { get; }
	public int ManagedThreadId { get; }

	// Methods
	public void .ctor(ThreadStart start);
	public void .ctor(ParameterizedThreadStart start);
	public void Start();
	public void Start(object parameter);
	private void Start(StackCrawlMark stackMark);
	internal ExecutionContext.Reader GetExecutionContextReader();
	internal bool get_ExecutionContextBelongsToCurrentScope();
	internal void set_ExecutionContextBelongsToCurrentScope(bool value);
	internal ExecutionContext GetMutableExecutionContext();
	internal void SetExecutionContext(ExecutionContext value, bool belongsToCurrentScope);
	internal void SetExecutionContext(ExecutionContext.Reader value, bool belongsToCurrentScope);
	private static void SleepInternal(int millisecondsTimeout);
	public static void Sleep(int millisecondsTimeout);
	private static bool YieldInternal();
	public static bool Yield();
	private void SetStartHelper(Delegate start, int maxStackSize);
	public CultureInfo get_CurrentUICulture();
	internal CultureInfo GetCurrentUICultureNoAppX();
	public CultureInfo get_CurrentCulture();
	private CultureInfo GetCurrentCultureNoAppX();
	public static void MemoryBarrier();
	private void ConstructInternalThread();
	private InternalThread get_Internal();
	public static Context get_CurrentContext();
	private static Thread GetCurrentThread();
	public static Thread get_CurrentThread();
	public static int GetDomainID();
	private IntPtr Thread_internal(MulticastDelegate start);
	protected override void Finalize();
	public bool get_IsThreadPoolThread();
	internal bool get_IsThreadPoolThreadInternal();
	public void set_IsBackground(bool value);
	private static void SetName_internal(InternalThread thread, string name);
	public void set_Name(string value);
	public ThreadState get_ThreadState();
	private static void SpinWait_nop();
	public static void SpinWait(int iterations);
	private void StartInternal(IPrincipal principal, StackCrawlMark stackMark);
	private static void SetState(InternalThread thread, ThreadState set);
	private static void ClrState(InternalThread thread, ThreadState clr);
	private static ThreadState GetState(InternalThread thread);
	private static int SystemMaxStackStize();
	private static int GetProcessDefaultStackSize(int maxStackSize);
	private void SetStart(MulticastDelegate start, int maxStackSize);
	public int get_ManagedThreadId();
	public static void BeginCriticalRegion();
	public static void EndCriticalRegion();
	public override int GetHashCode();
	private ThreadState ValidateThreadState();

}
//NameSpace:System.Threading
internal enum StackCrawlMark
{
	// Fields
	public int value__;
	public const StackCrawlMark LookForMe;
	public const StackCrawlMark LookForMyCaller;
	public const StackCrawlMark LookForMyCallersCaller;
	public const StackCrawlMark LookForThread;

}
//NameSpace:System.Threading
public sealed class ThreadAbortException : SystemException
{
	// Methods
	private void .ctor();
	internal void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Threading
public class ThreadInterruptedException : SystemException
{
	// Methods
	public void .ctor();
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Threading
internal interface IThreadPoolWorkItem
{
	// Methods
	public abstract void ExecuteWorkItem();
	public abstract void MarkAborted(ThreadAbortException tae);

}
//NameSpace:System.Threading
public sealed class WaitCallback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(object state);
	public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System.Threading
public sealed class WaitOrTimerCallback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(object state, bool timedOut);
	public virtual IAsyncResult BeginInvoke(object state, bool timedOut, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System.Threading
internal static class ThreadPoolGlobals
{
	// Fields
	public static uint tpQuantum;
	public static int processorCount;
	public static bool tpHosted;
	public static bool vmTpInitialized;
	public static bool enableWorkerTracking;
	public static ThreadPoolWorkQueue workQueue;

	// Methods
	private static void .cctor();

}
//NameSpace:System.Threading
internal sealed class ThreadPoolWorkQueue
{
	// Fields
	internal ThreadPoolWorkQueue.QueueSegment queueHead;
	internal ThreadPoolWorkQueue.QueueSegment queueTail;
	internal static SparseArray`1<ThreadPoolWorkQueue.WorkStealingQueue> allThreadQueues;
	private int numOutstandingThreadRequests;

	// Methods
	public void .ctor();
	public ThreadPoolWorkQueueThreadLocals EnsureCurrentThreadHasQueue();
	internal void EnsureThreadRequested();
	internal void MarkThreadRequestSatisfied();
	public void Enqueue(IThreadPoolWorkItem callback, bool forceGlobal);
	internal bool LocalFindAndPop(IThreadPoolWorkItem callback);
	public void Dequeue(ThreadPoolWorkQueueThreadLocals tl, out IThreadPoolWorkItem callback, out bool missedSteal);
	internal static bool Dispatch();
	private static void .cctor();

}
//NameSpace:
internal class ThreadPoolWorkQueue.SparseArray`1
{
	// Fields
	private T[] m_array;

	// Properties
	internal T[] Current { get; }

	// Methods
	internal void .ctor(int initialSize);
	internal T[] get_Current();
	internal int Add(T e);
	internal void Remove(T e);

}
//NameSpace:
internal class ThreadPoolWorkQueue.WorkStealingQueue
{
	// Fields
	internal IThreadPoolWorkItem[] m_array;
	private int m_mask;
	private int m_headIndex;
	private int m_tailIndex;
	private SpinLock m_foreignLock;

	// Methods
	public void LocalPush(IThreadPoolWorkItem obj);
	public bool LocalFindAndPop(IThreadPoolWorkItem obj);
	public bool LocalPop(out IThreadPoolWorkItem obj);
	public bool TrySteal(out IThreadPoolWorkItem obj, bool missedSteal);
	private bool TrySteal(out IThreadPoolWorkItem obj, bool missedSteal, int millisecondsTimeout);
	public void .ctor();

}
//NameSpace:
internal class ThreadPoolWorkQueue.QueueSegment
{
	// Fields
	internal readonly IThreadPoolWorkItem[] nodes;
	private int indexes;
	public ThreadPoolWorkQueue.QueueSegment Next;

	// Methods
	private void GetIndexes(out int upper, out int lower);
	private bool CompareExchangeIndexes(int prevUpper, int newUpper, int prevLower, int newLower);
	public void .ctor();
	public bool IsUsedUp();
	public bool TryEnqueue(IThreadPoolWorkItem node);
	public bool TryDequeue(out IThreadPoolWorkItem node);

}
//NameSpace:System.Threading
internal sealed class ThreadPoolWorkQueueThreadLocals
{
	// Fields
	public static ThreadPoolWorkQueueThreadLocals threadLocals;
	public readonly ThreadPoolWorkQueue workQueue;
	public readonly ThreadPoolWorkQueue.WorkStealingQueue workStealingQueue;
	public readonly Random random;

	// Methods
	public void .ctor(ThreadPoolWorkQueue tpq);
	private void CleanUp();
	protected override void Finalize();

}
//NameSpace:System.Threading
internal static class _ThreadPoolWaitCallback
{
	// Methods
	internal static bool PerformWaitCallback();

}
//NameSpace:System.Threading
internal sealed class QueueUserWorkItemCallback : IThreadPoolWorkItem
{
	// Fields
	private WaitCallback callback;
	private ExecutionContext context;
	private object state;
	internal static ContextCallback ccb;

	// Methods
	private static void .cctor();
	internal void .ctor(WaitCallback waitCallback, object stateObj, bool compressStack, StackCrawlMark stackMark);
	private void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
	private void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
	private static void WaitCallback_Context(object state);

}
//NameSpace:System.Threading
public static class ThreadPool
{
	// Methods
	private static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce, StackCrawlMark stackMark, bool compressStack);
	public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
	public static bool QueueUserWorkItem(WaitCallback callBack, object state);
	public static bool UnsafeQueueUserWorkItem(WaitCallback callBack, object state);
	private static bool QueueUserWorkItemHelper(WaitCallback callBack, object state, StackCrawlMark stackMark, bool compressStack);
	internal static void UnsafeQueueCustomWorkItem(IThreadPoolWorkItem workItem, bool forceGlobal);
	internal static bool TryPopCustomWorkItem(IThreadPoolWorkItem workItem);
	internal static bool RequestWorkerThread();
	private static void EnsureVMInitialized();
	internal static bool NotifyWorkItemComplete();
	internal static void ReportThreadStatus(bool isWorking);
	internal static void NotifyWorkItemProgress();
	internal static void NotifyWorkItemProgressNative();
	internal static bool IsThreadPoolHosted();
	private static void InitializeVMTp(bool enableWorkerTracking);

}
//NameSpace:System.Threading
public sealed class ThreadStart : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke();
	public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System.Threading
public enum ThreadState
{
	// Fields
	public int value__;
	public const ThreadState Running;
	public const ThreadState StopRequested;
	public const ThreadState SuspendRequested;
	public const ThreadState Background;
	public const ThreadState Unstarted;
	public const ThreadState Stopped;
	public const ThreadState WaitSleepJoin;
	public const ThreadState Suspended;
	public const ThreadState AbortRequested;
	public const ThreadState Aborted;

}
//NameSpace:System.Threading
public class ThreadStateException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Threading
public static class Timeout
{
	// Fields
	public static readonly TimeSpan InfiniteTimeSpan;

	// Methods
	private static void .cctor();

}
//NameSpace:System.Threading
public abstract class WaitHandle : MarshalByRefObject, IDisposable
{
	// Fields
	public const int WaitTimeout;
	private const int MAX_WAITHANDLES;
	private IntPtr waitHandle;
	internal SafeWaitHandle safeWaitHandle;
	internal bool hasThreadAffinity;
	private const int WAIT_OBJECT_0;
	private const int WAIT_ABANDONED;
	private const int WAIT_FAILED;
	private const int ERROR_TOO_MANY_POSTS;
	protected static readonly IntPtr InvalidHandle;
	internal const int MaxWaitHandles;

	// Properties
	public virtual void Handle { set; }
	public SafeWaitHandle SafeWaitHandle { get; }

	// Methods
	protected void .ctor();
	private void Init();
	public virtual void set_Handle(IntPtr value);
	public SafeWaitHandle get_SafeWaitHandle();
	internal void SetHandleInternal(SafeWaitHandle handle);
	public virtual bool WaitOne(int millisecondsTimeout, bool exitContext);
	public virtual bool WaitOne();
	public virtual bool WaitOne(int millisecondsTimeout);
	private bool WaitOne(long timeout, bool exitContext);
	internal static bool InternalWaitOne(SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext);
	public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
	public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
	private static void ThrowAbandonedMutexException();
	private static void ThrowAbandonedMutexException(int location, WaitHandle handle);
	public virtual void Close();
	protected virtual void Dispose(bool explicitDisposing);
	public void Dispose();
	private static int WaitMultiple(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext, bool WaitAll);
	private static int WaitOneNative(SafeHandle waitableSafeHandle, uint millisecondsTimeout, bool hasThreadAffinity, bool exitContext);
	private static int Wait_internal(IntPtr* handles, int numHandles, bool waitAll, int ms);
	private static void .cctor();

}
//NameSpace:System.Threading
public class WaitHandleCannotBeOpenedException : ApplicationException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Threading
public static class Interlocked
{
	// Methods
	public static int CompareExchange(int location1, int value, int comparand);
	internal static int CompareExchange(int location1, int value, int comparand, bool succeeded);
	public static object CompareExchange(object location1, object value, object comparand);
	public static float CompareExchange(float location1, float value, float comparand);
	public static int Decrement(int location);
	public static int Increment(int location);
	public static int Exchange(int location1, int value);
	public static object Exchange(object location1, object value);
	public static float Exchange(float location1, float value);
	public static long CompareExchange(long location1, long value, long comparand);
	public static IntPtr CompareExchange(IntPtr location1, IntPtr value, IntPtr comparand);
	public static double CompareExchange(double location1, double value, double comparand);
	public static T CompareExchange(T location1, T value, T comparand);
	public static long Exchange(long location1, long value);
	public static IntPtr Exchange(IntPtr location1, IntPtr value);
	public static double Exchange(double location1, double value);
	public static T Exchange(T location1, T value);
	public static long Read(long location);
	public static int Add(int location1, int value);

}
//NameSpace:System.Threading
public sealed class Mutex : WaitHandle
{
}
//NameSpace:System.Threading
internal static class NativeEventCalls
{
	// Methods
	public static IntPtr CreateEvent_internal(bool manual, bool initial, string name, out int errorCode);
	public static bool SetEvent(SafeWaitHandle handle);
	private static bool SetEvent_internal(IntPtr handle);
	public static bool ResetEvent(SafeWaitHandle handle);
	private static bool ResetEvent_internal(IntPtr handle);
	public static void CloseEvent_internal(IntPtr handle);

}
//NameSpace:System.Threading
public struct NativeOverlapped
{
	// Fields
	public IntPtr InternalLow;
	public IntPtr InternalHigh;
	public int OffsetLow;
	public int OffsetHigh;
	public IntPtr EventHandle;

}
//NameSpace:System.Threading
public sealed class RegisteredWaitHandle : MarshalByRefObject
{
	// Fields
	private WaitHandle _waitObject;
	private WaitOrTimerCallback _callback;
	private object _state;
	private WaitHandle _finalEvent;
	private ManualResetEvent _cancelEvent;
	private TimeSpan _timeout;
	private int _callsInProcess;
	private bool _executeOnlyOnce;
	private bool _unregistered;

	// Methods
	internal void .ctor(WaitHandle waitObject, WaitOrTimerCallback callback, object state, TimeSpan timeout, bool executeOnlyOnce);
	internal void Wait(object state);
	private void DoCallBack(object timedOut);

}
//NameSpace:System.Threading
internal sealed class InternalThread : CriticalFinalizerObject
{
	// Fields
	private int lock_thread_id;
	private IntPtr handle;
	private IntPtr native_handle;
	private IntPtr unused3;
	private IntPtr name;
	private int name_len;
	private ThreadState state;
	private object abort_exc;
	private int abort_state_handle;
	internal long thread_id;
	private IntPtr debugger_thread;
	private UIntPtr static_data;
	private IntPtr runtime_thread_info;
	private object current_appcontext;
	private object root_domain_thread;
	internal byte[] _serialized_principal;
	internal int _serialized_principal_version;
	private IntPtr appdomain_refs;
	private int interruption_requested;
	private IntPtr synch_cs;
	internal bool threadpool_thread;
	private bool thread_interrupt_requested;
	internal int stack_size;
	internal byte apartment_state;
	internal int critical_region_level;
	internal int managed_id;
	private int small_id;
	private IntPtr manage_callback;
	private IntPtr unused4;
	private IntPtr flags;
	private IntPtr thread_pinning_ref;
	private IntPtr abort_protected_block_count;
	private int priority;
	private IntPtr owned_mutex;
	private IntPtr suspended_event;
	private int self_suspended;
	private IntPtr unused1;
	private IntPtr unused2;
	private IntPtr last;

	// Methods
	private void Thread_free_internal();
	protected override void Finalize();

}
//NameSpace:System.Threading
public sealed class Timer : MarshalByRefObject, IDisposable
{
	// Fields
	private static readonly Timer.Scheduler scheduler;
	private TimerCallback callback;
	private object state;
	private long due_time_ms;
	private long period_ms;
	private long next_run;
	private bool disposed;

	// Methods
	public void .ctor(TimerCallback callback, object state, int dueTime, int period);
	public void .ctor(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);
	private void Init(TimerCallback callback, object state, long dueTime, long period);
	public bool Change(TimeSpan dueTime, TimeSpan period);
	public void Dispose();
	private bool Change(long dueTime, long period, bool first);
	internal void KeepRootedWhileScheduled();
	private static long GetTimeMonotonic();
	private static void .cctor();

}
//NameSpace:
private sealed class Timer.TimerComparer : IComparer
{
	// Methods
	public int Compare(object x, object y);
	public void .ctor();

}
//NameSpace:
private sealed class Timer.Scheduler
{
	// Fields
	private static Timer.Scheduler instance;
	private SortedList list;
	private ManualResetEvent changed;

	// Properties
	public static Timer.Scheduler Instance { get; }

	// Methods
	private static void .cctor();
	public static Timer.Scheduler get_Instance();
	private void .ctor();
	public void Remove(Timer timer);
	public void Change(Timer timer, long new_next_run);
	private int FindByDueTime(long nr);
	private void Add(Timer timer);
	private int InternalRemove(Timer timer);
	private static void TimerCB(object o);
	private void SchedulerThread();
	private void ShrinkIfNeeded(List`1<Timer> list, int initial);

}
//NameSpace:System.Threading
public sealed class TimerCallback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(object state);
	public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System.Threading
public static class Volatile
{
	// Methods
	public static bool Read(bool location);
	public static T Read(T location);
	public static void Write(T location, T value);

}
//NameSpace:System.Threading.Tasks
internal enum CausalityTraceLevel
{
	// Fields
	public int value__;
	public const CausalityTraceLevel Required;
	public const CausalityTraceLevel Important;
	public const CausalityTraceLevel Verbose;

}
//NameSpace:System.Threading.Tasks
internal enum AsyncCausalityStatus
{
	// Fields
	public int value__;
	public const AsyncCausalityStatus Started;
	public const AsyncCausalityStatus Completed;
	public const AsyncCausalityStatus Canceled;
	public const AsyncCausalityStatus Error;

}
//NameSpace:System.Threading.Tasks
internal enum CausalityRelation
{
	// Fields
	public int value__;
	public const CausalityRelation AssignDelegate;
	public const CausalityRelation Join;
	public const CausalityRelation Choice;
	public const CausalityRelation Cancel;
	public const CausalityRelation Error;

}
//NameSpace:System.Threading.Tasks
internal enum CausalitySynchronousWork
{
	// Fields
	public int value__;
	public const CausalitySynchronousWork CompletionNotification;
	public const CausalitySynchronousWork ProgressNotification;
	public const CausalitySynchronousWork Execution;

}
//NameSpace:System.Threading.Tasks
internal static class AsyncCausalityTracer
{
	// Properties
	internal static bool LoggingOn { get; }

	// Methods
	internal static bool get_LoggingOn();
	internal static void TraceOperationCreation(CausalityTraceLevel traceLevel, int taskId, string operationName, ulong relatedContext);
	internal static void TraceOperationCompletion(CausalityTraceLevel traceLevel, int taskId, AsyncCausalityStatus status);
	internal static void TraceOperationRelation(CausalityTraceLevel traceLevel, int taskId, CausalityRelation relation);
	internal static void TraceSynchronousWorkStart(CausalityTraceLevel traceLevel, int taskId, CausalitySynchronousWork work);
	internal static void TraceSynchronousWorkCompletion(CausalityTraceLevel traceLevel, CausalitySynchronousWork work);

}
//NameSpace:System.Threading.Tasks
public class Task`1 : Task
{
	// Fields
	internal T m_result;
	private static readonly TaskFactory`1<T> s_Factory;
	internal static readonly Func`2<Task`1<Task>Task`1<T>> TaskWhenAnyCast;

	// Properties
	public T Result { get; }
	internal T ResultOnSuccess { get; }

	// Methods
	internal void .ctor();
	internal void .ctor(T result);
	internal void .ctor(bool canceled, T result, TaskCreationOptions creationOptions, CancellationToken ct);
	public void .ctor(Func`2<objectT> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
	internal void .ctor(Func`1<T> valueSelector, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler, StackCrawlMark stackMark);
	internal void .ctor(Func`1<T> valueSelector, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
	internal void .ctor(Delegate valueSelector, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
	internal static Task`1<T> StartNew(Task parent, Func`1<T> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler, StackCrawlMark stackMark);
	internal bool TrySetResult(T result);
	internal void DangerousSetResult(T result);
	public T get_Result();
	internal T get_ResultOnSuccess();
	internal T GetResultCore(bool waitCompletionNotification);
	internal bool TrySetException(object exceptionObject);
	internal bool TrySetCanceled(CancellationToken tokenToRecord);
	internal bool TrySetCanceled(CancellationToken tokenToRecord, object cancellationException);
	internal override void InnerInvoke();
	public TaskAwaiter`1<T> GetAwaiter();
	public ConfiguredTaskAwaitable`1<T> ConfigureAwait(bool continueOnCapturedContext);
	private static void .cctor();

}
//NameSpace:
private sealed class Task`1.<>c
{
	// Fields
	public static readonly <>c<T> <>9;

	// Methods
	private static void .cctor();
	public void .ctor();
	internal Task`1<T> <.cctor>b__64_0(Task`1<Task> completed);

}
//NameSpace:System.Threading.Tasks
internal class SystemThreadingTasks_FutureDebugView`1
{
}
//NameSpace:System.Threading.Tasks
public class TaskFactory`1
{
	// Fields
	private CancellationToken m_defaultCancellationToken;
	private TaskScheduler m_defaultScheduler;
	private TaskCreationOptions m_defaultCreationOptions;
	private TaskContinuationOptions m_defaultContinuationOptions;

	// Methods
	public void .ctor();
	public void .ctor(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
	internal static Task`1<T> FromAsyncTrim(T thisRef, T args, Func`5<TTAsyncCallbackobjectIAsyncResult> beginMethod, Func`3<TIAsyncResultT> endMethod);

}
//NameSpace:
private sealed class TaskFactory`1.FromAsyncTrimPromise`1 : Task`1<T>
{
	// Fields
	internal static readonly AsyncCallback s_completeFromAsyncResult;
	private T m_thisRef;
	private Func`3<TIAsyncResultT> m_endMethod;

	// Methods
	internal void .ctor(T thisRef, Func`3<TIAsyncResultT> endMethod);
	internal static void CompleteFromAsyncResult(IAsyncResult asyncResult);
	internal void Complete(T thisRef, Func`3<TIAsyncResultT> endMethod, IAsyncResult asyncResult, bool requiresSynchronization);
	private static void .cctor();

}
//NameSpace:System.Threading.Tasks
internal class Shared`1
{
	// Fields
	internal T Value;

	// Methods
	internal void .ctor(T value);

}
//NameSpace:System.Threading.Tasks
public enum TaskStatus
{
	// Fields
	public int value__;
	public const TaskStatus Created;
	public const TaskStatus WaitingForActivation;
	public const TaskStatus WaitingToRun;
	public const TaskStatus Running;
	public const TaskStatus WaitingForChildrenToComplete;
	public const TaskStatus RanToCompletion;
	public const TaskStatus Canceled;
	public const TaskStatus Faulted;

}
//NameSpace:System.Threading.Tasks
public class Task : IThreadPoolWorkItem, IAsyncResult, IDisposable
{
	// Fields
	internal static Task t_currentTask;
	private static StackGuard t_stackGuard;
	internal static int s_taskIdCounter;
	private static readonly TaskFactory s_factory;
	private int m_taskId;
	internal object m_action;
	internal object m_stateObject;
	internal TaskScheduler m_taskScheduler;
	internal readonly Task m_parent;
	internal int m_stateFlags;
	private object m_continuationObject;
	private static readonly object s_taskCompletionSentinel;
	internal static bool s_asyncDebuggingEnabled;
	private static readonly Dictionary`2<intTask> s_currentActiveTasks;
	private static readonly object s_activeTasksLock;
	internal Task.ContingentProperties m_contingentProperties;
	private static readonly Action`1<object> s_taskCancelCallback;
	private static readonly Func`1<Task.ContingentProperties> s_createContingentProperties;
	private static Task s_completedTask;
	private static readonly Predicate`1<Task> s_IsExceptionObservedByParentPredicate;
	private static ContextCallback s_ecCallback;
	private static readonly Predicate`1<object> s_IsTaskContinuationNullPredicate;

	// Properties
	internal TaskCreationOptions Options { get; }
	internal bool IsWaitNotificationEnabledOrNotRanToCompletion { get; }
	internal virtual bool ShouldNotifyDebuggerOfWaitCompletion { get; }
	internal bool IsWaitNotificationEnabled { get; }
	public int Id { get; }
	internal static Task InternalCurrent { get; }
	internal static StackGuard CurrentStackGuard { get; }
	public AggregateException Exception { get; }
	public TaskStatus Status { get; }
	public bool IsCanceled { get; }
	internal bool IsCancellationRequested { get; }
	internal CancellationToken CancellationToken { get; }
	internal bool IsCancellationAcknowledged { get; }
	public bool IsCompleted { get; }
	internal bool IsRanToCompletion { get; }
	public TaskCreationOptions CreationOptions { get; }
	private WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }
	public object AsyncState { get; }
	private bool System.IAsyncResult.CompletedSynchronously { get; }
	internal TaskScheduler ExecutingTaskScheduler { get; }
	public static Task CompletedTask { get; }
	internal ManualResetEventSlim CompletedEvent { get; }
	internal bool IsSelfReplicatingRoot { get; }
	internal bool IsChildReplica { get; }
	internal bool ExceptionRecorded { get; }
	public bool IsFaulted { get; }
	internal ExecutionContext CapturedContext { get; set; }
	internal bool IsExceptionObservedByParent { get; }
	internal bool IsDelegateInvoked { get; }
	internal virtual object SavedStateForNextReplica { get; }
	internal virtual void SavedStateFromPreviousReplica { set; }
	internal virtual Task HandedOverChildReplica { get; set; }

	// Methods
	internal static bool AddToActiveTasks(Task task);
	internal static void RemoveFromActiveTasks(int taskId);
	internal void .ctor(bool canceled, TaskCreationOptions creationOptions, CancellationToken ct);
	internal void .ctor();
	internal void .ctor(Delegate action, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
	internal void TaskConstructorCore(object action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
	private void AssignCancellationToken(CancellationToken cancellationToken, Task antecedent, TaskContinuation continuation);
	private static void TaskCancelCallback(object o);
	internal void PossiblyCaptureContext(StackCrawlMark stackMark);
	internal TaskCreationOptions get_Options();
	internal static TaskCreationOptions OptionsMethod(int flags);
	internal bool AtomicStateUpdate(int newBits, int illegalBits);
	internal bool AtomicStateUpdate(int newBits, int illegalBits, int oldFlags);
	internal void SetNotificationForWaitCompletion(bool enabled);
	internal bool NotifyDebuggerOfWaitCompletionIfNecessary();
	internal bool get_IsWaitNotificationEnabledOrNotRanToCompletion();
	internal virtual bool get_ShouldNotifyDebuggerOfWaitCompletion();
	internal bool get_IsWaitNotificationEnabled();
	private void NotifyDebuggerOfWaitCompletion();
	internal bool MarkStarted();
	internal bool FireTaskScheduledIfNeeded(TaskScheduler ts);
	internal void AddNewChild();
	internal void DisregardChild();
	internal static Task InternalStartNew(Task creatingTask, Delegate action, object state, CancellationToken cancellationToken, TaskScheduler scheduler, TaskCreationOptions options, InternalTaskOptions internalOptions, StackCrawlMark stackMark);
	internal static int NewId();
	public int get_Id();
	internal static Task get_InternalCurrent();
	internal static Task InternalCurrentIfAttached(TaskCreationOptions creationOptions);
	internal static StackGuard get_CurrentStackGuard();
	public AggregateException get_Exception();
	public TaskStatus get_Status();
	public bool get_IsCanceled();
	internal bool get_IsCancellationRequested();
	internal Task.ContingentProperties EnsureContingentPropertiesInitialized(bool needsProtection);
	private Task.ContingentProperties EnsureContingentPropertiesInitializedCore(bool needsProtection);
	internal CancellationToken get_CancellationToken();
	internal bool get_IsCancellationAcknowledged();
	public bool get_IsCompleted();
	private static bool IsCompletedMethod(int flags);
	internal bool get_IsRanToCompletion();
	public TaskCreationOptions get_CreationOptions();
	private WaitHandle System.IAsyncResult.get_AsyncWaitHandle();
	public object get_AsyncState();
	private bool System.IAsyncResult.get_CompletedSynchronously();
	internal TaskScheduler get_ExecutingTaskScheduler();
	public static Task get_CompletedTask();
	internal ManualResetEventSlim get_CompletedEvent();
	internal bool get_IsSelfReplicatingRoot();
	internal bool get_IsChildReplica();
	internal bool get_ExceptionRecorded();
	public bool get_IsFaulted();
	internal ExecutionContext get_CapturedContext();
	internal void set_CapturedContext(ExecutionContext value);
	private static ExecutionContext CopyExecutionContext(ExecutionContext capturedContext);
	public void Dispose();
	protected virtual void Dispose(bool disposing);
	internal void ScheduleAndStart(bool needsProtection);
	internal void AddException(object exceptionObject);
	internal void AddException(object exceptionObject, bool representsCancellation);
	private AggregateException GetExceptions(bool includeTaskCanceledExceptions);
	internal ReadOnlyCollection`1<ExceptionDispatchInfo> GetExceptionDispatchInfos();
	internal ExceptionDispatchInfo GetCancellationExceptionDispatchInfo();
	internal void ThrowIfExceptional(bool includeTaskCanceledExceptions);
	internal void UpdateExceptionObservedStatus();
	internal bool get_IsExceptionObservedByParent();
	internal bool get_IsDelegateInvoked();
	internal void Finish(bool bUserDelegateExecuted);
	internal void FinishStageTwo();
	internal void FinishStageThree();
	internal void ProcessChildCompletion(Task childTask);
	internal void AddExceptionsFromChildren();
	internal void FinishThreadAbortedTask(bool bTAEAddedToExceptionHolder, bool delegateRan);
	private void Execute();
	internal virtual bool ShouldReplicate();
	internal virtual Task CreateReplicaTask(Action`1<object> taskReplicaDelegate, object stateObject, Task parentTask, TaskScheduler taskScheduler, TaskCreationOptions creationOptionsForReplica, InternalTaskOptions internalOptionsForReplica);
	internal virtual object get_SavedStateForNextReplica();
	internal virtual void set_SavedStateFromPreviousReplica(object value);
	internal virtual Task get_HandedOverChildReplica();
	internal virtual void set_HandedOverChildReplica(Task value);
	private static void ExecuteSelfReplicating(Task root);
	private void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
	private void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
	internal bool ExecuteEntry(bool bPreventDoubleExecution);
	private void ExecuteWithThreadLocal(Task currentTaskSlot);
	private static void ExecutionContextCallback(object obj);
	internal virtual void InnerInvoke();
	internal void InnerInvokeWithArg(Task childTask);
	private void HandleException(Exception unhandledException);
	public TaskAwaiter GetAwaiter();
	public ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
	internal void SetContinuationForAwait(Action continuationAction, bool continueOnCapturedContext, bool flowExecutionContext, StackCrawlMark stackMark);
	public void Wait();
	public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
	private bool WrappedTryRunInline();
	internal bool InternalWait(int millisecondsTimeout, CancellationToken cancellationToken);
	private bool SpinThenBlockingWait(int millisecondsTimeout, CancellationToken cancellationToken);
	private bool SpinWait(int millisecondsTimeout);
	internal bool InternalCancel(bool bCancelNonExecutingOnly);
	internal void RecordInternalCancellationRequest();
	internal void RecordInternalCancellationRequest(CancellationToken tokenToRecord);
	internal void RecordInternalCancellationRequest(CancellationToken tokenToRecord, object cancellationException);
	internal void CancellationCleanupLogic();
	private void SetCancellationAcknowledged();
	internal void FinishContinuations();
	private void LogFinishCompletionNotification();
	public Task ContinueWith(Action`2<Taskobject> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
	private Task ContinueWith(Action`2<Taskobject> continuationAction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, StackCrawlMark stackMark);
	internal static void CreationOptionsFromContinuationOptions(TaskContinuationOptions continuationOptions, out TaskCreationOptions creationOptions, out InternalTaskOptions internalOptions);
	internal void ContinueWithCore(Task continuationTask, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions options);
	internal void AddCompletionAction(ITaskCompletionAction action);
	private void AddCompletionAction(ITaskCompletionAction action, bool addBeforeOthers);
	private bool AddTaskContinuationComplex(object tc, bool addBeforeOthers);
	private bool AddTaskContinuation(object tc, bool addBeforeOthers);
	internal void RemoveContinuation(object continuationObject);
	public static Task`1<T> FromResult(T result);
	public static Task FromException(Exception exception);
	public static Task`1<T> FromException(Exception exception);
	internal static Task FromCancellation(CancellationToken cancellationToken);
	internal static Task`1<T> FromCancellation(CancellationToken cancellationToken);
	internal static Task`1<T> FromCancellation(OperationCanceledException exception);
	public static Task Run(Action action);
	public static Task`1<T> Run(Func`1<T> function);
	public static Task Delay(int millisecondsDelay, CancellationToken cancellationToken);
	public static Task`1<Task> WhenAny(Task[] tasks);
	private static void .cctor();

}
//NameSpace:
internal class Task.ContingentProperties
{
	// Fields
	internal ExecutionContext m_capturedContext;
	internal ManualResetEventSlim m_completionEvent;
	internal TaskExceptionHolder m_exceptionsHolder;
	internal CancellationToken m_cancellationToken;
	internal Shared`1<CancellationTokenRegistration> m_cancellationRegistration;
	internal int m_internalCancellationRequested;
	internal int m_completionCountdown;
	internal List`1<Task> m_exceptionalChildren;

	// Methods
	internal void SetCompleted();
	internal void DeregisterCancellationCallback();
	public void .ctor();

}
//NameSpace:
private sealed class Task.SetOnInvokeMres : ManualResetEventSlim, ITaskCompletionAction
{
	// Methods
	internal void .ctor();
	public void Invoke(Task completingTask);

}
//NameSpace:
private sealed class Task.DelayPromise : Task`1<VoidTaskResult>
{
	// Fields
	internal readonly CancellationToken Token;
	internal CancellationTokenRegistration Registration;
	internal Timer Timer;

	// Methods
	internal void .ctor(CancellationToken token);
	internal void Complete();

}
//NameSpace:
private sealed class Task.<>c__DisplayClass178_0
{
	// Fields
	public Task root;
	public bool replicasAreQuitting;
	public Action`1<object> taskReplicaDelegate;
	public TaskCreationOptions creationOptionsForReplicas;
	public InternalTaskOptions internalOptionsForReplicas;

	// Methods
	public void .ctor();
	internal void <ExecuteSelfReplicating>b__0(object <p0>);

}
//NameSpace:
private sealed class Task.<>c
{
	// Fields
	public static readonly Task.<>c <>9;
	public static Action`1<object> <>9__276_0;
	public static TimerCallback <>9__276_1;

	// Methods
	private static void .cctor();
	public void .ctor();
	internal void <Delay>b__276_0(object state);
	internal void <Delay>b__276_1(object state);
	internal Task.ContingentProperties <.cctor>b__295_0();
	internal bool <.cctor>b__295_1(Task t);
	internal bool <.cctor>b__295_2(object tc);

}
//NameSpace:System.Threading.Tasks
internal sealed class CompletionActionInvoker : IThreadPoolWorkItem
{
	// Fields
	private readonly ITaskCompletionAction m_action;
	private readonly Task m_completingTask;

	// Methods
	internal void .ctor(ITaskCompletionAction action, Task completingTask);
	public void ExecuteWorkItem();
	public void MarkAborted(ThreadAbortException tae);

}
//NameSpace:System.Threading.Tasks
internal class SystemThreadingTasks_TaskDebugView
{
}
//NameSpace:System.Threading.Tasks
public enum TaskCreationOptions
{
	// Fields
	public int value__;
	public const TaskCreationOptions None;
	public const TaskCreationOptions PreferFairness;
	public const TaskCreationOptions LongRunning;
	public const TaskCreationOptions AttachedToParent;
	public const TaskCreationOptions DenyChildAttach;
	public const TaskCreationOptions HideScheduler;
	public const TaskCreationOptions RunContinuationsAsynchronously;

}
//NameSpace:System.Threading.Tasks
internal enum InternalTaskOptions
{
	// Fields
	public int value__;
	public const InternalTaskOptions None;
	public const InternalTaskOptions InternalOptionsMask;
	public const InternalTaskOptions ChildReplica;
	public const InternalTaskOptions ContinuationTask;
	public const InternalTaskOptions PromiseTask;
	public const InternalTaskOptions SelfReplicating;
	public const InternalTaskOptions LazyCancellation;
	public const InternalTaskOptions QueuedByRuntime;
	public const InternalTaskOptions DoNotDispose;

}
//NameSpace:System.Threading.Tasks
public enum TaskContinuationOptions
{
	// Fields
	public int value__;
	public const TaskContinuationOptions None;
	public const TaskContinuationOptions PreferFairness;
	public const TaskContinuationOptions LongRunning;
	public const TaskContinuationOptions AttachedToParent;
	public const TaskContinuationOptions DenyChildAttach;
	public const TaskContinuationOptions HideScheduler;
	public const TaskContinuationOptions LazyCancellation;
	public const TaskContinuationOptions RunContinuationsAsynchronously;
	public const TaskContinuationOptions NotOnRanToCompletion;
	public const TaskContinuationOptions NotOnFaulted;
	public const TaskContinuationOptions NotOnCanceled;
	public const TaskContinuationOptions OnlyOnRanToCompletion;
	public const TaskContinuationOptions OnlyOnFaulted;
	public const TaskContinuationOptions OnlyOnCanceled;
	public const TaskContinuationOptions ExecuteSynchronously;

}
//NameSpace:System.Threading.Tasks
internal class StackGuard
{
	// Fields
	private int m_inliningDepth;

	// Methods
	internal bool TryBeginInliningScope();
	internal void EndInliningScope();
	private bool CheckForSufficientStack();
	public void .ctor();

}
//NameSpace:System.Threading.Tasks
internal struct VoidTaskResult
{
}
//NameSpace:System.Threading.Tasks
internal interface ITaskCompletionAction
{
	// Methods
	public abstract void Invoke(Task completingTask);

}
//NameSpace:System.Threading.Tasks
public class TaskCanceledException : OperationCanceledException
{
	// Fields
	private Task m_canceledTask;

	// Methods
	public void .ctor();
	public void .ctor(Task task);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Threading.Tasks
internal sealed class ContinuationTaskFromTask : Task
{
	// Fields
	private Task m_antecedent;

	// Methods
	public void .ctor(Task antecedent, Delegate action, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, StackCrawlMark stackMark);
	internal override void InnerInvoke();

}
//NameSpace:System.Threading.Tasks
internal abstract class TaskContinuation
{
	// Methods
	internal abstract void Run(Task completedTask, bool bCanInlineContinuationTask);
	protected static void InlineIfPossibleOrElseQueue(Task task, bool needsProtection);
	protected void .ctor();

}
//NameSpace:System.Threading.Tasks
internal class StandardTaskContinuation : TaskContinuation
{
	// Fields
	internal readonly Task m_task;
	internal readonly TaskContinuationOptions m_options;
	private readonly TaskScheduler m_taskScheduler;

	// Methods
	internal void .ctor(Task task, TaskContinuationOptions options, TaskScheduler scheduler);
	internal override void Run(Task completedTask, bool bCanInlineContinuationTask);

}
//NameSpace:System.Threading.Tasks
internal sealed class SynchronizationContextAwaitTaskContinuation : AwaitTaskContinuation
{
	// Fields
	private static readonly SendOrPostCallback s_postCallback;
	private static ContextCallback s_postActionCallback;
	private readonly SynchronizationContext m_syncContext;

	// Methods
	internal void .ctor(SynchronizationContext context, Action action, bool flowExecutionContext, StackCrawlMark stackMark);
	internal sealed override void Run(Task task, bool canInlineContinuationTask);
	private static void PostAction(object state);
	private static ContextCallback GetPostActionCallback();
	private static void .cctor();

}
//NameSpace:
private sealed class SynchronizationContextAwaitTaskContinuation.<>c
{
	// Fields
	public static readonly SynchronizationContextAwaitTaskContinuation.<>c <>9;

	// Methods
	private static void .cctor();
	public void .ctor();
	internal void <.cctor>b__7_0(object state);

}
//NameSpace:System.Threading.Tasks
internal sealed class TaskSchedulerAwaitTaskContinuation : AwaitTaskContinuation
{
	// Fields
	private readonly TaskScheduler m_scheduler;

	// Methods
	internal void .ctor(TaskScheduler scheduler, Action action, bool flowExecutionContext, StackCrawlMark stackMark);
	internal sealed override void Run(Task ignored, bool canInlineContinuationTask);

}
//NameSpace:
private sealed class TaskSchedulerAwaitTaskContinuation.<>c
{
	// Fields
	public static readonly TaskSchedulerAwaitTaskContinuation.<>c <>9;
	public static Action`1<object> <>9__2_0;

	// Methods
	private static void .cctor();
	public void .ctor();
	internal void <Run>b__2_0(object state);

}
//NameSpace:System.Threading.Tasks
internal class AwaitTaskContinuation : TaskContinuation, IThreadPoolWorkItem
{
	// Fields
	private readonly ExecutionContext m_capturedContext;
	protected readonly Action m_action;
	private static ContextCallback s_invokeActionCallback;

	// Properties
	internal static bool IsValidLocationForInlining { get; }

	// Methods
	internal void .ctor(Action action, bool flowExecutionContext, StackCrawlMark stackMark);
	internal void .ctor(Action action, bool flowExecutionContext);
	protected Task CreateTask(Action`1<object> action, object state, TaskScheduler scheduler);
	internal override void Run(Task task, bool canInlineContinuationTask);
	internal static bool get_IsValidLocationForInlining();
	private void ExecuteWorkItemHelper();
	private void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
	private void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
	private static void InvokeAction(object state);
	protected static ContextCallback GetInvokeActionCallback();
	protected void RunCallback(ContextCallback callback, object state, Task currentTask);
	internal static void RunOrScheduleAction(Action action, bool allowInlining, Task currentTask);
	internal static void UnsafeScheduleAction(Action action, Task task);
	protected static void ThrowAsyncIfNecessary(Exception exc);

}
//NameSpace:
private sealed class AwaitTaskContinuation.<>c
{
	// Fields
	public static readonly AwaitTaskContinuation.<>c <>9;
	public static WaitCallback <>9__17_0;

	// Methods
	private static void .cctor();
	public void .ctor();
	internal void <ThrowAsyncIfNecessary>b__17_0(object s);

}
//NameSpace:System.Threading.Tasks
internal class TaskExceptionHolder
{
	// Fields
	private static readonly bool s_failFastOnUnobservedException;
	private static bool s_domainUnloadStarted;
	private static EventHandler s_adUnloadEventHandler;
	private readonly Task m_task;
	private List`1<ExceptionDispatchInfo> m_faultExceptions;
	private ExceptionDispatchInfo m_cancellationException;
	private bool m_isHandled;

	// Properties
	internal bool ContainsFaultList { get; }

	// Methods
	internal void .ctor(Task task);
	private static bool ShouldFailFastOnUnobservedException();
	private static void EnsureADUnloadCallbackRegistered();
	private static void AppDomainUnloadCallback(object sender, EventArgs e);
	protected override void Finalize();
	internal bool get_ContainsFaultList();
	internal void Add(object exceptionObject, bool representsCancellation);
	private void SetCancellationException(object exceptionObject);
	private void AddFaultException(object exceptionObject);
	private void MarkAsUnhandled();
	internal void MarkAsHandled(bool calledFromFinalizer);
	internal AggregateException CreateExceptionObject(bool calledFromFinalizer, Exception includeThisException);
	internal ReadOnlyCollection`1<ExceptionDispatchInfo> GetExceptionDispatchInfos();
	internal ExceptionDispatchInfo GetCancellationExceptionDispatchInfo();
	private static void .cctor();

}
//NameSpace:System.Threading.Tasks
public class TaskFactory
{
	// Fields
	private CancellationToken m_defaultCancellationToken;
	private TaskScheduler m_defaultScheduler;
	private TaskCreationOptions m_defaultCreationOptions;
	private TaskContinuationOptions m_defaultContinuationOptions;

	// Methods
	public void .ctor();
	public void .ctor(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
	internal static void CheckCreationOptions(TaskCreationOptions creationOptions);
	internal static Task`1<Task> CommonCWAnyLogic(IList`1<Task> tasks);
	internal static void CheckMultiTaskContinuationOptions(TaskContinuationOptions continuationOptions);

}
//NameSpace:
internal sealed class TaskFactory.CompleteOnInvokePromise : Task`1<Task>, ITaskCompletionAction
{
	// Fields
	private IList`1<Task> _tasks;
	private int m_firstTaskAlreadyCompleted;

	// Methods
	public void .ctor(IList`1<Task> tasks);
	public void Invoke(Task completingTask);

}
//NameSpace:System.Threading.Tasks
public abstract class TaskScheduler
{
	// Fields
	private static ConditionalWeakTable`2<TaskSchedulerobject> s_activeTaskSchedulers;
	private static readonly TaskScheduler s_defaultTaskScheduler;
	internal static int s_taskSchedulerIdCounter;
	private int m_taskSchedulerId;
	private static EventHandler`1<UnobservedTaskExceptionEventArgs> _unobservedTaskException;
	private static readonly object _unobservedTaskExceptionLockObject;

	// Properties
	internal virtual bool RequiresAtomicStartTransition { get; }
	public static TaskScheduler Default { get; }
	internal static TaskScheduler InternalCurrent { get; }
	public int Id { get; }

	// Methods
	protected internal abstract void QueueTask(Task task);
	protected abstract bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
	internal bool TryRunInline(Task task, bool taskWasPreviouslyQueued);
	protected internal virtual bool TryDequeue(Task task);
	internal virtual void NotifyWorkItemProgress();
	internal virtual bool get_RequiresAtomicStartTransition();
	internal void InternalQueueTask(Task task);
	protected void .ctor();
	private void AddToActiveTaskSchedulers();
	public static TaskScheduler get_Default();
	internal static TaskScheduler get_InternalCurrent();
	public int get_Id();
	internal static void PublishUnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs ueea);
	private static void .cctor();

}
//NameSpace:
internal sealed class TaskScheduler.SystemThreadingTasks_TaskSchedulerDebugView
{
}
//NameSpace:System.Threading.Tasks
public class UnobservedTaskExceptionEventArgs : EventArgs
{
	// Fields
	private AggregateException m_exception;
	internal bool m_observed;

	// Methods
	public void .ctor(AggregateException exception);

}
//NameSpace:System.Threading.Tasks
public class TaskSchedulerException : Exception
{
	// Methods
	public void .ctor();
	public void .ctor(Exception innerException);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Threading.Tasks
internal static class TaskToApm
{
	// Methods
	public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
	public static void End(IAsyncResult asyncResult);
	public static T End(IAsyncResult asyncResult);
	private static void InvokeCallbackWhenTaskCompletes(Task antecedent, AsyncCallback callback, IAsyncResult asyncResult);

}
//NameSpace:
private sealed class TaskToApm.TaskWrapperAsyncResult : IAsyncResult
{
	// Fields
	internal readonly Task Task;
	private readonly object m_state;
	private readonly bool m_completedSynchronously;

	// Properties
	private object System.IAsyncResult.AsyncState { get; }
	private bool System.IAsyncResult.CompletedSynchronously { get; }
	private WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }

	// Methods
	internal void .ctor(Task task, object state, bool completedSynchronously);
	private object System.IAsyncResult.get_AsyncState();
	private bool System.IAsyncResult.get_CompletedSynchronously();
	private WaitHandle System.IAsyncResult.get_AsyncWaitHandle();

}
//NameSpace:
private sealed class TaskToApm.<>c__DisplayClass3_0
{
	// Fields
	public AsyncCallback callback;
	public IAsyncResult asyncResult;

	// Methods
	public void .ctor();
	internal void <InvokeCallbackWhenTaskCompletes>b__0();

}
//NameSpace:System.Threading.Tasks
internal sealed class ThreadPoolTaskScheduler : TaskScheduler
{
	// Fields
	private static readonly ParameterizedThreadStart s_longRunningThreadWork;

	// Properties
	internal override bool RequiresAtomicStartTransition { get; }

	// Methods
	internal void .ctor();
	private static void LongRunningThreadWork(object obj);
	protected internal override void QueueTask(Task task);
	protected override bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
	protected internal override bool TryDequeue(Task task);
	internal override void NotifyWorkItemProgress();
	internal override bool get_RequiresAtomicStartTransition();
	private static void .cctor();

}
//NameSpace:System.Security
public sealed class UnverifiableCodeAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Security
public sealed class AllowPartiallyTrustedCallersAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Security
public enum SecurityRuleSet
{
	// Fields
	public byte value__;
	public const SecurityRuleSet None;
	public const SecurityRuleSet Level1;
	public const SecurityRuleSet Level2;

}
//NameSpace:System.Security
public sealed class SecurityRulesAttribute : Attribute
{
	// Fields
	private SecurityRuleSet m_ruleSet;
	private bool m_skipVerificationInFullTrust;

	// Properties
	public void SkipVerificationInFullTrust { set; }

	// Methods
	public void .ctor(SecurityRuleSet ruleSet);
	public void set_SkipVerificationInFullTrust(bool value);

}
//NameSpace:System.Security
internal sealed class SecurityDocument
{
	// Fields
	internal byte[] m_data;

	// Methods
	public void .ctor(int numData);
	public void GuaranteeSize(int size);
	public void AddString(string str, int position);
	public void AppendString(string str, int position);
	public static int EncodedStringSize(string str);
	public string GetString(int position, bool bCreate);
	public void AddToken(byte b, int position);
	public SecurityElement GetRootElement();
	public SecurityElement GetElement(int position, bool bCreate);
	internal SecurityElement InternalGetElement(int position, bool bCreate);

}
//NameSpace:System.Security
public interface IEvidenceFactory
{
}
//NameSpace:System.Security
internal enum SecurityElementType
{
	// Fields
	public int value__;
	public const SecurityElementType Regular;
	public const SecurityElementType Format;
	public const SecurityElementType Comment;

}
//NameSpace:System.Security
public sealed class SecurityElement
{
	// Fields
	private string text;
	private string tag;
	private ArrayList attributes;
	private ArrayList children;
	private static readonly char[] invalid_tag_chars;
	private static readonly char[] invalid_text_chars;
	private static readonly char[] invalid_attr_name_chars;
	private static readonly char[] invalid_attr_value_chars;
	private static readonly char[] invalid_chars;

	// Properties
	public Hashtable Attributes { get; }
	public ArrayList Children { get; }
	public string Tag { get; }
	public string Text { get; set; }
	internal void m_strText { set; }

	// Methods
	public void .ctor(string tag);
	public void .ctor(string tag, string text);
	public Hashtable get_Attributes();
	public ArrayList get_Children();
	public string get_Tag();
	public string get_Text();
	public void set_Text(string value);
	public void AddAttribute(string name, string value);
	public void AddChild(SecurityElement child);
	public static string Escape(string str);
	private static string Unescape(string str);
	public static SecurityElement FromString(string xml);
	public static bool IsValidAttributeName(string name);
	public static bool IsValidAttributeValue(string value);
	public static bool IsValidTag(string tag);
	public static bool IsValidText(string text);
	public SecurityElement SearchForChildByTag(string tag);
	public override string ToString();
	private void ToXml(StringBuilder s, int level);
	internal SecurityElement.SecurityAttribute GetAttribute(string name);
	internal void set_m_strText(string value);
	internal string SearchForTextOfLocalName(string strLocalName);
	private static void .cctor();

}
//NameSpace:
internal class SecurityElement.SecurityAttribute
{
	// Fields
	private string _name;
	private string _value;

	// Properties
	public string Name { get; }
	public string Value { get; }

	// Methods
	public void .ctor(string name, string value);
	public string get_Name();
	public string get_Value();

}
//NameSpace:System.Security
public class SecurityException : SystemException
{
	// Fields
	private string permissionState;

	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public void .ctor(string message, Exception inner);
	public override void GetObjectData(SerializationInfo info, StreamingContext context);
	public override string ToString();

}
//NameSpace:System.Security
public static class SecurityManager
{
	// Methods
	internal static bool CheckElevatedPermissions();
	internal static void EnsureElevatedPermissions();

}
//NameSpace:System.Security
public sealed class XmlSyntaxException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(int lineNumber);
	public void .ctor(int lineNumber, string message);
	public void .ctor(string message);
	public void .ctor(string message, Exception inner);
	internal void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Security.Policy
public sealed class Evidence : ICollection, IEnumerable
{
	// Fields
	private bool _locked;
	private ArrayList hostEvidenceList;
	private ArrayList assemblyEvidenceList;

	// Properties
	public int Count { get; }
	public bool IsSynchronized { get; }
	public object SyncRoot { get; }

	// Methods
	public void .ctor();
	public int get_Count();
	public bool get_IsSynchronized();
	public object get_SyncRoot();
	public void CopyTo(Array array, int index);
	public IEnumerator GetEnumerator();

}
//NameSpace:
private class Evidence.EvidenceEnumerator : IEnumerator
{
	// Fields
	private IEnumerator currentEnum;
	private IEnumerator hostEnum;
	private IEnumerator assemblyEnum;

	// Properties
	public object Current { get; }

	// Methods
	public void .ctor(IEnumerator hostenum, IEnumerator assemblyenum);
	public bool MoveNext();
	public object get_Current();

}
//NameSpace:System.Security.Permissions
public abstract class CodeAccessSecurityAttribute : SecurityAttribute
{
}
//NameSpace:System.Security.Permissions
public abstract class SecurityAttribute : Attribute
{
}
//NameSpace:System.Security.Permissions
public sealed class SecurityPermissionAttribute : CodeAccessSecurityAttribute
{
	// Fields
	private SecurityPermissionFlag m_Flags;

	// Properties
	public void SkipVerification { set; }

	// Methods
	public void set_SkipVerification(bool value);

}
//NameSpace:System.Security.Permissions
public enum SecurityPermissionFlag
{
	// Fields
	public int value__;
	public const SecurityPermissionFlag NoFlags;
	public const SecurityPermissionFlag Assertion;
	public const SecurityPermissionFlag UnmanagedCode;
	public const SecurityPermissionFlag SkipVerification;
	public const SecurityPermissionFlag Execution;
	public const SecurityPermissionFlag ControlThread;
	public const SecurityPermissionFlag ControlEvidence;
	public const SecurityPermissionFlag ControlPolicy;
	public const SecurityPermissionFlag SerializationFormatter;
	public const SecurityPermissionFlag ControlDomainPolicy;
	public const SecurityPermissionFlag ControlPrincipal;
	public const SecurityPermissionFlag ControlAppDomain;
	public const SecurityPermissionFlag RemotingConfiguration;
	public const SecurityPermissionFlag Infrastructure;
	public const SecurityPermissionFlag BindingRedirects;
	public const SecurityPermissionFlag AllFlags;

}
//NameSpace:System.Security.Util
internal sealed class Parser
{
	// Fields
	private SecurityDocument _doc;
	private Tokenizer _t;

	// Methods
	internal SecurityElement GetTopElement();
	private void GetRequiredSizes(TokenizerStream stream, int index);
	private int DetermineFormat(TokenizerStream stream);
	private void ParseContents();
	private void .ctor(Tokenizer t);
	internal void .ctor(string input);

}
//NameSpace:System.Security.Util
internal sealed class Tokenizer
{
	// Fields
	public int LineNo;
	private int _inProcessingTag;
	private byte[] _inBytes;
	private char[] _inChars;
	private string _inString;
	private int _inIndex;
	private int _inSize;
	private int _inSavedCharacter;
	private Tokenizer.TokenSource _inTokenSource;
	private Tokenizer.ITokenReader _inTokenReader;
	private Tokenizer.StringMaker _maker;
	private string[] _searchStrings;
	private string[] _replaceStrings;
	private int _inNestedIndex;
	private int _inNestedSize;
	private string _inNestedString;

	// Methods
	internal void BasicInitialization();
	public void Recycle();
	internal void .ctor(string input);
	internal void ChangeFormat(Encoding encoding);
	internal void GetTokens(TokenizerStream stream, int maxNum, bool endAfterKet);
	private string GetStringToken();

}
//NameSpace:
private enum Tokenizer.TokenSource
{
	// Fields
	public int value__;
	public const Tokenizer.TokenSource UnicodeByteArray;
	public const Tokenizer.TokenSource UTF8ByteArray;
	public const Tokenizer.TokenSource ASCIIByteArray;
	public const Tokenizer.TokenSource CharArray;
	public const Tokenizer.TokenSource String;
	public const Tokenizer.TokenSource NestedStrings;
	public const Tokenizer.TokenSource Other;

}
//NameSpace:
internal sealed class Tokenizer.StringMaker
{
	// Fields
	private string[] aStrings;
	private uint cStringsMax;
	private uint cStringsUsed;
	public StringBuilder _outStringBuilder;
	public char[] _outChars;
	public int _outIndex;

	// Methods
	private static uint HashString(string str);
	private static uint HashCharArray(char[] a, int l);
	public void .ctor();
	private bool CompareStringAndChars(string str, char[] a, int l);
	public string MakeString();

}
//NameSpace:
internal interface Tokenizer.ITokenReader
{
	// Methods
	public abstract int Read();

}
//NameSpace:
internal class Tokenizer.StreamTokenReader : Tokenizer.ITokenReader
{
	// Fields
	internal StreamReader _in;
	internal int _numCharRead;

	// Properties
	internal int NumCharEncountered { get; }

	// Methods
	internal void .ctor(StreamReader input);
	public virtual int Read();
	internal int get_NumCharEncountered();

}
//NameSpace:System.Security.Util
internal sealed class TokenizerShortBlock
{
	// Fields
	internal short[] m_block;
	internal TokenizerShortBlock m_next;

	// Methods
	public void .ctor();

}
//NameSpace:System.Security.Util
internal sealed class TokenizerStringBlock
{
	// Fields
	internal string[] m_block;
	internal TokenizerStringBlock m_next;

	// Methods
	public void .ctor();

}
//NameSpace:System.Security.Util
internal sealed class TokenizerStream
{
	// Fields
	private int m_countTokens;
	private TokenizerShortBlock m_headTokens;
	private TokenizerShortBlock m_lastTokens;
	private TokenizerShortBlock m_currentTokens;
	private int m_indexTokens;
	private TokenizerStringBlock m_headStrings;
	private TokenizerStringBlock m_currentStrings;
	private int m_indexStrings;

	// Methods
	internal void .ctor();
	internal void AddToken(short token);
	internal void AddString(string str);
	internal void Reset();
	internal short GetNextFullToken();
	internal short GetNextToken();
	internal string GetNextString();
	internal void ThrowAwayNextString();
	internal void TagLastToken(short tag);
	internal int GetTokenCount();
	internal void GoToPosition(int position);

}
//NameSpace:System.Security.Principal
public interface IPrincipal
{
}
//NameSpace:System.Security.Cryptography
public abstract class AsymmetricAlgorithm : IDisposable
{
	// Fields
	protected int KeySizeValue;
	protected KeySizes[] LegalKeySizesValue;

	// Properties
	public virtual int KeySize { get; set; }

	// Methods
	protected void .ctor();
	public void Dispose();
	public void Clear();
	protected virtual void Dispose(bool disposing);
	public virtual int get_KeySize();
	public virtual void set_KeySize(int value);
	public virtual void FromXmlString(string xmlString);
	public virtual string ToXmlString(bool includePrivateParameters);

}
//NameSpace:System.Security.Cryptography
public enum CipherMode
{
	// Fields
	public int value__;
	public const CipherMode CBC;
	public const CipherMode ECB;
	public const CipherMode OFB;
	public const CipherMode CFB;
	public const CipherMode CTS;

}
//NameSpace:System.Security.Cryptography
public enum PaddingMode
{
	// Fields
	public int value__;
	public const PaddingMode None;
	public const PaddingMode PKCS7;
	public const PaddingMode Zeros;
	public const PaddingMode ANSIX923;
	public const PaddingMode ISO10126;

}
//NameSpace:System.Security.Cryptography
public sealed class KeySizes
{
	// Fields
	private int m_minSize;
	private int m_maxSize;
	private int m_skipSize;

	// Properties
	public int MinSize { get; }
	public int MaxSize { get; }
	public int SkipSize { get; }

	// Methods
	public int get_MinSize();
	public int get_MaxSize();
	public int get_SkipSize();
	public void .ctor(int minSize, int maxSize, int skipSize);
	internal bool IsLegal(int keySize);
	internal static bool IsLegalKeySize(KeySizes[] legalKeys, int size);

}
//NameSpace:System.Security.Cryptography
public class CryptographicException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	public void .ctor(string format, string insert);
	public void .ctor(string message, Exception inner);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Security.Cryptography
public class CryptographicUnexpectedOperationException : CryptographicException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Security.Cryptography
public enum CspProviderFlags
{
	// Fields
	public int value__;
	public const CspProviderFlags NoFlags;
	public const CspProviderFlags UseMachineKeyStore;
	public const CspProviderFlags UseDefaultKeyContainer;
	public const CspProviderFlags UseNonExportableKey;
	public const CspProviderFlags UseExistingKey;
	public const CspProviderFlags UseArchivableKey;
	public const CspProviderFlags UseUserProtectedKey;
	public const CspProviderFlags NoPrompt;
	public const CspProviderFlags CreateEphemeralKey;

}
//NameSpace:System.Security.Cryptography
public sealed class CspParameters
{
	// Fields
	public int ProviderType;
	public string ProviderName;
	public string KeyContainerName;
	public int KeyNumber;
	private int m_flags;

	// Properties
	public CspProviderFlags Flags { get; set; }

	// Methods
	public CspProviderFlags get_Flags();
	public void set_Flags(CspProviderFlags value);
	public void .ctor();
	public void .ctor(int dwTypeIn);
	public void .ctor(int dwTypeIn, string strProviderNameIn, string strContainerNameIn);
	internal void .ctor(int providerType, string providerName, string keyContainerName, CspProviderFlags flags);

}
//NameSpace:System.Security.Cryptography
public abstract class DES : SymmetricAlgorithm
{
	// Fields
	private static KeySizes[] s_legalBlockSizes;
	private static KeySizes[] s_legalKeySizes;

	// Properties
	public override byte[] Key { get; set; }

	// Methods
	protected void .ctor();
	public override byte[] get_Key();
	public override void set_Key(byte[] value);
	public static DES Create();
	public static bool IsWeakKey(byte[] rgbKey);
	public static bool IsSemiWeakKey(byte[] rgbKey);
	private static bool IsLegalKeySize(byte[] rgbKey);
	private static ulong QuadWordFromBigEndian(byte[] block);
	private static void .cctor();

}
//NameSpace:System.Security.Cryptography
public sealed class DESCryptoServiceProvider : DES
{
	// Methods
	public void .ctor();
	public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
	public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
	public override void GenerateKey();
	public override void GenerateIV();

}
//NameSpace:System.Security.Cryptography
public struct DSAParameters
{
	// Fields
	public byte[] P;
	public byte[] Q;
	public byte[] G;
	public byte[] Y;
	public byte[] J;
	public byte[] X;
	public byte[] Seed;
	public int Counter;

}
//NameSpace:System.Security.Cryptography
public abstract class DSA : AsymmetricAlgorithm
{
	// Methods
	protected void .ctor();
	public static DSA Create();
	public override void FromXmlString(string xmlString);
	public override string ToXmlString(bool includePrivateParameters);
	public abstract DSAParameters ExportParameters(bool includePrivateParameters);
	public abstract void ImportParameters(DSAParameters parameters);

}
//NameSpace:System.Security.Cryptography
public abstract class HashAlgorithm : IDisposable, ICryptoTransform
{
	// Fields
	protected int HashSizeValue;
	protected internal byte[] HashValue;
	protected int State;
	private bool m_bDisposed;

	// Properties
	public virtual int HashSize { get; }
	public virtual byte[] Hash { get; }

	// Methods
	protected void .ctor();
	public virtual int get_HashSize();
	public virtual byte[] get_Hash();
	public byte[] ComputeHash(byte[] buffer);
	public byte[] ComputeHash(byte[] buffer, int offset, int count);
	public int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
	public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
	public void Dispose();
	protected virtual void Dispose(bool disposing);
	public abstract void Initialize();
	protected abstract void HashCore(byte[] array, int ibStart, int cbSize);
	protected abstract byte[] HashFinal();

}
//NameSpace:System.Security.Cryptography
public abstract class HMAC : KeyedHashAlgorithm
{
	// Fields
	private int blockSizeValue;
	internal string m_hashName;
	internal HashAlgorithm m_hash1;
	internal HashAlgorithm m_hash2;
	private byte[] m_inner;
	private byte[] m_outer;
	private bool m_hashing;

	// Properties
	protected int BlockSizeValue { get; }
	public override void Key { set; }

	// Methods
	protected int get_BlockSizeValue();
	private void UpdateIOPadBuffers();
	internal void InitializeKey(byte[] key);
	public override void set_Key(byte[] value);
	public static HMAC Create();
	public override void Initialize();
	protected override void HashCore(byte[] rgb, int ib, int cb);
	protected override byte[] HashFinal();
	protected override void Dispose(bool disposing);
	protected void .ctor();

}
//NameSpace:System.Security.Cryptography
public class HMACSHA1 : HMAC
{
	// Methods
	public void .ctor();
	public void .ctor(byte[] key);
	public void .ctor(byte[] key, bool useManagedSha1);

}
//NameSpace:System.Security.Cryptography
public interface ICryptoTransform : IDisposable
{
	// Methods
	public abstract byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);

}
//NameSpace:System.Security.Cryptography
public abstract class KeyedHashAlgorithm : HashAlgorithm
{
	// Fields
	protected byte[] KeyValue;

	// Properties
	public virtual void Key { set; }

	// Methods
	protected void .ctor();
	protected override void Dispose(bool disposing);
	public virtual void set_Key(byte[] value);

}
//NameSpace:System.Security.Cryptography
public abstract class MD5 : HashAlgorithm
{
	// Methods
	protected void .ctor();
	public static MD5 Create();

}
//NameSpace:System.Security.Cryptography
public abstract class RandomNumberGenerator : IDisposable
{
	// Methods
	protected void .ctor();
	public static RandomNumberGenerator Create();
	public void Dispose();
	protected virtual void Dispose(bool disposing);
	public abstract void GetBytes(byte[] data);

}
//NameSpace:System.Security.Cryptography
public abstract class RC2 : SymmetricAlgorithm
{
	// Fields
	protected int EffectiveKeySizeValue;
	private static KeySizes[] s_legalBlockSizes;
	private static KeySizes[] s_legalKeySizes;

	// Properties
	public virtual int EffectiveKeySize { get; }
	public override int KeySize { get; }

	// Methods
	protected void .ctor();
	public virtual int get_EffectiveKeySize();
	public override int get_KeySize();
	public static RC2 Create();
	private static void .cctor();

}
//NameSpace:System.Security.Cryptography
public sealed class RC2CryptoServiceProvider : RC2
{
	// Fields
	private bool m_use40bitSalt;
	private static KeySizes[] s_legalKeySizes;

	// Properties
	public override int EffectiveKeySize { get; }

	// Methods
	public void .ctor();
	public override int get_EffectiveKeySize();
	public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
	public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
	public override void GenerateKey();
	public override void GenerateIV();
	private static void .cctor();

}
//NameSpace:System.Security.Cryptography
public abstract class RIPEMD160 : HashAlgorithm
{
	// Methods
	protected void .ctor();
	public static RIPEMD160 Create();

}
//NameSpace:System.Security.Cryptography
public class RIPEMD160Managed : RIPEMD160
{
	// Fields
	private byte[] _buffer;
	private long _count;
	private uint[] _stateMD160;
	private uint[] _blockDWords;

	// Methods
	public void .ctor();
	public override void Initialize();
	protected override void HashCore(byte[] rgb, int ibStart, int cbSize);
	protected override byte[] HashFinal();
	private void InitializeState();
	private void _HashData(byte[] partIn, int ibStart, int cbSize);
	private byte[] _EndHash();
	private static void MDTransform(uint* blockDWords, uint* state, byte* block);
	private static uint F(uint x, uint y, uint z);
	private static uint G(uint x, uint y, uint z);
	private static uint H(uint x, uint y, uint z);
	private static uint I(uint x, uint y, uint z);
	private static uint J(uint x, uint y, uint z);

}
//NameSpace:System.Security.Cryptography
public struct RSAParameters
{
	// Fields
	public byte[] Exponent;
	public byte[] Modulus;
	public byte[] P;
	public byte[] Q;
	public byte[] DP;
	public byte[] DQ;
	public byte[] InverseQ;
	public byte[] D;

}
//NameSpace:System.Security.Cryptography
public abstract class RSA : AsymmetricAlgorithm
{
	// Methods
	protected void .ctor();
	public static RSA Create();
	public override void FromXmlString(string xmlString);
	public override string ToXmlString(bool includePrivateParameters);
	public abstract RSAParameters ExportParameters(bool includePrivateParameters);
	public abstract void ImportParameters(RSAParameters parameters);

}
//NameSpace:System.Security.Cryptography
public sealed class RSACryptoServiceProvider : RSA, ICspAsymmetricAlgorithm
{
	// Fields
	private static CspProviderFlags s_UseMachineKeyStore;
	private KeyPairPersistence store;
	private bool persistKey;
	private bool persisted;
	private bool privateKeyExportable;
	private bool m_disposed;
	private RSAManaged rsa;

	// Properties
	public static bool UseMachineKeyStore { get; }
	public override int KeySize { get; }

	// Methods
	public static bool get_UseMachineKeyStore();
	public void .ctor();
	public void .ctor(CspParameters parameters);
	public void .ctor(int dwKeySize);
	public void .ctor(int dwKeySize, CspParameters parameters);
	private void Common(int dwKeySize, bool parameters);
	private void Common(CspParameters p);
	protected override void Finalize();
	public override int get_KeySize();
	public override RSAParameters ExportParameters(bool includePrivateParameters);
	public override void ImportParameters(RSAParameters parameters);
	protected override void Dispose(bool disposing);
	private void OnKeyGenerated(object sender, EventArgs e);
	private static void .cctor();

}
//NameSpace:System.Security.Cryptography
public abstract class SHA1 : HashAlgorithm
{
	// Methods
	protected void .ctor();
	public static SHA1 Create();

}
//NameSpace:System.Security.Cryptography
public class SHA1Managed : SHA1
{
	// Fields
	private byte[] _buffer;
	private long _count;
	private uint[] _stateSHA1;
	private uint[] _expandedBuffer;

	// Methods
	public void .ctor();
	public override void Initialize();
	protected override void HashCore(byte[] rgb, int ibStart, int cbSize);
	protected override byte[] HashFinal();
	private void InitializeState();
	private void _HashData(byte[] partIn, int ibStart, int cbSize);
	private byte[] _EndHash();
	private static void SHATransform(uint* expandedBuffer, uint* state, byte* block);
	private static void SHAExpand(uint* x);

}
//NameSpace:System.Security.Cryptography
public abstract class SHA256 : HashAlgorithm
{
	// Methods
	protected void .ctor();
	public static SHA256 Create();

}
//NameSpace:System.Security.Cryptography
public class SHA256Managed : SHA256
{
	// Fields
	private byte[] _buffer;
	private long _count;
	private uint[] _stateSHA256;
	private uint[] _W;
	private static readonly uint[] _K;

	// Methods
	public void .ctor();
	public override void Initialize();
	protected override void HashCore(byte[] rgb, int ibStart, int cbSize);
	protected override byte[] HashFinal();
	private void InitializeState();
	private void _HashData(byte[] partIn, int ibStart, int cbSize);
	private byte[] _EndHash();
	private static void SHATransform(uint* expandedBuffer, uint* state, byte* block);
	private static uint RotateRight(uint x, int n);
	private static uint Ch(uint x, uint y, uint z);
	private static uint Maj(uint x, uint y, uint z);
	private static uint sigma_0(uint x);
	private static uint sigma_1(uint x);
	private static uint Sigma_0(uint x);
	private static uint Sigma_1(uint x);
	private static void SHA256Expand(uint* x);
	private static void .cctor();

}
//NameSpace:System.Security.Cryptography
public abstract class SHA384 : HashAlgorithm
{
	// Methods
	protected void .ctor();
	public static SHA384 Create();

}
//NameSpace:System.Security.Cryptography
public class SHA384Managed : SHA384
{
	// Fields
	private byte[] _buffer;
	private ulong _count;
	private ulong[] _stateSHA384;
	private ulong[] _W;
	private static readonly ulong[] _K;

	// Methods
	public void .ctor();
	public override void Initialize();
	protected override void HashCore(byte[] rgb, int ibStart, int cbSize);
	protected override byte[] HashFinal();
	private void InitializeState();
	private void _HashData(byte[] partIn, int ibStart, int cbSize);
	private byte[] _EndHash();
	private static void SHATransform(ulong* expandedBuffer, ulong* state, byte* block);
	private static ulong RotateRight(ulong x, int n);
	private static ulong Ch(ulong x, ulong y, ulong z);
	private static ulong Maj(ulong x, ulong y, ulong z);
	private static ulong Sigma_0(ulong x);
	private static ulong Sigma_1(ulong x);
	private static ulong sigma_0(ulong x);
	private static ulong sigma_1(ulong x);
	private static void SHA384Expand(ulong* x);
	private static void .cctor();

}
//NameSpace:System.Security.Cryptography
public abstract class SHA512 : HashAlgorithm
{
	// Methods
	protected void .ctor();
	public static SHA512 Create();

}
//NameSpace:System.Security.Cryptography
public class SHA512Managed : SHA512
{
	// Fields
	private byte[] _buffer;
	private ulong _count;
	private ulong[] _stateSHA512;
	private ulong[] _W;
	private static readonly ulong[] _K;

	// Methods
	public void .ctor();
	public override void Initialize();
	protected override void HashCore(byte[] rgb, int ibStart, int cbSize);
	protected override byte[] HashFinal();
	private void InitializeState();
	private void _HashData(byte[] partIn, int ibStart, int cbSize);
	private byte[] _EndHash();
	private static void SHATransform(ulong* expandedBuffer, ulong* state, byte* block);
	private static ulong RotateRight(ulong x, int n);
	private static ulong Ch(ulong x, ulong y, ulong z);
	private static ulong Maj(ulong x, ulong y, ulong z);
	private static ulong Sigma_0(ulong x);
	private static ulong Sigma_1(ulong x);
	private static ulong sigma_0(ulong x);
	private static ulong sigma_1(ulong x);
	private static void SHA512Expand(ulong* x);
	private static void .cctor();

}
//NameSpace:System.Security.Cryptography
public abstract class SymmetricAlgorithm : IDisposable
{
	// Fields
	protected int BlockSizeValue;
	protected int FeedbackSizeValue;
	protected byte[] IVValue;
	protected byte[] KeyValue;
	protected KeySizes[] LegalBlockSizesValue;
	protected KeySizes[] LegalKeySizesValue;
	protected int KeySizeValue;
	protected CipherMode ModeValue;
	protected PaddingMode PaddingValue;

	// Properties
	public virtual int BlockSize { get; }
	public virtual int FeedbackSize { get; }
	public virtual byte[] IV { get; set; }
	public virtual byte[] Key { get; set; }
	public virtual KeySizes[] LegalKeySizes { get; }
	public virtual int KeySize { get; }
	public virtual CipherMode Mode { get; set; }
	public virtual PaddingMode Padding { get; }

	// Methods
	protected void .ctor();
	public void Dispose();
	public void Clear();
	protected virtual void Dispose(bool disposing);
	public virtual int get_BlockSize();
	public virtual int get_FeedbackSize();
	public virtual byte[] get_IV();
	public virtual void set_IV(byte[] value);
	public virtual byte[] get_Key();
	public virtual void set_Key(byte[] value);
	public virtual KeySizes[] get_LegalKeySizes();
	public virtual int get_KeySize();
	public virtual CipherMode get_Mode();
	public virtual void set_Mode(CipherMode value);
	public virtual PaddingMode get_Padding();
	public bool ValidKeySize(int bitLength);
	public virtual ICryptoTransform CreateEncryptor();
	public abstract ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
	public virtual ICryptoTransform CreateDecryptor();
	public abstract ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
	public abstract void GenerateKey();
	public abstract void GenerateIV();

}
//NameSpace:System.Security.Cryptography
public abstract class TripleDES : SymmetricAlgorithm
{
	// Fields
	private static KeySizes[] s_legalBlockSizes;
	private static KeySizes[] s_legalKeySizes;

	// Properties
	public override byte[] Key { get; set; }

	// Methods
	protected void .ctor();
	public override byte[] get_Key();
	public override void set_Key(byte[] value);
	public static TripleDES Create();
	public static bool IsWeakKey(byte[] rgbKey);
	private static bool EqualBytes(byte[] rgbKey, int start1, int start2, int count);
	private static bool IsLegalKeySize(byte[] rgbKey);
	private static void .cctor();

}
//NameSpace:System.Security.Cryptography
public sealed class TripleDESCryptoServiceProvider : TripleDES
{
	// Methods
	public void .ctor();
	public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
	public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
	public override void GenerateKey();
	public override void GenerateIV();

}
//NameSpace:System.Security.Cryptography
internal static class Utils
{
	// Fields
	private static RNGCryptoServiceProvider _rng;

	// Properties
	internal static RNGCryptoServiceProvider StaticRandomNumberGenerator { get; }

	// Methods
	private static void .cctor();
	internal static RNGCryptoServiceProvider get_StaticRandomNumberGenerator();
	internal static byte[] GenerateRandom(int keySize);
	internal static bool HasAlgorithm(int dwCalg, int dwKeySize);
	internal static string DiscardWhiteSpaces(string inputBuffer);
	internal static string DiscardWhiteSpaces(string inputBuffer, int inputOffset, int inputCount);
	internal static int ConvertByteArrayToInt(byte[] input);
	internal static byte[] ConvertIntToByteArray(int dwInput);
	internal static byte[] FixupKeyParity(byte[] key);
	internal static void DWORDFromLittleEndian(uint* x, int digits, byte* block);
	internal static void DWORDToLittleEndian(byte[] block, uint[] x, int digits);
	internal static void DWORDFromBigEndian(uint* x, int digits, byte* block);
	internal static void DWORDToBigEndian(byte[] block, uint[] x, int digits);
	internal static void QuadWordFromBigEndian(ulong* x, int digits, byte* block);
	internal static void QuadWordToBigEndian(byte[] block, ulong[] x, int digits);

}
//NameSpace:System.Security.Cryptography
public class CryptoConfig
{
	// Properties
	public static bool AllowOnlyFipsAlgorithms { get; }

	// Methods
	public static byte[] EncodeOID(string str);
	private static byte[] EncodeLongNumber(long x);
	public static bool get_AllowOnlyFipsAlgorithms();

}
//NameSpace:System.Security.Cryptography
internal class DESTransform : SymmetricTransform
{
	// Fields
	internal static readonly int KEY_BIT_SIZE;
	internal static readonly int KEY_BYTE_SIZE;
	internal static readonly int BLOCK_BIT_SIZE;
	internal static readonly int BLOCK_BYTE_SIZE;
	private byte[] keySchedule;
	private byte[] byteBuff;
	private uint[] dwordBuff;
	private static readonly uint[] spBoxes;
	private static readonly byte[] PC1;
	private static readonly byte[] leftRotTotal;
	private static readonly byte[] PC2;
	internal static readonly uint[] ipTab;
	internal static readonly uint[] fpTab;

	// Methods
	internal void .ctor(SymmetricAlgorithm symmAlgo, bool encryption, byte[] key, byte[] iv);
	private uint CipherFunct(uint r, int n);
	internal static void Permutation(byte[] input, byte[] output, uint[] permTab, bool preSwap);
	private static void BSwap(byte[] byteBuff);
	internal void SetKey(byte[] key);
	public void ProcessBlock(byte[] input, byte[] output);
	protected override void ECB(byte[] input, byte[] output);
	internal static byte[] GetStrongKey();
	private static void .cctor();

}
//NameSpace:System.Security.Cryptography
public sealed class DSACryptoServiceProvider : DSA, ICspAsymmetricAlgorithm
{
	// Fields
	private KeyPairPersistence store;
	private bool persistKey;
	private bool persisted;
	private bool privateKeyExportable;
	private bool m_disposed;
	private DSAManaged dsa;
	private static bool useMachineKeyStore;

	// Properties
	public override int KeySize { get; }

	// Methods
	public void .ctor();
	public void .ctor(int dwKeySize);
	private void Common(int dwKeySize, bool parameters);
	protected override void Finalize();
	public override int get_KeySize();
	public override DSAParameters ExportParameters(bool includePrivateParameters);
	public override void ImportParameters(DSAParameters parameters);
	protected override void Dispose(bool disposing);
	private void OnKeyGenerated(object sender, EventArgs e);

}
//NameSpace:System.Security.Cryptography
public interface ICspAsymmetricAlgorithm
{
}
//NameSpace:System.Security.Cryptography
public sealed class MD5CryptoServiceProvider : MD5
{
	// Fields
	private uint[] _H;
	private uint[] buff;
	private ulong count;
	private byte[] _ProcessingBuffer;
	private int _ProcessingBufferCount;
	private static readonly uint[] K;

	// Methods
	public void .ctor();
	protected override void Finalize();
	protected override void Dispose(bool disposing);
	protected override void HashCore(byte[] rgb, int ibStart, int cbSize);
	protected override byte[] HashFinal();
	public override void Initialize();
	private void ProcessBlock(byte[] inputBuffer, int inputOffset);
	private void ProcessFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
	internal void AddLength(ulong length, byte[] buffer, int position);
	private static void .cctor();

}
//NameSpace:System.Security.Cryptography
internal class RC2Transform : SymmetricTransform
{
	// Fields
	private ushort R0;
	private ushort R1;
	private ushort R2;
	private ushort R3;
	private ushort[] K;
	private int j;
	private static readonly byte[] pitable;

	// Methods
	public void .ctor(RC2 rc2Algo, bool encryption, byte[] key, byte[] iv);
	protected override void ECB(byte[] input, byte[] output);
	private static void .cctor();

}
//NameSpace:System.Security.Cryptography
public sealed class RNGCryptoServiceProvider : RandomNumberGenerator
{
	// Fields
	private static object _lock;
	private IntPtr _handle;

	// Methods
	private static void .cctor();
	public void .ctor();
	private void Check();
	private static bool RngOpen();
	private static IntPtr RngInitialize(byte[] seed);
	private static IntPtr RngGetBytes(IntPtr handle, byte[] data);
	private static void RngClose(IntPtr handle);
	public override void GetBytes(byte[] data);
	protected override void Finalize();
	protected override void Dispose(bool disposing);

}
//NameSpace:System.Security.Cryptography
internal class SHA1Internal
{
	// Fields
	private uint[] _H;
	private ulong count;
	private byte[] _ProcessingBuffer;
	private int _ProcessingBufferCount;
	private uint[] buff;

	// Methods
	public void .ctor();
	public void HashCore(byte[] rgb, int ibStart, int cbSize);
	public byte[] HashFinal();
	public void Initialize();
	private void ProcessBlock(byte[] inputBuffer, uint inputOffset);
	private static void InitialiseBuff(uint[] buff, byte[] input, uint inputOffset);
	private static void FillBuff(uint[] buff);
	private void ProcessFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
	internal void AddLength(ulong length, byte[] buffer, int position);

}
//NameSpace:System.Security.Cryptography
public sealed class SHA1CryptoServiceProvider : SHA1
{
	// Fields
	private SHA1Internal sha;

	// Methods
	public void .ctor();
	protected override void Finalize();
	protected override void Dispose(bool disposing);
	protected override void HashCore(byte[] rgb, int ibStart, int cbSize);
	protected override byte[] HashFinal();
	public override void Initialize();

}
//NameSpace:System.Security.Cryptography
internal class TripleDESTransform : SymmetricTransform
{
	// Fields
	private DESTransform E1;
	private DESTransform D2;
	private DESTransform E3;
	private DESTransform D1;
	private DESTransform E2;
	private DESTransform D3;

	// Methods
	public void .ctor(TripleDES algo, bool encryption, byte[] key, byte[] iv);
	protected override void ECB(byte[] input, byte[] output);
	internal static byte[] GetStrongKey();

}
//NameSpace:System.Security.Cryptography.X509Certificates
public enum X509KeyStorageFlags
{
	// Fields
	public int value__;
	public const X509KeyStorageFlags DefaultKeySet;
	public const X509KeyStorageFlags UserKeySet;
	public const X509KeyStorageFlags MachineKeySet;
	public const X509KeyStorageFlags Exportable;
	public const X509KeyStorageFlags UserProtected;
	public const X509KeyStorageFlags PersistKeySet;
	public const X509KeyStorageFlags EphemeralKeySet;

}
//NameSpace:System.Security.Cryptography.X509Certificates
public class X509Certificate : IDeserializationCallback, ISerializable, IDisposable
{
	// Fields
	private X509CertificateImpl impl;
	private bool hideDates;
	private string issuer_name;
	private string subject_name;

	// Properties
	internal X509CertificateImpl Impl { get; }

	// Methods
	internal void .ctor(X509CertificateImpl impl);
	internal X509CertificateImpl get_Impl();
	public virtual bool Equals(X509Certificate other);
	public override int GetHashCode();
	public virtual byte[] GetRawCertData();
	public override string ToString();
	public void .ctor();
	public void .ctor(SerializationInfo info, StreamingContext context);
	public override bool Equals(object obj);
	public virtual void Import(byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
	private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	public void Dispose();
	protected virtual void Dispose(bool disposing);
	public virtual void Reset();

}
//NameSpace:System.Security.Cryptography.X509Certificates
internal abstract class X509CertificateImpl : IDisposable
{
	// Fields
	private byte[] cachedCertificateHash;

	// Properties
	public abstract bool IsValid { get; }

	// Methods
	public abstract bool get_IsValid();
	protected void ThrowIfContextInvalid();
	public abstract X509CertificateImpl Clone();
	public abstract byte[] GetRawCertData();
	protected abstract byte[] GetCertHash(bool lazy);
	public override int GetHashCode();
	public abstract bool Equals(X509CertificateImpl other, out bool result);
	public override bool Equals(object obj);
	public void Dispose();
	protected virtual void Dispose(bool disposing);
	protected override void Finalize();
	protected void .ctor();

}
//NameSpace:System.Security.Cryptography.X509Certificates
internal sealed class X509CertificateImplMono : X509CertificateImpl
{
	// Fields
	private X509Certificate x509;

	// Properties
	public override bool IsValid { get; }

	// Methods
	public void .ctor(X509Certificate x509);
	public override bool get_IsValid();
	public override X509CertificateImpl Clone();
	public override byte[] GetRawCertData();
	protected override byte[] GetCertHash(bool lazy);
	public override bool Equals(X509CertificateImpl other, out bool result);
	protected override void Dispose(bool disposing);

}
//NameSpace:System.Security.Cryptography.X509Certificates
internal static class X509Helper
{
	// Methods
	private static X509CertificateImpl Import(byte[] rawData);
	public static X509CertificateImpl InitFromCertificate(X509CertificateImpl impl);
	public static bool IsValid(X509CertificateImpl impl);
	internal static void ThrowIfContextInvalid(X509CertificateImpl impl);
	internal static Exception GetInvalidContextException();
	internal static X509Certificate ImportPkcs12(byte[] rawData, string password);
	private static byte[] PEM(string type, byte[] data);
	private static byte[] ConvertData(byte[] data);
	private static X509CertificateImpl ImportCore(byte[] rawData);
	public static X509CertificateImpl Import(byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);

}
//NameSpace:System.Runtime.Versioning
internal static class BinaryCompatibility
{
	// Fields
	public static readonly bool TargetsAtLeast_Desktop_V4_5;
	public static readonly bool TargetsAtLeast_Desktop_V4_5_1;

	// Methods
	private static void .cctor();

}
//NameSpace:System.Runtime.Serialization
internal sealed class DeserializationEventHandler : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(object sender);
	public virtual IAsyncResult BeginInvoke(object sender, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System.Runtime.Serialization
internal sealed class SerializationEventHandler : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(StreamingContext context);
	public virtual IAsyncResult BeginInvoke(StreamingContext context, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System.Runtime.Serialization
public class FormatterConverter : IFormatterConverter
{
	// Methods
	public void .ctor();
	public object Convert(object value, Type type);
	public bool ToBoolean(object value);
	public int ToInt32(object value);
	public long ToInt64(object value);
	public float ToSingle(object value);
	public string ToString(object value);

}
//NameSpace:System.Runtime.Serialization
public static class FormatterServices
{
	// Fields
	internal static ConcurrentDictionary`2<MemberHolderMemberInfo[]> m_MemberInfoTable;
	private static bool unsafeTypeForwardersIsEnabled;
	private static bool unsafeTypeForwardersIsEnabledInitialized;
	private static readonly Type[] advancedTypes;
	private static Binder s_binder;

	// Methods
	private static void .cctor();
	private static MemberInfo[] GetSerializableMembers(RuntimeType type);
	private static bool CheckSerializable(RuntimeType type);
	private static MemberInfo[] InternalGetSerializableMembers(RuntimeType type);
	private static bool GetParentTypes(RuntimeType parentType, out RuntimeType[] parentTypes, out int parentTypeCount);
	public static MemberInfo[] GetSerializableMembers(Type type, StreamingContext context);
	public static object GetUninitializedObject(Type type);
	private static object nativeGetUninitializedObject(RuntimeType type);
	private static bool GetEnableUnsafeTypeForwarders();
	internal static bool UnsafeTypeForwardersIsEnabled();
	internal static void SerializationSetValue(MemberInfo fi, object target, object value);
	public static object PopulateObjectMembers(object obj, MemberInfo[] members, object[] data);
	public static object[] GetObjectData(object obj, MemberInfo[] members);
	public static Type GetTypeFromAssembly(Assembly assem, string name);
	internal static Assembly LoadAssemblyFromString(string assemblyName);
	internal static Assembly LoadAssemblyFromStringNoThrow(string assemblyName);
	internal static string GetClrAssemblyName(Type type, out bool hasTypeForwardedFrom);
	internal static string GetClrTypeFullName(Type type);
	private static string GetClrTypeFullNameForArray(Type type);
	private static string GetClrTypeFullNameForNonArrayTypes(Type type);

}
//NameSpace:
private sealed class FormatterServices.<>c__DisplayClass9_0
{
	// Fields
	public Type type;

	// Methods
	public void .ctor();
	internal MemberInfo[] <GetSerializableMembers>b__0(MemberHolder _);

}
//NameSpace:System.Runtime.Serialization
internal sealed class SurrogateForCyclicalReference : ISerializationSurrogate
{
	// Fields
	private ISerializationSurrogate innerSurrogate;

	// Methods
	public void GetObjectData(object obj, SerializationInfo info, StreamingContext context);
	public object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector);

}
//NameSpace:System.Runtime.Serialization
public interface IDeserializationCallback
{
	// Methods
	public abstract void OnDeserialization(object sender);

}
//NameSpace:System.Runtime.Serialization
public interface IFormatter
{
}
//NameSpace:System.Runtime.Serialization
public interface IFormatterConverter
{
	// Methods
	public abstract object Convert(object value, Type type);
	public abstract bool ToBoolean(object value);
	public abstract int ToInt32(object value);
	public abstract long ToInt64(object value);
	public abstract float ToSingle(object value);
	public abstract string ToString(object value);

}
//NameSpace:System.Runtime.Serialization
public interface IObjectReference
{
	// Methods
	public abstract object GetRealObject(StreamingContext context);

}
//NameSpace:System.Runtime.Serialization
public interface ISerializable
{
	// Methods
	public abstract void GetObjectData(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Runtime.Serialization
public interface ISerializationSurrogate
{
	// Methods
	public abstract void GetObjectData(object obj, SerializationInfo info, StreamingContext context);
	public abstract object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector);

}
//NameSpace:System.Runtime.Serialization
public interface ISurrogateSelector
{
	// Methods
	public abstract ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, out ISurrogateSelector selector);

}
//NameSpace:System.Runtime.Serialization
internal class MemberHolder
{
	// Fields
	internal Type memberType;
	internal StreamingContext context;

	// Methods
	internal void .ctor(Type type, StreamingContext ctx);
	public override int GetHashCode();
	public override bool Equals(object obj);

}
//NameSpace:System.Runtime.Serialization
public class ObjectIDGenerator
{
	// Fields
	internal int m_currentCount;
	internal int m_currentSize;
	internal long[] m_ids;
	internal object[] m_objs;
	private static readonly int[] sizes;

	// Methods
	public void .ctor();
	private int FindElement(object obj, out bool found);
	public virtual long GetId(object obj, out bool firstTime);
	public virtual long HasId(object obj, out bool firstTime);
	private void Rehash();
	private static void .cctor();

}
//NameSpace:System.Runtime.Serialization
public class ObjectManager
{
	// Fields
	private DeserializationEventHandler m_onDeserializationHandler;
	private SerializationEventHandler m_onDeserializedHandler;
	internal ObjectHolder[] m_objects;
	internal object m_topObject;
	internal ObjectHolderList m_specialFixupObjects;
	internal long m_fixupCount;
	internal ISurrogateSelector m_selector;
	internal StreamingContext m_context;

	// Properties
	internal object TopObject { get; set; }
	internal ObjectHolderList SpecialFixupObjects { get; }

	// Methods
	internal void .ctor(ISurrogateSelector selector, StreamingContext context, bool checkSecurity, bool isCrossAppDomain);
	private bool CanCallGetType(object obj);
	internal void set_TopObject(object value);
	internal object get_TopObject();
	internal ObjectHolderList get_SpecialFixupObjects();
	private static void .cctor();
	internal ObjectHolder FindObjectHolder(long objectID);
	internal ObjectHolder FindOrCreateObjectHolder(long objectID);
	private void AddObjectHolder(ObjectHolder holder);
	private bool GetCompletionInfo(FixupHolder fixup, out ObjectHolder holder, out object member, bool bThrowIfMissing);
	private void FixupSpecialObject(ObjectHolder holder);
	private bool ResolveObjectReference(ObjectHolder holder);
	private bool DoValueTypeFixup(FieldInfo memberToFix, ObjectHolder holder, object value);
	internal void CompleteObject(ObjectHolder holder, bool bObjectFullyComplete);
	private void DoNewlyRegisteredObjectFixups(ObjectHolder holder);
	public virtual object GetObject(long objectID);
	internal void RegisterString(string obj, long objectID, SerializationInfo info, long idOfContainingObj, MemberInfo member);
	public void RegisterObject(object obj, long objectID, SerializationInfo info, long idOfContainingObj, MemberInfo member, int[] arrayIndex);
	internal void CompleteISerializableObject(object obj, SerializationInfo info, StreamingContext context);
	internal static RuntimeConstructorInfo GetConstructor(RuntimeType t);
	public virtual void DoFixups();
	private void RegisterFixup(FixupHolder fixup, long objectToBeFixed, long objectRequired);
	public virtual void RecordFixup(long objectToBeFixed, MemberInfo member, long objectRequired);
	public virtual void RecordDelayedFixup(long objectToBeFixed, string memberName, long objectRequired);
	public virtual void RecordArrayElementFixup(long arrayToBeFixed, int[] indices, long objectRequired);
	public virtual void RaiseDeserializationEvent();
	internal virtual void AddOnDeserialization(DeserializationEventHandler handler);
	internal virtual void AddOnDeserialized(object obj);
	internal virtual void RaiseOnDeserializedEvent(object obj);
	public void RaiseOnDeserializingEvent(object obj);

}
//NameSpace:System.Runtime.Serialization
internal sealed class ObjectHolder
{
	// Fields
	private object m_object;
	internal long m_id;
	private int m_missingElementsRemaining;
	private int m_missingDecendents;
	internal SerializationInfo m_serInfo;
	internal ISerializationSurrogate m_surrogate;
	internal FixupHolderList m_missingElements;
	internal LongList m_dependentObjects;
	internal ObjectHolder m_next;
	internal int m_flags;
	private bool m_markForFixupWhenAvailable;
	private ValueTypeFixupInfo m_valueFixup;
	private TypeLoadExceptionHolder m_typeLoad;
	private bool m_reachable;

	// Properties
	internal bool IsIncompleteObjectReference { get; set; }
	internal bool RequiresDelayedFixup { get; }
	internal bool RequiresValueTypeFixup { get; }
	internal bool ValueTypeFixupPerformed { get; set; }
	internal bool HasISerializable { get; }
	internal bool HasSurrogate { get; }
	internal bool CanSurrogatedObjectValueChange { get; }
	internal bool CanObjectValueChange { get; }
	internal int DirectlyDependentObjects { get; }
	internal int TotalDependentObjects { get; }
	internal bool Reachable { get; set; }
	internal bool TypeLoadExceptionReachable { get; }
	internal TypeLoadExceptionHolder TypeLoadException { get; set; }
	internal object ObjectValue { get; }
	internal SerializationInfo SerializationInfo { get; set; }
	internal ISerializationSurrogate Surrogate { get; }
	internal LongList DependentObjects { get; set; }
	internal bool RequiresSerInfoFixup { get; set; }
	internal ValueTypeFixupInfo ValueFixup { get; }
	internal bool CompletelyFixed { get; }
	internal long ContainerID { get; }

	// Methods
	internal void .ctor(long objID);
	internal void .ctor(object obj, long objID, SerializationInfo info, ISerializationSurrogate surrogate, long idOfContainingObj, FieldInfo field, int[] arrayIndex);
	internal void .ctor(string obj, long objID, SerializationInfo info, ISerializationSurrogate surrogate, long idOfContainingObj, FieldInfo field, int[] arrayIndex);
	private void IncrementDescendentFixups(int amount);
	internal void DecrementFixupsRemaining(ObjectManager manager);
	internal void RemoveDependency(long id);
	internal void AddFixup(FixupHolder fixup, ObjectManager manager);
	private void UpdateDescendentDependencyChain(int amount, ObjectManager manager);
	internal void AddDependency(long dependentObject);
	internal void UpdateData(object obj, SerializationInfo info, ISerializationSurrogate surrogate, long idOfContainer, FieldInfo field, int[] arrayIndex, ObjectManager manager);
	internal void MarkForCompletionWhenAvailable();
	internal void SetFlags();
	internal bool get_IsIncompleteObjectReference();
	internal void set_IsIncompleteObjectReference(bool value);
	internal bool get_RequiresDelayedFixup();
	internal bool get_RequiresValueTypeFixup();
	internal bool get_ValueTypeFixupPerformed();
	internal void set_ValueTypeFixupPerformed(bool value);
	internal bool get_HasISerializable();
	internal bool get_HasSurrogate();
	internal bool get_CanSurrogatedObjectValueChange();
	internal bool get_CanObjectValueChange();
	internal int get_DirectlyDependentObjects();
	internal int get_TotalDependentObjects();
	internal bool get_Reachable();
	internal void set_Reachable(bool value);
	internal bool get_TypeLoadExceptionReachable();
	internal TypeLoadExceptionHolder get_TypeLoadException();
	internal void set_TypeLoadException(TypeLoadExceptionHolder value);
	internal object get_ObjectValue();
	internal void SetObjectValue(object obj, ObjectManager manager);
	internal SerializationInfo get_SerializationInfo();
	internal void set_SerializationInfo(SerializationInfo value);
	internal ISerializationSurrogate get_Surrogate();
	internal LongList get_DependentObjects();
	internal void set_DependentObjects(LongList value);
	internal bool get_RequiresSerInfoFixup();
	internal void set_RequiresSerInfoFixup(bool value);
	internal ValueTypeFixupInfo get_ValueFixup();
	internal bool get_CompletelyFixed();
	internal long get_ContainerID();

}
//NameSpace:System.Runtime.Serialization
internal class FixupHolder
{
	// Fields
	internal long m_id;
	internal object m_fixupInfo;
	internal int m_fixupType;

	// Methods
	internal void .ctor(long id, object fixupInfo, int fixupType);

}
//NameSpace:System.Runtime.Serialization
internal class FixupHolderList
{
	// Fields
	internal FixupHolder[] m_values;
	internal int m_count;

	// Methods
	internal void .ctor();
	internal void .ctor(int startingSize);
	internal virtual void Add(FixupHolder fixup);
	private void EnlargeArray();

}
//NameSpace:System.Runtime.Serialization
internal class LongList
{
	// Fields
	private long[] m_values;
	private int m_count;
	private int m_totalItems;
	private int m_currentItem;

	// Properties
	internal int Count { get; }
	internal long Current { get; }

	// Methods
	internal void .ctor();
	internal void .ctor(int startingSize);
	internal void Add(long value);
	internal int get_Count();
	internal void StartEnumeration();
	internal bool MoveNext();
	internal long get_Current();
	internal bool RemoveElement(long value);
	private void EnlargeArray();

}
//NameSpace:System.Runtime.Serialization
internal class ObjectHolderList
{
	// Fields
	internal ObjectHolder[] m_values;
	internal int m_count;

	// Properties
	internal int Version { get; }
	internal int Count { get; }

	// Methods
	internal void .ctor();
	internal void .ctor(int startingSize);
	internal virtual void Add(ObjectHolder value);
	internal ObjectHolderListEnumerator GetFixupEnumerator();
	private void EnlargeArray();
	internal int get_Version();
	internal int get_Count();

}
//NameSpace:System.Runtime.Serialization
internal class ObjectHolderListEnumerator
{
	// Fields
	private bool m_isFixupEnumerator;
	private ObjectHolderList m_list;
	private int m_startingVersion;
	private int m_currPos;

	// Properties
	internal ObjectHolder Current { get; }

	// Methods
	internal void .ctor(ObjectHolderList list, bool isFixupEnumerator);
	internal bool MoveNext();
	internal ObjectHolder get_Current();

}
//NameSpace:System.Runtime.Serialization
internal class TypeLoadExceptionHolder
{
	// Fields
	private string m_typeName;

	// Properties
	internal string TypeName { get; }

	// Methods
	internal void .ctor(string typeName);
	internal string get_TypeName();

}
//NameSpace:System.Runtime.Serialization
public sealed class SafeSerializationEventArgs : EventArgs
{
	// Fields
	private StreamingContext m_streamingContext;
	private List`1<object> m_serializedStates;

	// Properties
	internal IList`1<object> SerializedStates { get; }

	// Methods
	internal void .ctor(StreamingContext streamingContext);
	internal IList`1<object> get_SerializedStates();

}
//NameSpace:System.Runtime.Serialization
public interface ISafeSerializationData
{
	// Methods
	public abstract void CompleteDeserialization(object deserialized);

}
//NameSpace:System.Runtime.Serialization
internal sealed class SafeSerializationManager : IObjectReference, ISerializable
{
	// Fields
	private IList`1<object> m_serializedStates;
	private SerializationInfo m_savedSerializationInfo;
	private object m_realObject;
	private RuntimeType m_realType;
	private EventHandler`1<SafeSerializationEventArgs> SerializeObjectState;

	// Properties
	internal bool IsActive { get; }

	// Methods
	internal void .ctor();
	private void .ctor(SerializationInfo info, StreamingContext context);
	internal bool get_IsActive();
	internal void CompleteSerialization(object serializedObject, SerializationInfo info, StreamingContext context);
	internal void CompleteDeserialization(object deserializedObject);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	private object System.Runtime.Serialization.IObjectReference.GetRealObject(StreamingContext context);
	private void OnDeserialized(StreamingContext context);

}
//NameSpace:System.Runtime.Serialization
public sealed class OptionalFieldAttribute : Attribute
{
	// Fields
	private int versionAdded;

	// Properties
	public void VersionAdded { set; }

	// Methods
	public void .ctor();
	public void set_VersionAdded(int value);

}
//NameSpace:System.Runtime.Serialization
public sealed class OnSerializingAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.Serialization
public sealed class OnSerializedAttribute : Attribute
{
}
//NameSpace:System.Runtime.Serialization
public sealed class OnDeserializingAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.Serialization
public sealed class OnDeserializedAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.Serialization
public abstract class SerializationBinder
{
	// Methods
	public virtual void BindToName(Type serializedType, out string assemblyName, out string typeName);
	public abstract Type BindToType(string assemblyName, string typeName);
	protected void .ctor();

}
//NameSpace:System.Runtime.Serialization
internal class SerializationEvents
{
	// Fields
	private List`1<MethodInfo> m_OnSerializingMethods;
	private List`1<MethodInfo> m_OnSerializedMethods;
	private List`1<MethodInfo> m_OnDeserializingMethods;
	private List`1<MethodInfo> m_OnDeserializedMethods;

	// Properties
	internal bool HasOnSerializingEvents { get; }

	// Methods
	private List`1<MethodInfo> GetMethodsWithAttribute(Type attribute, Type t);
	internal void .ctor(Type t);
	internal bool get_HasOnSerializingEvents();
	internal void InvokeOnSerializing(object obj, StreamingContext context);
	internal void InvokeOnDeserializing(object obj, StreamingContext context);
	internal void InvokeOnDeserialized(object obj, StreamingContext context);
	internal SerializationEventHandler AddOnSerialized(object obj, SerializationEventHandler handler);
	internal SerializationEventHandler AddOnDeserialized(object obj, SerializationEventHandler handler);

}
//NameSpace:System.Runtime.Serialization
internal static class SerializationEventsCache
{
	// Fields
	private static Hashtable cache;

	// Methods
	internal static SerializationEvents GetSerializationEventsForType(Type t);
	private static void .cctor();

}
//NameSpace:System.Runtime.Serialization
public class SerializationException : SystemException
{
	// Fields
	private static string _nullMessage;

	// Methods
	public void .ctor();
	public void .ctor(string message);
	public void .ctor(string message, Exception innerException);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	private static void .cctor();

}
//NameSpace:System.Runtime.Serialization
internal sealed class SerializationFieldInfo : FieldInfo
{
	// Fields
	private RuntimeFieldInfo m_field;
	private string m_serializationName;

	// Properties
	public override Module Module { get; }
	public override int MetadataToken { get; }
	public override string Name { get; }
	public override Type DeclaringType { get; }
	public override Type ReflectedType { get; }
	public override Type FieldType { get; }
	internal RuntimeFieldInfo FieldInfo { get; }
	public override RuntimeFieldHandle FieldHandle { get; }
	public override FieldAttributes Attributes { get; }

	// Methods
	public override Module get_Module();
	public override int get_MetadataToken();
	internal void .ctor(RuntimeFieldInfo field, string namePrefix);
	public override string get_Name();
	public override Type get_DeclaringType();
	public override Type get_ReflectedType();
	public override object[] GetCustomAttributes(bool inherit);
	public override object[] GetCustomAttributes(Type attributeType, bool inherit);
	public override bool IsDefined(Type attributeType, bool inherit);
	public override Type get_FieldType();
	public override object GetValue(object obj);
	internal object InternalGetValue(object obj);
	public override void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
	internal void InternalSetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
	internal RuntimeFieldInfo get_FieldInfo();
	public override RuntimeFieldHandle get_FieldHandle();
	public override FieldAttributes get_Attributes();

}
//NameSpace:System.Runtime.Serialization
public sealed class SerializationInfo
{
	// Fields
	private const int defaultSize;
	private const string s_mscorlibAssemblySimpleName;
	private const string s_mscorlibFileName;
	internal string[] m_members;
	internal object[] m_data;
	internal Type[] m_types;
	private Dictionary`2<stringint> m_nameToIndex;
	internal int m_currMember;
	internal IFormatterConverter m_converter;
	private string m_fullTypeName;
	private string m_assemName;
	private Type objectType;
	private bool isFullTypeNameSetExplicit;
	private bool isAssemblyNameSetExplicit;
	private bool requireSameTokenInPartialTrust;

	// Properties
	public string FullTypeName { get; }
	public string AssemblyName { get; }
	public int MemberCount { get; }
	public Type ObjectType { get; }
	public bool IsFullTypeNameSetExplicit { get; }
	public bool IsAssemblyNameSetExplicit { get; }

	// Methods
	public void .ctor(Type type, IFormatterConverter converter);
	public void .ctor(Type type, IFormatterConverter converter, bool requireSameTokenInPartialTrust);
	public string get_FullTypeName();
	public string get_AssemblyName();
	public void SetType(Type type);
	private static bool Compare(byte[] a, byte[] b);
	internal static void DemandForUnsafeAssemblyNameAssignments(string originalAssemblyName, string newAssemblyName);
	internal static bool IsAssemblyNameAssignmentSafe(string originalAssemblyName, string newAssemblyName);
	public int get_MemberCount();
	public Type get_ObjectType();
	public bool get_IsFullTypeNameSetExplicit();
	public bool get_IsAssemblyNameSetExplicit();
	public SerializationInfoEnumerator GetEnumerator();
	private void ExpandArrays();
	public void AddValue(string name, object value, Type type);
	public void AddValue(string name, object value);
	public void AddValue(string name, bool value);
	public void AddValue(string name, char value);
	public void AddValue(string name, byte value);
	public void AddValue(string name, int value);
	public void AddValue(string name, long value);
	public void AddValue(string name, ulong value);
	public void AddValue(string name, float value);
	public void AddValue(string name, DateTime value);
	internal void AddValueInternal(string name, object value, Type type);
	internal void UpdateValue(string name, object value, Type type);
	private int FindElement(string name);
	private object GetElement(string name, out Type foundType);
	private object GetElementNoThrow(string name, out Type foundType);
	public object GetValue(string name, Type type);
	internal object GetValueNoThrow(string name, Type type);
	public bool GetBoolean(string name);
	public int GetInt32(string name);
	public long GetInt64(string name);
	public float GetSingle(string name);
	public string GetString(string name);

}
//NameSpace:System.Runtime.Serialization
public struct SerializationEntry
{
	// Fields
	private Type m_type;
	private object m_value;
	private string m_name;

	// Properties
	public object Value { get; }
	public string Name { get; }

	// Methods
	public object get_Value();
	public string get_Name();
	internal void .ctor(string entryName, object entryValue, Type entryType);

}
//NameSpace:System.Runtime.Serialization
public sealed class SerializationInfoEnumerator : IEnumerator
{
	// Fields
	private string[] m_members;
	private object[] m_data;
	private Type[] m_types;
	private int m_numItems;
	private int m_currItem;
	private bool m_current;

	// Properties
	private object System.Collections.IEnumerator.Current { get; }
	public SerializationEntry Current { get; }
	public string Name { get; }
	public object Value { get; }
	public Type ObjectType { get; }

	// Methods
	internal void .ctor(string[] members, object[] info, Type[] types, int numItems);
	public bool MoveNext();
	private object System.Collections.IEnumerator.get_Current();
	public SerializationEntry get_Current();
	public string get_Name();
	public object get_Value();
	public Type get_ObjectType();

}
//NameSpace:System.Runtime.Serialization
public sealed class SerializationObjectManager
{
	// Fields
	private Hashtable m_objectSeenTable;
	private SerializationEventHandler m_onSerializedHandler;
	private StreamingContext m_context;

	// Methods
	public void .ctor(StreamingContext context);
	public void RegisterObject(object obj);
	public void RaiseOnSerializedEvent();
	private void AddOnSerialized(object obj);

}
//NameSpace:System.Runtime.Serialization
public struct StreamingContext
{
	// Fields
	internal object m_additionalContext;
	internal StreamingContextStates m_state;

	// Properties
	public StreamingContextStates State { get; }

	// Methods
	public void .ctor(StreamingContextStates state);
	public void .ctor(StreamingContextStates state, object additional);
	public override bool Equals(object obj);
	public override int GetHashCode();
	public StreamingContextStates get_State();

}
//NameSpace:System.Runtime.Serialization
public enum StreamingContextStates
{
	// Fields
	public int value__;
	public const StreamingContextStates CrossProcess;
	public const StreamingContextStates CrossMachine;
	public const StreamingContextStates File;
	public const StreamingContextStates Persistence;
	public const StreamingContextStates Remoting;
	public const StreamingContextStates Other;
	public const StreamingContextStates Clone;
	public const StreamingContextStates CrossAppDomain;
	public const StreamingContextStates All;

}
//NameSpace:System.Runtime.Serialization
internal class ValueTypeFixupInfo
{
	// Fields
	private long m_containerID;
	private FieldInfo m_parentField;
	private int[] m_parentIndex;

	// Properties
	public long ContainerID { get; }
	public FieldInfo ParentField { get; }
	public int[] ParentIndex { get; }

	// Methods
	public void .ctor(long containerID, FieldInfo member, int[] parentIndex);
	public long get_ContainerID();
	public FieldInfo get_ParentField();
	public int[] get_ParentIndex();

}
//NameSpace:System.Runtime.Serialization.Formatters
public enum FormatterTypeStyle
{
	// Fields
	public int value__;
	public const FormatterTypeStyle TypesWhenNeeded;
	public const FormatterTypeStyle TypesAlways;
	public const FormatterTypeStyle XsdString;

}
//NameSpace:System.Runtime.Serialization.Formatters
public enum FormatterAssemblyStyle
{
	// Fields
	public int value__;
	public const FormatterAssemblyStyle Simple;
	public const FormatterAssemblyStyle Full;

}
//NameSpace:System.Runtime.Serialization.Formatters
public enum TypeFilterLevel
{
	// Fields
	public int value__;
	public const TypeFilterLevel Low;
	public const TypeFilterLevel Full;

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal static class BinaryConverter
{
	// Methods
	internal static BinaryTypeEnum GetBinaryTypeInfo(Type type, WriteObjectInfo objectInfo, string typeName, ObjectWriter objectWriter, out object typeInformation, out int assemId);
	internal static BinaryTypeEnum GetParserBinaryTypeInfo(Type type, out object typeInformation);
	internal static void WriteTypeInfo(BinaryTypeEnum binaryTypeEnum, object typeInformation, int assemId, __BinaryWriter sout);
	internal static object ReadTypeInfo(BinaryTypeEnum binaryTypeEnum, __BinaryParser input, out int assemId);
	internal static void TypeFromInfo(BinaryTypeEnum binaryTypeEnum, object typeInformation, ObjectReader objectReader, BinaryAssemblyInfo assemblyInfo, out InternalPrimitiveTypeE primitiveTypeEnum, out string typeString, out Type type, out bool isVariant);

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal static class IOUtil
{
	// Methods
	internal static bool FlagTest(MessageEnum flag, MessageEnum target);
	internal static void WriteStringWithCode(string value, __BinaryWriter sout);
	internal static void WriteWithCode(Type type, object value, __BinaryWriter sout);

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal interface IStreamable
{
}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class BinaryAssemblyInfo
{
	// Fields
	internal string assemblyString;
	private Assembly assembly;

	// Methods
	internal void .ctor(string assemblyString);
	internal void .ctor(string assemblyString, Assembly assembly);
	internal Assembly GetAssembly();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class SerializationHeaderRecord : IStreamable
{
	// Fields
	internal int binaryFormatterMajorVersion;
	internal int binaryFormatterMinorVersion;
	internal BinaryHeaderEnum binaryHeaderEnum;
	internal int topId;
	internal int headerId;
	internal int majorVersion;
	internal int minorVersion;

	// Methods
	internal void .ctor();
	internal void .ctor(BinaryHeaderEnum binaryHeaderEnum, int topId, int headerId, int majorVersion, int minorVersion);
	public void Write(__BinaryWriter sout);
	private static int GetInt32(byte[] buffer, int index);
	public void Read(__BinaryParser input);
	public void Dump();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class BinaryAssembly : IStreamable
{
	// Fields
	internal int assemId;
	internal string assemblyString;

	// Methods
	internal void .ctor();
	internal void Set(int assemId, string assemblyString);
	public void Write(__BinaryWriter sout);
	public void Read(__BinaryParser input);
	public void Dump();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class BinaryCrossAppDomainAssembly : IStreamable
{
	// Fields
	internal int assemId;
	internal int assemblyIndex;

	// Methods
	internal void .ctor();
	public void Read(__BinaryParser input);
	public void Dump();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class BinaryObject : IStreamable
{
	// Fields
	internal int objectId;
	internal int mapId;

	// Methods
	internal void .ctor();
	internal void Set(int objectId, int mapId);
	public void Write(__BinaryWriter sout);
	public void Read(__BinaryParser input);
	public void Dump();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class BinaryMethodCall
{
	// Fields
	private string methodName;
	private string typeName;
	private object[] args;
	private object callContext;
	private Type[] argTypes;
	private bool bArgsPrimitive;
	private MessageEnum messageEnum;

	// Methods
	internal void Write(__BinaryWriter sout);
	internal void Dump();
	public void .ctor();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class BinaryMethodReturn : IStreamable
{
	// Fields
	private object returnValue;
	private object[] args;
	private object callContext;
	private Type[] argTypes;
	private bool bArgsPrimitive;
	private MessageEnum messageEnum;
	private Type returnType;
	private static object instanceOfVoid;

	// Methods
	private static void .cctor();
	internal void .ctor();
	public void Write(__BinaryWriter sout);
	public void Dump();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class BinaryObjectString : IStreamable
{
	// Fields
	internal int objectId;
	internal string value;

	// Methods
	internal void .ctor();
	internal void Set(int objectId, string value);
	public void Write(__BinaryWriter sout);
	public void Read(__BinaryParser input);
	public void Dump();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class BinaryCrossAppDomainString : IStreamable
{
	// Fields
	internal int objectId;
	internal int value;

	// Methods
	internal void .ctor();
	public void Read(__BinaryParser input);
	public void Dump();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class BinaryCrossAppDomainMap : IStreamable
{
	// Fields
	internal int crossAppDomainArrayIndex;

	// Methods
	internal void .ctor();
	public void Read(__BinaryParser input);
	public void Dump();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class MemberPrimitiveTyped : IStreamable
{
	// Fields
	internal InternalPrimitiveTypeE primitiveTypeEnum;
	internal object value;

	// Methods
	internal void .ctor();
	internal void Set(InternalPrimitiveTypeE primitiveTypeEnum, object value);
	public void Write(__BinaryWriter sout);
	public void Read(__BinaryParser input);
	public void Dump();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class BinaryObjectWithMap : IStreamable
{
	// Fields
	internal BinaryHeaderEnum binaryHeaderEnum;
	internal int objectId;
	internal string name;
	internal int numMembers;
	internal string[] memberNames;
	internal int assemId;

	// Methods
	internal void .ctor();
	internal void .ctor(BinaryHeaderEnum binaryHeaderEnum);
	internal void Set(int objectId, string name, int numMembers, string[] memberNames, int assemId);
	public void Write(__BinaryWriter sout);
	public void Read(__BinaryParser input);
	public void Dump();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class BinaryObjectWithMapTyped : IStreamable
{
	// Fields
	internal BinaryHeaderEnum binaryHeaderEnum;
	internal int objectId;
	internal string name;
	internal int numMembers;
	internal string[] memberNames;
	internal BinaryTypeEnum[] binaryTypeEnumA;
	internal object[] typeInformationA;
	internal int[] memberAssemIds;
	internal int assemId;

	// Methods
	internal void .ctor();
	internal void .ctor(BinaryHeaderEnum binaryHeaderEnum);
	internal void Set(int objectId, string name, int numMembers, string[] memberNames, BinaryTypeEnum[] binaryTypeEnumA, object[] typeInformationA, int[] memberAssemIds, int assemId);
	public void Write(__BinaryWriter sout);
	public void Read(__BinaryParser input);

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class BinaryArray : IStreamable
{
	// Fields
	internal int objectId;
	internal int rank;
	internal int[] lengthA;
	internal int[] lowerBoundA;
	internal BinaryTypeEnum binaryTypeEnum;
	internal object typeInformation;
	internal int assemId;
	private BinaryHeaderEnum binaryHeaderEnum;
	internal BinaryArrayTypeEnum binaryArrayTypeEnum;

	// Methods
	internal void .ctor();
	internal void .ctor(BinaryHeaderEnum binaryHeaderEnum);
	internal void Set(int objectId, int rank, int[] lengthA, int[] lowerBoundA, BinaryTypeEnum binaryTypeEnum, object typeInformation, BinaryArrayTypeEnum binaryArrayTypeEnum, int assemId);
	public void Write(__BinaryWriter sout);
	public void Read(__BinaryParser input);

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class MemberPrimitiveUnTyped : IStreamable
{
	// Fields
	internal InternalPrimitiveTypeE typeInformation;
	internal object value;

	// Methods
	internal void .ctor();
	internal void Set(InternalPrimitiveTypeE typeInformation, object value);
	internal void Set(InternalPrimitiveTypeE typeInformation);
	public void Write(__BinaryWriter sout);
	public void Read(__BinaryParser input);
	public void Dump();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class MemberReference : IStreamable
{
	// Fields
	internal int idRef;

	// Methods
	internal void .ctor();
	internal void Set(int idRef);
	public void Write(__BinaryWriter sout);
	public void Read(__BinaryParser input);
	public void Dump();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class ObjectNull : IStreamable
{
	// Fields
	internal int nullCount;

	// Methods
	internal void .ctor();
	internal void SetNullCount(int nullCount);
	public void Write(__BinaryWriter sout);
	public void Read(__BinaryParser input, BinaryHeaderEnum binaryHeaderEnum);
	public void Dump();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class MessageEnd : IStreamable
{
	// Methods
	internal void .ctor();
	public void Write(__BinaryWriter sout);
	public void Read(__BinaryParser input);
	public void Dump();
	public void Dump(Stream sout);

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class ObjectMap
{
	// Fields
	internal string objectName;
	internal Type objectType;
	internal BinaryTypeEnum[] binaryTypeEnumA;
	internal object[] typeInformationA;
	internal Type[] memberTypes;
	internal string[] memberNames;
	internal ReadObjectInfo objectInfo;
	internal bool isInitObjectInfo;
	internal ObjectReader objectReader;
	internal int objectId;
	internal BinaryAssemblyInfo assemblyInfo;

	// Methods
	internal void .ctor(string objectName, Type objectType, string[] memberNames, ObjectReader objectReader, int objectId, BinaryAssemblyInfo assemblyInfo);
	internal void .ctor(string objectName, string[] memberNames, BinaryTypeEnum[] binaryTypeEnumA, object[] typeInformationA, int[] memberAssemIds, ObjectReader objectReader, int objectId, BinaryAssemblyInfo assemblyInfo, SizedArray assemIdToAssemblyTable);
	internal ReadObjectInfo CreateObjectInfo(SerializationInfo si, object[] memberData);
	internal static ObjectMap Create(string name, Type objectType, string[] memberNames, ObjectReader objectReader, int objectId, BinaryAssemblyInfo assemblyInfo);
	internal static ObjectMap Create(string name, string[] memberNames, BinaryTypeEnum[] binaryTypeEnumA, object[] typeInformationA, int[] memberAssemIds, ObjectReader objectReader, int objectId, BinaryAssemblyInfo assemblyInfo, SizedArray assemIdToAssemblyTable);

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class ObjectProgress
{
	// Fields
	internal static int opRecordIdCount;
	internal bool isInitial;
	internal int count;
	internal BinaryTypeEnum expectedType;
	internal object expectedTypeInformation;
	internal string name;
	internal InternalObjectTypeE objectTypeEnum;
	internal InternalMemberTypeE memberTypeEnum;
	internal InternalMemberValueE memberValueEnum;
	internal Type dtType;
	internal int numItems;
	internal BinaryTypeEnum binaryTypeEnum;
	internal object typeInformation;
	internal int nullCount;
	internal int memberLength;
	internal BinaryTypeEnum[] binaryTypeEnumA;
	internal object[] typeInformationA;
	internal string[] memberNames;
	internal Type[] memberTypes;
	internal ParseRecord pr;

	// Methods
	internal void .ctor();
	internal void Init();
	internal void ArrayCountIncrement(int value);
	internal bool GetNext(out BinaryTypeEnum outBinaryTypeEnum, out object outTypeInformation);
	private static void .cctor();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class Converter
{
	// Fields
	private static int primitiveTypeEnumLength;
	private static Type[] typeA;
	private static Type[] arrayTypeA;
	private static string[] valueA;
	private static TypeCode[] typeCodeA;
	private static InternalPrimitiveTypeE[] codeA;
	internal static Type typeofISerializable;
	internal static Type typeofString;
	internal static Type typeofConverter;
	internal static Type typeofBoolean;
	internal static Type typeofByte;
	internal static Type typeofChar;
	internal static Type typeofDecimal;
	internal static Type typeofDouble;
	internal static Type typeofInt16;
	internal static Type typeofInt32;
	internal static Type typeofInt64;
	internal static Type typeofSByte;
	internal static Type typeofSingle;
	internal static Type typeofTimeSpan;
	internal static Type typeofDateTime;
	internal static Type typeofUInt16;
	internal static Type typeofUInt32;
	internal static Type typeofUInt64;
	internal static Type typeofObject;
	internal static Type typeofSystemVoid;
	internal static Assembly urtAssembly;
	internal static string urtAssemblyString;
	internal static Type typeofTypeArray;
	internal static Type typeofObjectArray;
	internal static Type typeofStringArray;
	internal static Type typeofBooleanArray;
	internal static Type typeofByteArray;
	internal static Type typeofCharArray;
	internal static Type typeofDecimalArray;
	internal static Type typeofDoubleArray;
	internal static Type typeofInt16Array;
	internal static Type typeofInt32Array;
	internal static Type typeofInt64Array;
	internal static Type typeofSByteArray;
	internal static Type typeofSingleArray;
	internal static Type typeofTimeSpanArray;
	internal static Type typeofDateTimeArray;
	internal static Type typeofUInt16Array;
	internal static Type typeofUInt32Array;
	internal static Type typeofUInt64Array;
	internal static Type typeofMarshalByRefObject;

	// Methods
	internal static InternalPrimitiveTypeE ToCode(Type type);
	internal static bool IsWriteAsByteArray(InternalPrimitiveTypeE code);
	internal static int TypeLength(InternalPrimitiveTypeE code);
	internal static Type ToArrayType(InternalPrimitiveTypeE code);
	private static void InitTypeA();
	private static void InitArrayTypeA();
	internal static Type ToType(InternalPrimitiveTypeE code);
	internal static Array CreatePrimitiveArray(InternalPrimitiveTypeE code, int length);
	internal static bool IsPrimitiveArray(Type type, out object typeInformation);
	private static void InitValueA();
	internal static string ToComType(InternalPrimitiveTypeE code);
	private static void InitTypeCodeA();
	internal static TypeCode ToTypeCode(InternalPrimitiveTypeE code);
	private static void InitCodeA();
	internal static InternalPrimitiveTypeE ToPrimitiveTypeEnum(TypeCode typeCode);
	internal static object FromString(string value, InternalPrimitiveTypeE code);
	private static void .cctor();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal enum BinaryHeaderEnum
{
	// Fields
	public int value__;
	public const BinaryHeaderEnum SerializedStreamHeader;
	public const BinaryHeaderEnum Object;
	public const BinaryHeaderEnum ObjectWithMap;
	public const BinaryHeaderEnum ObjectWithMapAssemId;
	public const BinaryHeaderEnum ObjectWithMapTyped;
	public const BinaryHeaderEnum ObjectWithMapTypedAssemId;
	public const BinaryHeaderEnum ObjectString;
	public const BinaryHeaderEnum Array;
	public const BinaryHeaderEnum MemberPrimitiveTyped;
	public const BinaryHeaderEnum MemberReference;
	public const BinaryHeaderEnum ObjectNull;
	public const BinaryHeaderEnum MessageEnd;
	public const BinaryHeaderEnum Assembly;
	public const BinaryHeaderEnum ObjectNullMultiple256;
	public const BinaryHeaderEnum ObjectNullMultiple;
	public const BinaryHeaderEnum ArraySinglePrimitive;
	public const BinaryHeaderEnum ArraySingleObject;
	public const BinaryHeaderEnum ArraySingleString;
	public const BinaryHeaderEnum CrossAppDomainMap;
	public const BinaryHeaderEnum CrossAppDomainString;
	public const BinaryHeaderEnum CrossAppDomainAssembly;
	public const BinaryHeaderEnum MethodCall;
	public const BinaryHeaderEnum MethodReturn;

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal enum BinaryTypeEnum
{
	// Fields
	public int value__;
	public const BinaryTypeEnum Primitive;
	public const BinaryTypeEnum String;
	public const BinaryTypeEnum Object;
	public const BinaryTypeEnum ObjectUrt;
	public const BinaryTypeEnum ObjectUser;
	public const BinaryTypeEnum ObjectArray;
	public const BinaryTypeEnum StringArray;
	public const BinaryTypeEnum PrimitiveArray;

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal enum BinaryArrayTypeEnum
{
	// Fields
	public int value__;
	public const BinaryArrayTypeEnum Single;
	public const BinaryArrayTypeEnum Jagged;
	public const BinaryArrayTypeEnum Rectangular;
	public const BinaryArrayTypeEnum SingleOffset;
	public const BinaryArrayTypeEnum JaggedOffset;
	public const BinaryArrayTypeEnum RectangularOffset;

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal enum InternalSerializerTypeE
{
	// Fields
	public int value__;
	public const InternalSerializerTypeE Soap;
	public const InternalSerializerTypeE Binary;

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal enum InternalParseTypeE
{
	// Fields
	public int value__;
	public const InternalParseTypeE Empty;
	public const InternalParseTypeE SerializedStreamHeader;
	public const InternalParseTypeE Object;
	public const InternalParseTypeE Member;
	public const InternalParseTypeE ObjectEnd;
	public const InternalParseTypeE MemberEnd;
	public const InternalParseTypeE Headers;
	public const InternalParseTypeE HeadersEnd;
	public const InternalParseTypeE SerializedStreamHeaderEnd;
	public const InternalParseTypeE Envelope;
	public const InternalParseTypeE EnvelopeEnd;
	public const InternalParseTypeE Body;
	public const InternalParseTypeE BodyEnd;

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal enum InternalObjectTypeE
{
	// Fields
	public int value__;
	public const InternalObjectTypeE Empty;
	public const InternalObjectTypeE Object;
	public const InternalObjectTypeE Array;

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal enum InternalObjectPositionE
{
	// Fields
	public int value__;
	public const InternalObjectPositionE Empty;
	public const InternalObjectPositionE Top;
	public const InternalObjectPositionE Child;
	public const InternalObjectPositionE Headers;

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal enum InternalArrayTypeE
{
	// Fields
	public int value__;
	public const InternalArrayTypeE Empty;
	public const InternalArrayTypeE Single;
	public const InternalArrayTypeE Jagged;
	public const InternalArrayTypeE Rectangular;
	public const InternalArrayTypeE Base64;

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal enum InternalMemberTypeE
{
	// Fields
	public int value__;
	public const InternalMemberTypeE Empty;
	public const InternalMemberTypeE Header;
	public const InternalMemberTypeE Field;
	public const InternalMemberTypeE Item;

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal enum InternalMemberValueE
{
	// Fields
	public int value__;
	public const InternalMemberValueE Empty;
	public const InternalMemberValueE InlineValue;
	public const InternalMemberValueE Nested;
	public const InternalMemberValueE Reference;
	public const InternalMemberValueE Null;

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal enum InternalPrimitiveTypeE
{
	// Fields
	public int value__;
	public const InternalPrimitiveTypeE Invalid;
	public const InternalPrimitiveTypeE Boolean;
	public const InternalPrimitiveTypeE Byte;
	public const InternalPrimitiveTypeE Char;
	public const InternalPrimitiveTypeE Currency;
	public const InternalPrimitiveTypeE Decimal;
	public const InternalPrimitiveTypeE Double;
	public const InternalPrimitiveTypeE Int16;
	public const InternalPrimitiveTypeE Int32;
	public const InternalPrimitiveTypeE Int64;
	public const InternalPrimitiveTypeE SByte;
	public const InternalPrimitiveTypeE Single;
	public const InternalPrimitiveTypeE TimeSpan;
	public const InternalPrimitiveTypeE DateTime;
	public const InternalPrimitiveTypeE UInt16;
	public const InternalPrimitiveTypeE UInt32;
	public const InternalPrimitiveTypeE UInt64;
	public const InternalPrimitiveTypeE Null;
	public const InternalPrimitiveTypeE String;

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal enum MessageEnum
{
	// Fields
	public int value__;
	public const MessageEnum NoArgs;
	public const MessageEnum ArgsInline;
	public const MessageEnum ArgsIsArray;
	public const MessageEnum ArgsInArray;
	public const MessageEnum NoContext;
	public const MessageEnum ContextInline;
	public const MessageEnum ContextInArray;
	public const MessageEnum MethodSignatureInArray;
	public const MessageEnum PropertyInArray;
	public const MessageEnum NoReturnValue;
	public const MessageEnum ReturnValueVoid;
	public const MessageEnum ReturnValueInline;
	public const MessageEnum ReturnValueInArray;
	public const MessageEnum ExceptionInArray;
	public const MessageEnum GenericMethod;

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal enum ValueFixupEnum
{
	// Fields
	public int value__;
	public const ValueFixupEnum Empty;
	public const ValueFixupEnum Array;
	public const ValueFixupEnum Header;
	public const ValueFixupEnum Member;

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
public sealed class BinaryFormatter : IRemotingFormatter, IFormatter
{
	// Fields
	internal ISurrogateSelector m_surrogates;
	internal StreamingContext m_context;
	internal SerializationBinder m_binder;
	internal FormatterTypeStyle m_typeFormat;
	internal FormatterAssemblyStyle m_assemblyFormat;
	internal TypeFilterLevel m_securityLevel;
	internal object[] m_crossAppDomainArray;
	private static Dictionary`2<TypeTypeInformation> typeNameCache;

	// Properties
	public void AssemblyFormat { set; }
	public void SurrogateSelector { set; }

	// Methods
	public void set_AssemblyFormat(FormatterAssemblyStyle value);
	public void set_SurrogateSelector(ISurrogateSelector value);
	public void .ctor();
	public void .ctor(ISurrogateSelector selector, StreamingContext context);
	public object Deserialize(Stream serializationStream);
	internal object Deserialize(Stream serializationStream, HeaderHandler handler, bool fCheck);
	public object Deserialize(Stream serializationStream, HeaderHandler handler);
	public void Serialize(Stream serializationStream, object graph);
	public void Serialize(Stream serializationStream, object graph, Header[] headers);
	internal void Serialize(Stream serializationStream, object graph, Header[] headers, bool fCheck);
	internal static TypeInformation GetTypeInformation(Type type);
	private static void .cctor();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class __BinaryWriter
{
	// Fields
	internal Stream sout;
	internal FormatterTypeStyle formatterTypeStyle;
	internal Hashtable objectMapTable;
	internal ObjectWriter objectWriter;
	internal BinaryWriter dataWriter;
	internal int m_nestedObjectCount;
	private int nullCount;
	internal BinaryMethodCall binaryMethodCall;
	internal BinaryMethodReturn binaryMethodReturn;
	internal BinaryObject binaryObject;
	internal BinaryObjectWithMap binaryObjectWithMap;
	internal BinaryObjectWithMapTyped binaryObjectWithMapTyped;
	internal BinaryObjectString binaryObjectString;
	internal BinaryArray binaryArray;
	private byte[] byteBuffer;
	private int chunkSize;
	internal MemberPrimitiveUnTyped memberPrimitiveUnTyped;
	internal MemberPrimitiveTyped memberPrimitiveTyped;
	internal ObjectNull objectNull;
	internal MemberReference memberReference;
	internal BinaryAssembly binaryAssembly;

	// Methods
	internal void .ctor(Stream sout, ObjectWriter objectWriter, FormatterTypeStyle formatterTypeStyle);
	internal void WriteBegin();
	internal void WriteEnd();
	internal void WriteBoolean(bool value);
	internal void WriteByte(byte value);
	private void WriteBytes(byte[] value);
	private void WriteBytes(byte[] byteA, int offset, int size);
	internal void WriteChar(char value);
	internal void WriteChars(char[] value);
	internal void WriteDecimal(Decimal value);
	internal void WriteSingle(float value);
	internal void WriteDouble(double value);
	internal void WriteInt16(short value);
	internal void WriteInt32(int value);
	internal void WriteInt64(long value);
	internal void WriteSByte(sbyte value);
	internal void WriteString(string value);
	internal void WriteTimeSpan(TimeSpan value);
	internal void WriteDateTime(DateTime value);
	internal void WriteUInt16(ushort value);
	internal void WriteUInt32(uint value);
	internal void WriteUInt64(ulong value);
	internal void WriteObjectEnd(NameInfo memberNameInfo, NameInfo typeNameInfo);
	internal void WriteSerializationHeaderEnd();
	internal void WriteSerializationHeader(int topId, int headerId, int minorVersion, int majorVersion);
	internal void WriteMethodCall();
	internal void WriteMethodReturn();
	internal void WriteObject(NameInfo nameInfo, NameInfo typeNameInfo, int numMembers, string[] memberNames, Type[] memberTypes, WriteObjectInfo[] memberObjectInfos);
	internal void WriteObjectString(int objectId, string value);
	internal void WriteSingleArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int length, int lowerBound, Array array);
	private void WriteArrayAsBytes(Array array, int typeLength);
	internal void WriteJaggedArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int length, int lowerBound);
	internal void WriteRectangleArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int rank, int[] lengthA, int[] lowerBoundA);
	internal void WriteObjectByteArray(NameInfo memberNameInfo, NameInfo arrayNameInfo, WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, int length, int lowerBound, byte[] byteA);
	internal void WriteMember(NameInfo memberNameInfo, NameInfo typeNameInfo, object value);
	internal void WriteNullMember(NameInfo memberNameInfo, NameInfo typeNameInfo);
	internal void WriteMemberObjectRef(NameInfo memberNameInfo, int idRef);
	internal void WriteMemberNested(NameInfo memberNameInfo);
	internal void WriteMemberString(NameInfo memberNameInfo, NameInfo typeNameInfo, string value);
	internal void WriteItem(NameInfo itemNameInfo, NameInfo typeNameInfo, object value);
	internal void WriteNullItem(NameInfo itemNameInfo, NameInfo typeNameInfo);
	internal void WriteDelayedNullItem();
	internal void WriteItemEnd();
	private void InternalWriteItemNull();
	internal void WriteItemObjectRef(NameInfo nameInfo, int idRef);
	internal void WriteAssembly(Type type, string assemblyString, int assemId, bool isNew);
	internal void WriteValue(InternalPrimitiveTypeE code, object value);

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class ObjectMapInfo
{
	// Fields
	internal int objectId;
	private int numMembers;
	private string[] memberNames;
	private Type[] memberTypes;

	// Methods
	internal void .ctor(int objectId, int numMembers, string[] memberNames, Type[] memberTypes);
	internal bool isCompatible(int numMembers, string[] memberNames, Type[] memberTypes);

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class WriteObjectInfo
{
	// Fields
	internal int objectInfoId;
	internal object obj;
	internal Type objectType;
	internal bool isSi;
	internal bool isNamed;
	internal bool isTyped;
	internal bool isArray;
	internal SerializationInfo si;
	internal SerObjectInfoCache cache;
	internal object[] memberData;
	internal ISerializationSurrogate serializationSurrogate;
	internal StreamingContext context;
	internal SerObjectInfoInit serObjectInfoInit;
	internal long objectId;
	internal long assemId;
	private string binderTypeName;
	private string binderAssemblyString;

	// Methods
	internal void .ctor();
	internal void ObjectEnd();
	private void InternalInit();
	internal static WriteObjectInfo Serialize(object obj, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, ObjectWriter objectWriter, SerializationBinder binder);
	internal void InitSerialize(object obj, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, ObjectWriter objectWriter, SerializationBinder binder);
	internal static WriteObjectInfo Serialize(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, SerializationBinder binder);
	internal void InitSerialize(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, SerializationBinder binder);
	private void InitSiWrite();
	private static void CheckTypeForwardedFrom(SerObjectInfoCache cache, Type objectType, string binderAssemblyString);
	private void InitNoMembers();
	private void InitMemberInfo();
	internal string GetTypeFullName();
	internal string GetAssemblyString();
	private void InvokeSerializationBinder(SerializationBinder binder);
	internal Type GetMemberType(MemberInfo objMember);
	internal void GetMemberInfo(out string[] outMemberNames, out Type[] outMemberTypes, out object[] outMemberData);
	private static WriteObjectInfo GetObjectInfo(SerObjectInfoInit serObjectInfoInit);
	private static void PutObjectInfo(SerObjectInfoInit serObjectInfoInit, WriteObjectInfo objectInfo);

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class ReadObjectInfo
{
	// Fields
	internal int objectInfoId;
	internal static int readObjectInfoCounter;
	internal Type objectType;
	internal ObjectManager objectManager;
	internal int count;
	internal bool isSi;
	internal bool isNamed;
	internal bool isTyped;
	internal bool bSimpleAssembly;
	internal SerObjectInfoCache cache;
	internal string[] wireMemberNames;
	internal Type[] wireMemberTypes;
	private int lastPosition;
	internal ISerializationSurrogate serializationSurrogate;
	internal StreamingContext context;
	internal List`1<Type> memberTypesList;
	internal SerObjectInfoInit serObjectInfoInit;
	internal IFormatterConverter formatterConverter;

	// Methods
	internal void .ctor();
	internal void ObjectEnd();
	internal void PrepareForReuse();
	internal static ReadObjectInfo Create(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, bool bSimpleAssembly);
	internal void Init(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, bool bSimpleAssembly);
	internal static ReadObjectInfo Create(Type objectType, string[] memberNames, Type[] memberTypes, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, bool bSimpleAssembly);
	internal void Init(Type objectType, string[] memberNames, Type[] memberTypes, ISurrogateSelector surrogateSelector, StreamingContext context, ObjectManager objectManager, SerObjectInfoInit serObjectInfoInit, IFormatterConverter converter, bool bSimpleAssembly);
	private void InitReadConstructor(Type objectType, ISurrogateSelector surrogateSelector, StreamingContext context);
	private void InitSiRead();
	private void InitNoMembers();
	private void InitMemberInfo();
	internal MemberInfo GetMemberInfo(string name);
	internal Type GetType(string name);
	internal void AddValue(string name, object value, SerializationInfo si, object[] memberData);
	internal void InitDataStore(SerializationInfo si, object[] memberData);
	internal void RecordFixup(long objectId, string name, long idRef);
	internal void PopulateObjectMembers(object obj, object[] memberData);
	private int Position(string name);
	internal Type[] GetMemberTypes(string[] inMemberNames, Type objectType);
	internal Type GetMemberType(MemberInfo objMember);
	private static ReadObjectInfo GetObjectInfo(SerObjectInfoInit serObjectInfoInit);

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class SerObjectInfoInit
{
	// Fields
	internal Hashtable seenBeforeTable;
	internal int objectInfoIdCount;
	internal SerStack oiPool;

	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class SerObjectInfoCache
{
	// Fields
	internal string fullTypeName;
	internal string assemblyString;
	internal bool hasTypeForwardedFrom;
	internal MemberInfo[] memberInfos;
	internal string[] memberNames;
	internal Type[] memberTypes;

	// Methods
	internal void .ctor(string typeName, string assemblyName, bool hasTypeForwardedFrom);
	internal void .ctor(Type type);

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class TypeInformation
{
	// Fields
	private string fullTypeName;
	private string assemblyString;
	private bool hasTypeForwardedFrom;

	// Properties
	internal string FullTypeName { get; }
	internal string AssemblyString { get; }
	internal bool HasTypeForwardedFrom { get; }

	// Methods
	internal string get_FullTypeName();
	internal string get_AssemblyString();
	internal bool get_HasTypeForwardedFrom();
	internal void .ctor(string fullTypeName, string assemblyString, bool hasTypeForwardedFrom);

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class ObjectReader
{
	// Fields
	internal Stream m_stream;
	internal ISurrogateSelector m_surrogates;
	internal StreamingContext m_context;
	internal ObjectManager m_objectManager;
	internal InternalFE formatterEnums;
	internal SerializationBinder m_binder;
	internal long topId;
	internal bool bSimpleAssembly;
	internal object handlerObject;
	internal object m_topObject;
	internal Header[] headers;
	internal HeaderHandler handler;
	internal SerObjectInfoInit serObjectInfoInit;
	internal IFormatterConverter m_formatterConverter;
	internal SerStack stack;
	private SerStack valueFixupStack;
	internal object[] crossAppDomainArray;
	private bool bFullDeserialization;
	private bool bOldFormatDetected;
	private IntSizedArray valTypeObjectIdTable;
	private NameCache typeCache;
	private string previousAssemblyString;
	private string previousName;
	private Type previousType;

	// Properties
	private SerStack ValueFixupStack { get; }
	internal object TopObject { get; set; }

	// Methods
	private SerStack get_ValueFixupStack();
	internal object get_TopObject();
	internal void set_TopObject(object value);
	internal void .ctor(Stream stream, ISurrogateSelector selector, StreamingContext context, InternalFE formatterEnums, SerializationBinder binder);
	internal object Deserialize(HeaderHandler handler, __BinaryParser serParser, bool fCheck);
	private bool HasSurrogate(Type t);
	private void CheckSerializable(Type t);
	private void InitFullDeserialization();
	internal object CrossAppDomainArray(int index);
	internal ReadObjectInfo CreateReadObjectInfo(Type objectType);
	internal ReadObjectInfo CreateReadObjectInfo(Type objectType, string[] memberNames, Type[] memberTypes);
	internal void Parse(ParseRecord pr);
	private void ParseError(ParseRecord processing, ParseRecord onStack);
	private void ParseSerializedStreamHeader(ParseRecord pr);
	private void ParseSerializedStreamHeaderEnd(ParseRecord pr);
	private void ParseObject(ParseRecord pr);
	private void ParseObjectEnd(ParseRecord pr);
	private void ParseArray(ParseRecord pr);
	private void NextRectangleMap(ParseRecord pr);
	private void ParseArrayMember(ParseRecord pr);
	private void ParseArrayMemberEnd(ParseRecord pr);
	private void ParseMember(ParseRecord pr);
	private void ParseMemberEnd(ParseRecord pr);
	private void ParseString(ParseRecord pr, ParseRecord parentPr);
	private void RegisterObject(object obj, ParseRecord pr, ParseRecord objectPr);
	private void RegisterObject(object obj, ParseRecord pr, ParseRecord objectPr, bool bIsString);
	internal long GetId(long objectId);
	internal Type Bind(string assemblyString, string typeString);
	internal Type FastBindToType(string assemblyName, string typeName);
	private static Assembly ResolveSimpleAssemblyName(AssemblyName assemblyName);
	private static void GetSimplyNamedTypeFromAssembly(Assembly assm, string typeName, Type type);
	internal Type GetType(BinaryAssemblyInfo assemblyInfo, string name);
	private static void CheckTypeForwardedTo(Assembly sourceAssembly, Assembly destAssembly, Type resolvedType);

}
//NameSpace:
internal class ObjectReader.TypeNAssembly
{
	// Fields
	public Type type;
	public string assemblyName;

	// Methods
	public void .ctor();

}
//NameSpace:
internal sealed class ObjectReader.TopLevelAssemblyTypeResolver
{
	// Fields
	private Assembly m_topLevelAssembly;

	// Methods
	public void .ctor(Assembly topLevelAssembly);
	public Type ResolveType(Assembly assembly, string simpleTypeName, bool ignoreCase);

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class ObjectWriter
{
	// Fields
	private Queue m_objectQueue;
	private ObjectIDGenerator m_idGenerator;
	private int m_currentId;
	private ISurrogateSelector m_surrogates;
	private StreamingContext m_context;
	private __BinaryWriter serWriter;
	private SerializationObjectManager m_objectManager;
	private long topId;
	private string topName;
	private Header[] headers;
	private InternalFE formatterEnums;
	private SerializationBinder m_binder;
	private SerObjectInfoInit serObjectInfoInit;
	private IFormatterConverter m_formatterConverter;
	internal object[] crossAppDomainArray;
	private object previousObj;
	private long previousId;
	private Type previousType;
	private InternalPrimitiveTypeE previousCode;
	private Hashtable assemblyToIdTable;
	private SerStack niPool;

	// Properties
	internal SerializationObjectManager ObjectManager { get; }

	// Methods
	internal void .ctor(ISurrogateSelector selector, StreamingContext context, InternalFE formatterEnums, SerializationBinder binder);
	internal void Serialize(object graph, Header[] inHeaders, __BinaryWriter serWriter, bool fCheck);
	internal SerializationObjectManager get_ObjectManager();
	private void Write(WriteObjectInfo objectInfo, NameInfo memberNameInfo, NameInfo typeNameInfo);
	private void Write(WriteObjectInfo objectInfo, NameInfo memberNameInfo, NameInfo typeNameInfo, string[] memberNames, Type[] memberTypes, object[] memberData, WriteObjectInfo[] memberObjectInfos);
	private void WriteMemberSetup(WriteObjectInfo objectInfo, NameInfo memberNameInfo, NameInfo typeNameInfo, string memberName, Type memberType, object memberData, WriteObjectInfo memberObjectInfo);
	private void WriteMembers(NameInfo memberNameInfo, NameInfo memberTypeNameInfo, object memberData, WriteObjectInfo objectInfo, NameInfo typeNameInfo, WriteObjectInfo memberObjectInfo);
	private void WriteArray(WriteObjectInfo objectInfo, NameInfo memberNameInfo, WriteObjectInfo memberObjectInfo);
	private void WriteArrayMember(WriteObjectInfo objectInfo, NameInfo arrayElemTypeNameInfo, object data);
	private void WriteRectangle(WriteObjectInfo objectInfo, int rank, int[] maxA, Array array, NameInfo arrayElemNameTypeInfo, int[] lowerBoundA);
	private object GetNext(out long objID);
	private long InternalGetId(object obj, bool assignUniqueIdToValueType, Type type, out bool isNew);
	private long Schedule(object obj, bool assignUniqueIdToValueType, Type type);
	private long Schedule(object obj, bool assignUniqueIdToValueType, Type type, WriteObjectInfo objectInfo);
	private bool WriteKnownValueClass(NameInfo memberNameInfo, NameInfo typeNameInfo, object data);
	private void WriteObjectRef(NameInfo nameInfo, long objectId);
	private void WriteString(NameInfo memberNameInfo, NameInfo typeNameInfo, object stringObject);
	private bool CheckForNull(WriteObjectInfo objectInfo, NameInfo memberNameInfo, NameInfo typeNameInfo, object data);
	private void WriteSerializedStreamHeader(long topId, long headerId);
	private NameInfo TypeToNameInfo(Type type, WriteObjectInfo objectInfo, InternalPrimitiveTypeE code, NameInfo nameInfo);
	private NameInfo TypeToNameInfo(Type type);
	private NameInfo TypeToNameInfo(WriteObjectInfo objectInfo);
	private NameInfo TypeToNameInfo(WriteObjectInfo objectInfo, NameInfo nameInfo);
	private void TypeToNameInfo(Type type, NameInfo nameInfo);
	private NameInfo MemberToNameInfo(string name);
	internal InternalPrimitiveTypeE ToCode(Type type);
	private long GetAssemblyId(WriteObjectInfo objectInfo);
	private Type GetType(object obj);
	private NameInfo GetNameInfo();
	private bool CheckTypeFormat(FormatterTypeStyle test, FormatterTypeStyle want);
	private void PutNameInfo(NameInfo nameInfo);

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class __BinaryParser
{
	// Fields
	internal ObjectReader objectReader;
	internal Stream input;
	internal long topId;
	internal long headerId;
	internal SizedArray objectMapIdTable;
	internal SizedArray assemIdToAssemblyTable;
	internal SerStack stack;
	internal BinaryTypeEnum expectedType;
	internal object expectedTypeInformation;
	internal ParseRecord PRS;
	private BinaryAssemblyInfo systemAssemblyInfo;
	private BinaryReader dataReader;
	private static Encoding encoding;
	private SerStack opPool;
	private BinaryObject binaryObject;
	private BinaryObjectWithMap bowm;
	private BinaryObjectWithMapTyped bowmt;
	internal BinaryObjectString objectString;
	internal BinaryCrossAppDomainString crossAppDomainString;
	internal MemberPrimitiveTyped memberPrimitiveTyped;
	private byte[] byteBuffer;
	internal MemberPrimitiveUnTyped memberPrimitiveUnTyped;
	internal MemberReference memberReference;
	internal ObjectNull objectNull;
	internal static MessageEnd messageEnd;

	// Properties
	internal BinaryAssemblyInfo SystemAssemblyInfo { get; }
	internal SizedArray ObjectMapIdTable { get; }
	internal SizedArray AssemIdToAssemblyTable { get; }
	internal ParseRecord prs { get; }

	// Methods
	internal void .ctor(Stream stream, ObjectReader objectReader);
	internal BinaryAssemblyInfo get_SystemAssemblyInfo();
	internal SizedArray get_ObjectMapIdTable();
	internal SizedArray get_AssemIdToAssemblyTable();
	internal ParseRecord get_prs();
	internal void Run();
	internal void ReadBegin();
	internal void ReadEnd();
	internal bool ReadBoolean();
	internal byte ReadByte();
	internal byte[] ReadBytes(int length);
	internal void ReadBytes(byte[] byteA, int offset, int size);
	internal char ReadChar();
	internal char[] ReadChars(int length);
	internal Decimal ReadDecimal();
	internal float ReadSingle();
	internal double ReadDouble();
	internal short ReadInt16();
	internal int ReadInt32();
	internal long ReadInt64();
	internal sbyte ReadSByte();
	internal string ReadString();
	internal TimeSpan ReadTimeSpan();
	internal DateTime ReadDateTime();
	internal ushort ReadUInt16();
	internal uint ReadUInt32();
	internal ulong ReadUInt64();
	internal void ReadSerializationHeaderRecord();
	internal void ReadAssembly(BinaryHeaderEnum binaryHeaderEnum);
	private void ReadObject();
	internal void ReadCrossAppDomainMap();
	internal void ReadObjectWithMap(BinaryHeaderEnum binaryHeaderEnum);
	private void ReadObjectWithMap(BinaryObjectWithMap record);
	internal void ReadObjectWithMapTyped(BinaryHeaderEnum binaryHeaderEnum);
	private void ReadObjectWithMapTyped(BinaryObjectWithMapTyped record);
	private void ReadObjectString(BinaryHeaderEnum binaryHeaderEnum);
	private void ReadMemberPrimitiveTyped();
	private void ReadArray(BinaryHeaderEnum binaryHeaderEnum);
	private void ReadArrayAsBytes(ParseRecord pr);
	private void ReadMemberPrimitiveUnTyped();
	private void ReadMemberReference();
	private void ReadObjectNull(BinaryHeaderEnum binaryHeaderEnum);
	private void ReadMessageEnd();
	internal object ReadValue(InternalPrimitiveTypeE code);
	private ObjectProgress GetOp();
	private void PutOp(ObjectProgress op);
	private static void .cctor();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class ParseRecord
{
	// Fields
	internal static int parseRecordIdCount;
	internal InternalParseTypeE PRparseTypeEnum;
	internal InternalObjectTypeE PRobjectTypeEnum;
	internal InternalArrayTypeE PRarrayTypeEnum;
	internal InternalMemberTypeE PRmemberTypeEnum;
	internal InternalMemberValueE PRmemberValueEnum;
	internal InternalObjectPositionE PRobjectPositionEnum;
	internal string PRname;
	internal string PRvalue;
	internal object PRvarValue;
	internal string PRkeyDt;
	internal Type PRdtType;
	internal InternalPrimitiveTypeE PRdtTypeCode;
	internal bool PRisEnum;
	internal long PRobjectId;
	internal long PRidRef;
	internal string PRarrayElementTypeString;
	internal Type PRarrayElementType;
	internal bool PRisArrayVariant;
	internal InternalPrimitiveTypeE PRarrayElementTypeCode;
	internal int PRrank;
	internal int[] PRlengthA;
	internal int[] PRpositionA;
	internal int[] PRlowerBoundA;
	internal int[] PRupperBoundA;
	internal int[] PRindexMap;
	internal int PRmemberIndex;
	internal int PRlinearlength;
	internal int[] PRrectangularMap;
	internal bool PRisLowerBound;
	internal long PRtopId;
	internal long PRheaderId;
	internal ReadObjectInfo PRobjectInfo;
	internal bool PRisValueTypeFixup;
	internal object PRnewObj;
	internal object[] PRobjectA;
	internal PrimitiveArray PRprimitiveArray;
	internal bool PRisRegistered;
	internal object[] PRmemberData;
	internal SerializationInfo PRsi;
	internal int PRnullCount;

	// Methods
	internal void .ctor();
	internal void Init();
	private static void .cctor();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class SerStack
{
	// Fields
	internal object[] objects;
	internal string stackId;
	internal int top;

	// Methods
	internal void .ctor(string stackId);
	internal void Push(object obj);
	internal object Pop();
	internal void IncreaseCapacity();
	internal object Peek();
	internal object PeekPeek();
	internal bool IsEmpty();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class SizedArray : ICloneable
{
	// Fields
	internal object[] objects;
	internal object[] negObjects;

	// Properties
	internal object Item { get; set; }

	// Methods
	internal void .ctor();
	internal void .ctor(int length);
	private void .ctor(SizedArray sizedArray);
	public object Clone();
	internal object get_Item(int index);
	internal void set_Item(int index, object value);
	internal void IncreaseCapacity(int index);

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class IntSizedArray : ICloneable
{
	// Fields
	internal int[] objects;
	internal int[] negObjects;

	// Properties
	internal int Item { get; set; }

	// Methods
	public void .ctor();
	private void .ctor(IntSizedArray sizedArray);
	public object Clone();
	internal int get_Item(int index);
	internal void set_Item(int index, int value);
	internal void IncreaseCapacity(int index);

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class NameCache
{
	// Fields
	private static ConcurrentDictionary`2<stringobject> ht;
	private string name;

	// Methods
	internal object GetCachedValue(string name);
	internal void SetCachedValue(object value);
	public void .ctor();
	private static void .cctor();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class ValueFixup
{
	// Fields
	internal ValueFixupEnum valueFixupEnum;
	internal Array arrayObj;
	internal int[] indexMap;
	internal object header;
	internal object memberObject;
	internal static MemberInfo valueInfo;
	internal ReadObjectInfo objectInfo;
	internal string memberName;

	// Methods
	internal void .ctor(Array arrayObj, int[] indexMap);
	internal void .ctor(object memberObject, string memberName, ReadObjectInfo objectInfo);
	internal void Fixup(ParseRecord record, ParseRecord parent);

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class InternalFE
{
	// Fields
	internal FormatterTypeStyle FEtypeFormat;
	internal FormatterAssemblyStyle FEassemblyFormat;
	internal TypeFilterLevel FEsecurityLevel;
	internal InternalSerializerTypeE FEserializerTypeEnum;

	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class NameInfo
{
	// Fields
	internal string NIFullName;
	internal long NIobjectId;
	internal long NIassemId;
	internal InternalPrimitiveTypeE NIprimitiveTypeEnum;
	internal Type NItype;
	internal bool NIisSealed;
	internal bool NIisArray;
	internal bool NIisArrayItem;
	internal bool NItransmitTypeOnObject;
	internal bool NItransmitTypeOnMember;
	internal bool NIisParentTypeOnObject;
	internal InternalArrayTypeE NIarrayEnum;
	private bool NIsealedStatusChecked;

	// Properties
	public bool IsSealed { get; }
	public string NIname { get; set; }

	// Methods
	internal void .ctor();
	internal void Init();
	public bool get_IsSealed();
	public string get_NIname();
	public void set_NIname(string value);

}
//NameSpace:System.Runtime.Serialization.Formatters.Binary
internal sealed class PrimitiveArray
{
	// Fields
	private InternalPrimitiveTypeE code;
	private bool[] booleanA;
	private char[] charA;
	private double[] doubleA;
	private short[] int16A;
	private int[] int32A;
	private long[] int64A;
	private sbyte[] sbyteA;
	private float[] singleA;
	private ushort[] uint16A;
	private uint[] uint32A;
	private ulong[] uint64A;

	// Methods
	internal void .ctor(InternalPrimitiveTypeE code, Array array);
	internal void Init(InternalPrimitiveTypeE code, Array array);
	internal void SetValue(string value, int index);

}
//NameSpace:System.Runtime.Remoting
internal class ChannelInfo : IChannelInfo
{
	// Fields
	private object[] channelData;

	// Properties
	public object[] ChannelData { get; }

	// Methods
	public void .ctor();
	public void .ctor(object remoteChannelData);
	public object[] get_ChannelData();

}
//NameSpace:System.Runtime.Remoting
public class ActivatedClientTypeEntry : TypeEntry
{
	// Fields
	private string applicationUrl;
	private Type obj_type;

	// Properties
	public string ApplicationUrl { get; }
	public IContextAttribute[] ContextAttributes { get; }
	public Type ObjectType { get; }

	// Methods
	public void .ctor(string typeName, string assemblyName, string appUrl);
	public string get_ApplicationUrl();
	public IContextAttribute[] get_ContextAttributes();
	public Type get_ObjectType();
	public override string ToString();

}
//NameSpace:System.Runtime.Remoting
public class ActivatedServiceTypeEntry : TypeEntry
{
	// Fields
	private Type obj_type;

	// Properties
	public Type ObjectType { get; }

	// Methods
	public void .ctor(string typeName, string assemblyName);
	public Type get_ObjectType();
	public override string ToString();

}
//NameSpace:System.Runtime.Remoting
internal class EnvoyInfo : IEnvoyInfo
{
	// Fields
	private IMessageSink envoySinks;

	// Properties
	public IMessageSink EnvoySinks { get; }

	// Methods
	public void .ctor(IMessageSink sinks);
	public IMessageSink get_EnvoySinks();

}
//NameSpace:System.Runtime.Remoting
public interface IChannelInfo
{
	// Properties
	public abstract object[] ChannelData { get; }

	// Methods
	public abstract object[] get_ChannelData();

}
//NameSpace:System.Runtime.Remoting
public interface IEnvoyInfo
{
	// Properties
	public abstract IMessageSink EnvoySinks { get; }

	// Methods
	public abstract IMessageSink get_EnvoySinks();

}
//NameSpace:System.Runtime.Remoting
public interface IRemotingTypeInfo
{
	// Properties
	public abstract string TypeName { get; }

	// Methods
	public abstract string get_TypeName();
	public abstract bool CanCastTo(Type fromType, object o);

}
//NameSpace:System.Runtime.Remoting
internal abstract class Identity
{
	// Fields
	protected string _objectUri;
	protected IMessageSink _channelSink;
	protected IMessageSink _envoySink;
	private DynamicPropertyCollection _clientDynamicProperties;
	private DynamicPropertyCollection _serverDynamicProperties;
	protected ObjRef _objRef;
	private bool _disposed;

	// Properties
	public IMessageSink ChannelSink { get; set; }
	public IMessageSink EnvoySink { get; }
	public string ObjectUri { get; set; }
	public bool IsConnected { get; }
	public bool Disposed { get; set; }
	public DynamicPropertyCollection ClientDynamicProperties { get; }
	public bool HasServerDynamicSinks { get; }

	// Methods
	public void .ctor(string objectUri);
	public abstract ObjRef CreateObjRef(Type requestedType);
	public IMessageSink get_ChannelSink();
	public void set_ChannelSink(IMessageSink value);
	public IMessageSink get_EnvoySink();
	public string get_ObjectUri();
	public void set_ObjectUri(string value);
	public bool get_IsConnected();
	public bool get_Disposed();
	public void set_Disposed(bool value);
	public DynamicPropertyCollection get_ClientDynamicProperties();
	public bool get_HasServerDynamicSinks();
	public void NotifyClientDynamicSinks(bool start, IMessage req_msg, bool client_site, bool async);
	public void NotifyServerDynamicSinks(bool start, IMessage req_msg, bool client_site, bool async);

}
//NameSpace:System.Runtime.Remoting
internal class ClientIdentity : Identity
{
	// Fields
	private WeakReference _proxyReference;

	// Properties
	public MarshalByRefObject ClientProxy { get; set; }
	public string TargetUri { get; }

	// Methods
	public void .ctor(string objectUri, ObjRef objRef);
	public MarshalByRefObject get_ClientProxy();
	public void set_ClientProxy(MarshalByRefObject value);
	public override ObjRef CreateObjRef(Type requestedType);
	public string get_TargetUri();

}
//NameSpace:System.Runtime.Remoting
public class InternalRemotingServices
{
	// Fields
	private static Hashtable _soapAttributes;

	// Methods
	public static SoapAttribute GetCachedSoapAttribute(object reflectionObject);
	private static void .cctor();

}
//NameSpace:System.Runtime.Remoting
public class ObjRef : IObjectReference, ISerializable
{
	// Fields
	private IChannelInfo channel_info;
	private string uri;
	private IRemotingTypeInfo typeInfo;
	private IEnvoyInfo envoyInfo;
	private int flags;
	private Type _serverType;
	private static int MarshalledObjectRef;
	private static int WellKnowObjectRef;

	// Properties
	internal bool IsReferenceToWellKnow { get; }
	public virtual IChannelInfo ChannelInfo { get; }
	public virtual IEnvoyInfo EnvoyInfo { get; set; }
	public virtual IRemotingTypeInfo TypeInfo { get; set; }
	public virtual string URI { get; set; }
	internal Type ServerType { get; }

	// Methods
	public void .ctor();
	internal void .ctor(string uri, IChannelInfo cinfo);
	internal ObjRef DeserializeInTheCurrentDomain(int domainId, byte[] tInfo);
	internal byte[] SerializeType();
	internal void .ctor(Type type, string url, object remoteChannelData);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	internal bool get_IsReferenceToWellKnow();
	public virtual IChannelInfo get_ChannelInfo();
	public virtual IEnvoyInfo get_EnvoyInfo();
	public virtual void set_EnvoyInfo(IEnvoyInfo value);
	public virtual IRemotingTypeInfo get_TypeInfo();
	public virtual void set_TypeInfo(IRemotingTypeInfo value);
	public virtual string get_URI();
	public virtual void set_URI(string value);
	public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
	public virtual object GetRealObject(StreamingContext context);
	internal void UpdateChannelInfo();
	internal Type get_ServerType();
	private static void .cctor();

}
//NameSpace:System.Runtime.Remoting
public static class RemotingConfiguration
{
	// Fields
	private static string applicationID;
	private static string applicationName;
	private static string processGuid;
	private static bool defaultConfigRead;
	private static bool defaultDelayedConfigRead;
	private static string _errorMode;
	private static Hashtable wellKnownClientEntries;
	private static Hashtable activatedClientEntries;
	private static Hashtable wellKnownServiceEntries;
	private static Hashtable activatedServiceEntries;
	private static Hashtable channelTemplates;
	private static Hashtable clientProviderTemplates;
	private static Hashtable serverProviderTemplates;

	// Properties
	public static string ApplicationName { get; set; }
	public static string ProcessId { get; }

	// Methods
	public static string get_ApplicationName();
	public static void set_ApplicationName(string value);
	public static string get_ProcessId();
	internal static void LoadDefaultDelayedChannels();
	public static bool IsActivationAllowed(Type svrType);
	public static ActivatedClientTypeEntry IsRemotelyActivatedClientType(Type svrType);
	public static WellKnownClientTypeEntry IsWellKnownClientType(Type svrType);
	public static void RegisterActivatedClientType(ActivatedClientTypeEntry entry);
	public static void RegisterActivatedServiceType(ActivatedServiceTypeEntry entry);
	public static void RegisterWellKnownClientType(WellKnownClientTypeEntry entry);
	public static void RegisterWellKnownServiceType(WellKnownServiceTypeEntry entry);
	internal static void RegisterChannelTemplate(ChannelData channel);
	internal static void RegisterClientProviderTemplate(ProviderData prov);
	internal static void RegisterServerProviderTemplate(ProviderData prov);
	internal static void RegisterChannels(ArrayList channels, bool onlyDelayed);
	internal static void RegisterTypes(ArrayList types);
	public static bool CustomErrorsEnabled(bool isLocalRequest);
	internal static void SetCustomErrorsMode(string mode);
	private static void .cctor();

}
//NameSpace:System.Runtime.Remoting
internal class ConfigHandler : SmallXmlParser.IContentHandler
{
	// Fields
	private ArrayList typeEntries;
	private ArrayList channelInstances;
	private ChannelData currentChannel;
	private Stack currentProviderData;
	private string currentClientUrl;
	private string appName;
	private string currentXmlPath;
	private bool onlyDelayedChannels;

	// Methods
	public void .ctor(bool onlyDelayedChannels);
	private void ValidatePath(string element, string[] paths);
	private bool CheckPath(string path);
	public void OnStartParsing(SmallXmlParser parser);
	public void OnProcessingInstruction(string name, string text);
	public void OnIgnorableWhitespace(string s);
	public void OnStartElement(string name, SmallXmlParser.IAttrList attrs);
	public void ParseElement(string name, SmallXmlParser.IAttrList attrs);
	public void OnEndElement(string name);
	private void ReadCustomProviderData(string name, SmallXmlParser.IAttrList attrs);
	private void ReadLifetine(SmallXmlParser.IAttrList attrs);
	private TimeSpan ParseTime(string s);
	private void ReadChannel(SmallXmlParser.IAttrList attrs, bool isTemplate);
	private ProviderData ReadProvider(string name, SmallXmlParser.IAttrList attrs, bool isTemplate);
	private void ReadClientActivated(SmallXmlParser.IAttrList attrs);
	private void ReadServiceActivated(SmallXmlParser.IAttrList attrs);
	private void ReadClientWellKnown(SmallXmlParser.IAttrList attrs);
	private void ReadServiceWellKnown(SmallXmlParser.IAttrList attrs);
	private void ReadInteropXml(SmallXmlParser.IAttrList attrs, bool isElement);
	private void ReadPreload(SmallXmlParser.IAttrList attrs);
	private string GetNotNull(SmallXmlParser.IAttrList attrs, string name);
	private string ExtractAssembly(string type);
	public void OnChars(string ch);
	public void OnEndParsing(SmallXmlParser parser);

}
//NameSpace:System.Runtime.Remoting
internal class ChannelData
{
	// Fields
	internal string Ref;
	internal string Type;
	internal string Id;
	internal string DelayLoadAsClientChannel;
	private ArrayList _serverProviders;
	private ArrayList _clientProviders;
	private Hashtable _customProperties;

	// Properties
	internal ArrayList ServerProviders { get; }
	public ArrayList ClientProviders { get; }
	public Hashtable CustomProperties { get; }

	// Methods
	internal ArrayList get_ServerProviders();
	public ArrayList get_ClientProviders();
	public Hashtable get_CustomProperties();
	public void CopyFrom(ChannelData other);
	public void .ctor();

}
//NameSpace:System.Runtime.Remoting
internal class ProviderData
{
	// Fields
	internal string Ref;
	internal string Type;
	internal string Id;
	internal Hashtable CustomProperties;
	internal IList CustomData;

	// Methods
	public void CopyFrom(ProviderData other);
	public void .ctor();

}
//NameSpace:System.Runtime.Remoting
internal class FormatterData : ProviderData
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.Remoting
public class RemotingException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public void .ctor(string message, Exception InnerException);

}
//NameSpace:System.Runtime.Remoting
public static class RemotingServices
{
	// Fields
	private static Hashtable uri_hash;
	private static BinaryFormatter _serializationFormatter;
	private static BinaryFormatter _deserializationFormatter;
	private static string app_id;
	private static readonly object app_id_lock;
	private static int next_id;
	private static readonly MethodInfo FieldSetterMethod;
	private static readonly MethodInfo FieldGetterMethod;

	// Methods
	private static void .cctor();
	internal static object InternalExecute(MethodBase method, object obj, object[] parameters, out object[] out_args);
	internal static MethodBase GetVirtualMethod(Type type, MethodBase method);
	public static bool IsTransparentProxy(object proxy);
	internal static IMethodReturnMessage InternalExecuteMessage(MarshalByRefObject target, IMethodCallMessage reqMsg);
	public static object Connect(Type classToProxy, string url);
	public static object Connect(Type classToProxy, string url, object data);
	public static Type GetServerTypeForUri(string URI);
	public static object Unmarshal(ObjRef objectRef);
	public static object Unmarshal(ObjRef objectRef, bool fRefine);
	public static ObjRef Marshal(MarshalByRefObject Obj);
	public static ObjRef Marshal(MarshalByRefObject Obj, string ObjURI, Type RequestedType);
	private static string NewUri();
	public static RealProxy GetRealProxy(object proxy);
	public static MethodBase GetMethodBaseFromMethodMessage(IMethodMessage msg);
	internal static MethodBase GetMethodBaseFromName(Type type, string methodName, Type[] signature);
	private static MethodBase FindInterfaceMethod(Type type, string methodName, Type[] signature);
	public static void GetObjectData(object obj, SerializationInfo info, StreamingContext context);
	public static bool IsOneWay(MethodBase method);
	internal static object CreateClientProxy(ActivatedClientTypeEntry entry, object[] activationAttributes);
	internal static object CreateClientProxy(Type objectType, string url, object[] activationAttributes);
	internal static object CreateClientProxy(WellKnownClientTypeEntry entry);
	internal static object CreateClientProxyForContextBound(Type type, object[] activationAttributes);
	internal static Identity GetIdentityForUri(string uri);
	private static string RemoveAppNameFromUri(string uri);
	internal static ClientIdentity GetOrCreateClientIdentity(ObjRef objRef, Type proxyType, out object clientProxy);
	private static IMessageSink GetClientChannelSinkChain(string url, object channelData, out string objectUri);
	internal static ClientActivatedIdentity CreateContextBoundObjectIdentity(Type objectType);
	internal static ClientActivatedIdentity CreateClientActivatedServerIdentity(MarshalByRefObject realObject, Type objectType, string objectUri);
	internal static ServerIdentity CreateWellKnownServerIdentity(Type objectType, string objectUri, WellKnownObjectMode mode);
	private static void RegisterServerIdentity(ServerIdentity identity);
	internal static object GetProxyForRemoteObject(ObjRef objref, Type classToProxy);
	internal static object GetRemoteObject(ObjRef objRef, Type proxyType);
	internal static byte[] SerializeCallData(object obj);
	internal static object DeserializeCallData(byte[] array);
	internal static byte[] SerializeExceptionData(Exception ex);
	private static void RegisterInternalChannels();
	internal static void DisposeIdentity(Identity ident);
	internal static Identity GetMessageTargetIdentity(IMessage msg);
	internal static void SetMessageTargetIdentity(IMessage msg, Identity ident);
	internal static bool UpdateOutArgObject(ParameterInfo pi, object local, object remote);
	private static string GetNormalizedUri(string uri);

}
//NameSpace:
private class RemotingServices.CACD
{
	// Fields
	public object d;
	public object c;

	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.Remoting
internal abstract class ServerIdentity : Identity
{
	// Fields
	protected Type _objectType;
	protected MarshalByRefObject _serverObject;
	protected IMessageSink _serverSink;
	protected Context _context;
	protected Lease _lease;

	// Properties
	public Type ObjectType { get; }
	public Lease Lease { get; }
	public Context Context { get; set; }

	// Methods
	public void .ctor(string objectUri, Context context, Type objectType);
	public Type get_ObjectType();
	public void StartTrackingLifetime(ILease lease);
	public virtual void OnLifetimeExpired();
	public override ObjRef CreateObjRef(Type requestedType);
	public void AttachServerObject(MarshalByRefObject serverObject, Context context);
	public Lease get_Lease();
	public Context get_Context();
	public void set_Context(Context value);
	public abstract IMessage SyncObjectProcessMessage(IMessage msg);
	public abstract IMessageCtrl AsyncObjectProcessMessage(IMessage msg, IMessageSink replySink);
	protected void DisposeServerObject();

}
//NameSpace:System.Runtime.Remoting
internal class ClientActivatedIdentity : ServerIdentity
{
	// Fields
	private MarshalByRefObject _targetThis;

	// Methods
	public void .ctor(string objectUri, Type objectType);
	public MarshalByRefObject GetServerObject();
	public void SetClientProxy(MarshalByRefObject obj);
	public override void OnLifetimeExpired();
	public override IMessage SyncObjectProcessMessage(IMessage msg);
	public override IMessageCtrl AsyncObjectProcessMessage(IMessage msg, IMessageSink replySink);

}
//NameSpace:System.Runtime.Remoting
internal class SingletonIdentity : ServerIdentity
{
	// Methods
	public void .ctor(string objectUri, Context context, Type objectType);
	public MarshalByRefObject GetServerObject();
	public override IMessage SyncObjectProcessMessage(IMessage msg);
	public override IMessageCtrl AsyncObjectProcessMessage(IMessage msg, IMessageSink replySink);

}
//NameSpace:System.Runtime.Remoting
internal class SingleCallIdentity : ServerIdentity
{
	// Methods
	public void .ctor(string objectUri, Context context, Type objectType);
	public override IMessage SyncObjectProcessMessage(IMessage msg);
	public override IMessageCtrl AsyncObjectProcessMessage(IMessage msg, IMessageSink replySink);

}
//NameSpace:System.Runtime.Remoting
internal class DisposerReplySink : IMessageSink
{
	// Fields
	private IMessageSink _next;
	private IDisposable _disposable;

	// Methods
	public void .ctor(IMessageSink next, IDisposable disposable);
	public IMessage SyncProcessMessage(IMessage msg);
	public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);

}
//NameSpace:System.Runtime.Remoting
public class SoapServices
{
	// Fields
	private static Hashtable _xmlTypes;
	private static Hashtable _xmlElements;
	private static Hashtable _soapActions;
	private static Hashtable _soapActionsMethods;
	private static Hashtable _typeInfos;

	// Properties
	public static string XmlNsForClrTypeWithAssembly { get; }
	public static string XmlNsForClrTypeWithNs { get; }
	public static string XmlNsForClrTypeWithNsAndAssembly { get; }

	// Methods
	public static string get_XmlNsForClrTypeWithAssembly();
	public static string get_XmlNsForClrTypeWithNs();
	public static string get_XmlNsForClrTypeWithNsAndAssembly();
	public static string CodeXmlNamespaceForClrTypeNamespace(string typeNamespace, string assemblyName);
	private static string GetNameKey(string name, string namspace);
	private static string GetAssemblyName(MethodBase mb);
	public static bool GetXmlElementForInteropType(Type type, out string xmlElement, out string xmlNamespace);
	public static string GetXmlNamespaceForMethodCall(MethodBase mb);
	public static string GetXmlNamespaceForMethodResponse(MethodBase mb);
	public static bool GetXmlTypeForInteropType(Type type, out string xmlType, out string xmlTypeNamespace);
	public static void PreLoad(Assembly assembly);
	public static void PreLoad(Type type);
	public static void RegisterInteropXmlElement(string xmlElement, string xmlNamespace, Type type);
	public static void RegisterInteropXmlType(string xmlType, string xmlTypeNamespace, Type type);
	private static string EncodeNs(string ns);
	private static void .cctor();

}
//NameSpace:
private class SoapServices.TypeInfo
{
	// Fields
	public Hashtable Attributes;
	public Hashtable Elements;

	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.Remoting
public class TypeEntry
{
	// Fields
	private string assembly_name;
	private string type_name;

	// Properties
	public string AssemblyName { get; set; }
	public string TypeName { get; set; }

	// Methods
	protected void .ctor();
	public string get_AssemblyName();
	public void set_AssemblyName(string value);
	public string get_TypeName();
	public void set_TypeName(string value);

}
//NameSpace:System.Runtime.Remoting
internal class TypeInfo : IRemotingTypeInfo
{
	// Fields
	private string serverType;
	private string[] serverHierarchy;
	private string[] interfacesImplemented;

	// Properties
	public string TypeName { get; }

	// Methods
	public void .ctor(Type type);
	public string get_TypeName();
	public bool CanCastTo(Type fromType, object o);

}
//NameSpace:System.Runtime.Remoting
public class WellKnownClientTypeEntry : TypeEntry
{
	// Fields
	private Type obj_type;
	private string obj_url;
	private string app_url;

	// Properties
	public string ApplicationUrl { get; }
	public Type ObjectType { get; }
	public string ObjectUrl { get; }

	// Methods
	public void .ctor(string typeName, string assemblyName, string objectUrl);
	public string get_ApplicationUrl();
	public Type get_ObjectType();
	public string get_ObjectUrl();
	public override string ToString();

}
//NameSpace:System.Runtime.Remoting
public enum WellKnownObjectMode
{
	// Fields
	public int value__;
	public const WellKnownObjectMode Singleton;
	public const WellKnownObjectMode SingleCall;

}
//NameSpace:System.Runtime.Remoting
public class WellKnownServiceTypeEntry : TypeEntry
{
	// Fields
	private Type obj_type;
	private string obj_uri;
	private WellKnownObjectMode obj_mode;

	// Properties
	public WellKnownObjectMode Mode { get; }
	public Type ObjectType { get; }
	public string ObjectUri { get; }

	// Methods
	public void .ctor(string typeName, string assemblyName, string objectUri, WellKnownObjectMode mode);
	public WellKnownObjectMode get_Mode();
	public Type get_ObjectType();
	public string get_ObjectUri();
	public override string ToString();

}
//NameSpace:System.Runtime.Remoting.Services
public interface ITrackingHandler
{
	// Methods
	public abstract void DisconnectedObject(object obj);
	public abstract void MarshaledObject(object obj, ObjRef or);
	public abstract void UnmarshaledObject(object obj, ObjRef or);

}
//NameSpace:System.Runtime.Remoting.Services
public class TrackingServices
{
	// Fields
	private static ArrayList _handlers;

	// Methods
	internal static void NotifyMarshaledObject(object obj, ObjRef or);
	internal static void NotifyUnmarshaledObject(object obj, ObjRef or);
	internal static void NotifyDisconnectedObject(object obj);
	private static void .cctor();

}
//NameSpace:System.Runtime.Remoting.Proxies
public class ProxyAttribute : Attribute, IContextAttribute
{
	// Methods
	public virtual MarshalByRefObject CreateInstance(Type serverType);
	public virtual RealProxy CreateProxy(ObjRef objRef, Type serverType, object serverObject, Context serverContext);
	public void GetPropertiesForNewContext(IConstructionCallMessage msg);
	public bool IsContextOK(Context ctx, IConstructionCallMessage msg);

}
//NameSpace:System.Runtime.Remoting.Proxies
internal class TransparentProxy
{
	// Fields
	public RealProxy _rp;
	private RuntimeRemoteClassHandle _class;
	private bool _custom_type_info;

	// Properties
	private bool IsContextBoundObject { get; }
	private Context TargetContext { get; }

	// Methods
	internal RuntimeType GetProxyType();
	private bool get_IsContextBoundObject();
	private Context get_TargetContext();
	private bool InCurrentContext();
	internal object LoadRemoteFieldNew(IntPtr classPtr, IntPtr fieldPtr);
	internal void StoreRemoteField(IntPtr classPtr, IntPtr fieldPtr, object arg);

}
//NameSpace:System.Runtime.Remoting.Proxies
public abstract class RealProxy
{
	// Fields
	private Type class_to_proxy;
	internal Context _targetContext;
	internal MarshalByRefObject _server;
	private int _targetDomainId;
	internal string _targetUri;
	internal Identity _objectIdentity;
	private object _objTP;
	private object _stubData;

	// Properties
	internal Identity ObjectIdentity { get; set; }

	// Methods
	protected void .ctor(Type classToProxy);
	internal void .ctor(Type classToProxy, ClientIdentity identity);
	protected void .ctor(Type classToProxy, IntPtr stub, object stubData);
	private static Type InternalGetProxyType(object transparentProxy);
	public Type GetProxiedType();
	public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
	internal Identity get_ObjectIdentity();
	internal void set_ObjectIdentity(Identity value);
	public abstract IMessage Invoke(IMessage msg);
	internal static object PrivateInvoke(RealProxy rp, IMessage msg, out Exception exc, out object[] out_args);
	internal virtual object InternalGetTransparentProxy(string className);
	public virtual object GetTransparentProxy();
	protected void AttachServer(MarshalByRefObject s);
	internal void SetTargetDomain(int domainId);
	internal object GetAppDomainTarget();
	private static object[] ProcessResponse(IMethodReturnMessage mrm, MonoMethodMessage call);

}
//NameSpace:System.Runtime.Remoting.Proxies
internal class RemotingProxy : RealProxy, IRemotingTypeInfo
{
	// Fields
	private static MethodInfo _cache_GetTypeMethod;
	private static MethodInfo _cache_GetHashCodeMethod;
	private IMessageSink _sink;
	private bool _hasEnvoySink;
	private ConstructionCall _ctorCall;

	// Properties
	public string TypeName { get; }

	// Methods
	internal void .ctor(Type type, ClientIdentity identity);
	internal void .ctor(Type type, string activationUrl, object[] activationAttributes);
	public override IMessage Invoke(IMessage request);
	internal void AttachIdentity(Identity identity);
	internal IMessage ActivateRemoteObject(IMethodMessage request);
	public string get_TypeName();
	public bool CanCastTo(Type fromType, object o);
	protected override void Finalize();
	private static void .cctor();

}
//NameSpace:System.Runtime.Remoting.Lifetime
public interface ILease
{
	// Properties
	public abstract TimeSpan CurrentLeaseTime { get; }
	public abstract LeaseState CurrentState { get; }
	public abstract void InitialLeaseTime { set; }
	public abstract TimeSpan RenewOnCallTime { get; set; }
	public abstract void SponsorshipTimeout { set; }

	// Methods
	public abstract TimeSpan get_CurrentLeaseTime();
	public abstract LeaseState get_CurrentState();
	public abstract void set_InitialLeaseTime(TimeSpan value);
	public abstract TimeSpan get_RenewOnCallTime();
	public abstract void set_RenewOnCallTime(TimeSpan value);
	public abstract void set_SponsorshipTimeout(TimeSpan value);
	public abstract TimeSpan Renew(TimeSpan renewalTime);

}
//NameSpace:System.Runtime.Remoting.Lifetime
public interface ISponsor
{
	// Methods
	public abstract TimeSpan Renewal(ILease lease);

}
//NameSpace:System.Runtime.Remoting.Lifetime
internal class Lease : MarshalByRefObject, ILease
{
	// Fields
	private DateTime _leaseExpireTime;
	private LeaseState _currentState;
	private TimeSpan _initialLeaseTime;
	private TimeSpan _renewOnCallTime;
	private TimeSpan _sponsorshipTimeout;
	private ArrayList _sponsors;
	private Queue _renewingSponsors;
	private Lease.RenewalDelegate _renewalDelegate;

	// Properties
	public TimeSpan CurrentLeaseTime { get; }
	public LeaseState CurrentState { get; }
	public void InitialLeaseTime { set; }
	public TimeSpan RenewOnCallTime { get; set; }
	public void SponsorshipTimeout { set; }

	// Methods
	public void .ctor();
	public TimeSpan get_CurrentLeaseTime();
	public LeaseState get_CurrentState();
	public void Activate();
	public void set_InitialLeaseTime(TimeSpan value);
	public TimeSpan get_RenewOnCallTime();
	public void set_RenewOnCallTime(TimeSpan value);
	public void set_SponsorshipTimeout(TimeSpan value);
	public TimeSpan Renew(TimeSpan renewalTime);
	public void Unregister(ISponsor obj);
	internal void UpdateState();
	private void CheckNextSponsor();
	private void ProcessSponsorResponse(object state, bool timedOut);

}
//NameSpace:
private sealed class Lease.RenewalDelegate : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual TimeSpan Invoke(ILease lease);
	public virtual IAsyncResult BeginInvoke(ILease lease, AsyncCallback callback, object object);
	public virtual TimeSpan EndInvoke(IAsyncResult result);

}
//NameSpace:System.Runtime.Remoting.Lifetime
internal class LeaseManager
{
	// Fields
	private ArrayList _objects;
	private Timer _timer;

	// Methods
	public void SetPollTime(TimeSpan timeSpan);
	public void TrackLifetime(ServerIdentity identity);
	public void StartManager();
	public void StopManager();
	public void ManageLeases(object state);
	public void .ctor();

}
//NameSpace:System.Runtime.Remoting.Lifetime
internal class LeaseSink : IMessageSink
{
	// Fields
	private IMessageSink _nextSink;

	// Methods
	public void .ctor(IMessageSink nextSink);
	public IMessage SyncProcessMessage(IMessage msg);
	public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
	private void RenewLease(IMessage msg);

}
//NameSpace:System.Runtime.Remoting.Lifetime
public enum LeaseState
{
	// Fields
	public int value__;
	public const LeaseState Null;
	public const LeaseState Initial;
	public const LeaseState Active;
	public const LeaseState Renewing;
	public const LeaseState Expired;

}
//NameSpace:System.Runtime.Remoting.Lifetime
public sealed class LifetimeServices
{
	// Fields
	private static TimeSpan _leaseManagerPollTime;
	private static TimeSpan _leaseTime;
	private static TimeSpan _renewOnCallTime;
	private static TimeSpan _sponsorshipTimeout;
	private static LeaseManager _leaseManager;

	// Properties
	public static TimeSpan LeaseManagerPollTime { get; set; }
	public static TimeSpan LeaseTime { get; set; }
	public static TimeSpan RenewOnCallTime { get; set; }
	public static TimeSpan SponsorshipTimeout { get; set; }

	// Methods
	private static void .cctor();
	public static TimeSpan get_LeaseManagerPollTime();
	public static void set_LeaseManagerPollTime(TimeSpan value);
	public static TimeSpan get_LeaseTime();
	public static void set_LeaseTime(TimeSpan value);
	public static TimeSpan get_RenewOnCallTime();
	public static void set_RenewOnCallTime(TimeSpan value);
	public static TimeSpan get_SponsorshipTimeout();
	public static void set_SponsorshipTimeout(TimeSpan value);
	internal static void TrackLifetime(ServerIdentity identity);

}
//NameSpace:System.Runtime.Remoting.Contexts
public class Context
{
	// Fields
	private int domain_id;
	private int context_id;
	private UIntPtr static_data;
	private UIntPtr data;
	private static object[] local_slots;
	private static IMessageSink default_server_context_sink;
	private IMessageSink server_context_sink_chain;
	private IMessageSink client_context_sink_chain;
	private List`1<IContextProperty> context_properties;
	private static int global_count;
	private LocalDataStoreHolder _localDataStore;
	private static LocalDataStoreMgr _localDataStoreMgr;
	private static DynamicPropertyCollection global_dynamic_properties;
	private DynamicPropertyCollection context_dynamic_properties;
	private ContextCallbackObject callback_object;

	// Properties
	public static Context DefaultContext { get; }
	public virtual int ContextID { get; }
	public virtual IContextProperty[] ContextProperties { get; }
	internal bool IsDefaultContext { get; }
	internal bool NeedsContextSink { get; }
	internal static bool HasGlobalDynamicSinks { get; }
	internal bool HasDynamicSinks { get; }
	internal bool HasExitSinks { get; }
	private LocalDataStore MyLocalStore { get; }

	// Methods
	private static void RegisterContext(Context ctx);
	private static void ReleaseContext(Context ctx);
	public void .ctor();
	protected override void Finalize();
	public static Context get_DefaultContext();
	public virtual int get_ContextID();
	public virtual IContextProperty[] get_ContextProperties();
	internal bool get_IsDefaultContext();
	internal bool get_NeedsContextSink();
	public static bool RegisterDynamicProperty(IDynamicProperty prop, ContextBoundObject obj, Context ctx);
	public static bool UnregisterDynamicProperty(string name, ContextBoundObject obj, Context ctx);
	private static DynamicPropertyCollection GetDynamicPropertyCollection(ContextBoundObject obj, Context ctx);
	internal static void NotifyGlobalDynamicSinks(bool start, IMessage req_msg, bool client_site, bool async);
	internal static bool get_HasGlobalDynamicSinks();
	internal void NotifyDynamicSinks(bool start, IMessage req_msg, bool client_site, bool async);
	internal bool get_HasDynamicSinks();
	internal bool get_HasExitSinks();
	public virtual IContextProperty GetProperty(string name);
	public virtual void SetProperty(IContextProperty prop);
	public virtual void Freeze();
	public override string ToString();
	internal IMessageSink GetServerContextSinkChain();
	internal IMessageSink GetClientContextSinkChain();
	internal IMessageSink CreateServerObjectSinkChain(MarshalByRefObject obj, bool forceInternalExecute);
	internal IMessageSink CreateEnvoySink(MarshalByRefObject serverObject);
	internal static Context SwitchToContext(Context newContext);
	internal static Context CreateNewContext(IConstructionCallMessage msg);
	public void DoCallBack(CrossContextDelegate deleg);
	private LocalDataStore get_MyLocalStore();
	public static LocalDataStoreSlot AllocateDataSlot();
	public static LocalDataStoreSlot AllocateNamedDataSlot(string name);
	public static void FreeNamedDataSlot(string name);
	public static LocalDataStoreSlot GetNamedDataSlot(string name);
	public static object GetData(LocalDataStoreSlot slot);
	public static void SetData(LocalDataStoreSlot slot, object data);
	private static void .cctor();

}
//NameSpace:System.Runtime.Remoting.Contexts
internal class DynamicPropertyCollection
{
	// Fields
	private ArrayList _properties;

	// Properties
	public bool HasProperties { get; }

	// Methods
	public bool get_HasProperties();
	public bool RegisterDynamicProperty(IDynamicProperty prop);
	public bool UnregisterDynamicProperty(string name);
	public void NotifyMessage(bool start, IMessage msg, bool client_site, bool async);
	private int FindProperty(string name);
	public void .ctor();

}
//NameSpace:
private class DynamicPropertyCollection.DynamicPropertyReg
{
	// Fields
	public IDynamicProperty Property;
	public IDynamicMessageSink Sink;

	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.Remoting.Contexts
internal class ContextCallbackObject : ContextBoundObject
{
	// Methods
	public void DoCallBack(CrossContextDelegate deleg);
	public void .ctor();

}
//NameSpace:System.Runtime.Remoting.Contexts
internal class CrossContextChannel : IMessageSink
{
	// Methods
	public IMessage SyncProcessMessage(IMessage msg);
	public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
	public void .ctor();

}
//NameSpace:
private class CrossContextChannel.ContextRestoreSink : IMessageSink
{
	// Fields
	private IMessageSink _next;
	private Context _context;
	private IMessage _call;

	// Methods
	public void .ctor(IMessageSink next, Context context, IMessage call);
	public IMessage SyncProcessMessage(IMessage msg);
	public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);

}
//NameSpace:System.Runtime.Remoting.Contexts
public sealed class CrossContextDelegate : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke();
	public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System.Runtime.Remoting.Contexts
public interface IContextAttribute
{
	// Methods
	public abstract void GetPropertiesForNewContext(IConstructionCallMessage msg);
	public abstract bool IsContextOK(Context ctx, IConstructionCallMessage msg);

}
//NameSpace:System.Runtime.Remoting.Contexts
public interface IContextProperty
{
	// Properties
	public abstract string Name { get; }

	// Methods
	public abstract string get_Name();
	public abstract void Freeze(Context newContext);
	public abstract bool IsNewContextOK(Context newCtx);

}
//NameSpace:System.Runtime.Remoting.Contexts
public interface IContributeClientContextSink
{
	// Methods
	public abstract IMessageSink GetClientContextSink(IMessageSink nextSink);

}
//NameSpace:System.Runtime.Remoting.Contexts
public interface IContributeDynamicSink
{
	// Methods
	public abstract IDynamicMessageSink GetDynamicSink();

}
//NameSpace:System.Runtime.Remoting.Contexts
public interface IContributeEnvoySink
{
	// Methods
	public abstract IMessageSink GetEnvoySink(MarshalByRefObject obj, IMessageSink nextSink);

}
//NameSpace:System.Runtime.Remoting.Contexts
public interface IContributeObjectSink
{
	// Methods
	public abstract IMessageSink GetObjectSink(MarshalByRefObject obj, IMessageSink nextSink);

}
//NameSpace:System.Runtime.Remoting.Contexts
public interface IContributeServerContextSink
{
	// Methods
	public abstract IMessageSink GetServerContextSink(IMessageSink nextSink);

}
//NameSpace:System.Runtime.Remoting.Contexts
public interface IDynamicMessageSink
{
	// Methods
	public abstract void ProcessMessageFinish(IMessage replyMsg, bool bCliSide, bool bAsync);
	public abstract void ProcessMessageStart(IMessage reqMsg, bool bCliSide, bool bAsync);

}
//NameSpace:System.Runtime.Remoting.Contexts
public interface IDynamicProperty
{
	// Properties
	public abstract string Name { get; }

	// Methods
	public abstract string get_Name();

}
//NameSpace:System.Runtime.Remoting.Channels
public sealed class ChannelServices
{
	// Fields
	private static ArrayList registeredChannels;
	private static ArrayList delayedClientChannels;
	private static CrossContextChannel _crossContextSink;
	internal static string CrossContextUrl;
	private static IList oldStartModeTypes;

	// Properties
	internal static CrossContextChannel CrossContextChannel { get; }

	// Methods
	internal static CrossContextChannel get_CrossContextChannel();
	internal static IMessageSink CreateClientChannelSinkChain(string url, object remoteChannelData, out string objectUri);
	internal static IMessageSink CreateClientChannelSinkChain(IChannelSender sender, string url, object[] channelDataArray, out string objectUri);
	public static void RegisterChannel(IChannel chnl);
	public static void RegisterChannel(IChannel chnl, bool ensureSecurity);
	internal static void RegisterChannelConfig(ChannelData channel);
	private static object CreateProvider(ProviderData prov);
	public static IMessage SyncDispatchMessage(IMessage msg);
	private static ReturnMessage CheckIncomingMessage(IMessage msg);
	internal static IMessage CheckReturnMessage(IMessage callMsg, IMessage retMsg);
	private static bool IsLocalCall(IMessage callMsg);
	internal static object[] GetCurrentChannelInfo();
	private static void .cctor();

}
//NameSpace:System.Runtime.Remoting.Channels
internal class CrossAppDomainData
{
	// Fields
	private object _ContextID;
	private int _DomainID;
	private string _processGuid;

	// Properties
	internal int DomainID { get; }
	internal string ProcessID { get; }

	// Methods
	internal void .ctor(int domainId);
	internal int get_DomainID();
	internal string get_ProcessID();

}
//NameSpace:System.Runtime.Remoting.Channels
internal class CrossAppDomainChannel : IChannel, IChannelSender, IChannelReceiver
{
	// Fields
	private static object s_lock;

	// Properties
	public virtual string ChannelName { get; }
	public virtual int ChannelPriority { get; }
	public virtual object ChannelData { get; }

	// Methods
	internal static void RegisterCrossAppDomainChannel();
	public virtual string get_ChannelName();
	public virtual int get_ChannelPriority();
	public virtual object get_ChannelData();
	public virtual void StartListening(object data);
	public virtual IMessageSink CreateMessageSink(string url, object data, out string uri);
	public void .ctor();
	private static void .cctor();

}
//NameSpace:System.Runtime.Remoting.Channels
internal class CrossAppDomainSink : IMessageSink
{
	// Fields
	private static Hashtable s_sinks;
	private static MethodInfo processMessageMethod;
	private int _domainID;

	// Properties
	internal int TargetDomainId { get; }

	// Methods
	internal void .ctor(int domainID);
	internal static CrossAppDomainSink GetSink(int domainID);
	internal int get_TargetDomainId();
	private static CrossAppDomainSink.ProcessMessageRes ProcessMessageInDomain(byte[] arrRequest, CADMethodCallMessage cadMsg);
	public virtual IMessage SyncProcessMessage(IMessage msgRequest);
	public virtual IMessageCtrl AsyncProcessMessage(IMessage reqMsg, IMessageSink replySink);
	public void SendAsyncMessage(object data);
	private static void .cctor();
	private void <AsyncProcessMessage>b__10_0(object data);

}
//NameSpace:
private struct CrossAppDomainSink.ProcessMessageRes
{
	// Fields
	public byte[] arrResponse;
	public CADMethodReturnMessage cadMrm;

}
//NameSpace:System.Runtime.Remoting.Channels
internal class CADSerializer
{
	// Methods
	internal static IMessage DeserializeMessage(MemoryStream mem, IMethodCallMessage msg);
	internal static MemoryStream SerializeMessage(IMessage msg);
	internal static object DeserializeObjectSafe(byte[] mem);
	internal static MemoryStream SerializeObject(object obj);
	internal static object DeserializeObject(MemoryStream mem);

}
//NameSpace:System.Runtime.Remoting.Channels
internal class AsyncRequest
{
	// Fields
	internal IMessageSink ReplySink;
	internal IMessage MsgRequest;

	// Methods
	public void .ctor(IMessage msgRequest, IMessageSink replySink);

}
//NameSpace:System.Runtime.Remoting.Channels
public interface IChannel
{
	// Properties
	public abstract string ChannelName { get; }
	public abstract int ChannelPriority { get; }

	// Methods
	public abstract string get_ChannelName();
	public abstract int get_ChannelPriority();

}
//NameSpace:System.Runtime.Remoting.Channels
public interface IChannelDataStore
{
}
//NameSpace:System.Runtime.Remoting.Channels
public interface IChannelReceiver : IChannel
{
	// Properties
	public abstract object ChannelData { get; }

	// Methods
	public abstract object get_ChannelData();
	public abstract void StartListening(object data);

}
//NameSpace:System.Runtime.Remoting.Channels
public interface IChannelSender : IChannel
{
	// Methods
	public abstract IMessageSink CreateMessageSink(string url, object remoteChannelData, out string objectURI);

}
//NameSpace:System.Runtime.Remoting.Channels
public interface IClientChannelSinkProvider
{
	// Properties
	public abstract void Next { set; }

	// Methods
	public abstract void set_Next(IClientChannelSinkProvider value);

}
//NameSpace:System.Runtime.Remoting.Channels
public interface ISecurableChannel
{
	// Properties
	public abstract void IsSecured { set; }

	// Methods
	public abstract void set_IsSecured(bool value);

}
//NameSpace:System.Runtime.Remoting.Channels
public interface IServerChannelSinkProvider
{
	// Properties
	public abstract void Next { set; }

	// Methods
	public abstract void set_Next(IServerChannelSinkProvider value);

}
//NameSpace:System.Runtime.Remoting.Channels
public class SinkProviderData
{
	// Fields
	private string sinkName;
	private ArrayList children;
	private Hashtable properties;

	// Properties
	public IList Children { get; }
	public IDictionary Properties { get; }

	// Methods
	public void .ctor(string name);
	public IList get_Children();
	public IDictionary get_Properties();

}
//NameSpace:System.Runtime.Remoting.Activation
internal class ActivationServices
{
	// Fields
	private static IActivator _constructionActivator;

	// Properties
	private static IActivator ConstructionActivator { get; }

	// Methods
	private static IActivator get_ConstructionActivator();
	public static IMessage Activate(RemotingProxy proxy, ConstructionCall ctorCall);
	public static IMessage RemoteActivate(IConstructionCallMessage ctorCall);
	public static ConstructionCall CreateConstructionCall(Type type, string activationUrl, object[] activationAttributes);
	public static IMessage CreateInstanceFromMessage(IConstructionCallMessage ctorCall);
	public static object CreateProxyForType(Type type);
	public static object AllocateUninitializedClassInstance(Type type);
	public static void EnableProxyActivation(Type type, bool enable);

}
//NameSpace:System.Runtime.Remoting.Activation
internal class AppDomainLevelActivator : IActivator
{
	// Fields
	private string _activationUrl;
	private IActivator _next;

	// Properties
	public IActivator NextActivator { get; }

	// Methods
	public void .ctor(string activationUrl, IActivator next);
	public IActivator get_NextActivator();
	public IConstructionReturnMessage Activate(IConstructionCallMessage ctorCall);

}
//NameSpace:System.Runtime.Remoting.Activation
internal class ConstructionLevelActivator : IActivator
{
	// Properties
	public IActivator NextActivator { get; }

	// Methods
	public IActivator get_NextActivator();
	public IConstructionReturnMessage Activate(IConstructionCallMessage msg);
	public void .ctor();

}
//NameSpace:System.Runtime.Remoting.Activation
internal class ContextLevelActivator : IActivator
{
	// Fields
	private IActivator m_NextActivator;

	// Properties
	public IActivator NextActivator { get; }

	// Methods
	public void .ctor(IActivator next);
	public IActivator get_NextActivator();
	public IConstructionReturnMessage Activate(IConstructionCallMessage ctorCall);

}
//NameSpace:System.Runtime.Remoting.Activation
public interface IActivator
{
	// Properties
	public abstract IActivator NextActivator { get; }

	// Methods
	public abstract IActivator get_NextActivator();
	public abstract IConstructionReturnMessage Activate(IConstructionCallMessage msg);

}
//NameSpace:System.Runtime.Remoting.Activation
public interface IConstructionCallMessage : IMessage, IMethodCallMessage, IMethodMessage
{
	// Properties
	public abstract Type ActivationType { get; }
	public abstract string ActivationTypeName { get; }
	public abstract IActivator Activator { get; set; }
	public abstract object[] CallSiteActivationAttributes { get; }
	public abstract IList ContextProperties { get; }

	// Methods
	public abstract Type get_ActivationType();
	public abstract string get_ActivationTypeName();
	public abstract IActivator get_Activator();
	public abstract void set_Activator(IActivator value);
	public abstract object[] get_CallSiteActivationAttributes();
	public abstract IList get_ContextProperties();

}
//NameSpace:System.Runtime.Remoting.Activation
public interface IConstructionReturnMessage : IMethodReturnMessage, IMethodMessage, IMessage
{
}
//NameSpace:System.Runtime.Remoting.Activation
internal class RemoteActivationAttribute : Attribute, IContextAttribute
{
	// Fields
	private IList _contextProperties;

	// Methods
	public void .ctor(IList contextProperties);
	public bool IsContextOK(Context ctx, IConstructionCallMessage ctor);
	public void GetPropertiesForNewContext(IConstructionCallMessage ctor);

}
//NameSpace:System.Runtime.Remoting.Activation
internal class RemoteActivator : MarshalByRefObject, IActivator
{
	// Properties
	public IActivator NextActivator { get; }

	// Methods
	public IConstructionReturnMessage Activate(IConstructionCallMessage msg);
	public override object InitializeLifetimeService();
	public IActivator get_NextActivator();

}
//NameSpace:System.Runtime.Remoting.Metadata
public class SoapAttribute : Attribute
{
	// Fields
	private bool _useAttribute;
	protected string ProtXmlNamespace;
	protected object ReflectInfo;

	// Properties
	public virtual bool UseAttribute { get; }
	public virtual string XmlNamespace { get; }

	// Methods
	public void .ctor();
	public virtual bool get_UseAttribute();
	public virtual string get_XmlNamespace();
	internal virtual void SetReflectionObject(object reflectionObject);

}
//NameSpace:System.Runtime.Remoting.Metadata
public sealed class SoapFieldAttribute : SoapAttribute
{
	// Fields
	private string _elementName;
	private bool _isElement;

	// Properties
	public string XmlElementName { get; }

	// Methods
	public void .ctor();
	public string get_XmlElementName();
	public bool IsInteropXmlElement();
	internal override void SetReflectionObject(object reflectionObject);

}
//NameSpace:System.Runtime.Remoting.Metadata
public sealed class SoapMethodAttribute : SoapAttribute
{
	// Fields
	private string _responseElement;
	private string _responseNamespace;
	private string _returnElement;
	private string _soapAction;
	private bool _useAttribute;
	private string _namespace;

	// Properties
	public override bool UseAttribute { get; }
	public override string XmlNamespace { get; }

	// Methods
	public void .ctor();
	public override bool get_UseAttribute();
	public override string get_XmlNamespace();
	internal override void SetReflectionObject(object reflectionObject);

}
//NameSpace:System.Runtime.Remoting.Metadata
public sealed class SoapParameterAttribute : SoapAttribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.Remoting.Metadata
public sealed class SoapTypeAttribute : SoapAttribute
{
	// Fields
	private bool _useAttribute;
	private string _xmlElementName;
	private string _xmlNamespace;
	private string _xmlTypeName;
	private string _xmlTypeNamespace;
	private bool _isType;
	private bool _isElement;

	// Properties
	public override bool UseAttribute { get; }
	public string XmlElementName { get; }
	public override string XmlNamespace { get; }
	public string XmlTypeName { get; }
	public string XmlTypeNamespace { get; }
	internal bool IsInteropXmlElement { get; }
	internal bool IsInteropXmlType { get; }

	// Methods
	public void .ctor();
	public override bool get_UseAttribute();
	public string get_XmlElementName();
	public override string get_XmlNamespace();
	public string get_XmlTypeName();
	public string get_XmlTypeNamespace();
	internal bool get_IsInteropXmlElement();
	internal bool get_IsInteropXmlType();
	internal override void SetReflectionObject(object reflectionObject);

}
//NameSpace:System.Runtime.Remoting.Messaging
public sealed class CallContext
{
	// Methods
	private void .ctor();
	internal static object SetCurrentCallContext(LogicalCallContext ctx);
	internal static LogicalCallContext SetLogicalCallContext(LogicalCallContext callCtx);

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class IllogicalCallContext
{
	// Fields
	private Hashtable m_Datastore;
	private object m_HostContext;

	// Properties
	private Hashtable Datastore { get; }
	internal object HostContext { get; set; }
	internal bool HasUserData { get; }

	// Methods
	private Hashtable get_Datastore();
	internal object get_HostContext();
	internal void set_HostContext(object value);
	internal bool get_HasUserData();
	public IllogicalCallContext CreateCopy();
	public void .ctor();

}
//NameSpace:System.Runtime.Remoting.Messaging
public sealed class LogicalCallContext : ISerializable, ICloneable
{
	// Fields
	private static Type s_callContextType;
	private Hashtable m_Datastore;
	private CallContextRemotingData m_RemotingData;
	private CallContextSecurityData m_SecurityData;
	private object m_HostContext;
	private bool m_IsCorrelationMgr;

	// Properties
	public bool HasInfo { get; }
	private bool HasUserData { get; }
	private Hashtable Datastore { get; }

	// Methods
	internal void .ctor();
	internal void .ctor(SerializationInfo info, StreamingContext context);
	public void GetObjectData(SerializationInfo info, StreamingContext context);
	public object Clone();
	internal void Merge(LogicalCallContext lc);
	public bool get_HasInfo();
	private bool get_HasUserData();
	private Hashtable get_Datastore();
	private static void .cctor();

}
//NameSpace:
internal struct LogicalCallContext.Reader
{
	// Fields
	private LogicalCallContext m_ctx;

	// Properties
	public bool IsNull { get; }
	public bool HasInfo { get; }

	// Methods
	public void .ctor(LogicalCallContext ctx);
	public bool get_IsNull();
	public bool get_HasInfo();
	public LogicalCallContext Clone();

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class CallContextSecurityData : ICloneable
{
	// Fields
	private IPrincipal _principal;

	// Properties
	internal bool HasInfo { get; }

	// Methods
	internal bool get_HasInfo();
	public object Clone();
	public void .ctor();

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class CallContextRemotingData : ICloneable
{
	// Fields
	private string _logicalCallID;

	// Properties
	internal string LogicalCallID { get; set; }
	internal bool HasInfo { get; }

	// Methods
	internal string get_LogicalCallID();
	internal void set_LogicalCallID(string value);
	internal bool get_HasInfo();
	public object Clone();
	public void .ctor();

}
//NameSpace:System.Runtime.Remoting.Messaging
internal enum ArgInfoType
{
	// Fields
	public byte value__;
	public const ArgInfoType In;
	public const ArgInfoType Out;

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class ArgInfo
{
	// Fields
	private int[] _paramMap;
	private int _inoutArgCount;
	private MethodBase _method;

	// Methods
	public void .ctor(MethodBase method, ArgInfoType type);
	public object[] GetInOutArgs(object[] args);

}
//NameSpace:System.Runtime.Remoting.Messaging
public class AsyncResult : IAsyncResult, IMessageSink, IThreadPoolWorkItem
{
	// Fields
	private object async_state;
	private WaitHandle handle;
	private object async_delegate;
	private IntPtr data;
	private object object_data;
	private bool sync_completed;
	private bool completed;
	private bool endinvoke_called;
	private object async_callback;
	private ExecutionContext current;
	private ExecutionContext original;
	private long add_time;
	private MonoMethodMessage call_message;
	private IMessageCtrl message_ctrl;
	private IMessage reply_message;
	private WaitCallback orig_cb;
	internal static ContextCallback ccb;

	// Properties
	public virtual object AsyncState { get; }
	public virtual WaitHandle AsyncWaitHandle { get; }
	public virtual bool CompletedSynchronously { get; }
	public virtual bool IsCompleted { get; }
	public bool EndInvokeCalled { get; set; }
	public virtual object AsyncDelegate { get; }
	public IMessageSink NextSink { get; }
	internal MonoMethodMessage CallMessage { get; set; }

	// Methods
	internal void .ctor();
	internal void .ctor(WaitCallback cb, object state, bool capture_context);
	private static void WaitCallback_Context(object state);
	public virtual object get_AsyncState();
	public virtual WaitHandle get_AsyncWaitHandle();
	public virtual bool get_CompletedSynchronously();
	public virtual bool get_IsCompleted();
	public bool get_EndInvokeCalled();
	public void set_EndInvokeCalled(bool value);
	public virtual object get_AsyncDelegate();
	public IMessageSink get_NextSink();
	public virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
	public virtual IMessage GetReplyMessage();
	public virtual void SetMessageCtrl(IMessageCtrl mc);
	internal void SetCompletedSynchronously(bool completed);
	internal IMessage EndInvoke();
	public virtual IMessage SyncProcessMessage(IMessage msg);
	internal MonoMethodMessage get_CallMessage();
	internal void set_CallMessage(MonoMethodMessage value);
	private void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
	private void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
	internal object Invoke();
	private static void .cctor();
	private void <.ctor>b__17_0(object <p0>);

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class CADArgHolder
{
	// Fields
	public int index;

	// Methods
	public void .ctor(int i);

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class CADObjRef
{
	// Fields
	internal ObjRef objref;
	internal int SourceDomain;
	internal byte[] TypeInfo;

	// Methods
	public void .ctor(ObjRef o, int sourceDomain);

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class CADMethodRef
{
	// Fields
	private bool ctor;
	private string typeName;
	private string methodName;
	private string[] param_names;
	private string[] generic_arg_names;

	// Methods
	private Type[] GetTypes(string[] typeArray);
	public MethodBase Resolve();
	public void .ctor(IMethodMessage msg);

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class CADMessageBase
{
	// Fields
	protected object[] _args;
	protected byte[] _serializedArgs;
	protected int _propertyCount;
	protected CADArgHolder _callContext;
	internal byte[] serializedMethod;

	// Methods
	public void .ctor(IMethodMessage msg);
	internal MethodBase GetMethod();
	protected static Type[] GetSignature(MethodBase methodBase, bool load);
	internal static int MarshalProperties(IDictionary dict, ArrayList args);
	internal static void UnmarshalProperties(IDictionary dict, int count, ArrayList args);
	private static bool IsPossibleToIgnoreMarshal(object obj);
	protected object MarshalArgument(object arg, ArrayList args);
	protected object UnmarshalArgument(object arg, ArrayList args);
	internal object[] MarshalArguments(object[] arguments, ArrayList args);
	internal object[] UnmarshalArguments(object[] arguments, ArrayList args);
	protected void SaveLogicalCallContext(IMethodMessage msg, ArrayList serializeList);
	internal LogicalCallContext GetLogicalCallContext(ArrayList args);

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class CADMethodCallMessage : CADMessageBase
{
	// Fields
	private string _uri;

	// Properties
	internal string Uri { get; }
	internal int PropertiesCount { get; }

	// Methods
	internal string get_Uri();
	internal static CADMethodCallMessage Create(IMessage callMsg);
	internal void .ctor(IMethodCallMessage callMsg);
	internal ArrayList GetArguments();
	internal object[] GetArgs(ArrayList args);
	internal int get_PropertiesCount();

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class CADMethodReturnMessage : CADMessageBase
{
	// Fields
	private object _returnValue;
	private CADArgHolder _exception;
	private Type[] _sig;

	// Properties
	internal int PropertiesCount { get; }

	// Methods
	internal static CADMethodReturnMessage Create(IMessage callMsg);
	internal void .ctor(IMethodReturnMessage retMsg);
	internal ArrayList GetArguments();
	internal object[] GetArgs(ArrayList args);
	internal object GetReturnValue(ArrayList args);
	internal Exception GetException(ArrayList args);
	internal int get_PropertiesCount();

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class ClientContextTerminatorSink : IMessageSink
{
	// Fields
	private Context _context;

	// Methods
	public void .ctor(Context ctx);
	public IMessage SyncProcessMessage(IMessage msg);
	public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class ClientContextReplySink : IMessageSink
{
	// Fields
	private IMessageSink _replySink;
	private Context _context;

	// Methods
	public void .ctor(Context ctx, IMessageSink replySink);
	public IMessage SyncProcessMessage(IMessage msg);
	public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);

}
//NameSpace:System.Runtime.Remoting.Messaging
public class ConstructionCall : MethodCall, IConstructionCallMessage, IMessage, IMethodCallMessage, IMethodMessage
{
	// Fields
	private IActivator _activator;
	private object[] _activationAttributes;
	private IList _contextProperties;
	private Type _activationType;
	private string _activationTypeName;
	private bool _isContextOk;
	private RemotingProxy _sourceProxy;

	// Properties
	internal bool IsContextOk { get; set; }
	public Type ActivationType { get; }
	public string ActivationTypeName { get; }
	public IActivator Activator { get; set; }
	public object[] CallSiteActivationAttributes { get; }
	public IList ContextProperties { get; }
	public override IDictionary Properties { get; }
	internal RemotingProxy SourceProxy { get; set; }

	// Methods
	internal void .ctor(Type type);
	internal void .ctor(SerializationInfo info, StreamingContext context);
	internal override void InitDictionary();
	internal bool get_IsContextOk();
	internal void set_IsContextOk(bool value);
	public Type get_ActivationType();
	public string get_ActivationTypeName();
	public IActivator get_Activator();
	public void set_Activator(IActivator value);
	public object[] get_CallSiteActivationAttributes();
	internal void SetActivationAttributes(object[] attributes);
	public IList get_ContextProperties();
	internal override void InitMethodProperty(string key, object value);
	public override void GetObjectData(SerializationInfo info, StreamingContext context);
	public override IDictionary get_Properties();
	internal RemotingProxy get_SourceProxy();
	internal void set_SourceProxy(RemotingProxy value);

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class ConstructionCallDictionary : MessageDictionary
{
	// Fields
	public static string[] InternalKeys;

	// Methods
	public void .ctor(IConstructionCallMessage message);
	protected override object GetMethodProperty(string key);
	protected override void SetMethodProperty(string key, object value);
	private static void .cctor();

}
//NameSpace:System.Runtime.Remoting.Messaging
public class ConstructionResponse : MethodResponse, IConstructionReturnMessage, IMethodReturnMessage, IMethodMessage, IMessage
{
	// Properties
	public override IDictionary Properties { get; }

	// Methods
	internal void .ctor(object resultObject, LogicalCallContext callCtx, IMethodCallMessage msg);
	internal void .ctor(Exception e, IMethodCallMessage msg);
	internal void .ctor(SerializationInfo info, StreamingContext context);
	public override IDictionary get_Properties();

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class EnvoyTerminatorSink : IMessageSink
{
	// Fields
	public static EnvoyTerminatorSink Instance;

	// Methods
	public IMessage SyncProcessMessage(IMessage msg);
	public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
	public void .ctor();
	private static void .cctor();

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class ErrorMessage : IMethodCallMessage, IMethodMessage, IMessage
{
	// Fields
	private string _uri;

	// Properties
	public int ArgCount { get; }
	public object[] Args { get; }
	public MethodBase MethodBase { get; }
	public string MethodName { get; }
	public object MethodSignature { get; }
	public virtual IDictionary Properties { get; }
	public string TypeName { get; }
	public string Uri { get; }
	public LogicalCallContext LogicalCallContext { get; }

	// Methods
	public void .ctor();
	public int get_ArgCount();
	public object[] get_Args();
	public MethodBase get_MethodBase();
	public string get_MethodName();
	public object get_MethodSignature();
	public virtual IDictionary get_Properties();
	public string get_TypeName();
	public string get_Uri();
	public object GetArg(int arg_num);
	public LogicalCallContext get_LogicalCallContext();

}
//NameSpace:System.Runtime.Remoting.Messaging
public class Header
{
}
//NameSpace:System.Runtime.Remoting.Messaging
public sealed class HeaderHandler : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual object Invoke(Header[] headers);
	public virtual IAsyncResult BeginInvoke(Header[] headers, AsyncCallback callback, object object);
	public virtual object EndInvoke(IAsyncResult result);

}
//NameSpace:System.Runtime.Remoting.Messaging
internal interface IInternalMessage
{
	// Properties
	public abstract Identity TargetIdentity { get; set; }
	public abstract string Uri { get; set; }

	// Methods
	public abstract Identity get_TargetIdentity();
	public abstract void set_TargetIdentity(Identity value);
	public abstract string get_Uri();
	public abstract void set_Uri(string value);

}
//NameSpace:System.Runtime.Remoting.Messaging
public interface IMessage
{
	// Properties
	public abstract IDictionary Properties { get; }

	// Methods
	public abstract IDictionary get_Properties();

}
//NameSpace:System.Runtime.Remoting.Messaging
public interface IMessageCtrl
{
}
//NameSpace:System.Runtime.Remoting.Messaging
public interface IMessageSink
{
	// Methods
	public abstract IMessage SyncProcessMessage(IMessage msg);
	public abstract IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);

}
//NameSpace:System.Runtime.Remoting.Messaging
public interface IMethodCallMessage : IMethodMessage, IMessage
{
}
//NameSpace:System.Runtime.Remoting.Messaging
public interface IMethodMessage : IMessage
{
	// Properties
	public abstract int ArgCount { get; }
	public abstract object[] Args { get; }
	public abstract LogicalCallContext LogicalCallContext { get; }
	public abstract MethodBase MethodBase { get; }
	public abstract string MethodName { get; }
	public abstract object MethodSignature { get; }
	public abstract string TypeName { get; }
	public abstract string Uri { get; }

	// Methods
	public abstract int get_ArgCount();
	public abstract object[] get_Args();
	public abstract LogicalCallContext get_LogicalCallContext();
	public abstract MethodBase get_MethodBase();
	public abstract string get_MethodName();
	public abstract object get_MethodSignature();
	public abstract string get_TypeName();
	public abstract string get_Uri();
	public abstract object GetArg(int argNum);

}
//NameSpace:System.Runtime.Remoting.Messaging
public interface IMethodReturnMessage : IMethodMessage, IMessage
{
	// Properties
	public abstract Exception Exception { get; }
	public abstract object[] OutArgs { get; }
	public abstract object ReturnValue { get; }

	// Methods
	public abstract Exception get_Exception();
	public abstract object[] get_OutArgs();
	public abstract object get_ReturnValue();

}
//NameSpace:System.Runtime.Remoting.Messaging
public interface IRemotingFormatter : IFormatter
{
}
//NameSpace:System.Runtime.Remoting.Messaging
internal interface ISerializationRootObject
{
}
//NameSpace:System.Runtime.Remoting.Messaging
public class MethodCall : IMethodCallMessage, IMethodMessage, IMessage, ISerializable, IInternalMessage, ISerializationRootObject
{
	// Fields
	private string _uri;
	private string _typeName;
	private string _methodName;
	private object[] _args;
	private Type[] _methodSignature;
	private MethodBase _methodBase;
	private LogicalCallContext _callContext;
	private Identity _targetIdentity;
	private Type[] _genericArguments;
	protected IDictionary ExternalProperties;
	protected IDictionary InternalProperties;

	// Properties
	public int ArgCount { get; }
	public object[] Args { get; }
	public LogicalCallContext LogicalCallContext { get; }
	public MethodBase MethodBase { get; }
	public string MethodName { get; }
	public object MethodSignature { get; }
	public virtual IDictionary Properties { get; }
	public string TypeName { get; }
	public string Uri { get; set; }
	private string System.Runtime.Remoting.Messaging.IInternalMessage.Uri { get; set; }
	private Identity System.Runtime.Remoting.Messaging.IInternalMessage.TargetIdentity { get; set; }
	private Type[] GenericArguments { get; }

	// Methods
	internal void .ctor(SerializationInfo info, StreamingContext context);
	internal void .ctor(CADMethodCallMessage msg);
	internal void .ctor();
	internal void CopyFrom(IMethodMessage call);
	internal virtual void InitMethodProperty(string key, object value);
	public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
	public int get_ArgCount();
	public object[] get_Args();
	public LogicalCallContext get_LogicalCallContext();
	public MethodBase get_MethodBase();
	public string get_MethodName();
	public object get_MethodSignature();
	public virtual IDictionary get_Properties();
	internal virtual void InitDictionary();
	public string get_TypeName();
	public string get_Uri();
	public void set_Uri(string value);
	private string System.Runtime.Remoting.Messaging.IInternalMessage.get_Uri();
	private void System.Runtime.Remoting.Messaging.IInternalMessage.set_Uri(string value);
	public object GetArg(int argNum);
	public virtual void Init();
	public void ResolveMethod();
	private Type CastTo(string clientType, Type serverType);
	private static string GetTypeNameFromAssemblyQualifiedName(string aqname);
	private Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity();
	private void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(Identity value);
	private Type[] get_GenericArguments();

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class MCMDictionary : MessageDictionary
{
	// Fields
	public static string[] InternalKeys;

	// Methods
	public void .ctor(IMethodMessage message);
	private static void .cctor();

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class MessageDictionary : IDictionary, ICollection, IEnumerable
{
	// Fields
	private IDictionary _internalProperties;
	protected IMethodMessage _message;
	private string[] _methodKeys;
	private bool _ownProperties;

	// Properties
	internal IDictionary InternalDictionary { get; }
	public void MethodKeys { set; }
	public object Item { get; set; }
	public ICollection Values { get; }
	public int Count { get; }
	public bool IsSynchronized { get; }
	public object SyncRoot { get; }

	// Methods
	public void .ctor(IMethodMessage message);
	internal bool HasUserData();
	internal IDictionary get_InternalDictionary();
	public void set_MethodKeys(string[] value);
	protected virtual IDictionary AllocInternalProperties();
	public IDictionary GetInternalProperties();
	private bool IsOverridenKey(string key);
	public object get_Item(object key);
	public void set_Item(object key, object value);
	protected virtual object GetMethodProperty(string key);
	protected virtual void SetMethodProperty(string key, object value);
	public ICollection get_Values();
	public void Add(object key, object value);
	public int get_Count();
	public bool get_IsSynchronized();
	public object get_SyncRoot();
	public void CopyTo(Array array, int index);
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();
	public IDictionaryEnumerator GetEnumerator();

}
//NameSpace:
private class MessageDictionary.DictionaryEnumerator : IDictionaryEnumerator, IEnumerator
{
	// Fields
	private MessageDictionary _methodDictionary;
	private IDictionaryEnumerator _hashtableEnum;
	private int _posMethod;

	// Properties
	public object Current { get; }
	public DictionaryEntry Entry { get; }
	public object Key { get; }
	public object Value { get; }

	// Methods
	public void .ctor(MessageDictionary methodDictionary);
	public object get_Current();
	public bool MoveNext();
	public DictionaryEntry get_Entry();
	public object get_Key();
	public object get_Value();

}
//NameSpace:System.Runtime.Remoting.Messaging
public class MethodResponse : IMethodReturnMessage, IMethodMessage, IMessage, ISerializable, IInternalMessage, ISerializationRootObject
{
	// Fields
	private string _methodName;
	private string _uri;
	private string _typeName;
	private MethodBase _methodBase;
	private object _returnValue;
	private Exception _exception;
	private Type[] _methodSignature;
	private ArgInfo _inArgInfo;
	private object[] _args;
	private object[] _outArgs;
	private IMethodCallMessage _callMsg;
	private LogicalCallContext _callContext;
	private Identity _targetIdentity;
	protected IDictionary ExternalProperties;
	protected IDictionary InternalProperties;

	// Properties
	public int ArgCount { get; }
	public object[] Args { get; }
	public Exception Exception { get; }
	public LogicalCallContext LogicalCallContext { get; }
	public MethodBase MethodBase { get; }
	public string MethodName { get; }
	public object MethodSignature { get; }
	public object[] OutArgs { get; }
	public virtual IDictionary Properties { get; }
	public object ReturnValue { get; }
	public string TypeName { get; }
	public string Uri { get; set; }
	private string System.Runtime.Remoting.Messaging.IInternalMessage.Uri { get; set; }
	private Identity System.Runtime.Remoting.Messaging.IInternalMessage.TargetIdentity { get; set; }

	// Methods
	internal void .ctor(Exception e, IMethodCallMessage msg);
	internal void .ctor(object returnValue, object[] outArgs, LogicalCallContext callCtx, IMethodCallMessage msg);
	internal void .ctor(IMethodCallMessage msg, CADMethodReturnMessage retmsg);
	internal void .ctor(SerializationInfo info, StreamingContext context);
	internal void InitMethodProperty(string key, object value);
	public int get_ArgCount();
	public object[] get_Args();
	public Exception get_Exception();
	public LogicalCallContext get_LogicalCallContext();
	public MethodBase get_MethodBase();
	public string get_MethodName();
	public object get_MethodSignature();
	public object[] get_OutArgs();
	public virtual IDictionary get_Properties();
	public object get_ReturnValue();
	public string get_TypeName();
	public string get_Uri();
	public void set_Uri(string value);
	private string System.Runtime.Remoting.Messaging.IInternalMessage.get_Uri();
	private void System.Runtime.Remoting.Messaging.IInternalMessage.set_Uri(string value);
	public object GetArg(int argNum);
	public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
	private Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity();
	private void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(Identity value);

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class MethodReturnDictionary : MessageDictionary
{
	// Fields
	public static string[] InternalReturnKeys;
	public static string[] InternalExceptionKeys;

	// Methods
	public void .ctor(IMethodReturnMessage message);
	private static void .cctor();

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class MonoMethodMessage : IMethodCallMessage, IMethodMessage, IMessage, IMethodReturnMessage, IInternalMessage
{
	// Fields
	private MonoMethod method;
	private object[] args;
	private string[] names;
	private byte[] arg_types;
	public LogicalCallContext ctx;
	public object rval;
	public Exception exc;
	private AsyncResult asyncResult;
	private CallType call_type;
	private string uri;
	private MCMDictionary properties;
	private Type[] methodSignature;
	private Identity identity;
	internal static string CallContextKey;
	internal static string UriKey;

	// Properties
	public IDictionary Properties { get; }
	public int ArgCount { get; }
	public object[] Args { get; }
	public LogicalCallContext LogicalCallContext { get; set; }
	public MethodBase MethodBase { get; }
	public string MethodName { get; }
	public object MethodSignature { get; }
	public string TypeName { get; }
	public string Uri { get; set; }
	public Exception Exception { get; }
	public int OutArgCount { get; }
	public object[] OutArgs { get; }
	public object ReturnValue { get; }
	private Identity System.Runtime.Remoting.Messaging.IInternalMessage.TargetIdentity { get; set; }
	public AsyncResult AsyncResult { get; }
	internal CallType CallType { get; }

	// Methods
	internal void InitMessage(MonoMethod method, object[] out_args);
	internal void .ctor(MethodInfo minfo, object[] in_args, object[] out_args);
	public IDictionary get_Properties();
	public int get_ArgCount();
	public object[] get_Args();
	public LogicalCallContext get_LogicalCallContext();
	public void set_LogicalCallContext(LogicalCallContext value);
	public MethodBase get_MethodBase();
	public string get_MethodName();
	public object get_MethodSignature();
	public string get_TypeName();
	public string get_Uri();
	public void set_Uri(string value);
	public object GetArg(int arg_num);
	public Exception get_Exception();
	public int get_OutArgCount();
	public object[] get_OutArgs();
	public object get_ReturnValue();
	private Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity();
	private void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(Identity value);
	public AsyncResult get_AsyncResult();
	internal CallType get_CallType();
	public bool NeedsOutProcessing(out int outCount);
	private static void .cctor();

}
//NameSpace:System.Runtime.Remoting.Messaging
internal enum CallType
{
	// Fields
	public int value__;
	public const CallType Sync;
	public const CallType BeginInvoke;
	public const CallType EndInvoke;
	public const CallType OneWay;

}
//NameSpace:System.Runtime.Remoting.Messaging
public class OneWayAttribute : Attribute
{
}
//NameSpace:System.Runtime.Remoting.Messaging
internal class RemotingSurrogate : ISerializationSurrogate
{
	// Methods
	public virtual void GetObjectData(object obj, SerializationInfo si, StreamingContext sc);
	public virtual object SetObjectData(object obj, SerializationInfo si, StreamingContext sc, ISurrogateSelector selector);
	public void .ctor();

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class ObjRefSurrogate : ISerializationSurrogate
{
	// Methods
	public virtual void GetObjectData(object obj, SerializationInfo si, StreamingContext sc);
	public virtual object SetObjectData(object obj, SerializationInfo si, StreamingContext sc, ISurrogateSelector selector);
	public void .ctor();

}
//NameSpace:System.Runtime.Remoting.Messaging
public class RemotingSurrogateSelector : ISurrogateSelector
{
	// Fields
	private static Type s_cachedTypeObjRef;
	private static ObjRefSurrogate _objRefSurrogate;
	private static RemotingSurrogate _objRemotingSurrogate;
	private ISurrogateSelector _next;

	// Methods
	public void .ctor();
	public virtual ISerializationSurrogate GetSurrogate(Type type, StreamingContext context, out ISurrogateSelector ssout);
	private static void .cctor();

}
//NameSpace:System.Runtime.Remoting.Messaging
public class ReturnMessage : IMethodReturnMessage, IMethodMessage, IMessage, IInternalMessage
{
	// Fields
	private object[] _outArgs;
	private object[] _args;
	private LogicalCallContext _callCtx;
	private object _returnValue;
	private string _uri;
	private Exception _exception;
	private MethodBase _methodBase;
	private string _methodName;
	private Type[] _methodSignature;
	private string _typeName;
	private MethodReturnDictionary _properties;
	private Identity _targetIdentity;
	private ArgInfo _inArgInfo;

	// Properties
	public int ArgCount { get; }
	public object[] Args { get; }
	public LogicalCallContext LogicalCallContext { get; }
	public MethodBase MethodBase { get; }
	public string MethodName { get; }
	public object MethodSignature { get; }
	public virtual IDictionary Properties { get; }
	public string TypeName { get; }
	public string Uri { get; set; }
	private string System.Runtime.Remoting.Messaging.IInternalMessage.Uri { get; set; }
	public Exception Exception { get; }
	public object[] OutArgs { get; }
	public virtual object ReturnValue { get; }
	private Identity System.Runtime.Remoting.Messaging.IInternalMessage.TargetIdentity { get; set; }

	// Methods
	public void .ctor(object ret, object[] outArgs, int outArgsCount, LogicalCallContext callCtx, IMethodCallMessage mcm);
	public void .ctor(Exception e, IMethodCallMessage mcm);
	public int get_ArgCount();
	public object[] get_Args();
	public LogicalCallContext get_LogicalCallContext();
	public MethodBase get_MethodBase();
	public string get_MethodName();
	public object get_MethodSignature();
	public virtual IDictionary get_Properties();
	public string get_TypeName();
	public string get_Uri();
	public void set_Uri(string value);
	private string System.Runtime.Remoting.Messaging.IInternalMessage.get_Uri();
	private void System.Runtime.Remoting.Messaging.IInternalMessage.set_Uri(string value);
	public object GetArg(int argNum);
	public Exception get_Exception();
	public object[] get_OutArgs();
	public virtual object get_ReturnValue();
	private Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity();
	private void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(Identity value);

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class ServerContextTerminatorSink : IMessageSink
{
	// Methods
	public IMessage SyncProcessMessage(IMessage msg);
	public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
	public void .ctor();

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class ServerObjectTerminatorSink : IMessageSink
{
	// Fields
	private IMessageSink _nextSink;

	// Methods
	public void .ctor(IMessageSink nextSink);
	public IMessage SyncProcessMessage(IMessage msg);
	public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class ServerObjectReplySink : IMessageSink
{
	// Fields
	private IMessageSink _replySink;
	private ServerIdentity _identity;

	// Methods
	public void .ctor(ServerIdentity identity, IMessageSink replySink);
	public IMessage SyncProcessMessage(IMessage msg);
	public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);

}
//NameSpace:System.Runtime.Remoting.Messaging
internal class StackBuilderSink : IMessageSink
{
	// Fields
	private MarshalByRefObject _target;
	private RealProxy _rp;

	// Methods
	public void .ctor(MarshalByRefObject obj, bool forceInternalExecute);
	public IMessage SyncProcessMessage(IMessage msg);
	public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
	private void ExecuteAsyncMessage(object ob);
	private void CheckParameters(IMessage msg);
	private void <AsyncProcessMessage>b__4_0(object data);

}
//NameSpace:System.Runtime.ExceptionServices
public sealed class HandleProcessCorruptedStateExceptionsAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.ExceptionServices
public class FirstChanceExceptionEventArgs : EventArgs
{
}
//NameSpace:System.Runtime.ExceptionServices
public sealed class ExceptionDispatchInfo
{
	// Fields
	private Exception m_Exception;
	private object m_stackTrace;

	// Properties
	internal object BinaryStackTraceArray { get; }
	public Exception SourceException { get; }

	// Methods
	private void .ctor(Exception exception);
	internal object get_BinaryStackTraceArray();
	public static ExceptionDispatchInfo Capture(Exception source);
	public Exception get_SourceException();
	public void Throw();

}
//NameSpace:System.Runtime.ConstrainedExecution
public abstract class CriticalFinalizerObject
{
	// Methods
	protected void .ctor();
	protected override void Finalize();

}
//NameSpace:System.Runtime.ConstrainedExecution
public enum Consistency
{
	// Fields
	public int value__;
	public const Consistency MayCorruptProcess;
	public const Consistency MayCorruptAppDomain;
	public const Consistency MayCorruptInstance;
	public const Consistency WillNotCorruptState;

}
//NameSpace:System.Runtime.ConstrainedExecution
public enum Cer
{
	// Fields
	public int value__;
	public const Cer None;
	public const Cer MayFail;
	public const Cer Success;

}
//NameSpace:System.Runtime.ConstrainedExecution
public sealed class ReliabilityContractAttribute : Attribute
{
	// Fields
	private Consistency _consistency;
	private Cer _cer;

	// Methods
	public void .ctor(Consistency consistencyGuarantee, Cer cer);

}
//NameSpace:System.Runtime.CompilerServices
public interface ITuple
{
}
//NameSpace:System.Runtime.CompilerServices
public sealed class TupleElementNamesAttribute : Attribute
{
	// Fields
	private readonly string[] _transformNames;

	// Methods
	public void .ctor(string[] transformNames);

}
//NameSpace:System.Runtime.CompilerServices
public struct AsyncTaskMethodBuilder
{
	// Fields
	private static readonly Task`1<VoidTaskResult> s_cachedCompleted;
	private AsyncTaskMethodBuilder`1<VoidTaskResult> m_builder;

	// Properties
	public Task Task { get; }

	// Methods
	public static AsyncTaskMethodBuilder Create();
	public void Start(T stateMachine);
	public void SetStateMachine(IAsyncStateMachine stateMachine);
	public void AwaitUnsafeOnCompleted(T awaiter, T stateMachine);
	public Task get_Task();
	public void SetResult();
	public void SetException(Exception exception);
	private static void .cctor();

}
//NameSpace:System.Runtime.CompilerServices
public struct AsyncTaskMethodBuilder`1
{
	// Fields
	internal static readonly Task`1<T> s_defaultResultTask;
	private AsyncMethodBuilderCore m_coreState;
	private Task`1<T> m_task;

	// Properties
	public Task`1<T> Task { get; }

	// Methods
	public static AsyncTaskMethodBuilder`1<T> Create();
	public void Start(T stateMachine);
	public void SetStateMachine(IAsyncStateMachine stateMachine);
	public void AwaitUnsafeOnCompleted(T awaiter, T stateMachine);
	public Task`1<T> get_Task();
	public void SetResult(T result);
	internal void SetResult(Task`1<T> completedTask);
	public void SetException(Exception exception);
	private Task`1<T> GetTaskForResult(T result);
	private static void .cctor();

}
//NameSpace:System.Runtime.CompilerServices
internal static class AsyncTaskCache
{
	// Fields
	internal static readonly Task`1<bool> TrueTask;
	internal static readonly Task`1<bool> FalseTask;
	internal static readonly Task`1<int>[] Int32Tasks;

	// Methods
	private static Task`1<int>[] CreateInt32Tasks();
	internal static Task`1<T> CreateCacheableTask(T result);
	private static void .cctor();

}
//NameSpace:System.Runtime.CompilerServices
internal struct AsyncMethodBuilderCore
{
	// Fields
	internal IAsyncStateMachine m_stateMachine;
	internal Action m_defaultContextAction;

	// Methods
	public void SetStateMachine(IAsyncStateMachine stateMachine);
	internal Action GetCompletionAction(Task taskForTracing, AsyncMethodBuilderCore.MoveNextRunner runnerToInitialize);
	private Action OutputAsyncCausalityEvents(Task innerTask, Action continuation);
	internal void PostBoxInitialization(IAsyncStateMachine stateMachine, AsyncMethodBuilderCore.MoveNextRunner runner, Task builtTask);
	internal static void ThrowAsync(Exception exception, SynchronizationContext targetContext);
	internal static Action CreateContinuationWrapper(Action continuation, Action invokeAction, optional Task innerTask);
	internal static Task TryGetContinuationTask(Action action);

}
//NameSpace:
internal sealed class AsyncMethodBuilderCore.MoveNextRunner
{
	// Fields
	private readonly ExecutionContext m_context;
	internal IAsyncStateMachine m_stateMachine;
	private static ContextCallback s_invokeMoveNext;

	// Methods
	internal void .ctor(ExecutionContext context, IAsyncStateMachine stateMachine);
	internal void Run();
	private static void InvokeMoveNext(object stateMachine);

}
//NameSpace:
private class AsyncMethodBuilderCore.ContinuationWrapper
{
	// Fields
	internal readonly Action m_continuation;
	private readonly Action m_invokeAction;
	internal readonly Task m_innerTask;

	// Methods
	internal void .ctor(Action continuation, Action invokeAction, Task innerTask);
	internal void Invoke();

}
//NameSpace:
private sealed class AsyncMethodBuilderCore.<>c__DisplayClass4_0
{
	// Fields
	public Task innerTask;
	public Action continuation;

	// Methods
	public void .ctor();
	internal void <OutputAsyncCausalityEvents>b__0();

}
//NameSpace:
private sealed class AsyncMethodBuilderCore.<>c
{
	// Fields
	public static readonly AsyncMethodBuilderCore.<>c <>9;
	public static SendOrPostCallback <>9__6_0;
	public static WaitCallback <>9__6_1;

	// Methods
	private static void .cctor();
	public void .ctor();
	internal void <ThrowAsync>b__6_0(object state);
	internal void <ThrowAsync>b__6_1(object state);

}
//NameSpace:System.Runtime.CompilerServices
public sealed class AsyncStateMachineAttribute : StateMachineAttribute
{
	// Methods
	public void .ctor(Type stateMachineType);

}
//NameSpace:System.Runtime.CompilerServices
public interface IAsyncStateMachine
{
	// Methods
	public abstract void MoveNext();
	public abstract void SetStateMachine(IAsyncStateMachine stateMachine);

}
//NameSpace:System.Runtime.CompilerServices
public interface INotifyCompletion
{
}
//NameSpace:System.Runtime.CompilerServices
public interface ICriticalNotifyCompletion : INotifyCompletion
{
	// Methods
	public abstract void UnsafeOnCompleted(Action continuation);

}
//NameSpace:System.Runtime.CompilerServices
public sealed class IteratorStateMachineAttribute : StateMachineAttribute
{
	// Methods
	public void .ctor(Type stateMachineType);

}
//NameSpace:System.Runtime.CompilerServices
public sealed class RuntimeCompatibilityAttribute : Attribute
{
	// Fields
	private bool m_wrapNonExceptionThrows;

	// Properties
	public void WrapNonExceptionThrows { set; }

	// Methods
	public void .ctor();
	public void set_WrapNonExceptionThrows(bool value);

}
//NameSpace:System.Runtime.CompilerServices
public sealed class RuntimeWrappedException : Exception
{
	// Fields
	private object m_wrappedException;

	// Methods
	private void .ctor(object thrownObject);
	public override void GetObjectData(SerializationInfo info, StreamingContext context);
	internal void .ctor(SerializationInfo info, StreamingContext context);
	internal void .ctor();

}
//NameSpace:System.Runtime.CompilerServices
public class StateMachineAttribute : Attribute
{
	// Fields
	private Type <StateMachineType>k__BackingField;

	// Properties
	private void StateMachineType { set; }

	// Methods
	private void set_StateMachineType(Type value);
	public void .ctor(Type stateMachineType);

}
//NameSpace:System.Runtime.CompilerServices
public struct TaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion
{
	// Fields
	private readonly Task m_task;

	// Methods
	internal void .ctor(Task task);
	public void UnsafeOnCompleted(Action continuation);
	public void GetResult();
	internal static void ValidateEnd(Task task);
	private static void HandleNonSuccessAndDebuggerNotification(Task task);
	private static void ThrowForNonSuccess(Task task);
	internal static void OnCompletedInternal(Task task, Action continuation, bool continueOnCapturedContext, bool flowExecutionContext);

}
//NameSpace:System.Runtime.CompilerServices
public struct TaskAwaiter`1 : ICriticalNotifyCompletion, INotifyCompletion
{
	// Fields
	private readonly Task`1<T> m_task;

	// Methods
	internal void .ctor(Task`1<T> task);
	public void UnsafeOnCompleted(Action continuation);
	public T GetResult();

}
//NameSpace:System.Runtime.CompilerServices
public struct ConfiguredTaskAwaitable
{
	// Fields
	private readonly ConfiguredTaskAwaitable.ConfiguredTaskAwaiter m_configuredTaskAwaiter;

	// Methods
	internal void .ctor(Task task, bool continueOnCapturedContext);
	public ConfiguredTaskAwaitable.ConfiguredTaskAwaiter GetAwaiter();

}
//NameSpace:
public struct ConfiguredTaskAwaitable.ConfiguredTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion
{
	// Fields
	private readonly Task m_task;
	private readonly bool m_continueOnCapturedContext;

	// Properties
	public bool IsCompleted { get; }

	// Methods
	internal void .ctor(Task task, bool continueOnCapturedContext);
	public bool get_IsCompleted();
	public void OnCompleted(Action continuation);
	public void UnsafeOnCompleted(Action continuation);
	public void GetResult();

}
//NameSpace:System.Runtime.CompilerServices
public struct ConfiguredTaskAwaitable`1
{
	// Fields
	private readonly ConfiguredTaskAwaiter<T> m_configuredTaskAwaiter;

	// Methods
	internal void .ctor(Task`1<T> task, bool continueOnCapturedContext);
	public ConfiguredTaskAwaiter<T> GetAwaiter();

}
//NameSpace:
public struct ConfiguredTaskAwaitable`1.ConfiguredTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion
{
	// Fields
	private readonly Task`1<T> m_task;
	private readonly bool m_continueOnCapturedContext;

	// Properties
	public bool IsCompleted { get; }

	// Methods
	internal void .ctor(Task`1<T> task, bool continueOnCapturedContext);
	public bool get_IsCompleted();
	public void UnsafeOnCompleted(Action continuation);
	public T GetResult();

}
//NameSpace:System.Runtime.CompilerServices
public sealed class TypeForwardedFromAttribute : Attribute
{
	// Fields
	private string assemblyFullName;

	// Properties
	public string AssemblyFullName { get; }

	// Methods
	public void .ctor(string assemblyFullName);
	public string get_AssemblyFullName();

}
//NameSpace:System.Runtime.CompilerServices
public enum LoadHint
{
	// Fields
	public int value__;
	public const LoadHint Default;
	public const LoadHint Always;
	public const LoadHint Sometimes;

}
//NameSpace:System.Runtime.CompilerServices
public sealed class DefaultDependencyAttribute : Attribute
{
	// Fields
	private LoadHint loadHint;

	// Methods
	public void .ctor(LoadHint loadHintArgument);

}
//NameSpace:System.Runtime.CompilerServices
public sealed class DependencyAttribute : Attribute
{
	// Fields
	private string dependentAssembly;
	private LoadHint loadHint;

	// Methods
	public void .ctor(string dependentAssemblyArgument, LoadHint loadHintArgument);

}
//NameSpace:System.Runtime.CompilerServices
public enum CompilationRelaxations
{
	// Fields
	public int value__;
	public const CompilationRelaxations NoStringInterning;

}
//NameSpace:System.Runtime.CompilerServices
public class CompilationRelaxationsAttribute : Attribute
{
	// Fields
	private int m_relaxations;

	// Properties
	public int CompilationRelaxations { get; }

	// Methods
	public void .ctor(int relaxations);
	public void .ctor(CompilationRelaxations relaxations);
	public int get_CompilationRelaxations();

}
//NameSpace:System.Runtime.CompilerServices
public sealed class CompilerGeneratedAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.CompilerServices
public abstract class CustomConstantAttribute : Attribute
{
	// Properties
	public abstract object Value { get; }

	// Methods
	public abstract object get_Value();
	protected void .ctor();

}
//NameSpace:System.Runtime.CompilerServices
public sealed class DateTimeConstantAttribute : CustomConstantAttribute
{
	// Fields
	private DateTime date;

	// Properties
	public override object Value { get; }

	// Methods
	public override object get_Value();

}
//NameSpace:System.Runtime.CompilerServices
public sealed class DecimalConstantAttribute : Attribute
{
	// Fields
	private Decimal dec;

	// Properties
	public Decimal Value { get; }

	// Methods
	public void .ctor(byte scale, byte sign, uint hi, uint mid, uint low);
	public Decimal get_Value();

}
//NameSpace:System.Runtime.CompilerServices
public sealed class ExtensionAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.CompilerServices
public sealed class FixedBufferAttribute : Attribute
{
	// Fields
	private Type elementType;
	private int length;

	// Properties
	public Type ElementType { get; }
	public int Length { get; }

	// Methods
	public void .ctor(Type elementType, int length);
	public Type get_ElementType();
	public int get_Length();

}
//NameSpace:System.Runtime.CompilerServices
public sealed class InternalsVisibleToAttribute : Attribute
{
	// Fields
	private string _assemblyName;
	private bool _allInternalsVisible;

	// Properties
	public string AssemblyName { get; }
	public bool AllInternalsVisible { get; set; }

	// Methods
	public void .ctor(string assemblyName);
	public string get_AssemblyName();
	public bool get_AllInternalsVisible();
	public void set_AllInternalsVisible(bool value);

}
//NameSpace:System.Runtime.CompilerServices
internal sealed class FriendAccessAllowedAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.CompilerServices
public static class IsVolatile
{
}
//NameSpace:System.Runtime.CompilerServices
internal sealed class TypeDependencyAttribute : Attribute
{
	// Fields
	private string typeName;

	// Methods
	public void .ctor(string typeName);

}
//NameSpace:System.Runtime.CompilerServices
public sealed class UnsafeValueTypeAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.CompilerServices
public sealed class StringFreezingAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.CompilerServices
internal static class JitHelpers
{
	// Methods
	internal static T UnsafeCast(object o);
	internal static int UnsafeEnumCast(T val);
	internal static long UnsafeEnumCastLong(T val);

}
//NameSpace:System.Runtime.CompilerServices
internal struct Ephemeron
{
	// Fields
	internal object key;
	internal object value;

}
//NameSpace:System.Runtime.CompilerServices
public sealed class ConditionalWeakTable`2
{
	// Fields
	private Ephemeron[] data;
	private object _lock;
	private int size;

	// Methods
	public void .ctor();
	protected override void Finalize();
	private void RehashWithoutResize();
	private void RecomputeSize();
	private void Rehash();
	public void Add(T key, T value);
	public bool Remove(T key);
	public bool TryGetValue(T key, out T value);

}
//NameSpace:System.Runtime.CompilerServices
public static class RuntimeHelpers
{
	// Properties
	public static int OffsetToStringData { get; }

	// Methods
	private static void InitializeArray(Array array, IntPtr fldHandle);
	public static void InitializeArray(Array array, RuntimeFieldHandle fldHandle);
	public static int get_OffsetToStringData();
	public static int GetHashCode(object o);
	public static void PrepareConstrainedRegions();
	public static bool IsReferenceOrContainsReferences();

}
//NameSpace:System.Runtime.InteropServices
public sealed class UnmanagedFunctionPointerAttribute : Attribute
{
	// Fields
	private CallingConvention m_callingConvention;
	public CharSet CharSet;
	public bool BestFitMapping;
	public bool ThrowOnUnmappableChar;
	public bool SetLastError;

	// Methods
	public void .ctor(CallingConvention callingConvention);

}
//NameSpace:System.Runtime.InteropServices
public sealed class DispIdAttribute : Attribute
{
	// Fields
	internal int _val;

	// Methods
	public void .ctor(int dispId);

}
//NameSpace:System.Runtime.InteropServices
public enum ComInterfaceType
{
	// Fields
	public int value__;
	public const ComInterfaceType InterfaceIsDual;
	public const ComInterfaceType InterfaceIsIUnknown;
	public const ComInterfaceType InterfaceIsIDispatch;
	public const ComInterfaceType InterfaceIsIInspectable;

}
//NameSpace:System.Runtime.InteropServices
public sealed class InterfaceTypeAttribute : Attribute
{
	// Fields
	internal ComInterfaceType _val;

	// Methods
	public void .ctor(ComInterfaceType interfaceType);

}
//NameSpace:System.Runtime.InteropServices
public sealed class ComDefaultInterfaceAttribute : Attribute
{
	// Fields
	internal Type _val;

	// Methods
	public void .ctor(Type defaultInterface);

}
//NameSpace:System.Runtime.InteropServices
public enum ClassInterfaceType
{
	// Fields
	public int value__;
	public const ClassInterfaceType None;
	public const ClassInterfaceType AutoDispatch;
	public const ClassInterfaceType AutoDual;

}
//NameSpace:System.Runtime.InteropServices
public sealed class ClassInterfaceAttribute : Attribute
{
	// Fields
	internal ClassInterfaceType _val;

	// Methods
	public void .ctor(ClassInterfaceType classInterfaceType);

}
//NameSpace:System.Runtime.InteropServices
public sealed class ComVisibleAttribute : Attribute
{
	// Fields
	internal bool _val;

	// Methods
	public void .ctor(bool visibility);

}
//NameSpace:System.Runtime.InteropServices
public sealed class TypeLibImportClassAttribute : Attribute
{
	// Fields
	internal string _importClassName;

	// Methods
	public void .ctor(Type importClass);

}
//NameSpace:System.Runtime.InteropServices
public enum VarEnum
{
	// Fields
	public int value__;
	public const VarEnum VT_EMPTY;
	public const VarEnum VT_NULL;
	public const VarEnum VT_I2;
	public const VarEnum VT_I4;
	public const VarEnum VT_R4;
	public const VarEnum VT_R8;
	public const VarEnum VT_CY;
	public const VarEnum VT_DATE;
	public const VarEnum VT_BSTR;
	public const VarEnum VT_DISPATCH;
	public const VarEnum VT_ERROR;
	public const VarEnum VT_BOOL;
	public const VarEnum VT_VARIANT;
	public const VarEnum VT_UNKNOWN;
	public const VarEnum VT_DECIMAL;
	public const VarEnum VT_I1;
	public const VarEnum VT_UI1;
	public const VarEnum VT_UI2;
	public const VarEnum VT_UI4;
	public const VarEnum VT_I8;
	public const VarEnum VT_UI8;
	public const VarEnum VT_INT;
	public const VarEnum VT_UINT;
	public const VarEnum VT_VOID;
	public const VarEnum VT_HRESULT;
	public const VarEnum VT_PTR;
	public const VarEnum VT_SAFEARRAY;
	public const VarEnum VT_CARRAY;
	public const VarEnum VT_USERDEFINED;
	public const VarEnum VT_LPSTR;
	public const VarEnum VT_LPWSTR;
	public const VarEnum VT_RECORD;
	public const VarEnum VT_FILETIME;
	public const VarEnum VT_BLOB;
	public const VarEnum VT_STREAM;
	public const VarEnum VT_STORAGE;
	public const VarEnum VT_STREAMED_OBJECT;
	public const VarEnum VT_STORED_OBJECT;
	public const VarEnum VT_BLOB_OBJECT;
	public const VarEnum VT_CF;
	public const VarEnum VT_CLSID;
	public const VarEnum VT_VECTOR;
	public const VarEnum VT_ARRAY;
	public const VarEnum VT_BYREF;

}
//NameSpace:System.Runtime.InteropServices
public enum UnmanagedType
{
	// Fields
	public int value__;
	public const UnmanagedType Bool;
	public const UnmanagedType I1;
	public const UnmanagedType U1;
	public const UnmanagedType I2;
	public const UnmanagedType U2;
	public const UnmanagedType I4;
	public const UnmanagedType U4;
	public const UnmanagedType I8;
	public const UnmanagedType U8;
	public const UnmanagedType R4;
	public const UnmanagedType R8;
	public const UnmanagedType Currency;
	public const UnmanagedType BStr;
	public const UnmanagedType LPStr;
	public const UnmanagedType LPWStr;
	public const UnmanagedType LPTStr;
	public const UnmanagedType ByValTStr;
	public const UnmanagedType IUnknown;
	public const UnmanagedType IDispatch;
	public const UnmanagedType Struct;
	public const UnmanagedType Interface;
	public const UnmanagedType SafeArray;
	public const UnmanagedType ByValArray;
	public const UnmanagedType SysInt;
	public const UnmanagedType SysUInt;
	public const UnmanagedType VBByRefStr;
	public const UnmanagedType AnsiBStr;
	public const UnmanagedType TBStr;
	public const UnmanagedType VariantBool;
	public const UnmanagedType FunctionPtr;
	public const UnmanagedType AsAny;
	public const UnmanagedType LPArray;
	public const UnmanagedType LPStruct;
	public const UnmanagedType CustomMarshaler;
	public const UnmanagedType Error;
	public const UnmanagedType IInspectable;
	public const UnmanagedType HString;
	public const UnmanagedType LPUTF8Str;

}
//NameSpace:System.Runtime.InteropServices
public sealed class ComImportAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.InteropServices
public sealed class GuidAttribute : Attribute
{
	// Fields
	internal string _val;

	// Methods
	public void .ctor(string guid);

}
//NameSpace:System.Runtime.InteropServices
public sealed class PreserveSigAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.InteropServices
public sealed class InAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.InteropServices
public sealed class OutAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.InteropServices
public sealed class OptionalAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Runtime.InteropServices
public enum DllImportSearchPath
{
	// Fields
	public int value__;
	public const DllImportSearchPath UseDllDirectoryForDependencies;
	public const DllImportSearchPath ApplicationDirectory;
	public const DllImportSearchPath UserDirectories;
	public const DllImportSearchPath System32;
	public const DllImportSearchPath SafeDirectories;
	public const DllImportSearchPath AssemblyDirectory;
	public const DllImportSearchPath LegacyBehavior;

}
//NameSpace:System.Runtime.InteropServices
public sealed class DefaultDllImportSearchPathsAttribute : Attribute
{
	// Fields
	internal DllImportSearchPath _paths;

	// Methods
	public void .ctor(DllImportSearchPath paths);

}
//NameSpace:System.Runtime.InteropServices
public sealed class DllImportAttribute : Attribute
{
	// Fields
	internal string _val;
	public string EntryPoint;
	public CharSet CharSet;
	public bool SetLastError;
	public bool ExactSpelling;
	public bool PreserveSig;
	public CallingConvention CallingConvention;
	public bool BestFitMapping;
	public bool ThrowOnUnmappableChar;

	// Properties
	public string Value { get; }

	// Methods
	internal static Attribute GetCustomAttribute(RuntimeMethodInfo method);
	internal static bool IsDefined(RuntimeMethodInfo method);
	internal void .ctor(string dllName, string entryPoint, CharSet charSet, bool exactSpelling, bool setLastError, bool preserveSig, CallingConvention callingConvention, bool bestFitMapping, bool throwOnUnmappableChar);
	public void .ctor(string dllName);
	public string get_Value();

}
//NameSpace:System.Runtime.InteropServices
public sealed class FieldOffsetAttribute : Attribute
{
	// Fields
	internal int _val;

	// Methods
	public void .ctor(int offset);

}
//NameSpace:System.Runtime.InteropServices
public sealed class TypeLibVersionAttribute : Attribute
{
	// Fields
	internal int _major;
	internal int _minor;

	// Methods
	public void .ctor(int major, int minor);

}
//NameSpace:System.Runtime.InteropServices
public sealed class ComCompatibleVersionAttribute : Attribute
{
	// Fields
	internal int _major;
	internal int _minor;
	internal int _build;
	internal int _revision;

	// Methods
	public void .ctor(int major, int minor, int build, int revision);

}
//NameSpace:System.Runtime.InteropServices
public sealed class BestFitMappingAttribute : Attribute
{
	// Fields
	internal bool _bestFitMapping;

	// Methods
	public void .ctor(bool BestFitMapping);

}
//NameSpace:System.Runtime.InteropServices
public enum CallingConvention
{
	// Fields
	public int value__;
	public const CallingConvention Winapi;
	public const CallingConvention Cdecl;
	public const CallingConvention StdCall;
	public const CallingConvention ThisCall;
	public const CallingConvention FastCall;

}
//NameSpace:System.Runtime.InteropServices
public enum CharSet
{
	// Fields
	public int value__;
	public const CharSet None;
	public const CharSet Ansi;
	public const CharSet Unicode;
	public const CharSet Auto;

}
//NameSpace:System.Runtime.InteropServices
public class COMException : ExternalException
{
	// Methods
	public void .ctor();
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public override string ToString();

}
//NameSpace:System.Runtime.InteropServices
public sealed class ErrorWrapper
{
	// Fields
	private int m_ErrorCode;

}
//NameSpace:System.Runtime.InteropServices
public class ExternalException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public override string ToString();

}
//NameSpace:System.Runtime.InteropServices
public interface ICustomMarshaler
{
	// Methods
	public abstract object MarshalNativeToManaged(IntPtr pNativeData);
	public abstract IntPtr MarshalManagedToNative(object ManagedObj);
	public abstract void CleanUpNativeData(IntPtr pNativeData);
	public abstract void CleanUpManagedData(object ManagedObj);
	public abstract int GetNativeDataSize();

}
//NameSpace:System.Runtime.InteropServices
public class MarshalDirectiveException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Runtime.InteropServices
public abstract class SafeHandle : CriticalFinalizerObject, IDisposable
{
	// Fields
	protected IntPtr handle;
	private int _state;
	private bool _ownsHandle;
	private bool _fullyInitialized;
	private const int RefCount_Mask;
	private const int RefCount_One;

	// Properties
	public bool IsClosed { get; }
	public abstract bool IsInvalid { get; }

	// Methods
	protected void .ctor(IntPtr invalidHandleValue, bool ownsHandle);
	protected override void Finalize();
	protected void SetHandle(IntPtr handle);
	public IntPtr DangerousGetHandle();
	public bool get_IsClosed();
	public abstract bool get_IsInvalid();
	public void Close();
	public void Dispose();
	protected virtual void Dispose(bool disposing);
	protected abstract bool ReleaseHandle();
	public void SetHandleAsInvalid();
	public void DangerousAddRef(bool success);
	public void DangerousRelease();
	private void InternalDispose();
	private void InternalFinalize();
	private void DangerousReleaseInternal(bool dispose);

}
//NameSpace:System.Runtime.InteropServices
public struct GCHandle
{
	// Fields
	private int handle;

	// Properties
	public bool IsAllocated { get; }
	public object Target { get; }

	// Methods
	internal void .ctor(object value, GCHandleType type);
	public bool get_IsAllocated();
	public object get_Target();
	public IntPtr AddrOfPinnedObject();
	public static GCHandle Alloc(object value, GCHandleType type);
	public void Free();
	private static object GetTarget(int handle);
	private static int GetTargetHandle(object obj, int handle, GCHandleType type);
	private static void FreeHandle(int handle);
	private static IntPtr GetAddrOfPinnedObject(int handle);
	public static bool op_Equality(GCHandle a, GCHandle b);
	public override bool Equals(object o);
	public override int GetHashCode();

}
//NameSpace:System.Runtime.InteropServices
public enum GCHandleType
{
	// Fields
	public int value__;
	public const GCHandleType Weak;
	public const GCHandleType WeakTrackResurrection;
	public const GCHandleType Normal;
	public const GCHandleType Pinned;

}
//NameSpace:System.Runtime.InteropServices
public static class Marshal
{
	// Fields
	public static readonly int SystemMaxDBCSCharSize;
	public static readonly int SystemDefaultCharSize;

	// Methods
	internal static void copy_from_unmanaged(IntPtr source, int startIndex, Array destination, int length);
	public static void Copy(IntPtr source, byte[] destination, int startIndex, int length);
	public static void Copy(IntPtr source, char[] destination, int startIndex, int length);
	public static void FreeBSTR(IntPtr ptr);
	public static int GetHRForException(Exception e);
	public static int GetLastWin32Error();
	public static object PtrToStructure(IntPtr ptr, Type structureType);
	public static T PtrToStructure(IntPtr ptr);
	private static int ReleaseInternal(IntPtr pUnk);
	public static int Release(IntPtr pUnk);
	public static void StructureToPtr(object structure, IntPtr ptr, bool fDeleteOld);
	public static void StructureToPtr(T structure, IntPtr ptr, bool fDeleteOld);
	private static void .cctor();

}
//NameSpace:System.Runtime.InteropServices
public sealed class MarshalAsAttribute : Attribute
{
	// Fields
	public string MarshalCookie;
	public string MarshalType;
	public Type MarshalTypeRef;
	public Type SafeArrayUserDefinedSubType;
	private UnmanagedType utype;
	public UnmanagedType ArraySubType;
	public VarEnum SafeArraySubType;
	public int SizeConst;
	public int IidParameterIndex;
	public short SizeParamIndex;

	// Methods
	internal MarshalAsAttribute Copy();

}
//NameSpace:System.Runtime.InteropServices
public abstract class SafeBuffer : SafeHandleZeroOrMinusOneIsInvalid, IDisposable
{
	// Fields
	private bool inited;

	// Methods
	public void AcquirePointer(byte* pointer);
	public void ReleasePointer();

}
//NameSpace:System.Runtime.InteropServices
public interface _Activator
{
}
//NameSpace:System.Runtime.InteropServices
public interface _Assembly
{
}
//NameSpace:System.Runtime.InteropServices
public interface _AssemblyName
{
}
//NameSpace:System.Runtime.InteropServices
public interface _Attribute
{
}
//NameSpace:System.Runtime.InteropServices
public interface _ConstructorInfo
{
}
//NameSpace:System.Runtime.InteropServices
public interface _EventInfo
{
}
//NameSpace:System.Runtime.InteropServices
public interface _Exception
{
}
//NameSpace:System.Runtime.InteropServices
public interface _FieldInfo
{
}
//NameSpace:System.Runtime.InteropServices
public interface _MemberInfo
{
}
//NameSpace:System.Runtime.InteropServices
public interface _MethodBase
{
}
//NameSpace:System.Runtime.InteropServices
public interface _MethodInfo
{
}
//NameSpace:System.Runtime.InteropServices
public interface _Module
{
}
//NameSpace:System.Runtime.InteropServices
public interface _ParameterInfo
{
}
//NameSpace:System.Runtime.InteropServices
public interface _PropertyInfo
{
}
//NameSpace:System.Runtime.InteropServices
public interface _SignatureHelper
{
}
//NameSpace:System.Runtime.InteropServices
public interface _Thread
{
}
//NameSpace:System.Runtime.InteropServices
public interface _Type
{
}
//NameSpace:System.Collections
public struct DictionaryEntry
{
	// Fields
	private object _key;
	private object _value;

	// Properties
	public object Key { get; }
	public object Value { get; }

	// Methods
	public void .ctor(object key, object value);
	public object get_Key();
	public object get_Value();

}
//NameSpace:System.Collections
internal sealed class LowLevelComparer : IComparer
{
	// Fields
	internal static readonly LowLevelComparer Default;

	// Methods
	private void .ctor();
	public int Compare(object a, object b);
	private static void .cctor();

}
//NameSpace:System.Collections
public class ArrayList : IList, ICollection, IEnumerable, ICloneable
{
	// Fields
	private object[] _items;
	private int _size;
	private int _version;
	private object _syncRoot;
	private static readonly object[] emptyArray;

	// Properties
	public virtual void Capacity { set; }
	public virtual int Count { get; }
	public virtual bool IsFixedSize { get; }
	public virtual bool IsReadOnly { get; }
	public virtual bool IsSynchronized { get; }
	public virtual object SyncRoot { get; }
	public virtual object Item { get; set; }

	// Methods
	public void .ctor();
	public void .ctor(int capacity);
	public void .ctor(ICollection c);
	public virtual void set_Capacity(int value);
	public virtual int get_Count();
	public virtual bool get_IsFixedSize();
	public virtual bool get_IsReadOnly();
	public virtual bool get_IsSynchronized();
	public virtual object get_SyncRoot();
	public virtual object get_Item(int index);
	public virtual void set_Item(int index, object value);
	public virtual int Add(object value);
	public virtual void AddRange(ICollection c);
	public virtual void Clear();
	public virtual object Clone();
	public virtual bool Contains(object item);
	public virtual void CopyTo(Array array, int arrayIndex);
	private void EnsureCapacity(int min);
	public virtual IEnumerator GetEnumerator();
	public virtual int IndexOf(object value);
	public virtual void Insert(int index, object value);
	public virtual void InsertRange(int index, ICollection c);
	public static ArrayList ReadOnly(ArrayList list);
	public virtual void Remove(object obj);
	public virtual void RemoveAt(int index);
	public virtual object[] ToArray();
	public virtual Array ToArray(Type type);
	private static void .cctor();

}
//NameSpace:
private class ArrayList.ReadOnlyArrayList : ArrayList
{
	// Fields
	private ArrayList _list;

	// Properties
	public override int Count { get; }
	public override bool IsReadOnly { get; }
	public override bool IsFixedSize { get; }
	public override bool IsSynchronized { get; }
	public override object Item { get; set; }
	public override object SyncRoot { get; }
	public override void Capacity { set; }

	// Methods
	internal void .ctor(ArrayList l);
	public override int get_Count();
	public override bool get_IsReadOnly();
	public override bool get_IsFixedSize();
	public override bool get_IsSynchronized();
	public override object get_Item(int index);
	public override void set_Item(int index, object value);
	public override object get_SyncRoot();
	public override int Add(object obj);
	public override void AddRange(ICollection c);
	public override void set_Capacity(int value);
	public override void Clear();
	public override object Clone();
	public override bool Contains(object obj);
	public override void CopyTo(Array array, int index);
	public override IEnumerator GetEnumerator();
	public override int IndexOf(object value);
	public override void Insert(int index, object obj);
	public override void InsertRange(int index, ICollection c);
	public override void Remove(object value);
	public override void RemoveAt(int index);
	public override object[] ToArray();
	public override Array ToArray(Type type);

}
//NameSpace:
private sealed class ArrayList.ArrayListEnumeratorSimple : IEnumerator, ICloneable
{
	// Fields
	private ArrayList list;
	private int index;
	private int version;
	private object currentElement;
	private bool isArrayList;
	private static object dummyObject;

	// Properties
	public object Current { get; }

	// Methods
	internal void .ctor(ArrayList list);
	public object Clone();
	public bool MoveNext();
	public object get_Current();
	private static void .cctor();

}
//NameSpace:
internal class ArrayList.ArrayListDebugView
{
}
//NameSpace:System.Collections
public class CaseInsensitiveComparer : IComparer
{
	// Fields
	private CompareInfo m_compareInfo;

	// Properties
	public static CaseInsensitiveComparer Default { get; }

	// Methods
	public void .ctor();
	public void .ctor(CultureInfo culture);
	public static CaseInsensitiveComparer get_Default();
	public int Compare(object a, object b);

}
//NameSpace:System.Collections
public class CaseInsensitiveHashCodeProvider : IHashCodeProvider
{
	// Fields
	private TextInfo m_text;

	// Properties
	public static CaseInsensitiveHashCodeProvider Default { get; }

	// Methods
	public void .ctor();
	public void .ctor(CultureInfo culture);
	public static CaseInsensitiveHashCodeProvider get_Default();
	public int GetHashCode(object obj);
	private static void .cctor();

}
//NameSpace:System.Collections
public abstract class CollectionBase : IList, ICollection, IEnumerable
{
	// Fields
	private ArrayList list;

	// Properties
	protected ArrayList InnerList { get; }
	public int Count { get; }
	private bool System.Collections.IList.IsReadOnly { get; }
	private bool System.Collections.IList.IsFixedSize { get; }
	private bool System.Collections.ICollection.IsSynchronized { get; }
	private object System.Collections.ICollection.SyncRoot { get; }
	private object System.Collections.IList.Item { get; set; }

	// Methods
	protected void .ctor();
	protected ArrayList get_InnerList();
	public int get_Count();
	public void Clear();
	public void RemoveAt(int index);
	private bool System.Collections.IList.get_IsReadOnly();
	private bool System.Collections.IList.get_IsFixedSize();
	private bool System.Collections.ICollection.get_IsSynchronized();
	private object System.Collections.ICollection.get_SyncRoot();
	private void System.Collections.ICollection.CopyTo(Array array, int index);
	private object System.Collections.IList.get_Item(int index);
	private void System.Collections.IList.set_Item(int index, object value);
	private bool System.Collections.IList.Contains(object value);
	private int System.Collections.IList.Add(object value);
	private void System.Collections.IList.Remove(object value);
	private int System.Collections.IList.IndexOf(object value);
	private void System.Collections.IList.Insert(int index, object value);
	public IEnumerator GetEnumerator();
	protected virtual void OnSet(int index, object oldValue, object newValue);
	protected virtual void OnInsert(int index, object value);
	protected virtual void OnClear();
	protected virtual void OnRemove(int index, object value);
	protected virtual void OnValidate(object value);
	protected virtual void OnSetComplete(int index, object oldValue, object newValue);
	protected virtual void OnInsertComplete(int index, object value);
	protected virtual void OnClearComplete();
	protected virtual void OnRemoveComplete(int index, object value);

}
//NameSpace:System.Collections
public sealed class Comparer : IComparer, ISerializable
{
	// Fields
	private CompareInfo m_compareInfo;
	public static readonly Comparer Default;
	public static readonly Comparer DefaultInvariant;

	// Methods
	private void .ctor();
	public void .ctor(CultureInfo culture);
	private void .ctor(SerializationInfo info, StreamingContext context);
	public int Compare(object a, object b);
	public void GetObjectData(SerializationInfo info, StreamingContext context);
	private static void .cctor();

}
//NameSpace:System.Collections
internal class CompatibleComparer : IEqualityComparer
{
	// Fields
	private IComparer _comparer;
	private IHashCodeProvider _hcp;

	// Properties
	internal IComparer Comparer { get; }
	internal IHashCodeProvider HashCodeProvider { get; }

	// Methods
	internal void .ctor(IComparer comparer, IHashCodeProvider hashCodeProvider);
	public int Compare(object a, object b);
	public bool Equals(object a, object b);
	public int GetHashCode(object obj);
	internal IComparer get_Comparer();
	internal IHashCodeProvider get_HashCodeProvider();

}
//NameSpace:System.Collections
public class Hashtable : IDictionary, ICollection, IEnumerable, ISerializable, IDeserializationCallback, ICloneable
{
	// Fields
	private Hashtable.bucket[] buckets;
	private int count;
	private int occupancy;
	private int loadsize;
	private float loadFactor;
	private int version;
	private bool isWriterInProgress;
	private ICollection keys;
	private IEqualityComparer _keycomparer;
	private object _syncRoot;

	// Properties
	public virtual object Item { get; set; }
	public virtual bool IsSynchronized { get; }
	public virtual ICollection Keys { get; }
	public virtual object SyncRoot { get; }
	public virtual int Count { get; }

	// Methods
	internal void .ctor(bool trash);
	public void .ctor();
	public void .ctor(int capacity);
	public void .ctor(int capacity, float loadFactor);
	public void .ctor(int capacity, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
	public void .ctor(int capacity, float loadFactor, IEqualityComparer equalityComparer);
	public void .ctor(IHashCodeProvider hcp, IComparer comparer);
	public void .ctor(IEqualityComparer equalityComparer);
	public void .ctor(int capacity, IEqualityComparer equalityComparer);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	private uint InitHash(object key, int hashsize, out uint seed, out uint incr);
	public virtual void Add(object key, object value);
	public virtual void Clear();
	public virtual object Clone();
	public virtual bool Contains(object key);
	public virtual bool ContainsKey(object key);
	private void CopyKeys(Array array, int arrayIndex);
	private void CopyEntries(Array array, int arrayIndex);
	public virtual void CopyTo(Array array, int arrayIndex);
	private void CopyValues(Array array, int arrayIndex);
	public virtual object get_Item(object key);
	public virtual void set_Item(object key, object value);
	private void expand();
	private void rehash();
	private void UpdateVersion();
	private void rehash(int newsize, bool forceNewHashCode);
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();
	public virtual IDictionaryEnumerator GetEnumerator();
	protected virtual int GetHash(object key);
	public virtual bool get_IsSynchronized();
	protected virtual bool KeyEquals(object item, object key);
	public virtual ICollection get_Keys();
	private void Insert(object key, object nvalue, bool add);
	private void putEntry(Hashtable.bucket[] newBuckets, object key, object nvalue, int hashcode);
	public virtual void Remove(object key);
	public virtual object get_SyncRoot();
	public virtual int get_Count();
	public static Hashtable Synchronized(Hashtable table);
	public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
	public virtual void OnDeserialization(object sender);

}
//NameSpace:
private struct Hashtable.bucket
{
	// Fields
	public object key;
	public object val;
	public int hash_coll;

}
//NameSpace:
private class Hashtable.KeyCollection : ICollection, IEnumerable
{
	// Fields
	private Hashtable _hashtable;

	// Properties
	public virtual bool IsSynchronized { get; }
	public virtual object SyncRoot { get; }
	public virtual int Count { get; }

	// Methods
	internal void .ctor(Hashtable hashtable);
	public virtual void CopyTo(Array array, int arrayIndex);
	public virtual IEnumerator GetEnumerator();
	public virtual bool get_IsSynchronized();
	public virtual object get_SyncRoot();
	public virtual int get_Count();

}
//NameSpace:
private class Hashtable.SyncHashtable : Hashtable, IEnumerable
{
	// Fields
	protected Hashtable _table;

	// Properties
	public override int Count { get; }
	public override bool IsSynchronized { get; }
	public override object Item { get; set; }
	public override object SyncRoot { get; }
	public override ICollection Keys { get; }

	// Methods
	internal void .ctor(Hashtable table);
	internal void .ctor(SerializationInfo info, StreamingContext context);
	public override void GetObjectData(SerializationInfo info, StreamingContext context);
	public override int get_Count();
	public override bool get_IsSynchronized();
	public override object get_Item(object key);
	public override void set_Item(object key, object value);
	public override object get_SyncRoot();
	public override void Add(object key, object value);
	public override void Clear();
	public override bool Contains(object key);
	public override bool ContainsKey(object key);
	public override void CopyTo(Array array, int arrayIndex);
	public override object Clone();
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();
	public override IDictionaryEnumerator GetEnumerator();
	public override ICollection get_Keys();
	public override void Remove(object key);
	public override void OnDeserialization(object sender);

}
//NameSpace:
private class Hashtable.HashtableEnumerator : IDictionaryEnumerator, IEnumerator, ICloneable
{
	// Fields
	private Hashtable hashtable;
	private int bucket;
	private int version;
	private bool current;
	private int getObjectRetType;
	private object currentKey;
	private object currentValue;

	// Properties
	public virtual object Key { get; }
	public virtual DictionaryEntry Entry { get; }
	public virtual object Current { get; }
	public virtual object Value { get; }

	// Methods
	internal void .ctor(Hashtable hashtable, int getObjRetType);
	public object Clone();
	public virtual object get_Key();
	public virtual bool MoveNext();
	public virtual DictionaryEntry get_Entry();
	public virtual object get_Current();
	public virtual object get_Value();

}
//NameSpace:
internal class Hashtable.HashtableDebugView
{
}
//NameSpace:System.Collections
internal static class HashHelpers
{
	// Fields
	public static readonly int[] primes;
	private static ConditionalWeakTable`2<objectSerializationInfo> s_SerializationInfoTable;

	// Properties
	internal static ConditionalWeakTable`2<objectSerializationInfo> SerializationInfoTable { get; }

	// Methods
	internal static ConditionalWeakTable`2<objectSerializationInfo> get_SerializationInfoTable();
	public static bool IsPrime(int candidate);
	public static int GetPrime(int min);
	public static int ExpandPrime(int oldSize);
	private static void .cctor();

}
//NameSpace:System.Collections
public interface ICollection : IEnumerable
{
	// Properties
	public abstract int Count { get; }
	public abstract object SyncRoot { get; }
	public abstract bool IsSynchronized { get; }

	// Methods
	public abstract void CopyTo(Array array, int index);
	public abstract int get_Count();
	public abstract object get_SyncRoot();
	public abstract bool get_IsSynchronized();

}
//NameSpace:System.Collections
public interface IComparer
{
	// Methods
	public abstract int Compare(object x, object y);

}
//NameSpace:System.Collections
public interface IDictionary : ICollection, IEnumerable
{
	// Properties
	public abstract object Item { get; set; }

	// Methods
	public abstract object get_Item(object key);
	public abstract void set_Item(object key, object value);
	public abstract IDictionaryEnumerator GetEnumerator();

}
//NameSpace:System.Collections
public interface IDictionaryEnumerator : IEnumerator
{
	// Properties
	public abstract object Key { get; }
	public abstract object Value { get; }
	public abstract DictionaryEntry Entry { get; }

	// Methods
	public abstract object get_Key();
	public abstract object get_Value();
	public abstract DictionaryEntry get_Entry();

}
//NameSpace:System.Collections
public interface IEnumerable
{
	// Methods
	public abstract IEnumerator GetEnumerator();

}
//NameSpace:System.Collections
public interface IEnumerator
{
	// Properties
	public abstract object Current { get; }

	// Methods
	public abstract bool MoveNext();
	public abstract object get_Current();

}
//NameSpace:System.Collections
public interface IEqualityComparer
{
	// Methods
	public abstract bool Equals(object x, object y);
	public abstract int GetHashCode(object obj);

}
//NameSpace:System.Collections
public interface IHashCodeProvider
{
	// Methods
	public abstract int GetHashCode(object obj);

}
//NameSpace:System.Collections
public interface IList : ICollection, IEnumerable
{
	// Properties
	public abstract object Item { get; set; }
	public abstract bool IsReadOnly { get; }
	public abstract bool IsFixedSize { get; }

	// Methods
	public abstract object get_Item(int index);
	public abstract void set_Item(int index, object value);
	public abstract int Add(object value);
	public abstract bool Contains(object value);
	public abstract void Clear();
	public abstract bool get_IsReadOnly();
	public abstract bool get_IsFixedSize();
	public abstract int IndexOf(object value);
	public abstract void Insert(int index, object value);
	public abstract void Remove(object value);
	public abstract void RemoveAt(int index);

}
//NameSpace:System.Collections
public interface IStructuralComparable
{
	// Methods
	public abstract int CompareTo(object other, IComparer comparer);

}
//NameSpace:System.Collections
public interface IStructuralEquatable
{
	// Methods
	public abstract bool Equals(object other, IEqualityComparer comparer);
	public abstract int GetHashCode(IEqualityComparer comparer);

}
//NameSpace:System.Collections
public class Queue : ICollection, IEnumerable, ICloneable
{
	// Fields
	private object[] _array;
	private int _head;
	private int _tail;
	private int _size;
	private int _growFactor;
	private int _version;
	private object _syncRoot;

	// Properties
	public virtual int Count { get; }
	public virtual bool IsSynchronized { get; }
	public virtual object SyncRoot { get; }

	// Methods
	public void .ctor();
	public void .ctor(int capacity);
	public void .ctor(int capacity, float growFactor);
	public void .ctor(ICollection col);
	public virtual int get_Count();
	public virtual object Clone();
	public virtual bool get_IsSynchronized();
	public virtual object get_SyncRoot();
	public virtual void CopyTo(Array array, int index);
	public virtual void Enqueue(object obj);
	public virtual IEnumerator GetEnumerator();
	public virtual object Dequeue();
	public virtual object Peek();
	internal object GetElement(int i);
	private void SetCapacity(int capacity);

}
//NameSpace:
private class Queue.QueueEnumerator : IEnumerator, ICloneable
{
	// Fields
	private Queue _q;
	private int _index;
	private int _version;
	private object currentElement;

	// Properties
	public virtual object Current { get; }

	// Methods
	internal void .ctor(Queue q);
	public object Clone();
	public virtual bool MoveNext();
	public virtual object get_Current();

}
//NameSpace:
internal class Queue.QueueDebugView
{
}
//NameSpace:System.Collections
public class SortedList : IDictionary, ICollection, IEnumerable, ICloneable
{
	// Fields
	private object[] keys;
	private object[] values;
	private int _size;
	private int version;
	private IComparer comparer;
	private object _syncRoot;
	private static object[] emptyArray;

	// Properties
	public virtual int Capacity { get; set; }
	public virtual int Count { get; }
	public virtual bool IsSynchronized { get; }
	public virtual object SyncRoot { get; }
	public virtual object Item { get; set; }

	// Methods
	public void .ctor();
	private void Init();
	public void .ctor(int initialCapacity);
	public void .ctor(IComparer comparer);
	public void .ctor(IComparer comparer, int capacity);
	public virtual void Add(object key, object value);
	public virtual int get_Capacity();
	public virtual void set_Capacity(int value);
	public virtual int get_Count();
	public virtual bool get_IsSynchronized();
	public virtual object get_SyncRoot();
	public virtual object Clone();
	public virtual void CopyTo(Array array, int arrayIndex);
	private void EnsureCapacity(int min);
	public virtual object GetByIndex(int index);
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();
	public virtual IDictionaryEnumerator GetEnumerator();
	public virtual object GetKey(int index);
	public virtual object get_Item(object key);
	public virtual void set_Item(object key, object value);
	public virtual int IndexOfKey(object key);
	private void Insert(int index, object key, object value);
	public virtual void RemoveAt(int index);
	private static void .cctor();

}
//NameSpace:
private class SortedList.SortedListEnumerator : IDictionaryEnumerator, IEnumerator, ICloneable
{
	// Fields
	private SortedList sortedList;
	private object key;
	private object value;
	private int index;
	private int startIndex;
	private int endIndex;
	private int version;
	private bool current;
	private int getObjectRetType;

	// Properties
	public virtual object Key { get; }
	public virtual DictionaryEntry Entry { get; }
	public virtual object Current { get; }
	public virtual object Value { get; }

	// Methods
	internal void .ctor(SortedList sortedList, int index, int count, int getObjRetType);
	public object Clone();
	public virtual object get_Key();
	public virtual bool MoveNext();
	public virtual DictionaryEntry get_Entry();
	public virtual object get_Current();
	public virtual object get_Value();

}
//NameSpace:
internal class SortedList.SortedListDebugView
{
}
//NameSpace:System.Collections
public class Stack : ICollection, IEnumerable, ICloneable
{
	// Fields
	private object[] _array;
	private int _size;
	private int _version;
	private object _syncRoot;

	// Properties
	public virtual int Count { get; }
	public virtual bool IsSynchronized { get; }
	public virtual object SyncRoot { get; }

	// Methods
	public void .ctor();
	public void .ctor(int initialCapacity);
	public virtual int get_Count();
	public virtual bool get_IsSynchronized();
	public virtual object get_SyncRoot();
	public virtual void Clear();
	public virtual object Clone();
	public virtual void CopyTo(Array array, int index);
	public virtual IEnumerator GetEnumerator();
	public virtual object Peek();
	public virtual object Pop();
	public virtual void Push(object obj);

}
//NameSpace:
private class Stack.StackEnumerator : IEnumerator, ICloneable
{
	// Fields
	private Stack _stack;
	private int _index;
	private int _version;
	private object currentElement;

	// Properties
	public virtual object Current { get; }

	// Methods
	internal void .ctor(Stack stack);
	public object Clone();
	public virtual bool MoveNext();
	public virtual object get_Current();

}
//NameSpace:
internal class Stack.StackDebugView
{
}
//NameSpace:System.Collections.ObjectModel
public class ReadOnlyCollection`1 : IList`1<T>, ICollection`1<T>, IEnumerable`1<T>, IEnumerable, IList, ICollection, IReadOnlyList`1<T>, IReadOnlyCollection`1<T>
{
	// Fields
	private IList`1<T> list;
	private object _syncRoot;

	// Properties
	public int Count { get; }
	public T Item { get; }
	private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
	private T System.Collections.Generic.IList<T>.Item { get; set; }
	private bool System.Collections.ICollection.IsSynchronized { get; }
	private object System.Collections.ICollection.SyncRoot { get; }
	private bool System.Collections.IList.IsFixedSize { get; }
	private bool System.Collections.IList.IsReadOnly { get; }
	private object System.Collections.IList.Item { get; set; }

	// Methods
	public void .ctor(IList`1<T> list);
	public int get_Count();
	public T get_Item(int index);
	public bool Contains(T value);
	public void CopyTo(T[] array, int index);
	public IEnumerator`1<T> GetEnumerator();
	public int IndexOf(T value);
	private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
	private T System.Collections.Generic.IList<T>.get_Item(int index);
	private void System.Collections.Generic.IList<T>.set_Item(int index, T value);
	private void System.Collections.Generic.ICollection<T>.Add(T value);
	private void System.Collections.Generic.ICollection<T>.Clear();
	private void System.Collections.Generic.IList<T>.Insert(int index, T value);
	private bool System.Collections.Generic.ICollection<T>.Remove(T value);
	private void System.Collections.Generic.IList<T>.RemoveAt(int index);
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();
	private bool System.Collections.ICollection.get_IsSynchronized();
	private object System.Collections.ICollection.get_SyncRoot();
	private void System.Collections.ICollection.CopyTo(Array array, int index);
	private bool System.Collections.IList.get_IsFixedSize();
	private bool System.Collections.IList.get_IsReadOnly();
	private object System.Collections.IList.get_Item(int index);
	private void System.Collections.IList.set_Item(int index, object value);
	private int System.Collections.IList.Add(object value);
	private void System.Collections.IList.Clear();
	private static bool IsCompatibleObject(object value);
	private bool System.Collections.IList.Contains(object value);
	private int System.Collections.IList.IndexOf(object value);
	private void System.Collections.IList.Insert(int index, object value);
	private void System.Collections.IList.Remove(object value);
	private void System.Collections.IList.RemoveAt(int index);

}
//NameSpace:System.Collections.Concurrent
internal sealed class CDSCollectionETWBCLProvider : EventSource
{
	// Fields
	public static CDSCollectionETWBCLProvider Log;

	// Methods
	private void .ctor();
	public void ConcurrentDictionary_AcquiringAllLocks(int numOfBuckets);
	private static void .cctor();

}
//NameSpace:System.Collections.Concurrent
public class ConcurrentDictionary`2 : IDictionary`2<TT>, ICollection`1<KeyValuePair`2<TT>>, IEnumerable`1<KeyValuePair`2<TT>>, IEnumerable, IDictionary, ICollection, IReadOnlyDictionary`2<TT>, IReadOnlyCollection`1<KeyValuePair`2<TT>>
{
	// Fields
	private Tables<TT> _tables;
	private IEqualityComparer`1<T> _comparer;
	private readonly bool _growLockArray;
	private int _budget;
	private static readonly bool s_isValueWriteAtomic;

	// Properties
	public void Item { set; }
	public int Count { get; }
	private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
	private object System.Collections.IDictionary.Item { get; set; }
	private bool System.Collections.ICollection.IsSynchronized { get; }
	private object System.Collections.ICollection.SyncRoot { get; }
	private static int DefaultConcurrencyLevel { get; }

	// Methods
	private static bool IsValueWriteAtomic();
	public void .ctor();
	internal void .ctor(int concurrencyLevel, int capacity, bool growLockArray, IEqualityComparer`1<T> comparer);
	public bool TryAdd(T key, T value);
	private bool TryRemoveInternal(T key, out T value, bool matchValue, T oldValue);
	public bool TryGetValue(T key, out T value);
	private bool TryGetValueInternal(T key, int hashcode, out T value);
	public void Clear();
	private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2<TT>[] array, int index);
	private void CopyToPairs(KeyValuePair`2<TT>[] array, int index);
	private void CopyToEntries(DictionaryEntry[] array, int index);
	private void CopyToObjects(object[] array, int index);
	public IEnumerator`1<KeyValuePair`2<TT>> GetEnumerator();
	private bool TryAddInternal(T key, int hashcode, T value, bool updateIfExists, bool acquireLock, out T resultingValue);
	public void set_Item(T key, T value);
	private static void ThrowKeyNullException();
	public int get_Count();
	private int GetCountInternal();
	public T GetOrAdd(T key, Func`2<TT> valueFactory);
	private void System.Collections.Generic.IDictionary<TKey,TValue>.Add(T key, T value);
	private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TT> keyValuePair);
	private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TT> keyValuePair);
	private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
	private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TT> keyValuePair);
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();
	private IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
	private object System.Collections.IDictionary.get_Item(object key);
	private void System.Collections.IDictionary.set_Item(object key, object value);
	private void System.Collections.ICollection.CopyTo(Array array, int index);
	private bool System.Collections.ICollection.get_IsSynchronized();
	private object System.Collections.ICollection.get_SyncRoot();
	private void GrowTable(Tables<TT> tables);
	private static int GetBucket(int hashcode, int bucketCount);
	private static void GetBucketAndLockNo(int hashcode, out int bucketNo, out int lockNo, int bucketCount, int lockCount);
	private static int get_DefaultConcurrencyLevel();
	private void AcquireAllLocks(int locksAcquired);
	private void AcquireLocks(int fromInclusive, int toExclusive, int locksAcquired);
	private void ReleaseLocks(int fromInclusive, int toExclusive);
	private static void .cctor();

}
//NameSpace:
private sealed class ConcurrentDictionary`2.Tables
{
	// Fields
	internal readonly Node<TT>[] _buckets;
	internal readonly object[] _locks;
	internal int[] _countPerLock;

	// Methods
	internal void .ctor(Node<TT>[] buckets, object[] locks, int[] countPerLock);

}
//NameSpace:
private sealed class ConcurrentDictionary`2.Node
{
	// Fields
	internal readonly T _key;
	internal T _value;
	internal Node<TT> _next;
	internal readonly int _hashcode;

	// Methods
	internal void .ctor(T key, T value, int hashcode, Node<TT> next);

}
//NameSpace:
private sealed class ConcurrentDictionary`2.DictionaryEnumerator : IDictionaryEnumerator, IEnumerator
{
	// Fields
	private IEnumerator`1<KeyValuePair`2<TT>> _enumerator;

	// Properties
	public DictionaryEntry Entry { get; }
	public object Key { get; }
	public object Value { get; }
	public object Current { get; }

	// Methods
	internal void .ctor(ConcurrentDictionary`2<TT> dictionary);
	public DictionaryEntry get_Entry();
	public object get_Key();
	public object get_Value();
	public object get_Current();
	public bool MoveNext();

}
//NameSpace:
private sealed class ConcurrentDictionary`2.<GetEnumerator>d__32 : IEnumerator`1<KeyValuePair`2<TT>>, IDisposable, IEnumerator
{
	// Fields
	private int <>1__state;
	private KeyValuePair`2<TT> <>2__current;
	public ConcurrentDictionary`2<TT> <>4__this;
	private Node<TT>[] <buckets>5__1;
	private Node<TT> <current>5__2;
	private int <i>5__3;

	// Properties
	private KeyValuePair`2<TT> System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Current { get; }
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	public void .ctor(int <>1__state);
	private void System.IDisposable.Dispose();
	private bool MoveNext();
	private KeyValuePair`2<TT> System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_Current();
	private object System.Collections.IEnumerator.get_Current();

}
//NameSpace:System.Collections.Concurrent
internal sealed class IDictionaryDebugView`2
{
}
//NameSpace:System.Collections.Generic
public static class CollectionExtensions
{
	// Methods
	public static T GetValueOrDefault(IReadOnlyDictionary`2<TT> dictionary, T key);
	public static T GetValueOrDefault(IReadOnlyDictionary`2<TT> dictionary, T key, T defaultValue);

}
//NameSpace:System.Collections.Generic
public static class KeyValuePair
{
	// Methods
	internal static string PairToString(object key, object value);

}
//NameSpace:System.Collections.Generic
public struct KeyValuePair`2
{
	// Fields
	private T key;
	private T value;

	// Properties
	public T Key { get; }
	public T Value { get; }

	// Methods
	public void .ctor(T key, T value);
	public T get_Key();
	public T get_Value();
	public override string ToString();

}
//NameSpace:System.Collections.Generic
internal static class IntrospectiveSortUtilities
{
	// Methods
	internal static int FloorLog2(int n);
	internal static void ThrowOrIgnoreBadComparer(object comparer);

}
//NameSpace:System.Collections.Generic
internal class ArraySortHelper`1
{
	// Methods
	public static void Sort(T[] keys, int index, int length, IComparer`1<T> comparer);
	public static int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
	internal static void Sort(T[] keys, int index, int length, Comparison`1<T> comparer);
	internal static int InternalBinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
	private static void SwapIfGreater(T[] keys, Comparison`1<T> comparer, int a, int b);
	private static void Swap(T[] a, int i, int j);
	internal static void IntrospectiveSort(T[] keys, int left, int length, Comparison`1<T> comparer);
	private static void IntroSort(T[] keys, int lo, int hi, int depthLimit, Comparison`1<T> comparer);
	private static int PickPivotAndPartition(T[] keys, int lo, int hi, Comparison`1<T> comparer);
	private static void Heapsort(T[] keys, int lo, int hi, Comparison`1<T> comparer);
	private static void DownHeap(T[] keys, int i, int n, int lo, Comparison`1<T> comparer);
	private static void InsertionSort(T[] keys, int lo, int hi, Comparison`1<T> comparer);

}
//NameSpace:System.Collections.Generic
internal class ArraySortHelper`2
{
	// Fields
	private static ArraySortHelper`2<TT> s_defaultArraySortHelper;

	// Properties
	public static ArraySortHelper`2<TT> Default { get; }

	// Methods
	public static ArraySortHelper`2<TT> get_Default();
	private static ArraySortHelper`2<TT> CreateArraySortHelper();
	public void Sort(T[] keys, T[] values, int index, int length, IComparer`1<T> comparer);
	private static void SwapIfGreaterWithItems(T[] keys, T[] values, IComparer`1<T> comparer, int a, int b);
	private static void Swap(T[] keys, T[] values, int i, int j);
	internal static void IntrospectiveSort(T[] keys, T[] values, int left, int length, IComparer`1<T> comparer);
	private static void IntroSort(T[] keys, T[] values, int lo, int hi, int depthLimit, IComparer`1<T> comparer);
	private static int PickPivotAndPartition(T[] keys, T[] values, int lo, int hi, IComparer`1<T> comparer);
	private static void Heapsort(T[] keys, T[] values, int lo, int hi, IComparer`1<T> comparer);
	private static void DownHeap(T[] keys, T[] values, int i, int n, int lo, IComparer`1<T> comparer);
	private static void InsertionSort(T[] keys, T[] values, int lo, int hi, IComparer`1<T> comparer);
	public void .ctor();

}
//NameSpace:System.Collections.Generic
internal enum InsertionBehavior
{
	// Fields
	public byte value__;
	public const InsertionBehavior None;
	public const InsertionBehavior OverwriteExisting;
	public const InsertionBehavior ThrowOnExisting;

}
//NameSpace:System.Collections.Generic
public class Dictionary`2 : IDictionary`2<TT>, ICollection`1<KeyValuePair`2<TT>>, IEnumerable`1<KeyValuePair`2<TT>>, IEnumerable, IDictionary, ICollection, IReadOnlyDictionary`2<TT>, IReadOnlyCollection`1<KeyValuePair`2<TT>>, ISerializable, IDeserializationCallback
{
	// Fields
	private int[] buckets;
	private Entry<TT>[] entries;
	private int count;
	private int version;
	private int freeList;
	private int freeCount;
	private IEqualityComparer`1<T> comparer;
	private KeyCollection<TT> keys;
	private ValueCollection<TT> values;
	private object _syncRoot;
	private const string VersionName;
	private const string HashSizeName;
	private const string KeyValuePairsName;
	private const string ComparerName;

	// Properties
	public int Count { get; }
	public ValueCollection<TT> Values { get; }
	public T Item { get; set; }
	private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
	private bool System.Collections.ICollection.IsSynchronized { get; }
	private object System.Collections.ICollection.SyncRoot { get; }
	private object System.Collections.IDictionary.Item { get; set; }

	// Methods
	public void .ctor();
	public void .ctor(int capacity);
	public void .ctor(IEqualityComparer`1<T> comparer);
	public void .ctor(int capacity, IEqualityComparer`1<T> comparer);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public int get_Count();
	public ValueCollection<TT> get_Values();
	public T get_Item(T key);
	public void set_Item(T key, T value);
	public void Add(T key, T value);
	private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TT> keyValuePair);
	private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TT> keyValuePair);
	private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TT> keyValuePair);
	public void Clear();
	public bool ContainsKey(T key);
	public bool ContainsValue(T value);
	private void CopyTo(KeyValuePair`2<TT>[] array, int index);
	public Enumerator<TT> GetEnumerator();
	private IEnumerator`1<KeyValuePair`2<TT>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
	public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
	private int FindEntry(T key);
	private void Initialize(int capacity);
	private bool TryInsert(T key, T value, InsertionBehavior behavior);
	public virtual void OnDeserialization(object sender);
	private void Resize();
	private void Resize(int newSize, bool forceNewHashCodes);
	public bool Remove(T key);
	public bool TryGetValue(T key, out T value);
	private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
	private void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2<TT>[] array, int index);
	private void System.Collections.ICollection.CopyTo(Array array, int index);
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();
	private bool System.Collections.ICollection.get_IsSynchronized();
	private object System.Collections.ICollection.get_SyncRoot();
	private object System.Collections.IDictionary.get_Item(object key);
	private void System.Collections.IDictionary.set_Item(object key, object value);
	private static bool IsCompatibleKey(object key);
	private IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();

}
//NameSpace:
private struct Dictionary`2.Entry
{
	// Fields
	public int hashCode;
	public int next;
	public T key;
	public T value;

}
//NameSpace:
public struct Dictionary`2.Enumerator : IEnumerator`1<KeyValuePair`2<TT>>, IDisposable, IEnumerator, IDictionaryEnumerator
{
	// Fields
	private Dictionary`2<TT> dictionary;
	private int version;
	private int index;
	private KeyValuePair`2<TT> current;
	private int getEnumeratorRetType;

	// Properties
	public KeyValuePair`2<TT> Current { get; }
	private object System.Collections.IEnumerator.Current { get; }
	private DictionaryEntry System.Collections.IDictionaryEnumerator.Entry { get; }
	private object System.Collections.IDictionaryEnumerator.Key { get; }
	private object System.Collections.IDictionaryEnumerator.Value { get; }

	// Methods
	internal void .ctor(Dictionary`2<TT> dictionary, int getEnumeratorRetType);
	public bool MoveNext();
	public KeyValuePair`2<TT> get_Current();
	public void Dispose();
	private object System.Collections.IEnumerator.get_Current();
	private DictionaryEntry System.Collections.IDictionaryEnumerator.get_Entry();
	private object System.Collections.IDictionaryEnumerator.get_Key();
	private object System.Collections.IDictionaryEnumerator.get_Value();

}
//NameSpace:
public sealed class Dictionary`2.KeyCollection : ICollection`1<T>, IEnumerable`1<T>, IEnumerable, ICollection, IReadOnlyCollection`1<T>
{
	// Fields
	private Dictionary`2<TT> dictionary;

	// Properties
	public int Count { get; }
	private bool System.Collections.Generic.ICollection<TKey>.IsReadOnly { get; }
	private bool System.Collections.ICollection.IsSynchronized { get; }
	private object System.Collections.ICollection.SyncRoot { get; }

	// Methods
	public void CopyTo(T[] array, int index);
	public int get_Count();
	private bool System.Collections.Generic.ICollection<TKey>.get_IsReadOnly();
	private void System.Collections.Generic.ICollection<TKey>.Add(T item);
	private void System.Collections.Generic.ICollection<TKey>.Clear();
	private bool System.Collections.Generic.ICollection<TKey>.Contains(T item);
	private bool System.Collections.Generic.ICollection<TKey>.Remove(T item);
	private IEnumerator`1<T> System.Collections.Generic.IEnumerable<TKey>.GetEnumerator();
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();
	private void System.Collections.ICollection.CopyTo(Array array, int index);
	private bool System.Collections.ICollection.get_IsSynchronized();
	private object System.Collections.ICollection.get_SyncRoot();

}
//NameSpace:
public struct Dictionary`2.KeyCollection.Enumerator : IEnumerator`1<T>, IDisposable, IEnumerator
{
	// Fields
	private Dictionary`2<TT> dictionary;
	private int index;
	private int version;
	private T currentKey;

	// Properties
	public T Current { get; }
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	internal void .ctor(Dictionary`2<TT> dictionary);
	public void Dispose();
	public bool MoveNext();
	public T get_Current();
	private object System.Collections.IEnumerator.get_Current();

}
//NameSpace:
public sealed class Dictionary`2.ValueCollection : ICollection`1<T>, IEnumerable`1<T>, IEnumerable, ICollection, IReadOnlyCollection`1<T>
{
	// Fields
	private Dictionary`2<TT> dictionary;

	// Properties
	public int Count { get; }
	private bool System.Collections.Generic.ICollection<TValue>.IsReadOnly { get; }
	private bool System.Collections.ICollection.IsSynchronized { get; }
	private object System.Collections.ICollection.SyncRoot { get; }

	// Methods
	public void .ctor(Dictionary`2<TT> dictionary);
	public Enumerator<TT> GetEnumerator();
	public void CopyTo(T[] array, int index);
	public int get_Count();
	private bool System.Collections.Generic.ICollection<TValue>.get_IsReadOnly();
	private void System.Collections.Generic.ICollection<TValue>.Add(T item);
	private bool System.Collections.Generic.ICollection<TValue>.Remove(T item);
	private void System.Collections.Generic.ICollection<TValue>.Clear();
	private bool System.Collections.Generic.ICollection<TValue>.Contains(T item);
	private IEnumerator`1<T> System.Collections.Generic.IEnumerable<TValue>.GetEnumerator();
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();
	private void System.Collections.ICollection.CopyTo(Array array, int index);
	private bool System.Collections.ICollection.get_IsSynchronized();
	private object System.Collections.ICollection.get_SyncRoot();

}
//NameSpace:
public struct Dictionary`2.ValueCollection.Enumerator : IEnumerator`1<T>, IDisposable, IEnumerator
{
	// Fields
	private Dictionary`2<TT> dictionary;
	private int index;
	private int version;
	private T currentValue;

	// Properties
	public T Current { get; }
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	internal void .ctor(Dictionary`2<TT> dictionary);
	public void Dispose();
	public bool MoveNext();
	public T get_Current();
	private object System.Collections.IEnumerator.get_Current();

}
//NameSpace:System.Collections.Generic
internal class DictionaryHashHelpers
{
	// Fields
	private static readonly ConditionalWeakTable`2<objectSerializationInfo> <SerializationInfoTable>k__BackingField;

	// Properties
	internal static ConditionalWeakTable`2<objectSerializationInfo> SerializationInfoTable { get; }

	// Methods
	internal static ConditionalWeakTable`2<objectSerializationInfo> get_SerializationInfoTable();
	private static void .cctor();

}
//NameSpace:System.Collections.Generic
internal sealed class IDictionaryDebugView`2
{
}
//NameSpace:System.Collections.Generic
internal sealed class DictionaryKeyCollectionDebugView`2
{
}
//NameSpace:System.Collections.Generic
internal sealed class DictionaryValueCollectionDebugView`2
{
}
//NameSpace:System.Collections.Generic
internal sealed class NonRandomizedStringEqualityComparer : EqualityComparer`1<string>
{
	// Methods
	public sealed override bool Equals(string x, string y);
	public sealed override int GetHashCode(string obj);
	public void .ctor();

}
//NameSpace:System.Collections.Generic
internal sealed class ObjectEqualityComparer : IEqualityComparer
{
	// Fields
	internal static readonly ObjectEqualityComparer Default;

	// Methods
	private void .ctor();
	private int System.Collections.IEqualityComparer.GetHashCode(object obj);
	private bool System.Collections.IEqualityComparer.Equals(object x, object y);
	private static void .cctor();

}
//NameSpace:System.Collections.Generic
public abstract class Comparer`1 : IComparer, IComparer`1<T>
{
	// Fields
	private static Comparer`1<T> defaultComparer;

	// Properties
	public static Comparer`1<T> Default { get; }

	// Methods
	public static Comparer`1<T> get_Default();
	private static Comparer`1<T> CreateComparer();
	public abstract int Compare(T x, T y);
	private int System.Collections.IComparer.Compare(object x, object y);
	protected void .ctor();

}
//NameSpace:System.Collections.Generic
internal class GenericComparer`1 : Comparer`1<T>
{
	// Methods
	public override int Compare(T x, T y);
	public override bool Equals(object obj);
	public override int GetHashCode();
	public void .ctor();

}
//NameSpace:System.Collections.Generic
internal class NullableComparer`1 : Comparer`1<Nullable`1<T>>
{
	// Methods
	public override int Compare(Nullable`1<T> x, Nullable`1<T> y);
	public override bool Equals(object obj);
	public override int GetHashCode();
	public void .ctor();

}
//NameSpace:System.Collections.Generic
internal class ObjectComparer`1 : Comparer`1<T>
{
	// Methods
	public override int Compare(T x, T y);
	public override bool Equals(object obj);
	public override int GetHashCode();
	public void .ctor();

}
//NameSpace:System.Collections.Generic
internal sealed class Mscorlib_CollectionDebugView`1
{
}
//NameSpace:System.Collections.Generic
public abstract class EqualityComparer`1 : IEqualityComparer, IEqualityComparer`1<T>
{
	// Fields
	private static EqualityComparer`1<T> defaultComparer;

	// Properties
	public static EqualityComparer`1<T> Default { get; }

	// Methods
	public static EqualityComparer`1<T> get_Default();
	private static EqualityComparer`1<T> CreateComparer();
	public abstract bool Equals(T x, T y);
	public abstract int GetHashCode(T obj);
	internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
	internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
	private int System.Collections.IEqualityComparer.GetHashCode(object obj);
	private bool System.Collections.IEqualityComparer.Equals(object x, object y);
	protected void .ctor();

}
//NameSpace:System.Collections.Generic
internal class GenericEqualityComparer`1 : EqualityComparer`1<T>
{
	// Methods
	public override bool Equals(T x, T y);
	public override int GetHashCode(T obj);
	internal override int IndexOf(T[] array, T value, int startIndex, int count);
	internal override int LastIndexOf(T[] array, T value, int startIndex, int count);
	public override bool Equals(object obj);
	public override int GetHashCode();
	public void .ctor();

}
//NameSpace:System.Collections.Generic
internal class NullableEqualityComparer`1 : EqualityComparer`1<Nullable`1<T>>
{
	// Methods
	public override bool Equals(Nullable`1<T> x, Nullable`1<T> y);
	public override int GetHashCode(Nullable`1<T> obj);
	internal override int IndexOf(Nullable`1<T>[] array, Nullable`1<T> value, int startIndex, int count);
	internal override int LastIndexOf(Nullable`1<T>[] array, Nullable`1<T> value, int startIndex, int count);
	public override bool Equals(object obj);
	public override int GetHashCode();
	public void .ctor();

}
//NameSpace:System.Collections.Generic
internal class ObjectEqualityComparer`1 : EqualityComparer`1<T>
{
	// Methods
	public override bool Equals(T x, T y);
	public override int GetHashCode(T obj);
	internal override int IndexOf(T[] array, T value, int startIndex, int count);
	internal override int LastIndexOf(T[] array, T value, int startIndex, int count);
	public override bool Equals(object obj);
	public override int GetHashCode();
	public void .ctor();

}
//NameSpace:System.Collections.Generic
internal class ByteEqualityComparer : EqualityComparer`1<byte>
{
	// Methods
	public override bool Equals(byte x, byte y);
	public override int GetHashCode(byte b);
	internal override int IndexOf(byte[] array, byte value, int startIndex, int count);
	internal override int LastIndexOf(byte[] array, byte value, int startIndex, int count);
	public override bool Equals(object obj);
	public override int GetHashCode();
	public void .ctor();

}
//NameSpace:System.Collections.Generic
internal class EnumEqualityComparer`1 : EqualityComparer`1<T>, ISerializable
{
	// Methods
	public override bool Equals(T x, T y);
	public override int GetHashCode(T obj);
	public void .ctor();
	protected void .ctor(SerializationInfo information, StreamingContext context);
	public void GetObjectData(SerializationInfo info, StreamingContext context);
	public override bool Equals(object obj);
	public override int GetHashCode();

}
//NameSpace:System.Collections.Generic
internal sealed class SByteEnumEqualityComparer`1 : EnumEqualityComparer`1<T>, ISerializable
{
	// Methods
	public void .ctor();
	public void .ctor(SerializationInfo information, StreamingContext context);
	public override int GetHashCode(T obj);

}
//NameSpace:System.Collections.Generic
internal sealed class ShortEnumEqualityComparer`1 : EnumEqualityComparer`1<T>, ISerializable
{
	// Methods
	public void .ctor();
	public void .ctor(SerializationInfo information, StreamingContext context);
	public override int GetHashCode(T obj);

}
//NameSpace:System.Collections.Generic
internal sealed class LongEnumEqualityComparer`1 : EqualityComparer`1<T>, ISerializable
{
	// Methods
	public override bool Equals(T x, T y);
	public override int GetHashCode(T obj);
	public override bool Equals(object obj);
	public override int GetHashCode();
	public void .ctor();
	public void .ctor(SerializationInfo information, StreamingContext context);
	public void GetObjectData(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Collections.Generic
internal sealed class InternalStringComparer : EqualityComparer`1<string>
{
	// Methods
	public override int GetHashCode(string obj);
	public override bool Equals(string x, string y);
	internal override int IndexOf(string[] array, string value, int startIndex, int count);
	public void .ctor();

}
//NameSpace:System.Collections.Generic
public interface ICollection`1 : IEnumerable`1<T>, IEnumerable
{
	// Properties
	public abstract int Count { get; }
	public abstract bool IsReadOnly { get; }

	// Methods
	public abstract int get_Count();
	public abstract bool get_IsReadOnly();
	public abstract void Add(T item);
	public abstract void Clear();
	public abstract bool Contains(T item);
	public abstract void CopyTo(T[] array, int arrayIndex);
	public abstract bool Remove(T item);

}
//NameSpace:System.Collections.Generic
public interface IComparer`1
{
	// Methods
	public abstract int Compare(T x, T y);

}
//NameSpace:System.Collections.Generic
public interface IDictionary`2 : ICollection`1<KeyValuePair`2<TT>>, IEnumerable`1<KeyValuePair`2<TT>>, IEnumerable
{
	// Methods
	public abstract void Add(T key, T value);

}
//NameSpace:System.Collections.Generic
public interface IEnumerable`1 : IEnumerable
{
	// Methods
	public abstract IEnumerator`1<T> GetEnumerator();

}
//NameSpace:System.Collections.Generic
public interface IEnumerator`1 : IDisposable, IEnumerator
{
	// Properties
	public abstract T Current { get; }

	// Methods
	public abstract T get_Current();

}
//NameSpace:System.Collections.Generic
public interface IEqualityComparer`1
{
	// Methods
	public abstract bool Equals(T x, T y);
	public abstract int GetHashCode(T obj);

}
//NameSpace:System.Collections.Generic
public interface IList`1 : ICollection`1<T>, IEnumerable`1<T>, IEnumerable
{
	// Properties
	public abstract T Item { get; set; }

	// Methods
	public abstract T get_Item(int index);
	public abstract void set_Item(int index, T value);
	public abstract int IndexOf(T item);
	public abstract void Insert(int index, T item);
	public abstract void RemoveAt(int index);

}
//NameSpace:System.Collections.Generic
public interface IReadOnlyCollection`1 : IEnumerable`1<T>, IEnumerable
{
	// Properties
	public abstract int Count { get; }

	// Methods
	public abstract int get_Count();

}
//NameSpace:System.Collections.Generic
public interface IReadOnlyDictionary`2 : IReadOnlyCollection`1<KeyValuePair`2<TT>>, IEnumerable`1<KeyValuePair`2<TT>>, IEnumerable
{
	// Methods
	public abstract bool TryGetValue(T key, out T value);

}
//NameSpace:System.Collections.Generic
public interface IReadOnlyList`1 : IReadOnlyCollection`1<T>, IEnumerable`1<T>, IEnumerable
{
	// Properties
	public abstract T Item { get; }

	// Methods
	public abstract T get_Item(int index);

}
//NameSpace:System.Collections.Generic
public class KeyNotFoundException : SystemException, ISerializable
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:System.Collections.Generic
public class List`1 : IList`1<T>, ICollection`1<T>, IEnumerable`1<T>, IEnumerable, IList, ICollection, IReadOnlyList`1<T>, IReadOnlyCollection`1<T>
{
	// Fields
	private const int _defaultCapacity;
	private T[] _items;
	private int _size;
	private int _version;
	private object _syncRoot;
	private static readonly T[] _emptyArray;

	// Properties
	public int Capacity { get; set; }
	public int Count { get; }
	private bool System.Collections.IList.IsFixedSize { get; }
	private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
	private bool System.Collections.IList.IsReadOnly { get; }
	private bool System.Collections.ICollection.IsSynchronized { get; }
	private object System.Collections.ICollection.SyncRoot { get; }
	public T Item { get; set; }
	private object System.Collections.IList.Item { get; set; }

	// Methods
	public void .ctor();
	public void .ctor(int capacity);
	public void .ctor(IEnumerable`1<T> collection);
	public int get_Capacity();
	public void set_Capacity(int value);
	public int get_Count();
	private bool System.Collections.IList.get_IsFixedSize();
	private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
	private bool System.Collections.IList.get_IsReadOnly();
	private bool System.Collections.ICollection.get_IsSynchronized();
	private object System.Collections.ICollection.get_SyncRoot();
	public T get_Item(int index);
	public void set_Item(int index, T value);
	private static bool IsCompatibleObject(object value);
	private object System.Collections.IList.get_Item(int index);
	private void System.Collections.IList.set_Item(int index, object value);
	public void Add(T item);
	private int System.Collections.IList.Add(object item);
	public void AddRange(IEnumerable`1<T> collection);
	public ReadOnlyCollection`1<T> AsReadOnly();
	public void Clear();
	public bool Contains(T item);
	private bool System.Collections.IList.Contains(object item);
	public void CopyTo(T[] array);
	private void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
	public void CopyTo(int index, T[] array, int arrayIndex, int count);
	public void CopyTo(T[] array, int arrayIndex);
	private void EnsureCapacity(int min);
	public T Find(Predicate`1<T> match);
	public Enumerator<T> GetEnumerator();
	private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();
	public int IndexOf(T item);
	private int System.Collections.IList.IndexOf(object item);
	public void Insert(int index, T item);
	private void System.Collections.IList.Insert(int index, object item);
	public void InsertRange(int index, IEnumerable`1<T> collection);
	public bool Remove(T item);
	private void System.Collections.IList.Remove(object item);
	public int RemoveAll(Predicate`1<T> match);
	public void RemoveAt(int index);
	public void RemoveRange(int index, int count);
	public void Reverse();
	public void Reverse(int index, int count);
	public void Sort();
	public void Sort(IComparer`1<T> comparer);
	public void Sort(int index, int count, IComparer`1<T> comparer);
	public void Sort(Comparison`1<T> comparison);
	public T[] ToArray();
	public void TrimExcess();
	private static void .cctor();

}
//NameSpace:
public struct List`1.Enumerator : IEnumerator`1<T>, IDisposable, IEnumerator
{
	// Fields
	private List`1<T> list;
	private int index;
	private int version;
	private T current;

	// Properties
	public T Current { get; }
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	internal void .ctor(List`1<T> list);
	public void Dispose();
	public bool MoveNext();
	private bool MoveNextRare();
	public T get_Current();
	private object System.Collections.IEnumerator.get_Current();

}
//NameSpace:
internal sealed class <PrivateImplementationDetails>
{
	// Fields
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=256 0392525BCB01691D1F319D89F2C12BF93A478467;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 0588059ACBD52F7EA2835882F977A9CF72EB9775;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=84 0A1ADB22C1D3E1F4B2448EE3F27DF9DE63329C4C;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=240 121EC59E23F7559B28D338D562528F6299C2DE22;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=3 12D04472A8285260EA12FD3813CDFA9F2D2B548C;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=3 13A35EF1A549297C70E2AD46045BBD2ECA17852D;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=24 1730F09044E91DB8371B849EFF5E6D17BDE4AED0;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=3 1A84029C80CB5518379F199F53FF08A7B764F8FD;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=2048 1E41C4CD0767AEA21C00DEABA2EA9407F1E6CEA5;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=16 1FE6CE411858B3D864679DE2139FB081F08BFACD;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=3 235D99572263B22ADFEE10FDA0C25E12F4D94FFC;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=40 25420D0055076FA8D3E4DD96BC53AE24DE6E619F;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=1208 25CF935D2AE9EDF05DD75BCD47FF84D9255D6F6E;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=42 29C1A61550F0E3260E1953D4FAD71C256218EF40;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=12 2B33BEC8C30DFDC49DAFE20D3BDE19487850D717;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=36 2BA840FF6020B8FF623DBCB7188248CF853FAF4F;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 2C840AFA48C27B9C05593E468C1232CA1CC74AFD;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=16 2D1DA5BB407F0C11C3B5116196C0C6374D932B20;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=14 2D3CF0F15AC2DDEC2956EA1B7BBE43FB8B923130;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 2F71D2DA12F3CD0A6A112F5A5A75B4FDC6FE8547;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=64 320B018758ECE3752FFEDBAEB1A6DB67C80B9359;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 34476C29F6F81C989CFCA42F7C06E84C66236834;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=2382 35EED060772F2748D13B745DAEC8CD7BD3B87604;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=38 375F9AE9769A3D1DA789E9ACFE81F3A1BB14F0D3;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=1450 379C06C9E702D31469C29033F0DD63931EB349F5;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=10 399BD13E240F33F808CA7940293D6EC4E6FD5A00;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 39C9CE73C7B0619D409EF28344F687C1B5C130FE;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=320 3C53AFB51FEC23491684C7BEDBC6D4E0F409F851;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=3 3E3442C7396F3F2BB4C7348F4A2074C7DC677D68;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=12 3E823444D2DFECF0F90B436B88F02A533CB376F1;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 3FE6C283BCF384FD2C8789880DFF59664E2AB4A1;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=1665 40981BAA39513E58B28DCF0103CC04DE2A0A0444;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=40 40E7C49413D261F3F38AD3A870C0AC69C8BDA048;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 421EC7E82F2967DF6CA8C3605514DC6F29EE5845;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=256 433175D38B13FFE177FDD661A309F1B528B3F6E2;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 4858DB4AA76D3933F1CA9E6712D4FDB16903F628;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=48 4E3B533C39447AAEB59A8E48FABD7E15B5B5D195;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=40 4F7A8890F332B22B8DE0BD29D36FA7364748D76A;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 536422B321459B242ADED7240B7447E904E083E3;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=1080 5382CEF491F422BFE0D6FC46EFAFF9EF9D4C89F3;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=10 56DFA5053B3131883637F53219E7D88CCEF35949;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=3 57218C316B6921E2CD61027A2387EDC31A2D9471;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=40 57F320D62696EC99727E0FE2045A05F1289CC0C6;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=212 594A33A00BC4F785DFD43E3C6C44FBA1242CCAF3;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=36 5BBDF8058D4235C33F2E8DCF76004031B6187A2F;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=288 5BCD21C341BE6DDF8FFFAE1A23ABA24DCBB612BF;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 5BFE2819B4778217C56416C7585FF0E56EBACD89;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=128 609C0E8D8DA86A09D6013D301C86BA8782C16B8C;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=48 62BAB0F245E66C3EB982CF5A7015F0A7C3382283;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=2048 646036A65DECCD6835C914A46E6E44B729433B60;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=40 65E32B4E150FD8D24B93B0D42A17F1DAD146162B;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=52 6770974FEF1E98B9C1864370E2B5B786EB0EA39E;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 67EEAD805D708D9AA4E14BF747E44CED801744F3;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=120 6C71197D228427B2864C69B357FEF73D8C9D59DF;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=9 6D49C9D487D7AD3491ECE08732D68A593CC2038D;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=2048 6D797C11E1D4FB68B6570CF2A92B792433527065;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=3132 6E5DC824F803F8565AF31B42199DAE39FE7F4EA9;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=76 6FC754859E4EC74E447048364B216D825C6F8FE7;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=40 704939CD172085D1295FCE3F1D92431D685D7AA2;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=24 7088AAE49F0627B72729078DE6E3182DDCF8ED99;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 7341C933A70EAE383CC50C4B945ADB8E08F06737;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=3 736D39815215889F11249D9958F6ED12D37B9F57;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=40 7FE820C9CF0F0B90445A71F1D262D22E4F0C4C68;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=21252 811A927B7DADD378BE60BBDE794B9277AA9B50EC;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=36 81917F1E21F3C22B9F916994547A614FB03E968E;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=40 823566DA642D6EA356E15585921F2A4CA23D6760;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=12 82C2A59850B2E85BCE1A45A479537A384DF6098D;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=44 82C383F8E6E4D3D87AEBB986A5D0077E8AD157C4;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=3 86F4F563FA2C61798AE6238D789139739428463A;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=40 871B9CF85DB352BAADF12BAE8F19857683E385AC;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=16 89A040451C8CC5C8FB268BE44BDD74964C104155;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=40 8CAA092E783257106251246FF5C97F88D28517A6;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=2100 8D231DD55FE1AD7631BBD0905A17D5EB616C2154;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=40 8E10AC2F34545DFBBF3FCBC06055D797A8C99991;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=640 90A0542282A011472F94E97CEAE59F8B3B1A3291;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=12 93A63E90605400F34B49F0EB3361D23C89164BDA;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 94841DD2F330CCB1089BF413E4FA9B04505152E2;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=12 95264589E48F94B7857CFF398FB72A537E13EEE2;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 95C48758CAE1715783472FB073AB158AB8A0AB2A;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 973417296623D8DC6961B09664E54039E44CA5D8;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=3 97FB30C84FF4A41CD4625B44B2940BFC8DB43003;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=64 9A9C3962CD4753376E3507C8CB5FD8FCC4B4EDB5;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=3 9BB00D1FCCBAF03165447FC8028E7CA07CA9FE88;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=40 A0074C15377C0C870B055927403EA9FA7A349D12;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=130 A1319B706116AB2C6D44483F60A7D0ACEA543396;
	internal static readonly long A13AA52274D951A18029131A8DDECF76B569A15D;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=3 A323DB0813C4D072957BA6FDA79D9776674CD06B;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=212 A5444763673307F6828C748D4B9708CFC02B0959;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 A6732F8E7FC23766AB329B492D6BF82E3B33233F;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=174 A705A106D95282BD15E13EEA6B0AF583FF786D83;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=1018 A8A491E4CED49AE0027560476C10D933CE70C8DF;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 AC791C4F39504D1184B73478943D0636258DA7B1;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=52 AFCD4E1211233E99373A3367B23105A3D624B1F2;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=40 B472ED77CB3B2A66D49D179F1EE2081B70A6AB61;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=16 B4FBD02AAB5B16E0F4BD858DA5D9E348F3CE501D;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=256 B53A2C6DF21FC88B17AEFC40EB895B8D63210CDF;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=998 B881DA88BE0B68D8A6B6B6893822586B8B2CFC45;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=162 B8864ACB9DD69E3D42151513C840AAE270BF21C8;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=360 B8F87834C3597B2EEF22BA6D3A392CC925636401;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 B9B670F134A59FB1107AF01A9FE8F8E3980B3093;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=20 BE1BDEC0AA74B4DCB079943E70528096CCA985F8;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 BEBC9ECC660A13EFC359BA3383411F698CFF25DB;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=40 BEE1CFE5DFAA408E14CE4AF4DCD824FA2E42DCB7;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=3 BF477463CE2F5EF38FC4C644BBBF4DF109E7670A;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=6 BF5EB60806ECB74EE484105DD9D6F463BF994867;
	internal static readonly long C1A1100642BA9685B30A84D97348484E14AA1865;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=16 C6F364A0AD934EFED8909446C215752E565D77C1;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=174 CE5835130F5277F63D716FC9115526B0AC68FFAD;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=6 CE93C35B755802BC4B3D180716B048FC61701EF7;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=64 CF0B42666EF5E37EDEA0AB8E173E42C196D03814;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=256 D002CBBE1FF33721AF7C4D1D3ECAD1B7DB5258B7;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=32 D117188BE8D4609C0D531C51B0BB911A4219DEBE;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=32 D28E8ABDBD777A482CE0EE5C24814ACAE52AABFE;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=256 D2C5BAE967587C6F3D9F2C4551911E0575A1101F;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=44 D78D08081C7A5AD6FBA7A8DC86BCD6D7A577C636;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=76 DA19DB47B583EFCF7825D2E39D661D2354F28219;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=56 DC2B830D8CD59AD6A4E4332D21CA0DCA2821AD82;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=52 DD3AEFEADB1CD615F3017763F1568179FEE640B0;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=36 E1827270A5FE1C85F5352A66FD87BA747213D006;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=40 E45BAB43F7D5D038672B3E3431F92E34A7AF2571;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=64 E75835D001C843F156FBA01B001DFE1B8029AC17;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=52 E92B39D8233061927D9ACDE54665E68E7535635A;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=12 EA9506959484C55CFE0C139C624DF6060E285866;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=262 EB5E9A80A40096AB74D2E226650C7258D7BC5E9D;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=64 EBF68F411848D603D059DFDEA2321C5A5EA78044;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=10 EC5BB4F59D4B9B2E9ECD3904D44A8275F23AFB11;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=3 EC83FB16C20052BEE2B4025159BC2ED45C9C70C3;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 EC89C317EA2BF49A70EFF5E89C691E34733D7C37;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=40 F06E829E62F3AFBC045D064E10A4F5DF7C969612;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=11614 F073AA332018FDA0D572E99448FFF1D6422BD520;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=120 F34B0E10653402E8F788F8BC3F7CD7090928A429;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72 F37E34BEADB04F34FCC31078A59F49856CA83D5B;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=94 F512A9ABF88066AAEB92684F95CC05D8101B462B;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=12 F8FAABB821300AA500C2CEC6091B3782A7FB44A4;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=2350 FCBD2781A933F0828ED4AAF88FD8B08D76DDD49B;

	// Methods
	internal static uint ComputeStringHash(string s);

}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=3
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=6
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=9
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=10
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=12
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=14
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=16
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=20
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=24
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=32
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=36
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=38
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=40
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=42
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=44
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=48
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=52
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=56
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=64
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=72
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=76
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=84
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=94
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=120
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=128
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=130
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=162
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=174
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=212
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=240
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=256
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=262
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=288
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=320
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=360
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=640
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=998
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=1018
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=1080
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=1208
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=1450
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=1665
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=2048
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=2100
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=2350
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=2382
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=3132
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=11614
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=21252
{
}
//NameSpace:System.Runtime.InteropServices
public interface _AssemblyBuilder
{
}
//NameSpace:System.Runtime.InteropServices
public interface _ConstructorBuilder
{
}
//NameSpace:System.Runtime.InteropServices
public interface _CustomAttributeBuilder
{
}
//NameSpace:System.Runtime.InteropServices
public interface _EnumBuilder
{
}
//NameSpace:System.Runtime.InteropServices
public interface _EventBuilder
{
}
//NameSpace:System.Reflection.Emit
public sealed class UnmanagedMarshal
{
	// Methods
	internal void .ctor();

}
//NameSpace:System.Runtime.InteropServices
public interface _FieldBuilder
{
}
//NameSpace:System.Runtime.InteropServices
public interface _ILGenerator
{
}
//NameSpace:System.Runtime.InteropServices
public interface _LocalBuilder
{
}
//NameSpace:System.Runtime.InteropServices
public interface _MethodBuilder
{
}
//NameSpace:System.Runtime.InteropServices
public interface _ModuleBuilder
{
}
//NameSpace:System.Runtime.InteropServices
public interface _ParameterBuilder
{
}
//NameSpace:System.Runtime.InteropServices
public interface _PropertyBuilder
{
}
//NameSpace:System.Runtime.InteropServices
public interface _TypeBuilder
{
}
//NameSpace:System.Reflection.Emit
public sealed class DynamicMethod : MethodInfo
{
	// Properties
	public override MethodAttributes Attributes { get; }
	public override Type DeclaringType { get; }
	public override RuntimeMethodHandle MethodHandle { get; }
	public override string Name { get; }
	public override Type ReflectedType { get; }

	// Methods
	public override MethodAttributes get_Attributes();
	public override Type get_DeclaringType();
	public override RuntimeMethodHandle get_MethodHandle();
	public override string get_Name();
	public override Type get_ReflectedType();
	public override object[] GetCustomAttributes(bool inherit);
	public override object[] GetCustomAttributes(Type attributeType, bool inherit);
	public override MethodImplAttributes GetMethodImplementationFlags();
	public override ParameterInfo[] GetParameters();
	public override object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);
	public override bool IsDefined(Type attributeType, bool inherit);

}
//NameSpace:Unity
internal sealed class ThrowStub : ObjectDisposedException
{
	// Methods
	public static void ThrowNotSupportedException();

}
//NameSpace:System
internal class __Il2CppComObject
{
	// Methods
	protected override void Finalize();

}
//NameSpace:System
internal sealed class __Il2CppComDelegate : __Il2CppComObject
{
	// Methods
	protected override void Finalize();

}
//NameSpace:
internal class <Module>
{
}
//NameSpace:System.Xml
public enum ReadState
{
	// Fields
	public int value__;
	public const ReadState Initial;
	public const ReadState Interactive;
	public const ReadState Error;
	public const ReadState EndOfFile;
	public const ReadState Closed;

}
//NameSpace:System.Xml
public abstract class XmlReader : IDisposable
{
	// Fields
	private static uint IsTextualNodeBitmap;
	private static uint CanReadContentAsBitmap;
	private static uint HasValueBitmap;

	// Properties
	public abstract ReadState ReadState { get; }

	// Methods
	public virtual void Close();
	public abstract ReadState get_ReadState();
	public void Dispose();
	protected virtual void Dispose(bool disposing);
	private static void .cctor();

}
//NameSpace:System.Xml
internal sealed class XmlChildEnumerator : IEnumerator
{
	// Fields
	internal XmlNode container;
	internal XmlNode child;
	internal bool isFirst;

	// Properties
	private object System.Collections.IEnumerator.Current { get; }
	internal XmlNode Current { get; }

	// Methods
	internal void .ctor(XmlNode container);
	private bool System.Collections.IEnumerator.MoveNext();
	internal bool MoveNext();
	private object System.Collections.IEnumerator.get_Current();
	internal XmlNode get_Current();

}
//NameSpace:System.Xml
public abstract class XmlLinkedNode : XmlNode
{
	// Fields
	internal XmlLinkedNode next;

	// Properties
	public override XmlNode NextSibling { get; }

	// Methods
	public override XmlNode get_NextSibling();

}
//NameSpace:System.Xml
public abstract class XmlNode : ICloneable, IEnumerable, IXPathNavigable
{
	// Fields
	internal XmlNode parentNode;

	// Properties
	public abstract XmlNodeType NodeType { get; }
	public virtual XmlNode ParentNode { get; }
	public virtual XmlNode NextSibling { get; }
	public virtual XmlNode FirstChild { get; }
	internal virtual XmlLinkedNode LastNode { get; }

	// Methods
	public abstract XmlNodeType get_NodeType();
	public virtual XmlNode get_ParentNode();
	public virtual XmlNode get_NextSibling();
	public virtual XmlNode get_FirstChild();
	internal virtual XmlLinkedNode get_LastNode();
	public abstract XmlNode CloneNode(bool deep);
	private object System.ICloneable.Clone();
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();

}
//NameSpace:System.Xml
public enum XmlNodeType
{
	// Fields
	public int value__;
	public const XmlNodeType None;
	public const XmlNodeType Element;
	public const XmlNodeType Attribute;
	public const XmlNodeType Text;
	public const XmlNodeType CDATA;
	public const XmlNodeType EntityReference;
	public const XmlNodeType Entity;
	public const XmlNodeType ProcessingInstruction;
	public const XmlNodeType Comment;
	public const XmlNodeType Document;
	public const XmlNodeType DocumentType;
	public const XmlNodeType DocumentFragment;
	public const XmlNodeType Notation;
	public const XmlNodeType Whitespace;
	public const XmlNodeType SignificantWhitespace;
	public const XmlNodeType EndElement;
	public const XmlNodeType EndEntity;
	public const XmlNodeType XmlDeclaration;

}
//NameSpace:System.Xml
internal static class Res
{
	// Methods
	public static string GetString(string name);

}
//NameSpace:System.Xml.XPath
public interface IXPathNavigable
{
}
//NameSpace:
internal class <Module>
{
}
//NameSpace:System.Configuration
public abstract class ConfigurationSection : ConfigurationElement
{
	// Methods
	protected internal virtual void DeserializeSection(XmlReader reader);
	protected internal override bool IsModified();
	protected internal override void ResetModified();
	protected internal virtual string SerializeSection(ConfigurationElement parentElement, string name, ConfigurationSaveMode saveMode);

}
//NameSpace:System.Configuration
public abstract class ConfigurationElement
{
	// Properties
	protected internal virtual ConfigurationPropertyCollection Properties { get; }

	// Methods
	protected internal virtual ConfigurationPropertyCollection get_Properties();
	protected internal virtual bool IsModified();
	protected internal virtual void Reset(ConfigurationElement parentElement);
	protected internal virtual void ResetModified();

}
//NameSpace:System.Configuration
public abstract class ConfigurationElementCollection : ConfigurationElement, ICollection, IEnumerable
{
	// Properties
	public int Count { get; }
	public bool IsSynchronized { get; }
	public object SyncRoot { get; }

	// Methods
	public int get_Count();
	public bool get_IsSynchronized();
	public object get_SyncRoot();
	public IEnumerator GetEnumerator();
	protected internal override bool IsModified();
	protected internal override void Reset(ConfigurationElement parentElement);
	protected internal override void ResetModified();
	private void System.Collections.ICollection.CopyTo(Array arr, int index);

}
//NameSpace:System.Configuration
public enum ConfigurationSaveMode
{
	// Fields
	public int value__;
	public const ConfigurationSaveMode Full;
	public const ConfigurationSaveMode Minimal;
	public const ConfigurationSaveMode Modified;

}
//NameSpace:System.Configuration
public class ConfigurationPropertyCollection : ICollection, IEnumerable
{
	// Properties
	public int Count { get; }
	public bool IsSynchronized { get; }
	public object SyncRoot { get; }

	// Methods
	public int get_Count();
	public bool get_IsSynchronized();
	public object get_SyncRoot();
	public IEnumerator GetEnumerator();
	private void System.Collections.ICollection.CopyTo(Array array, int index);

}
//NameSpace:System.Configuration
public sealed class ConfigurationCollectionAttribute : Attribute
{
	// Methods
	public void .ctor(Type itemType);

}
//NameSpace:System.Configuration
public class ConfigurationSectionGroup
{
}
//NameSpace:System.Configuration
public sealed class IgnoreSection : ConfigurationSection
{
	// Properties
	protected internal override ConfigurationPropertyCollection Properties { get; }

	// Methods
	public void .ctor();
	protected internal override ConfigurationPropertyCollection get_Properties();
	protected internal override void DeserializeSection(XmlReader xmlReader);
	protected internal override bool IsModified();
	protected internal override void Reset(ConfigurationElement parentSection);
	protected internal override void ResetModified();
	protected internal override string SerializeSection(ConfigurationElement parentSection, string name, ConfigurationSaveMode saveMode);

}
//NameSpace:Unity
internal sealed class ThrowStub : ObjectDisposedException
{
	// Methods
	public static void ThrowNotSupportedException();

}
//NameSpace:
internal class <Module>
{
}
//NameSpace:Mono.Security
public class ASN1
{
	// Fields
	private byte m_nTag;
	private byte[] m_aValue;
	private ArrayList elist;

	// Properties
	public int Count { get; }
	public byte Tag { get; }
	public byte[] Value { get; set; }
	public ASN1 Item { get; }

	// Methods
	public void .ctor(byte tag);
	public void .ctor(byte tag, byte[] data);
	public void .ctor(byte[] data);
	public int get_Count();
	public byte get_Tag();
	public byte[] get_Value();
	public void set_Value(byte[] value);
	public ASN1 Add(ASN1 asn1);
	public virtual byte[] GetBytes();
	protected void Decode(byte[] asn1, int anPos, int anLength);
	protected void DecodeTLV(byte[] asn1, int pos, out byte tag, out int length, out byte[] content);
	public ASN1 get_Item(int index);
	public override string ToString();

}
//NameSpace:Mono.Security
public static class ASN1Convert
{
	// Methods
	public static ASN1 FromInt32(int value);
	public static int ToInt32(ASN1 asn1);
	public static string ToOid(ASN1 asn1);

}
//NameSpace:Mono.Security
internal sealed class BitConverterLE
{
	// Methods
	private static byte[] GetUIntBytes(byte* bytes);
	internal static byte[] GetBytes(int value);

}
//NameSpace:Mono.Security.Interface
public interface ICertificateValidator
{
	// Properties
	public abstract MonoTlsSettings Settings { get; }

	// Methods
	public abstract MonoTlsSettings get_Settings();

}
//NameSpace:Mono.Security.Interface
internal interface ICertificateValidator2 : ICertificateValidator
{
}
//NameSpace:Mono.Security.Interface
public interface IMonoSslStream : IDisposable
{
	// Properties
	public abstract bool IsAuthenticated { get; }
	public abstract bool CanRead { get; }
	public abstract bool CanWrite { get; }
	public abstract long Length { get; }
	public abstract long Position { get; }

	// Methods
	public abstract int Read(byte[] buffer, int offset, int count);
	public abstract void Write(byte[] buffer, int offset, int count);
	public abstract IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
	public abstract int EndRead(IAsyncResult asyncResult);
	public abstract IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
	public abstract void EndWrite(IAsyncResult asyncResult);
	public abstract bool get_IsAuthenticated();
	public abstract bool get_CanRead();
	public abstract bool get_CanWrite();
	public abstract long get_Length();
	public abstract long get_Position();

}
//NameSpace:Mono.Security.Interface
public enum MonoSslPolicyErrors
{
	// Fields
	public int value__;
	public const MonoSslPolicyErrors None;
	public const MonoSslPolicyErrors RemoteCertificateNotAvailable;
	public const MonoSslPolicyErrors RemoteCertificateNameMismatch;
	public const MonoSslPolicyErrors RemoteCertificateChainErrors;

}
//NameSpace:Mono.Security.Interface
public abstract class MonoTlsProvider
{
	// Properties
	public abstract Guid ID { get; }
	public abstract string Name { get; }
	public abstract bool SupportsSslStream { get; }
	public abstract bool SupportsConnectionInfo { get; }
	public abstract bool SupportsMonoExtensions { get; }
	public abstract SslProtocols SupportedProtocols { get; }
	internal abstract bool SupportsCleanShutdown { get; }

	// Methods
	internal void .ctor();
	public abstract Guid get_ID();
	public abstract string get_Name();
	public abstract bool get_SupportsSslStream();
	public abstract bool get_SupportsConnectionInfo();
	public abstract bool get_SupportsMonoExtensions();
	public abstract SslProtocols get_SupportedProtocols();
	public abstract IMonoSslStream CreateSslStream(Stream innerStream, bool leaveInnerStreamOpen, optional MonoTlsSettings settings);
	internal abstract IMonoSslStream CreateSslStreamInternal(SslStream sslStream, Stream innerStream, bool leaveInnerStreamOpen, MonoTlsSettings settings);
	internal abstract bool ValidateCertificate(ICertificateValidator2 validator, string targetHost, bool serverMode, X509CertificateCollection certificates, bool wantsChain, X509Chain chain, MonoSslPolicyErrors errors, int status11);
	internal abstract bool get_SupportsCleanShutdown();

}
//NameSpace:Mono.Security.Interface
public sealed class MonoTlsSettings
{
	// Fields
	private X509CertificateCollection <TrustAnchors>k__BackingField;

	// Properties
	public X509CertificateCollection TrustAnchors { get; }

	// Methods
	public X509CertificateCollection get_TrustAnchors();

}
//NameSpace:Mono.Security.Cryptography
public sealed class CryptoConvert
{
	// Methods
	public static string ToHex(byte[] input);

}
//NameSpace:
internal class <Module>
{
}
//NameSpace:
internal static class SR
{
	// Methods
	internal static string GetString(string name, object[] args);
	internal static string GetString(CultureInfo culture, string name, object[] args);
	internal static string GetString(string name);

}
//NameSpace:Mono.Unity
internal static class CertHelper
{
	// Methods
	public static void AddCertificatesToNativeChain(UnityTls.unitytls_x509list* nativeCertificateChain, X509CertificateCollection certificates, UnityTls.unitytls_errorstate* errorState);
	public static void AddCertificateToNativeChain(UnityTls.unitytls_x509list* nativeCertificateChain, X509Certificate certificate, UnityTls.unitytls_errorstate* errorState);

}
//NameSpace:Mono.Unity
internal static class UnityTls
{
	// Fields
	private static UnityTls.unitytls_interface_struct marshalledInterface;

	// Properties
	public static UnityTls.unitytls_interface_struct NativeInterface { get; }

	// Methods
	private static IntPtr GetUnityTlsInterface();
	public static UnityTls.unitytls_interface_struct get_NativeInterface();
	private static void .cctor();

}
//NameSpace:
public enum UnityTls.unitytls_error_code
{
	// Fields
	public uint value__;
	public const UnityTls.unitytls_error_code UNITYTLS_SUCCESS;
	public const UnityTls.unitytls_error_code UNITYTLS_INVALID_ARGUMENT;
	public const UnityTls.unitytls_error_code UNITYTLS_INVALID_FORMAT;
	public const UnityTls.unitytls_error_code UNITYTLS_INVALID_PASSWORD;
	public const UnityTls.unitytls_error_code UNITYTLS_INVALID_STATE;
	public const UnityTls.unitytls_error_code UNITYTLS_BUFFER_OVERFLOW;
	public const UnityTls.unitytls_error_code UNITYTLS_OUT_OF_MEMORY;
	public const UnityTls.unitytls_error_code UNITYTLS_INTERNAL_ERROR;
	public const UnityTls.unitytls_error_code UNITYTLS_NOT_SUPPORTED;
	public const UnityTls.unitytls_error_code UNITYTLS_ENTROPY_SOURCE_FAILED;
	public const UnityTls.unitytls_error_code UNITYTLS_STREAM_CLOSED;
	public const UnityTls.unitytls_error_code UNITYTLS_USER_CUSTOM_ERROR_START;
	public const UnityTls.unitytls_error_code UNITYTLS_USER_WOULD_BLOCK;
	public const UnityTls.unitytls_error_code UNITYTLS_USER_READ_FAILED;
	public const UnityTls.unitytls_error_code UNITYTLS_USER_WRITE_FAILED;
	public const UnityTls.unitytls_error_code UNITYTLS_USER_UNKNOWN_ERROR;
	public const UnityTls.unitytls_error_code UNITYTLS_USER_CUSTOM_ERROR_END;

}
//NameSpace:
public struct UnityTls.unitytls_errorstate
{
	// Fields
	private uint magic;
	public UnityTls.unitytls_error_code code;
	private ulong reserved;

}
//NameSpace:
public struct UnityTls.unitytls_key
{
}
//NameSpace:
public struct UnityTls.unitytls_key_ref
{
	// Fields
	public ulong handle;

}
//NameSpace:
public struct UnityTls.unitytls_x509_ref
{
	// Fields
	public ulong handle;

}
//NameSpace:
public struct UnityTls.unitytls_x509list
{
}
//NameSpace:
public struct UnityTls.unitytls_x509list_ref
{
	// Fields
	public ulong handle;

}
//NameSpace:
public enum UnityTls.unitytls_x509verify_result
{
	// Fields
	public uint value__;
	public const UnityTls.unitytls_x509verify_result UNITYTLS_X509VERIFY_SUCCESS;
	public const UnityTls.unitytls_x509verify_result UNITYTLS_X509VERIFY_NOT_DONE;
	public const UnityTls.unitytls_x509verify_result UNITYTLS_X509VERIFY_FATAL_ERROR;
	public const UnityTls.unitytls_x509verify_result UNITYTLS_X509VERIFY_FLAG_EXPIRED;
	public const UnityTls.unitytls_x509verify_result UNITYTLS_X509VERIFY_FLAG_REVOKED;
	public const UnityTls.unitytls_x509verify_result UNITYTLS_X509VERIFY_FLAG_CN_MISMATCH;
	public const UnityTls.unitytls_x509verify_result UNITYTLS_X509VERIFY_FLAG_NOT_TRUSTED;
	public const UnityTls.unitytls_x509verify_result UNITYTLS_X509VERIFY_FLAG_USER_ERROR1;
	public const UnityTls.unitytls_x509verify_result UNITYTLS_X509VERIFY_FLAG_USER_ERROR2;
	public const UnityTls.unitytls_x509verify_result UNITYTLS_X509VERIFY_FLAG_USER_ERROR3;
	public const UnityTls.unitytls_x509verify_result UNITYTLS_X509VERIFY_FLAG_USER_ERROR4;
	public const UnityTls.unitytls_x509verify_result UNITYTLS_X509VERIFY_FLAG_USER_ERROR5;
	public const UnityTls.unitytls_x509verify_result UNITYTLS_X509VERIFY_FLAG_USER_ERROR6;
	public const UnityTls.unitytls_x509verify_result UNITYTLS_X509VERIFY_FLAG_USER_ERROR7;
	public const UnityTls.unitytls_x509verify_result UNITYTLS_X509VERIFY_FLAG_USER_ERROR8;
	public const UnityTls.unitytls_x509verify_result UNITYTLS_X509VERIFY_FLAG_UNKNOWN_ERROR;

}
//NameSpace:
public sealed class UnityTls.unitytls_x509verify_callback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual UnityTls.unitytls_x509verify_result Invoke(void* userData, UnityTls.unitytls_x509_ref cert, UnityTls.unitytls_x509verify_result result, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(void* userData, UnityTls.unitytls_x509_ref cert, UnityTls.unitytls_x509verify_result result, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual UnityTls.unitytls_x509verify_result EndInvoke(IAsyncResult result);

}
//NameSpace:
public struct UnityTls.unitytls_tlsctx
{
}
//NameSpace:
public struct UnityTls.unitytls_x509name
{
}
//NameSpace:
public enum UnityTls.unitytls_ciphersuite
{
	// Fields
	public uint value__;
	public const UnityTls.unitytls_ciphersuite UNITYTLS_CIPHERSUITE_INVALID;

}
//NameSpace:
public enum UnityTls.unitytls_protocol
{
	// Fields
	public uint value__;
	public const UnityTls.unitytls_protocol UNITYTLS_PROTOCOL_TLS_1_0;
	public const UnityTls.unitytls_protocol UNITYTLS_PROTOCOL_TLS_1_1;
	public const UnityTls.unitytls_protocol UNITYTLS_PROTOCOL_TLS_1_2;
	public const UnityTls.unitytls_protocol UNITYTLS_PROTOCOL_INVALID;

}
//NameSpace:
public struct UnityTls.unitytls_tlsctx_protocolrange
{
	// Fields
	public UnityTls.unitytls_protocol min;
	public UnityTls.unitytls_protocol max;

}
//NameSpace:
public sealed class UnityTls.unitytls_tlsctx_write_callback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual IntPtr Invoke(void* userData, byte* data, IntPtr bufferLen, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(void* userData, byte* data, IntPtr bufferLen, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual IntPtr EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_tlsctx_read_callback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual IntPtr Invoke(void* userData, byte* buffer, IntPtr bufferLen, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(void* userData, byte* buffer, IntPtr bufferLen, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual IntPtr EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_tlsctx_trace_callback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(void* userData, UnityTls.unitytls_tlsctx* ctx, byte* traceMessage, IntPtr traceMessageLen);
	public virtual IAsyncResult BeginInvoke(void* userData, UnityTls.unitytls_tlsctx* ctx, byte* traceMessage, IntPtr traceMessageLen, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_tlsctx_certificate_callback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(void* userData, UnityTls.unitytls_tlsctx* ctx, byte* cn, IntPtr cnLen, UnityTls.unitytls_x509name* caList, IntPtr caListLen, UnityTls.unitytls_x509list_ref* chain, UnityTls.unitytls_key_ref* key, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(void* userData, UnityTls.unitytls_tlsctx* ctx, byte* cn, IntPtr cnLen, UnityTls.unitytls_x509name* caList, IntPtr caListLen, UnityTls.unitytls_x509list_ref* chain, UnityTls.unitytls_key_ref* key, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_tlsctx_x509verify_callback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual UnityTls.unitytls_x509verify_result Invoke(void* userData, UnityTls.unitytls_x509list_ref chain, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(void* userData, UnityTls.unitytls_x509list_ref chain, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual UnityTls.unitytls_x509verify_result EndInvoke(IAsyncResult result);

}
//NameSpace:
public struct UnityTls.unitytls_tlsctx_callbacks
{
	// Fields
	public UnityTls.unitytls_tlsctx_read_callback read;
	public UnityTls.unitytls_tlsctx_write_callback write;
	public void* data;

}
//NameSpace:
public class UnityTls.unitytls_interface_struct
{
	// Fields
	public readonly ulong UNITYTLS_INVALID_HANDLE;
	public readonly UnityTls.unitytls_tlsctx_protocolrange UNITYTLS_TLSCTX_PROTOCOLRANGE_DEFAULT;
	public UnityTls.unitytls_interface_struct.unitytls_errorstate_create_t unitytls_errorstate_create;
	public UnityTls.unitytls_interface_struct.unitytls_errorstate_raise_error_t unitytls_errorstate_raise_error;
	public UnityTls.unitytls_interface_struct.unitytls_key_get_ref_t unitytls_key_get_ref;
	public UnityTls.unitytls_interface_struct.unitytls_key_parse_der_t unitytls_key_parse_der;
	public UnityTls.unitytls_interface_struct.unitytls_key_parse_pem_t unitytls_key_parse_pem;
	public UnityTls.unitytls_interface_struct.unitytls_key_free_t unitytls_key_free;
	public UnityTls.unitytls_interface_struct.unitytls_x509_export_der_t unitytls_x509_export_der;
	public UnityTls.unitytls_interface_struct.unitytls_x509list_get_ref_t unitytls_x509list_get_ref;
	public UnityTls.unitytls_interface_struct.unitytls_x509list_get_x509_t unitytls_x509list_get_x509;
	public UnityTls.unitytls_interface_struct.unitytls_x509list_create_t unitytls_x509list_create;
	public UnityTls.unitytls_interface_struct.unitytls_x509list_append_t unitytls_x509list_append;
	public UnityTls.unitytls_interface_struct.unitytls_x509list_append_der_t unitytls_x509list_append_der;
	public UnityTls.unitytls_interface_struct.unitytls_x509list_append_der_t unitytls_x509list_append_pem;
	public UnityTls.unitytls_interface_struct.unitytls_x509list_free_t unitytls_x509list_free;
	public UnityTls.unitytls_interface_struct.unitytls_x509verify_default_ca_t unitytls_x509verify_default_ca;
	public UnityTls.unitytls_interface_struct.unitytls_x509verify_explicit_ca_t unitytls_x509verify_explicit_ca;
	public UnityTls.unitytls_interface_struct.unitytls_tlsctx_create_server_t unitytls_tlsctx_create_server;
	public UnityTls.unitytls_interface_struct.unitytls_tlsctx_create_client_t unitytls_tlsctx_create_client;
	public UnityTls.unitytls_interface_struct.unitytls_tlsctx_server_require_client_authentication_t unitytls_tlsctx_server_require_client_authentication;
	public UnityTls.unitytls_interface_struct.unitytls_tlsctx_set_certificate_callback_t unitytls_tlsctx_set_certificate_callback;
	public UnityTls.unitytls_interface_struct.unitytls_tlsctx_set_trace_callback_t unitytls_tlsctx_set_trace_callback;
	public UnityTls.unitytls_interface_struct.unitytls_tlsctx_set_x509verify_callback_t unitytls_tlsctx_set_x509verify_callback;
	public UnityTls.unitytls_interface_struct.unitytls_tlsctx_set_supported_ciphersuites_t unitytls_tlsctx_set_supported_ciphersuites;
	public UnityTls.unitytls_interface_struct.unitytls_tlsctx_get_ciphersuite_t unitytls_tlsctx_get_ciphersuite;
	public UnityTls.unitytls_interface_struct.unitytls_tlsctx_get_protocol_t unitytls_tlsctx_get_protocol;
	public UnityTls.unitytls_interface_struct.unitytls_tlsctx_process_handshake_t unitytls_tlsctx_process_handshake;
	public UnityTls.unitytls_interface_struct.unitytls_tlsctx_read_t unitytls_tlsctx_read;
	public UnityTls.unitytls_interface_struct.unitytls_tlsctx_write_t unitytls_tlsctx_write;
	public UnityTls.unitytls_interface_struct.unitytls_tlsctx_notify_close_t unitytls_tlsctx_notify_close;
	public UnityTls.unitytls_interface_struct.unitytls_tlsctx_free_t unitytls_tlsctx_free;
	public UnityTls.unitytls_interface_struct.unitytls_random_generate_bytes_t unitytls_random_generate_bytes;

	// Methods
	public void .ctor();

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_errorstate_create_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual UnityTls.unitytls_errorstate Invoke();
	public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
	public virtual UnityTls.unitytls_errorstate EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_errorstate_raise_error_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(UnityTls.unitytls_errorstate* errorState, UnityTls.unitytls_error_code errorCode);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_errorstate* errorState, UnityTls.unitytls_error_code errorCode, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_key_get_ref_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual UnityTls.unitytls_key_ref Invoke(UnityTls.unitytls_key* key, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_key* key, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual UnityTls.unitytls_key_ref EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_key_parse_der_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual UnityTls.unitytls_key* Invoke(byte* buffer, IntPtr bufferLen, byte* password, IntPtr passwordLen, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(byte* buffer, IntPtr bufferLen, byte* password, IntPtr passwordLen, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual UnityTls.unitytls_key* EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_key_parse_pem_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual UnityTls.unitytls_key* Invoke(byte* buffer, IntPtr bufferLen, byte* password, IntPtr passwordLen, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(byte* buffer, IntPtr bufferLen, byte* password, IntPtr passwordLen, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual UnityTls.unitytls_key* EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_key_free_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(UnityTls.unitytls_key* key);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_key* key, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_x509_export_der_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual IntPtr Invoke(UnityTls.unitytls_x509_ref cert, byte* buffer, IntPtr bufferLen, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_x509_ref cert, byte* buffer, IntPtr bufferLen, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual IntPtr EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_x509list_get_ref_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual UnityTls.unitytls_x509list_ref Invoke(UnityTls.unitytls_x509list* list, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_x509list* list, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual UnityTls.unitytls_x509list_ref EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_x509list_get_x509_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual UnityTls.unitytls_x509_ref Invoke(UnityTls.unitytls_x509list_ref list, IntPtr index, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_x509list_ref list, IntPtr index, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual UnityTls.unitytls_x509_ref EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_x509list_create_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual UnityTls.unitytls_x509list* Invoke(UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual UnityTls.unitytls_x509list* EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_x509list_append_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(UnityTls.unitytls_x509list* list, UnityTls.unitytls_x509_ref cert, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_x509list* list, UnityTls.unitytls_x509_ref cert, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_x509list_append_der_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(UnityTls.unitytls_x509list* list, byte* buffer, IntPtr bufferLen, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_x509list* list, byte* buffer, IntPtr bufferLen, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_x509list_free_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(UnityTls.unitytls_x509list* list);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_x509list* list, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_x509verify_default_ca_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual UnityTls.unitytls_x509verify_result Invoke(UnityTls.unitytls_x509list_ref chain, byte* cn, IntPtr cnLen, UnityTls.unitytls_x509verify_callback cb, void* userData, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_x509list_ref chain, byte* cn, IntPtr cnLen, UnityTls.unitytls_x509verify_callback cb, void* userData, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual UnityTls.unitytls_x509verify_result EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_x509verify_explicit_ca_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual UnityTls.unitytls_x509verify_result Invoke(UnityTls.unitytls_x509list_ref chain, UnityTls.unitytls_x509list_ref trustCA, byte* cn, IntPtr cnLen, UnityTls.unitytls_x509verify_callback cb, void* userData, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_x509list_ref chain, UnityTls.unitytls_x509list_ref trustCA, byte* cn, IntPtr cnLen, UnityTls.unitytls_x509verify_callback cb, void* userData, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual UnityTls.unitytls_x509verify_result EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_tlsctx_create_server_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual UnityTls.unitytls_tlsctx* Invoke(UnityTls.unitytls_tlsctx_protocolrange supportedProtocols, UnityTls.unitytls_tlsctx_callbacks callbacks, ulong certChain, ulong leafCertificateKey, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_tlsctx_protocolrange supportedProtocols, UnityTls.unitytls_tlsctx_callbacks callbacks, ulong certChain, ulong leafCertificateKey, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual UnityTls.unitytls_tlsctx* EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_tlsctx_create_client_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual UnityTls.unitytls_tlsctx* Invoke(UnityTls.unitytls_tlsctx_protocolrange supportedProtocols, UnityTls.unitytls_tlsctx_callbacks callbacks, byte* cn, IntPtr cnLen, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_tlsctx_protocolrange supportedProtocols, UnityTls.unitytls_tlsctx_callbacks callbacks, byte* cn, IntPtr cnLen, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual UnityTls.unitytls_tlsctx* EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_tlsctx_server_require_client_authentication_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(UnityTls.unitytls_tlsctx* ctx, UnityTls.unitytls_x509list_ref clientAuthCAList, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_tlsctx* ctx, UnityTls.unitytls_x509list_ref clientAuthCAList, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_tlsctx_set_certificate_callback_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(UnityTls.unitytls_tlsctx* ctx, UnityTls.unitytls_tlsctx_certificate_callback cb, void* userData, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_tlsctx* ctx, UnityTls.unitytls_tlsctx_certificate_callback cb, void* userData, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_tlsctx_set_trace_callback_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(UnityTls.unitytls_tlsctx* ctx, UnityTls.unitytls_tlsctx_trace_callback cb, void* userData, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_tlsctx* ctx, UnityTls.unitytls_tlsctx_trace_callback cb, void* userData, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_tlsctx_set_x509verify_callback_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(UnityTls.unitytls_tlsctx* ctx, UnityTls.unitytls_tlsctx_x509verify_callback cb, void* userData, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_tlsctx* ctx, UnityTls.unitytls_tlsctx_x509verify_callback cb, void* userData, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_tlsctx_set_supported_ciphersuites_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(UnityTls.unitytls_tlsctx* ctx, UnityTls.unitytls_ciphersuite* supportedCiphersuites, IntPtr supportedCiphersuitesLen, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_tlsctx* ctx, UnityTls.unitytls_ciphersuite* supportedCiphersuites, IntPtr supportedCiphersuitesLen, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_tlsctx_get_ciphersuite_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual UnityTls.unitytls_ciphersuite Invoke(UnityTls.unitytls_tlsctx* ctx, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_tlsctx* ctx, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual UnityTls.unitytls_ciphersuite EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_tlsctx_get_protocol_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual UnityTls.unitytls_protocol Invoke(UnityTls.unitytls_tlsctx* ctx, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_tlsctx* ctx, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual UnityTls.unitytls_protocol EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_tlsctx_process_handshake_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual UnityTls.unitytls_x509verify_result Invoke(UnityTls.unitytls_tlsctx* ctx, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_tlsctx* ctx, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual UnityTls.unitytls_x509verify_result EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_tlsctx_read_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual IntPtr Invoke(UnityTls.unitytls_tlsctx* ctx, byte* buffer, IntPtr bufferLen, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_tlsctx* ctx, byte* buffer, IntPtr bufferLen, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual IntPtr EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_tlsctx_write_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual IntPtr Invoke(UnityTls.unitytls_tlsctx* ctx, byte* data, IntPtr bufferLen, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_tlsctx* ctx, byte* data, IntPtr bufferLen, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual IntPtr EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_tlsctx_notify_close_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(UnityTls.unitytls_tlsctx* ctx, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_tlsctx* ctx, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_tlsctx_free_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(UnityTls.unitytls_tlsctx* ctx);
	public virtual IAsyncResult BeginInvoke(UnityTls.unitytls_tlsctx* ctx, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class UnityTls.unitytls_interface_struct.unitytls_random_generate_bytes_t : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(byte* buffer, IntPtr bufferLen, UnityTls.unitytls_errorstate* errorState);
	public virtual IAsyncResult BeginInvoke(byte* buffer, IntPtr bufferLen, UnityTls.unitytls_errorstate* errorState, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:Mono.Unity
internal static class UnityTlsConversions
{
	// Methods
	public static MonoSslPolicyErrors VerifyResultToPolicyErrror(UnityTls.unitytls_x509verify_result verifyResult);

}
//NameSpace:Mono.Unity
internal class UnityTlsProvider : MonoTlsProvider
{
	// Properties
	public override string Name { get; }
	public override Guid ID { get; }
	public override bool SupportsSslStream { get; }
	public override bool SupportsMonoExtensions { get; }
	public override bool SupportsConnectionInfo { get; }
	internal override bool SupportsCleanShutdown { get; }
	public override SslProtocols SupportedProtocols { get; }

	// Methods
	public override string get_Name();
	public override Guid get_ID();
	public override bool get_SupportsSslStream();
	public override bool get_SupportsMonoExtensions();
	public override bool get_SupportsConnectionInfo();
	internal override bool get_SupportsCleanShutdown();
	public override SslProtocols get_SupportedProtocols();
	public override IMonoSslStream CreateSslStream(Stream innerStream, bool leaveInnerStreamOpen, optional MonoTlsSettings settings);
	internal override IMonoSslStream CreateSslStreamInternal(SslStream sslStream, Stream innerStream, bool leaveInnerStreamOpen, MonoTlsSettings settings);
	internal override bool ValidateCertificate(ICertificateValidator2 validator, string targetHost, bool serverMode, X509CertificateCollection certificates, bool wantsChain, X509Chain chain, MonoSslPolicyErrors errors, int status11);
	public void .ctor();

}
//NameSpace:Mono.Unity
internal class UnityTlsStream : MobileAuthenticatedStream
{
	// Methods
	public void .ctor(Stream innerStream, bool leaveInnerStreamOpen, SslStream owner, MonoTlsSettings settings, MonoTlsProvider provider);

}
//NameSpace:Mono.Net.Security
internal class BufferOffsetSize
{
	// Fields
	public byte[] Buffer;
	public int Offset;
	public int Size;
	public int TotalBytes;
	public bool Complete;

	// Properties
	public int EndOffset { get; }
	public int Remaining { get; }

	// Methods
	public int get_EndOffset();
	public int get_Remaining();
	public void .ctor(byte[] buffer, int offset, int size);
	public override string ToString();

}
//NameSpace:Mono.Net.Security
internal class BufferOffsetSize2 : BufferOffsetSize
{
	// Fields
	public readonly int InitialSize;

	// Methods
	public void .ctor(int size);
	public void Reset();

}
//NameSpace:Mono.Net.Security
internal enum AsyncOperationStatus
{
	// Fields
	public int value__;
	public const AsyncOperationStatus Initialize;
	public const AsyncOperationStatus Continue;
	public const AsyncOperationStatus ReadDone;
	public const AsyncOperationStatus Complete;

}
//NameSpace:Mono.Net.Security
internal class AsyncProtocolResult
{
	// Fields
	private readonly int <UserResult>k__BackingField;
	private readonly ExceptionDispatchInfo <Error>k__BackingField;

	// Properties
	public int UserResult { get; }
	public ExceptionDispatchInfo Error { get; }

	// Methods
	public int get_UserResult();
	public ExceptionDispatchInfo get_Error();
	public void .ctor(int result);
	public void .ctor(ExceptionDispatchInfo error);

}
//NameSpace:Mono.Net.Security
internal abstract class AsyncProtocolRequest
{
	// Fields
	private readonly MobileAuthenticatedStream <Parent>k__BackingField;
	private readonly bool <RunSynchronously>k__BackingField;
	private int <UserResult>k__BackingField;
	private int Started;
	private int RequestedSize;
	private int WriteRequested;
	private readonly object locker;

	// Properties
	public MobileAuthenticatedStream Parent { get; }
	public bool RunSynchronously { get; }
	public string Name { get; }
	public int UserResult { get; set; }

	// Methods
	public MobileAuthenticatedStream get_Parent();
	public bool get_RunSynchronously();
	public string get_Name();
	public int get_UserResult();
	protected void set_UserResult(int value);
	public void .ctor(MobileAuthenticatedStream parent, bool sync);
	internal Task`1<AsyncProtocolResult> StartOperation(CancellationToken cancellationToken);
	private Task ProcessOperation(CancellationToken cancellationToken);
	private Task`1<Nullable`1<int>> InnerRead(CancellationToken cancellationToken);
	protected abstract AsyncOperationStatus Run(AsyncOperationStatus status);
	public override string ToString();

}
//NameSpace:
private struct AsyncProtocolRequest.<StartOperation>d__23 : IAsyncStateMachine
{
	// Fields
	public int <>1__state;
	public AsyncTaskMethodBuilder`1<AsyncProtocolResult> <>t__builder;
	public AsyncProtocolRequest <>4__this;
	public CancellationToken cancellationToken;
	private ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__1;

	// Methods
	private void MoveNext();
	private void SetStateMachine(IAsyncStateMachine stateMachine);

}
//NameSpace:
private struct AsyncProtocolRequest.<ProcessOperation>d__24 : IAsyncStateMachine
{
	// Fields
	public int <>1__state;
	public AsyncTaskMethodBuilder <>t__builder;
	public CancellationToken cancellationToken;
	public AsyncProtocolRequest <>4__this;
	private AsyncOperationStatus <status>5__1;
	private AsyncOperationStatus <newStatus>5__2;
	private ConfiguredTaskAwaiter<Nullable`1<int>> <>u__1;
	private ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__2;

	// Methods
	private void MoveNext();
	private void SetStateMachine(IAsyncStateMachine stateMachine);

}
//NameSpace:
private struct AsyncProtocolRequest.<InnerRead>d__25 : IAsyncStateMachine
{
	// Fields
	public int <>1__state;
	public AsyncTaskMethodBuilder`1<Nullable`1<int>> <>t__builder;
	public AsyncProtocolRequest <>4__this;
	public CancellationToken cancellationToken;
	private int <requestedSize>5__1;
	private Nullable`1<int> <totalRead>5__2;
	private ConfiguredTaskAwaiter<int> <>u__1;

	// Methods
	private void MoveNext();
	private void SetStateMachine(IAsyncStateMachine stateMachine);

}
//NameSpace:Mono.Net.Security
internal abstract class AsyncReadOrWriteRequest : AsyncProtocolRequest
{
	// Fields
	private readonly BufferOffsetSize <UserBuffer>k__BackingField;
	private int <CurrentSize>k__BackingField;

	// Properties
	protected BufferOffsetSize UserBuffer { get; }
	protected int CurrentSize { get; set; }

	// Methods
	protected BufferOffsetSize get_UserBuffer();
	protected int get_CurrentSize();
	protected void set_CurrentSize(int value);
	public void .ctor(MobileAuthenticatedStream parent, bool sync, byte[] buffer, int offset, int size);
	public override string ToString();

}
//NameSpace:Mono.Net.Security
internal class AsyncReadRequest : AsyncReadOrWriteRequest
{
	// Methods
	public void .ctor(MobileAuthenticatedStream parent, bool sync, byte[] buffer, int offset, int size);
	protected override AsyncOperationStatus Run(AsyncOperationStatus status);

}
//NameSpace:Mono.Net.Security
internal class AsyncWriteRequest : AsyncReadOrWriteRequest
{
	// Methods
	public void .ctor(MobileAuthenticatedStream parent, bool sync, byte[] buffer, int offset, int size);
	protected override AsyncOperationStatus Run(AsyncOperationStatus status);

}
//NameSpace:Mono.Net.Security
internal abstract class MobileAuthenticatedStream : AuthenticatedStream, IMonoSslStream, IDisposable
{
	// Fields
	private MobileTlsContext xobileTlsContext;
	private ExceptionDispatchInfo lastException;
	private AsyncProtocolRequest asyncReadRequest;
	private AsyncProtocolRequest asyncWriteRequest;
	private BufferOffsetSize2 readBuffer;
	private BufferOffsetSize2 writeBuffer;
	private object ioLock;
	private bool shutdown;
	private static int uniqueNameInteger;
	private readonly SslStream <SslStream>k__BackingField;
	private readonly MonoTlsSettings <Settings>k__BackingField;
	private readonly MonoTlsProvider <Provider>k__BackingField;
	private static int nextId;
	internal readonly int ID;

	// Properties
	public override bool IsAuthenticated { get; }
	public override bool CanRead { get; }
	public override bool CanWrite { get; }
	public override bool CanSeek { get; }
	public override long Length { get; }
	public override long Position { get; set; }

	// Methods
	public void .ctor(Stream innerStream, bool leaveInnerStreamOpen, SslStream owner, MonoTlsSettings settings, MonoTlsProvider provider);
	internal void CheckThrow(bool authSuccessCheck, optional bool shutdownCheck);
	internal static Exception GetSSPIException(Exception e);
	internal static Exception GetIOException(Exception e, string message);
	internal ExceptionDispatchInfo SetException(Exception e);
	public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
	public override int EndRead(IAsyncResult asyncResult);
	public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
	public override void EndWrite(IAsyncResult asyncResult);
	public override int Read(byte[] buffer, int offset, int count);
	public override void Write(byte[] buffer, int offset, int count);
	public override Task`1<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
	public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken);
	private Task`1<int> StartOperation(MobileAuthenticatedStream.OperationType type, AsyncProtocolRequest asyncRequest, CancellationToken cancellationToken);
	internal Task`1<int> InnerRead(bool sync, int requestedSize, CancellationToken cancellationToken);
	internal Task InnerWrite(bool sync, CancellationToken cancellationToken);
	internal ValueTuple`2<intbool> ProcessRead(BufferOffsetSize userBuffer);
	internal ValueTuple`2<intbool> ProcessWrite(BufferOffsetSize userBuffer);
	public override bool get_IsAuthenticated();
	protected override void Dispose(bool disposing);
	public override void Flush();
	public override long Seek(long offset, SeekOrigin origin);
	public override bool get_CanRead();
	public override bool get_CanWrite();
	public override bool get_CanSeek();
	public override long get_Length();
	public override long get_Position();
	public override void set_Position(long value);
	private static void .cctor();
	private void <InnerWrite>b__67_0();

}
//NameSpace:
private enum MobileAuthenticatedStream.OperationType
{
	// Fields
	public int value__;
	public const MobileAuthenticatedStream.OperationType Read;
	public const MobileAuthenticatedStream.OperationType Write;
	public const MobileAuthenticatedStream.OperationType Shutdown;

}
//NameSpace:
private struct MobileAuthenticatedStream.<StartOperation>d__58 : IAsyncStateMachine
{
	// Fields
	public int <>1__state;
	public AsyncTaskMethodBuilder`1<int> <>t__builder;
	public MobileAuthenticatedStream <>4__this;
	public MobileAuthenticatedStream.OperationType type;
	public AsyncProtocolRequest asyncRequest;
	public CancellationToken cancellationToken;
	private ConfiguredTaskAwaiter<AsyncProtocolResult> <>u__1;

	// Methods
	private void MoveNext();
	private void SetStateMachine(IAsyncStateMachine stateMachine);

}
//NameSpace:
private sealed class MobileAuthenticatedStream.<>c__DisplayClass66_0
{
	// Fields
	public MobileAuthenticatedStream <>4__this;
	public int len;

	// Methods
	public void .ctor();
	internal int <InnerRead>b__0();

}
//NameSpace:
private struct MobileAuthenticatedStream.<InnerRead>d__66 : IAsyncStateMachine
{
	// Fields
	public int <>1__state;
	public AsyncTaskMethodBuilder`1<int> <>t__builder;
	public MobileAuthenticatedStream <>4__this;
	public CancellationToken cancellationToken;
	public int requestedSize;
	public bool sync;
	private ConfiguredTaskAwaiter<int> <>u__1;

	// Methods
	private void MoveNext();
	private void SetStateMachine(IAsyncStateMachine stateMachine);

}
//NameSpace:
private struct MobileAuthenticatedStream.<InnerWrite>d__67 : IAsyncStateMachine
{
	// Fields
	public int <>1__state;
	public AsyncTaskMethodBuilder <>t__builder;
	public CancellationToken cancellationToken;
	public MobileAuthenticatedStream <>4__this;
	public bool sync;
	private ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__1;

	// Methods
	private void MoveNext();
	private void SetStateMachine(IAsyncStateMachine stateMachine);

}
//NameSpace:Mono.Net.Security
internal abstract class MobileTlsContext : IDisposable
{
	// Properties
	public abstract bool IsAuthenticated { get; }

	// Methods
	public abstract bool get_IsAuthenticated();
	public abstract ValueTuple`2<intbool> Read(byte[] buffer, int offset, int count);
	public abstract ValueTuple`2<intbool> Write(byte[] buffer, int offset, int count);
	public void Dispose();
	protected virtual void Dispose(bool disposing);
	protected override void Finalize();

}
//NameSpace:Mono.Net.Security
internal static class MonoTlsProviderFactory
{
	// Fields
	private static object locker;
	internal static readonly Guid UnityTlsId;
	internal static readonly Guid AppleTlsId;
	internal static readonly Guid BtlsId;
	internal static readonly Guid LegacyId;

	// Methods
	private static void .cctor();

}
//NameSpace:Mono.Net.Security
internal static class SystemCertificateValidator
{
	// Fields
	private static bool is_macosx;
	private static X509KeyUsageFlags s_flags;

	// Methods
	private static void .cctor();
	public static X509Chain CreateX509Chain(X509CertificateCollection certs);

}
//NameSpace:System
internal static class IriHelper
{
	// Methods
	internal static bool CheckIriUnicodeRange(char unicode, bool isQuery);
	internal static bool CheckIriUnicodeRange(char highSurr, char lowSurr, bool surrogatePair, bool isQuery);
	internal static bool CheckIsReserved(char ch, UriComponents component);
	internal static string EscapeUnescapeIri(char* pInput, int start, int end, UriComponents component);

}
//NameSpace:System
public class Uri : ISerializable
{
	// Fields
	public static readonly string UriSchemeFile;
	public static readonly string UriSchemeFtp;
	public static readonly string UriSchemeGopher;
	public static readonly string UriSchemeHttp;
	public static readonly string UriSchemeHttps;
	internal static readonly string UriSchemeWs;
	internal static readonly string UriSchemeWss;
	public static readonly string UriSchemeMailto;
	public static readonly string UriSchemeNews;
	public static readonly string UriSchemeNntp;
	public static readonly string UriSchemeNetTcp;
	public static readonly string UriSchemeNetPipe;
	public static readonly string SchemeDelimiter;
	private string m_String;
	private string m_originalUnicodeString;
	private UriParser m_Syntax;
	private string m_DnsSafeHost;
	private Uri.Flags m_Flags;
	private Uri.UriInfo m_Info;
	private bool m_iriParsing;
	private static bool s_ConfigInitialized;
	private static bool s_ConfigInitializing;
	private static UriIdnScope s_IdnScope;
	private static bool s_IriParsing;
	private static bool useDotNetRelativeOrAbsolute;
	internal static readonly bool IsWindowsFileSystem;
	private static object s_initLock;
	internal static readonly char[] HexLowerChars;
	private static readonly char[] _WSchars;

	// Properties
	private bool IsImplicitFile { get; }
	private bool IsUncOrDosPath { get; }
	private bool IsDosPath { get; }
	private bool IsUncPath { get; }
	private Uri.Flags HostType { get; }
	private UriParser Syntax { get; }
	private bool IsNotAbsoluteUri { get; }
	private bool AllowIdn { get; }
	internal bool UserDrivenParsing { get; }
	private ushort SecuredPathIndex { get; }
	public string AbsoluteUri { get; }
	public bool IsUnc { get; }
	private static object InitializeLock { get; }
	public int Port { get; }
	public string Scheme { get; }
	private bool OriginalStringSwitched { get; }
	public string OriginalString { get; }
	public string DnsSafeHost { get; }
	public bool IsAbsoluteUri { get; }
	public bool UserEscaped { get; }

	// Methods
	private bool get_IsImplicitFile();
	private bool get_IsUncOrDosPath();
	private bool get_IsDosPath();
	private bool get_IsUncPath();
	private Uri.Flags get_HostType();
	private UriParser get_Syntax();
	private bool get_IsNotAbsoluteUri();
	internal static bool IriParsingStatic(UriParser syntax);
	private bool get_AllowIdn();
	private bool AllowIdnStatic(UriParser syntax, Uri.Flags flags);
	private bool IsIntranet(string schemeHost);
	internal bool get_UserDrivenParsing();
	private void SetUserDrivenParsing();
	private ushort get_SecuredPathIndex();
	private bool NotAny(Uri.Flags flags);
	private bool InFact(Uri.Flags flags);
	private static bool StaticNotAny(Uri.Flags allFlags, Uri.Flags checkFlags);
	private static bool StaticInFact(Uri.Flags allFlags, Uri.Flags checkFlags);
	private Uri.UriInfo EnsureUriInfo();
	private void EnsureParseRemaining();
	private void EnsureHostString(bool allowDnsOptimization);
	public void .ctor(string uriString);
	public void .ctor(string uriString, UriKind uriKind);
	public void .ctor(Uri baseUri, Uri relativeUri);
	private static ParsingError GetCombinedString(Uri baseUri, string relativeStr, bool dontEscape, string result);
	private static UriFormatException GetException(ParsingError err);
	protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
	protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
	public string get_AbsoluteUri();
	public bool get_IsUnc();
	private static bool StaticIsFile(UriParser syntax);
	private static object get_InitializeLock();
	private static void InitializeUriConfig();
	public int get_Port();
	public string get_Scheme();
	private bool get_OriginalStringSwitched();
	public string get_OriginalString();
	public string get_DnsSafeHost();
	public bool get_IsAbsoluteUri();
	public bool get_UserEscaped();
	internal static bool IsGenDelim(char ch);
	public static bool IsHexDigit(char character);
	public static int FromHex(char digit);
	public override int GetHashCode();
	public override string ToString();
	public static bool op_Inequality(Uri uri1, Uri uri2);
	public override bool Equals(object comparand);
	private static ParsingError ParseScheme(string uriString, Uri.Flags flags, UriParser syntax);
	internal UriFormatException ParseMinimal();
	private ParsingError PrivateParseMinimal();
	private void PrivateParseMinimalIri(string newHost, ushort idx);
	private void CreateUriInfo(Uri.Flags cF);
	private void CreateHostString();
	private static string CreateHostStringHelper(string str, ushort idx, ushort end, Uri.Flags flags, string scopeId);
	private void GetHostViaCustomSyntax();
	internal string GetParts(UriComponents uriParts, UriFormat formatAs);
	private string GetEscapedParts(UriComponents uriParts);
	private string GetUnescapedParts(UriComponents uriParts, UriFormat formatAs);
	private string ReCreateParts(UriComponents parts, ushort nonCanonical, UriFormat formatAs);
	private string GetUriPartsFromUserString(UriComponents uriParts);
	private void ParseRemaining();
	private static ushort ParseSchemeCheckImplicitFile(char* uriString, ushort length, ParsingError err, Uri.Flags flags, UriParser syntax);
	private static bool CheckKnownSchemes(long* lptr, ushort nChars, UriParser syntax);
	private static ParsingError CheckSchemeSyntax(char* ptr, ushort length, UriParser syntax);
	private ushort CheckAuthorityHelper(char* pString, ushort idx, ushort length, ParsingError err, Uri.Flags flags, UriParser syntax, string newHost);
	private void CheckAuthorityHelperHandleDnsIri(char* pString, ushort start, int end, int startInput, bool iriParsing, bool hasUnicode, UriParser syntax, string userInfoString, Uri.Flags flags, bool justNormalized, string newHost, ParsingError err);
	private void CheckAuthorityHelperHandleAnyHostIri(char* pString, int startInput, int end, bool iriParsing, bool hasUnicode, UriParser syntax, Uri.Flags flags, string newHost, ParsingError err);
	private void FindEndOfComponent(string input, ushort idx, ushort end, char delim);
	private void FindEndOfComponent(char* str, ushort idx, ushort end, char delim);
	private Uri.Check CheckCanonical(char* str, ushort idx, ushort end, char delim);
	private char[] GetCanonicalPath(char[] dest, int pos, UriFormat formatAs);
	private static void UnescapeOnly(char* pch, int start, int end, char ch1, char ch2, char ch3);
	private static char[] Compress(char[] dest, ushort start, int destLength, UriParser syntax);
	internal static int CalculateCaseInsensitiveHashCode(string text);
	private static string CombineUri(Uri basePart, string relativePart, UriFormat uriFormat);
	private static bool IsLWS(char ch);
	private static bool IsAsciiLetter(char character);
	internal static bool IsAsciiLetterOrDigit(char character);
	internal static bool IsBidiControlCharacter(char ch);
	internal static string StripBidiControlCharacter(char* strToClean, int start, int length);
	private void CreateThis(string uri, bool dontEscape, UriKind uriKind);
	private void InitializeUri(ParsingError err, UriKind uriKind, out UriFormatException e);
	private bool CheckForConfigLoad(string data);
	private bool CheckForUnicode(string data);
	private bool CheckForEscapedUnreserved(string data);
	public static bool TryCreate(string uriString, UriKind uriKind, out Uri result);
	public string GetComponents(UriComponents components, UriFormat format);
	public static string UnescapeDataString(string stringToUnescape);
	internal string EscapeUnescapeIri(string input, int start, int end, UriComponents component);
	private void .ctor(Uri.Flags flags, UriParser uriParser, string uri);
	internal static Uri CreateHelper(string uriString, bool dontEscape, UriKind uriKind, UriFormatException e);
	internal static Uri ResolveHelper(Uri baseUri, Uri relativeUri, string newUriString, bool userEscaped, out UriFormatException e);
	private string GetRelativeSerializationString(UriFormat format);
	internal string GetComponentsHelper(UriComponents uriComponents, UriFormat uriFormat);
	private void CreateThisFromUri(Uri otherUri);
	private static void .cctor();

}
//NameSpace:
private enum Uri.Flags
{
	// Fields
	public ulong value__;
	public const Uri.Flags Zero;
	public const Uri.Flags SchemeNotCanonical;
	public const Uri.Flags UserNotCanonical;
	public const Uri.Flags HostNotCanonical;
	public const Uri.Flags PortNotCanonical;
	public const Uri.Flags PathNotCanonical;
	public const Uri.Flags QueryNotCanonical;
	public const Uri.Flags FragmentNotCanonical;
	public const Uri.Flags CannotDisplayCanonical;
	public const Uri.Flags E_UserNotCanonical;
	public const Uri.Flags E_HostNotCanonical;
	public const Uri.Flags E_PortNotCanonical;
	public const Uri.Flags E_PathNotCanonical;
	public const Uri.Flags E_QueryNotCanonical;
	public const Uri.Flags E_FragmentNotCanonical;
	public const Uri.Flags E_CannotDisplayCanonical;
	public const Uri.Flags ShouldBeCompressed;
	public const Uri.Flags FirstSlashAbsent;
	public const Uri.Flags BackslashInPath;
	public const Uri.Flags IndexMask;
	public const Uri.Flags HostTypeMask;
	public const Uri.Flags HostNotParsed;
	public const Uri.Flags IPv6HostType;
	public const Uri.Flags IPv4HostType;
	public const Uri.Flags DnsHostType;
	public const Uri.Flags UncHostType;
	public const Uri.Flags BasicHostType;
	public const Uri.Flags UnusedHostType;
	public const Uri.Flags UnknownHostType;
	public const Uri.Flags UserEscaped;
	public const Uri.Flags AuthorityFound;
	public const Uri.Flags HasUserInfo;
	public const Uri.Flags LoopbackHost;
	public const Uri.Flags NotDefaultPort;
	public const Uri.Flags UserDrivenParsing;
	public const Uri.Flags CanonicalDnsHost;
	public const Uri.Flags ErrorOrParsingRecursion;
	public const Uri.Flags DosPath;
	public const Uri.Flags UncPath;
	public const Uri.Flags ImplicitFile;
	public const Uri.Flags MinimalUriInfoSet;
	public const Uri.Flags AllUriInfoSet;
	public const Uri.Flags IdnHost;
	public const Uri.Flags HasUnicode;
	public const Uri.Flags HostUnicodeNormalized;
	public const Uri.Flags RestUnicodeNormalized;
	public const Uri.Flags UnicodeHost;
	public const Uri.Flags IntranetUri;
	public const Uri.Flags UseOrigUncdStrOffset;
	public const Uri.Flags UserIriCanonical;
	public const Uri.Flags PathIriCanonical;
	public const Uri.Flags QueryIriCanonical;
	public const Uri.Flags FragmentIriCanonical;
	public const Uri.Flags IriCanonical;
	public const Uri.Flags CompressedSlashes;

}
//NameSpace:
private class Uri.UriInfo
{
	// Fields
	public string Host;
	public string ScopeId;
	public string String;
	public Uri.Offset Offset;
	public string DnsSafeHost;
	public Uri.MoreInfo MoreInfo;

	// Methods
	public void .ctor();

}
//NameSpace:
private struct Uri.Offset
{
	// Fields
	public ushort Scheme;
	public ushort User;
	public ushort Host;
	public ushort PortValue;
	public ushort Path;
	public ushort Query;
	public ushort Fragment;
	public ushort End;

}
//NameSpace:
private class Uri.MoreInfo
{
	// Fields
	public string AbsoluteUri;
	public int Hash;
	public string RemoteUrl;

	// Methods
	public void .ctor();

}
//NameSpace:
private enum Uri.Check
{
	// Fields
	public int value__;
	public const Uri.Check None;
	public const Uri.Check EscapedCanonical;
	public const Uri.Check DisplayCanonical;
	public const Uri.Check DotSlashAttn;
	public const Uri.Check DotSlashEscaped;
	public const Uri.Check BackslashInPath;
	public const Uri.Check ReservedFound;
	public const Uri.Check NotIriCanonical;
	public const Uri.Check FoundNonAscii;

}
//NameSpace:System
public class UriFormatException : FormatException, ISerializable
{
	// Methods
	public void .ctor();
	public void .ctor(string textString);
	protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);

}
//NameSpace:System
public enum UriKind
{
	// Fields
	public int value__;
	public const UriKind RelativeOrAbsolute;
	public const UriKind Absolute;
	public const UriKind Relative;

}
//NameSpace:System
public enum UriComponents
{
	// Fields
	public int value__;
	public const UriComponents Scheme;
	public const UriComponents UserInfo;
	public const UriComponents Host;
	public const UriComponents Port;
	public const UriComponents Path;
	public const UriComponents Query;
	public const UriComponents Fragment;
	public const UriComponents StrongPort;
	public const UriComponents NormalizedHost;
	public const UriComponents KeepDelimiter;
	public const UriComponents SerializationInfoString;
	public const UriComponents AbsoluteUri;
	public const UriComponents HostAndPort;
	public const UriComponents StrongAuthority;
	public const UriComponents SchemeAndServer;
	public const UriComponents HttpRequestUrl;
	public const UriComponents PathAndQuery;

}
//NameSpace:System
public enum UriFormat
{
	// Fields
	public int value__;
	public const UriFormat UriEscaped;
	public const UriFormat Unescaped;
	public const UriFormat SafeUnescaped;

}
//NameSpace:System
public enum UriIdnScope
{
	// Fields
	public int value__;
	public const UriIdnScope None;
	public const UriIdnScope AllExceptIntranet;
	public const UriIdnScope All;

}
//NameSpace:System
internal enum ParsingError
{
	// Fields
	public int value__;
	public const ParsingError None;
	public const ParsingError BadFormat;
	public const ParsingError BadScheme;
	public const ParsingError BadAuthority;
	public const ParsingError EmptyUriString;
	public const ParsingError LastRelativeUriOkErrIndex;
	public const ParsingError SchemeLimit;
	public const ParsingError SizeLimit;
	public const ParsingError MustRootedPath;
	public const ParsingError BadHostName;
	public const ParsingError NonEmptyHost;
	public const ParsingError BadPort;
	public const ParsingError BadAuthorityTerminator;
	public const ParsingError CannotCreateRelative;

}
//NameSpace:System
internal enum UnescapeMode
{
	// Fields
	public int value__;
	public const UnescapeMode CopyOnly;
	public const UnescapeMode Escape;
	public const UnescapeMode Unescape;
	public const UnescapeMode EscapeUnescape;
	public const UnescapeMode V1ToStringFlag;
	public const UnescapeMode UnescapeAll;
	public const UnescapeMode UnescapeAllOrThrow;

}
//NameSpace:System
internal static class UriHelper
{
	// Fields
	private static readonly char[] HexUpperChars;

	// Methods
	internal static char[] EscapeString(string input, int start, int end, char[] dest, int destPos, bool isUriString, char force1, char force2, char rsvd);
	private static char[] EnsureDestinationSize(char* pStr, char[] dest, int currentInputPos, short charsToAdd, short minReallocateChars, int destPos, int prevInputPos);
	internal static char[] UnescapeString(string input, int start, int end, char[] dest, int destPosition, char rsvd1, char rsvd2, char rsvd3, UnescapeMode unescapeMode, UriParser syntax, bool isQuery);
	internal static char[] UnescapeString(char* pStr, int start, int end, char[] dest, int destPosition, char rsvd1, char rsvd2, char rsvd3, UnescapeMode unescapeMode, UriParser syntax, bool isQuery);
	internal static void MatchUTF8Sequence(char* pDest, char[] dest, int destOffset, char[] unescapedChars, int charCount, byte[] bytes, int byteCount, bool isQuery, bool iriParsing);
	internal static void EscapeAsciiChar(char ch, char[] to, int pos);
	internal static char EscapedAscii(char digit, char next);
	internal static bool IsNotSafeForUnescape(char ch);
	private static bool IsReservedUnreservedOrHash(char c);
	internal static bool IsUnreserved(char c);
	internal static bool Is3986Unreserved(char c);
	private static void .cctor();

}
//NameSpace:System
public abstract class UriParser
{
	// Fields
	private static readonly Dictionary`2<stringUriParser> m_Table;
	private static Dictionary`2<stringUriParser> m_TempTable;
	private UriSyntaxFlags m_Flags;
	private UriSyntaxFlags m_UpdatableFlags;
	private bool m_UpdatableFlagsUsed;
	private int m_Port;
	private string m_Scheme;
	internal static UriParser HttpUri;
	internal static UriParser HttpsUri;
	internal static UriParser WsUri;
	internal static UriParser WssUri;
	internal static UriParser FtpUri;
	internal static UriParser FileUri;
	internal static UriParser GopherUri;
	internal static UriParser NntpUri;
	internal static UriParser NewsUri;
	internal static UriParser MailToUri;
	internal static UriParser UuidUri;
	internal static UriParser TelnetUri;
	internal static UriParser LdapUri;
	internal static UriParser NetTcpUri;
	internal static UriParser NetPipeUri;
	internal static UriParser VsMacrosUri;
	private static readonly UriParser.UriQuirksVersion s_QuirksVersion;
	private static readonly UriSyntaxFlags HttpSyntaxFlags;
	private static readonly UriSyntaxFlags FileSyntaxFlags;

	// Properties
	internal string SchemeName { get; }
	internal int DefaultPort { get; }
	internal static bool ShouldUseLegacyV2Quirks { get; }
	internal UriSyntaxFlags Flags { get; }
	internal bool IsSimple { get; }

	// Methods
	internal string get_SchemeName();
	internal int get_DefaultPort();
	protected virtual UriParser OnNewUri();
	protected virtual void InitializeAndValidate(Uri uri, out UriFormatException parsingError);
	protected virtual string Resolve(Uri baseUri, Uri relativeUri, out UriFormatException parsingError);
	protected virtual string GetComponents(Uri uri, UriComponents components, UriFormat format);
	internal static bool get_ShouldUseLegacyV2Quirks();
	private static void .cctor();
	internal UriSyntaxFlags get_Flags();
	internal bool NotAny(UriSyntaxFlags flags);
	internal bool InFact(UriSyntaxFlags flags);
	internal bool IsAllSet(UriSyntaxFlags flags);
	private bool IsFullMatch(UriSyntaxFlags flags, UriSyntaxFlags expected);
	internal void .ctor(UriSyntaxFlags flags);
	internal static UriParser FindOrFetchAsUnknownV1Syntax(string lwrCaseScheme);
	internal bool get_IsSimple();
	internal UriParser InternalOnNewUri();
	internal void InternalValidate(Uri thisUri, out UriFormatException parsingError);
	internal string InternalResolve(Uri thisBaseUri, Uri uriLink, out UriFormatException parsingError);
	internal string InternalGetComponents(Uri thisUri, UriComponents uriComponents, UriFormat uriFormat);

}
//NameSpace:
private enum UriParser.UriQuirksVersion
{
	// Fields
	public int value__;
	public const UriParser.UriQuirksVersion V2;
	public const UriParser.UriQuirksVersion V3;

}
//NameSpace:
private class UriParser.BuiltInUriParser : UriParser
{
	// Methods
	internal void .ctor(string lwrCaseScheme, int defaultPort, UriSyntaxFlags syntaxFlags);

}
//NameSpace:System
internal class DomainNameHelper
{
	// Methods
	internal static string ParseCanonicalName(string str, int start, int end, bool loopback);
	internal static bool IsValid(char* name, ushort pos, int returnedEnd, bool notCanonical, bool notImplicitFile);
	internal static bool IsValidByIri(char* name, ushort pos, int returnedEnd, bool notCanonical, bool notImplicitFile);
	internal static string IdnEquivalent(char* hostname, int start, int end, bool allAscii, bool atLeastOneValidIdn);
	internal static string IdnEquivalent(char* hostname, int start, int end, bool allAscii, string bidiStrippedHost);
	private static bool IsIdnAce(string input, int index);
	private static bool IsIdnAce(char* input, int index);
	internal static string UnicodeEquivalent(string idnHost, char* hostname, int start, int end);
	internal static string UnicodeEquivalent(char* hostname, int start, int end, bool allAscii, bool atLeastOneValidIdn);
	private static bool IsASCIILetterOrDigit(char character, bool notCanonical);
	private static bool IsValidDomainLabelCharacter(char character, bool notCanonical);

}
//NameSpace:System
internal static class IPv4AddressHelper
{
	// Methods
	internal static string ParseCanonicalName(string str, int start, int end, bool isLoopback);
	internal static int ParseHostNumber(string str, int start, int end);
	internal static bool IsValid(char* name, int start, int end, bool allowIPv6, bool notImplicitFile, bool unknownScheme);
	internal static bool IsValidCanonical(char* name, int start, int end, bool allowIPv6, bool notImplicitFile);
	internal static long ParseNonCanonical(char* name, int start, int end, bool notImplicitFile);
	private static bool Parse(string name, byte* numbers, int start, int end);
	private static bool ParseCanonical(string name, byte* numbers, int start, int end);

}
//NameSpace:System
internal static class IPv6AddressHelper
{
	// Methods
	internal static string ParseCanonicalName(string str, int start, bool isLoopback, string scopeId);
	internal static string CreateCanonicalName(ushort* numbers);
	private static KeyValuePair`2<intint> FindCompressionRange(ushort* numbers);
	private static bool ShouldHaveIpv4Embedded(ushort* numbers);
	private static bool InternalIsValid(char* name, int start, int end, bool validateStrictAddress);
	internal static bool IsValid(char* name, int start, int end);
	internal static bool Parse(string address, ushort* numbers, int start, string scopeId);

}
//NameSpace:System
internal class UncNameHelper
{
	// Methods
	internal static string ParseCanonicalName(string str, int start, int end, bool loopback);
	internal static bool IsValid(char* name, ushort start, int returnedEnd, bool notImplicitFile);

}
//NameSpace:System
internal enum UriSyntaxFlags
{
	// Fields
	public int value__;
	public const UriSyntaxFlags None;
	public const UriSyntaxFlags MustHaveAuthority;
	public const UriSyntaxFlags OptionalAuthority;
	public const UriSyntaxFlags MayHaveUserInfo;
	public const UriSyntaxFlags MayHavePort;
	public const UriSyntaxFlags MayHavePath;
	public const UriSyntaxFlags MayHaveQuery;
	public const UriSyntaxFlags MayHaveFragment;
	public const UriSyntaxFlags AllowEmptyHost;
	public const UriSyntaxFlags AllowUncHost;
	public const UriSyntaxFlags AllowDnsHost;
	public const UriSyntaxFlags AllowIPv4Host;
	public const UriSyntaxFlags AllowIPv6Host;
	public const UriSyntaxFlags AllowAnInternetHost;
	public const UriSyntaxFlags AllowAnyOtherHost;
	public const UriSyntaxFlags FileLikeUri;
	public const UriSyntaxFlags MailToLikeUri;
	public const UriSyntaxFlags V1_UnknownUri;
	public const UriSyntaxFlags SimpleUserSyntax;
	public const UriSyntaxFlags BuiltInSyntax;
	public const UriSyntaxFlags ParserSchemeOnly;
	public const UriSyntaxFlags AllowDOSPath;
	public const UriSyntaxFlags PathIsRooted;
	public const UriSyntaxFlags ConvertPathSlashes;
	public const UriSyntaxFlags CompressPath;
	public const UriSyntaxFlags CanonicalizeAsFilePath;
	public const UriSyntaxFlags UnEscapeDotsAndSlashes;
	public const UriSyntaxFlags AllowIdn;
	public const UriSyntaxFlags AllowIriParsing;

}
//NameSpace:System
internal enum IOOperation
{
	// Fields
	public int value__;
	public const IOOperation Read;
	public const IOOperation Write;

}
//NameSpace:System
internal sealed class IOAsyncCallback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(IOAsyncResult ioares);
	public virtual IAsyncResult BeginInvoke(IOAsyncResult ioares, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:System
internal abstract class IOAsyncResult : IAsyncResult
{
	// Fields
	private AsyncCallback async_callback;
	private object async_state;
	private ManualResetEvent wait_handle;
	private bool completed_synchronously;
	private bool completed;

	// Properties
	public object AsyncState { get; }
	public WaitHandle AsyncWaitHandle { get; }
	public bool CompletedSynchronously { get; }

	// Methods
	public object get_AsyncState();
	public WaitHandle get_AsyncWaitHandle();
	public bool get_CompletedSynchronously();

}
//NameSpace:System
internal class IOSelectorJob : IThreadPoolWorkItem
{
	// Fields
	private IOOperation operation;
	private IOAsyncCallback callback;
	private IOAsyncResult state;

	// Methods
	private void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
	private void System.Threading.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);

}
//NameSpace:System
public class UriTypeConverter : TypeConverter
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Text.RegularExpressions
public class Regex : ISerializable
{
	// Fields
	protected internal string pattern;
	protected internal RegexRunnerFactory factory;
	protected internal RegexOptions roptions;
	private static readonly TimeSpan MaximumMatchTimeout;
	public static readonly TimeSpan InfiniteMatchTimeout;
	protected internal TimeSpan internalMatchTimeout;
	internal static readonly TimeSpan FallbackDefaultMatchTimeout;
	internal static readonly TimeSpan DefaultMatchTimeout;
	protected internal Hashtable caps;
	protected internal Hashtable capnames;
	protected internal string[] capslist;
	protected internal int capsize;
	internal ExclusiveReference runnerref;
	internal SharedReference replref;
	internal RegexCode code;
	internal bool refsInitialized;
	internal static LinkedList`1<CachedCodeEntry> livecode;
	internal static int cacheSize;

	// Properties
	public RegexOptions Options { get; }
	public TimeSpan MatchTimeout { get; }

	// Methods
	protected void .ctor();
	public void .ctor(string pattern);
	public void .ctor(string pattern, RegexOptions options);
	private void .ctor(string pattern, RegexOptions options, TimeSpan matchTimeout, bool useCache);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context);
	protected internal static void ValidateMatchTimeout(TimeSpan matchTimeout);
	private static TimeSpan InitDefaultMatchTimeout();
	public RegexOptions get_Options();
	public TimeSpan get_MatchTimeout();
	public override string ToString();
	protected void InitializeReferences();
	private static CachedCodeEntry LookupCachedAndUpdate(string key);
	private CachedCodeEntry CacheCode(string key);
	private static void .cctor();

}
//NameSpace:System.Text.RegularExpressions
internal sealed class CachedCodeEntry
{
	// Fields
	internal string _key;
	internal RegexCode _code;
	internal Hashtable _caps;
	internal Hashtable _capnames;
	internal string[] _capslist;
	internal int _capsize;
	internal RegexRunnerFactory _factory;
	internal ExclusiveReference _runnerref;
	internal SharedReference _replref;

	// Methods
	internal void .ctor(string key, Hashtable capnames, string[] capslist, RegexCode code, Hashtable caps, int capsize, ExclusiveReference runner, SharedReference repl);

}
//NameSpace:System.Text.RegularExpressions
internal sealed class ExclusiveReference
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Text.RegularExpressions
internal sealed class SharedReference
{
	// Fields
	private WeakReference _ref;

	// Methods
	public void .ctor();

}
//NameSpace:System.Text.RegularExpressions
internal sealed class RegexBoyerMoore
{
	// Fields
	internal int[] _positive;
	internal int[] _negativeASCII;
	internal int[][] _negativeUnicode;
	internal string _pattern;
	internal int _lowASCII;
	internal int _highASCII;
	internal bool _rightToLeft;
	internal bool _caseInsensitive;
	internal CultureInfo _culture;

	// Methods
	internal void .ctor(string pattern, bool caseInsensitive, bool rightToLeft, CultureInfo culture);
	public override string ToString();

}
//NameSpace:System.Text.RegularExpressions
internal sealed class RegexCharClass
{
	// Fields
	private List`1<RegexCharClass.SingleRange> _rangelist;
	private StringBuilder _categories;
	private bool _canonical;
	private bool _negate;
	private RegexCharClass _subtractor;
	private static readonly string InternalRegexIgnoreCase;
	private static readonly string Space;
	private static readonly string NotSpace;
	private static readonly string Word;
	private static readonly string NotWord;
	internal static readonly string SpaceClass;
	internal static readonly string NotSpaceClass;
	internal static readonly string WordClass;
	internal static readonly string NotWordClass;
	internal static readonly string DigitClass;
	internal static readonly string NotDigitClass;
	private static Dictionary`2<stringstring> _definedCategories;
	private static readonly string[2] _propTable;
	private static readonly RegexCharClass.LowerCaseMapping[] _lcTable;

	// Properties
	internal bool CanMerge { get; }
	internal void Negate { set; }

	// Methods
	private static void .cctor();
	internal void .ctor();
	private void .ctor(bool negate, List`1<RegexCharClass.SingleRange> ranges, StringBuilder categories, RegexCharClass subtraction);
	internal bool get_CanMerge();
	internal void set_Negate(bool value);
	internal void AddChar(char c);
	internal void AddCharClass(RegexCharClass cc);
	private void AddSet(string set);
	internal void AddSubtraction(RegexCharClass sub);
	internal void AddRange(char first, char last);
	internal void AddCategoryFromName(string categoryName, bool invert, bool caseInsensitive, string pattern);
	private void AddCategory(string category);
	internal void AddLowercase(CultureInfo culture);
	private void AddLowercaseRange(char chMin, char chMax, CultureInfo culture);
	internal void AddWord(bool ecma, bool negate);
	internal void AddSpace(bool ecma, bool negate);
	internal void AddDigit(bool ecma, bool negate, string pattern);
	internal static char SingletonChar(string set);
	internal static bool IsMergeable(string charClass);
	internal static bool IsEmpty(string charClass);
	internal static bool IsSingleton(string set);
	internal static bool IsSingletonInverse(string set);
	private static bool IsSubtraction(string charClass);
	internal static bool IsNegated(string set);
	internal static bool IsWordChar(char ch);
	internal static bool CharInClass(char ch, string set);
	internal static bool CharInClassRecursive(char ch, string set, int start);
	private static bool CharInClassInternal(char ch, string set, int start, int mySetLength, int myCategoryLength);
	private static bool CharInCategory(char ch, string set, int start, int mySetLength, int myCategoryLength);
	private static bool CharInCategoryGroup(char ch, UnicodeCategory chcategory, string category, int i);
	private static string NegateCategory(string category);
	internal static RegexCharClass Parse(string charClass);
	private static RegexCharClass ParseRecursive(string charClass, int start);
	private int RangeCount();
	internal string ToStringClass();
	private RegexCharClass.SingleRange GetRangeAt(int i);
	private void Canonicalize();
	private static string SetFromProperty(string capname, bool invert, string pattern);

}
//NameSpace:
private struct RegexCharClass.LowerCaseMapping
{
	// Fields
	internal char _chMin;
	internal char _chMax;
	internal int _lcOp;
	internal int _data;

	// Methods
	internal void .ctor(char chMin, char chMax, int lcOp, int data);

}
//NameSpace:
private sealed class RegexCharClass.SingleRangeComparer : IComparer`1<RegexCharClass.SingleRange>
{
	// Methods
	public int Compare(RegexCharClass.SingleRange x, RegexCharClass.SingleRange y);
	public void .ctor();

}
//NameSpace:
private sealed class RegexCharClass.SingleRange
{
	// Fields
	internal char _first;
	internal char _last;

	// Methods
	internal void .ctor(char first, char last);

}
//NameSpace:System.Text.RegularExpressions
internal sealed class RegexCode
{
	// Fields
	internal int[] _codes;
	internal string[] _strings;
	internal int _trackcount;
	internal Hashtable _caps;
	internal int _capsize;
	internal RegexPrefix _fcPrefix;
	internal RegexBoyerMoore _bmPrefix;
	internal int _anchors;
	internal bool _rightToLeft;

	// Methods
	internal void .ctor(int[] codes, List`1<string> stringlist, int trackcount, Hashtable caps, int capsize, RegexBoyerMoore bmPrefix, RegexPrefix fcPrefix, int anchors, bool rightToLeft);
	internal static bool OpcodeBacktracks(int Op);

}
//NameSpace:System.Text.RegularExpressions
internal sealed class RegexFCD
{
	// Fields
	private int[] _intStack;
	private int _intDepth;
	private RegexFC[] _fcStack;
	private int _fcDepth;
	private bool _skipAllChildren;
	private bool _skipchild;
	private bool _failed;

	// Methods
	internal static RegexPrefix FirstChars(RegexTree t);
	internal static RegexPrefix Prefix(RegexTree tree);
	internal static int Anchors(RegexTree tree);
	private static int AnchorFromType(int type);
	private void .ctor();
	private void PushInt(int I);
	private bool IntIsEmpty();
	private int PopInt();
	private void PushFC(RegexFC fc);
	private bool FCIsEmpty();
	private RegexFC PopFC();
	private RegexFC TopFC();
	private RegexFC RegexFCFromRegexTree(RegexTree tree);
	private void SkipChild();
	private void CalculateFC(int NodeType, RegexNode node, int CurIndex);

}
//NameSpace:System.Text.RegularExpressions
internal sealed class RegexFC
{
	// Fields
	internal RegexCharClass _cc;
	internal bool _nullable;
	internal bool _caseInsensitive;

	// Methods
	internal void .ctor(bool nullable);
	internal void .ctor(char ch, bool not, bool nullable, bool caseInsensitive);
	internal void .ctor(string charClass, bool nullable, bool caseInsensitive);
	internal bool AddFC(RegexFC fc, bool concatenate);
	internal string GetFirstChars(CultureInfo culture);
	internal bool IsCaseInsensitive();

}
//NameSpace:System.Text.RegularExpressions
internal sealed class RegexPrefix
{
	// Fields
	internal string _prefix;
	internal bool _caseInsensitive;
	internal static RegexPrefix _empty;

	// Properties
	internal string Prefix { get; }
	internal bool CaseInsensitive { get; }
	internal static RegexPrefix Empty { get; }

	// Methods
	internal void .ctor(string prefix, bool ci);
	internal string get_Prefix();
	internal bool get_CaseInsensitive();
	internal static RegexPrefix get_Empty();
	private static void .cctor();

}
//NameSpace:System.Text.RegularExpressions
internal sealed class RegexNode
{
	// Fields
	internal int _type;
	internal List`1<RegexNode> _children;
	internal string _str;
	internal char _ch;
	internal int _m;
	internal int _n;
	internal RegexOptions _options;
	internal RegexNode _next;

	// Methods
	internal void .ctor(int type, RegexOptions options);
	internal void .ctor(int type, RegexOptions options, char ch);
	internal void .ctor(int type, RegexOptions options, string str);
	internal void .ctor(int type, RegexOptions options, int m);
	internal void .ctor(int type, RegexOptions options, int m, int n);
	internal bool UseOptionR();
	internal RegexNode ReverseLeft();
	internal void MakeRep(int type, int min, int max);
	internal RegexNode Reduce();
	internal RegexNode StripEnation(int emptyType);
	internal RegexNode ReduceGroup();
	internal RegexNode ReduceRep();
	internal RegexNode ReduceSet();
	internal RegexNode ReduceAlternation();
	internal RegexNode ReduceConcatenation();
	internal RegexNode MakeQuantifier(bool lazy, int min, int max);
	internal void AddChild(RegexNode newChild);
	internal RegexNode Child(int i);
	internal int ChildCount();
	internal int Type();

}
//NameSpace:System.Text.RegularExpressions
public enum RegexOptions
{
	// Fields
	public int value__;
	public const RegexOptions None;
	public const RegexOptions IgnoreCase;
	public const RegexOptions Multiline;
	public const RegexOptions ExplicitCapture;
	public const RegexOptions Compiled;
	public const RegexOptions Singleline;
	public const RegexOptions IgnorePatternWhitespace;
	public const RegexOptions RightToLeft;
	public const RegexOptions ECMAScript;
	public const RegexOptions CultureInvariant;

}
//NameSpace:System.Text.RegularExpressions
internal sealed class RegexParser
{
	// Fields
	internal RegexNode _stack;
	internal RegexNode _group;
	internal RegexNode _alternation;
	internal RegexNode _concatenation;
	internal RegexNode _unit;
	internal string _pattern;
	internal int _currentPos;
	internal CultureInfo _culture;
	internal int _autocap;
	internal int _capcount;
	internal int _captop;
	internal int _capsize;
	internal Hashtable _caps;
	internal Hashtable _capnames;
	internal int[] _capnumlist;
	internal List`1<string> _capnamelist;
	internal RegexOptions _options;
	internal List`1<RegexOptions> _optionsStack;
	internal bool _ignoreNextParen;
	internal static readonly byte[] _category;

	// Methods
	internal static RegexTree Parse(string re, RegexOptions op);
	private void .ctor(CultureInfo culture);
	internal void SetPattern(string Re);
	internal void Reset(RegexOptions topopts);
	internal RegexNode ScanRegex();
	internal RegexCharClass ScanCharClass(bool caseInsensitive);
	internal RegexCharClass ScanCharClass(bool caseInsensitive, bool scanOnly);
	internal RegexNode ScanGroupOpen();
	internal void ScanBlank();
	internal RegexNode ScanBackslash();
	internal RegexNode ScanBasicBackslash();
	internal string ScanCapname();
	internal char ScanOctal();
	internal int ScanDecimal();
	internal char ScanHex(int c);
	internal static int HexDigit(char ch);
	internal char ScanControl();
	internal bool IsOnlyTopOption(RegexOptions option);
	internal void ScanOptions();
	internal char ScanCharEscape();
	internal string ParseProperty();
	internal int TypeFromCode(char ch);
	internal static RegexOptions OptionFromCode(char ch);
	internal void CountCaptures();
	internal void NoteCaptureSlot(int i, int pos);
	internal void NoteCaptureName(string name, int pos);
	internal void AssignNameSlots();
	internal int CaptureSlotFromName(string capname);
	internal bool IsCaptureSlot(int i);
	internal bool IsCaptureName(string capname);
	internal bool UseOptionN();
	internal bool UseOptionI();
	internal bool UseOptionM();
	internal bool UseOptionS();
	internal bool UseOptionX();
	internal bool UseOptionE();
	internal static bool IsSpecial(char ch);
	internal static bool IsStopperX(char ch);
	internal static bool IsQuantifier(char ch);
	internal bool IsTrueQuantifier();
	internal static bool IsSpace(char ch);
	internal void AddConcatenate(int pos, int cch, bool isReplacement);
	internal void PushGroup();
	internal void PopGroup();
	internal bool EmptyStack();
	internal void StartGroup(RegexNode openGroup);
	internal void AddAlternate();
	internal void AddConcatenate();
	internal void AddConcatenate(bool lazy, int min, int max);
	internal RegexNode Unit();
	internal void AddUnitOne(char ch);
	internal void AddUnitNotone(char ch);
	internal void AddUnitSet(string cc);
	internal void AddUnitNode(RegexNode node);
	internal void AddUnitType(int type);
	internal void AddGroup();
	internal void PushOptions();
	internal void PopOptions();
	internal bool EmptyOptionsStack();
	internal void PopKeepOptions();
	internal ArgumentException MakeException(string message);
	internal int Textpos();
	internal void Textto(int pos);
	internal char MoveRightGetChar();
	internal void MoveRight();
	internal void MoveRight(int i);
	internal void MoveLeft();
	internal char CharAt(int i);
	internal char RightChar();
	internal char RightChar(int i);
	internal int CharsRight();
	private static void .cctor();

}
//NameSpace:System.Text.RegularExpressions
public abstract class RegexRunnerFactory
{
}
//NameSpace:System.Text.RegularExpressions
internal sealed class RegexTree
{
	// Fields
	internal RegexNode _root;
	internal Hashtable _caps;
	internal int[] _capnumlist;
	internal Hashtable _capnames;
	internal string[] _capslist;
	internal RegexOptions _options;
	internal int _captop;

	// Methods
	internal void .ctor(RegexNode root, Hashtable caps, int[] capnumlist, int captop, Hashtable capnames, string[] capslist, RegexOptions opts);

}
//NameSpace:System.Text.RegularExpressions
internal sealed class RegexWriter
{
	// Fields
	internal int[] _intStack;
	internal int _depth;
	internal int[] _emitted;
	internal int _curpos;
	internal Dictionary`2<stringint> _stringhash;
	internal List`1<string> _stringtable;
	internal bool _counting;
	internal int _count;
	internal int _trackcount;
	internal Hashtable _caps;

	// Methods
	internal static RegexCode Write(RegexTree t);
	private void .ctor();
	internal void PushInt(int I);
	internal bool EmptyStack();
	internal int PopInt();
	internal int CurPos();
	internal void PatchJump(int Offset, int jumpDest);
	internal void Emit(int op);
	internal void Emit(int op, int opd1);
	internal void Emit(int op, int opd1, int opd2);
	internal int StringCode(string str);
	internal ArgumentException MakeException(string message);
	internal int MapCapnum(int capnum);
	internal RegexCode RegexCodeFromRegexTree(RegexTree tree);
	internal void EmitFragment(int nodetype, RegexNode node, int CurIndex);

}
//NameSpace:System.ComponentModel
public class ArrayConverter : CollectionConverter
{
	// Methods
	public void .ctor();

}
//NameSpace:System.ComponentModel
public class BooleanConverter : TypeConverter
{
	// Fields
	private static TypeConverter.StandardValuesCollection values;

	// Methods
	public void .ctor();

}
//NameSpace:System.ComponentModel
public class CollectionConverter : TypeConverter
{
	// Methods
	public void .ctor();

}
//NameSpace:System.ComponentModel
public class DecimalConverter : BaseNumberConverter
{
	// Methods
	public void .ctor();

}
//NameSpace:System.ComponentModel
public class DoubleConverter : BaseNumberConverter
{
	// Methods
	public void .ctor();

}
//NameSpace:System.ComponentModel
public sealed class EditorBrowsableAttribute : Attribute
{
	// Fields
	private EditorBrowsableState browsableState;

	// Methods
	public void .ctor(EditorBrowsableState state);
	public override bool Equals(object obj);
	public override int GetHashCode();

}
//NameSpace:System.ComponentModel
public enum EditorBrowsableState
{
	// Fields
	public int value__;
	public const EditorBrowsableState Always;
	public const EditorBrowsableState Never;
	public const EditorBrowsableState Advanced;

}
//NameSpace:System.ComponentModel
public class EnumConverter : TypeConverter
{
	// Fields
	private TypeConverter.StandardValuesCollection values;
	private Type type;

	// Methods
	public void .ctor(Type type);

}
//NameSpace:System.ComponentModel
public class Int16Converter : BaseNumberConverter
{
	// Methods
	public void .ctor();

}
//NameSpace:System.ComponentModel
public class Int32Converter : BaseNumberConverter
{
	// Methods
	public void .ctor();

}
//NameSpace:System.ComponentModel
public class Int64Converter : BaseNumberConverter
{
	// Methods
	public void .ctor();

}
//NameSpace:System.ComponentModel
public class SingleConverter : BaseNumberConverter
{
	// Methods
	public void .ctor();

}
//NameSpace:System.ComponentModel
public class StringConverter : TypeConverter
{
	// Methods
	public void .ctor();

}
//NameSpace:System.ComponentModel
public class TimeSpanConverter : TypeConverter
{
	// Methods
	public void .ctor();

}
//NameSpace:System.ComponentModel
public class TypeConverter
{
	// Fields
	private const string s_UseCompatibleTypeConverterBehavior;
	private static bool useCompatibleTypeConversion;

	// Methods
	public void .ctor();
	private static void .cctor();

}
//NameSpace:
public class TypeConverter.StandardValuesCollection : ICollection, IEnumerable
{
	// Fields
	private ICollection values;
	private Array valueArray;

	// Properties
	public int Count { get; }
	private int System.Collections.ICollection.Count { get; }
	private bool System.Collections.ICollection.IsSynchronized { get; }
	private object System.Collections.ICollection.SyncRoot { get; }

	// Methods
	public int get_Count();
	public void CopyTo(Array array, int index);
	public IEnumerator GetEnumerator();
	private int System.Collections.ICollection.get_Count();
	private bool System.Collections.ICollection.get_IsSynchronized();
	private object System.Collections.ICollection.get_SyncRoot();
	private void System.Collections.ICollection.CopyTo(Array array, int index);
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();

}
//NameSpace:System.ComponentModel
public sealed class TypeConverterAttribute : Attribute
{
	// Fields
	private string typeName;
	public static readonly TypeConverterAttribute Default;

	// Properties
	public string ConverterTypeName { get; }

	// Methods
	public void .ctor();
	public void .ctor(Type type);
	public string get_ConverterTypeName();
	public override bool Equals(object obj);
	public override int GetHashCode();
	private static void .cctor();

}
//NameSpace:System.ComponentModel
public class Win32Exception : ExternalException, ISerializable
{
	// Fields
	private readonly int nativeErrorCode;
	private static bool s_ErrorMessagesInitialized;
	private static Dictionary`2<intstring> s_ErrorMessage;

	// Methods
	public void .ctor();
	public void .ctor(int error);
	public void .ctor(int error, string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public override void GetObjectData(SerializationInfo info, StreamingContext context);
	internal static string GetErrorMessage(int error);
	private static void InitializeErrorMessages();
	private static void .cctor();

}
//NameSpace:System.ComponentModel
public abstract class BaseNumberConverter : TypeConverter
{
	// Methods
	protected void .ctor();

}
//NameSpace:System.Security.Authentication
public class AuthenticationException : SystemException
{
	// Methods
	public void .ctor();
	public void .ctor(string message, Exception innerException);
	protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext);

}
//NameSpace:System.Security.Authentication
public enum SslProtocols
{
	// Fields
	public int value__;
	public const SslProtocols None;
	public const SslProtocols Ssl2;
	public const SslProtocols Ssl3;
	public const SslProtocols Tls;
	public const SslProtocols Tls11;
	public const SslProtocols Tls12;
	public const SslProtocols Default;

}
//NameSpace:System.Security.Cryptography
public enum OidGroup
{
	// Fields
	public int value__;
	public const OidGroup All;
	public const OidGroup HashAlgorithm;
	public const OidGroup EncryptionAlgorithm;
	public const OidGroup PublicKeyAlgorithm;
	public const OidGroup SignatureAlgorithm;
	public const OidGroup Attribute;
	public const OidGroup ExtensionOrAttribute;
	public const OidGroup EnhancedKeyUsage;
	public const OidGroup Policy;
	public const OidGroup Template;
	public const OidGroup KeyDerivationFunction;

}
//NameSpace:System.Security.Cryptography
public sealed class Oid
{
	// Fields
	private string m_value;
	private string m_friendlyName;
	private OidGroup m_group;

	// Properties
	public string Value { get; set; }

	// Methods
	public void .ctor(string oid);
	internal void .ctor(string oid, OidGroup group, bool lookupFriendlyName);
	public void .ctor(string value, string friendlyName);
	public void .ctor(Oid oid);
	public string get_Value();
	public void set_Value(string value);

}
//NameSpace:System.Security.Cryptography
public sealed class OidCollection : ICollection, IEnumerable
{
	// Fields
	private ArrayList m_list;

	// Properties
	public Oid Item { get; }
	public int Count { get; }
	public bool IsSynchronized { get; }
	public object SyncRoot { get; }

	// Methods
	public void .ctor();
	public int Add(Oid oid);
	public Oid get_Item(int index);
	public int get_Count();
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();
	private void System.Collections.ICollection.CopyTo(Array array, int index);
	public bool get_IsSynchronized();
	public object get_SyncRoot();

}
//NameSpace:System.Security.Cryptography
public sealed class OidEnumerator : IEnumerator
{
	// Fields
	private OidCollection m_oids;
	private int m_current;

	// Properties
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	internal void .ctor(OidCollection oids);
	private object System.Collections.IEnumerator.get_Current();
	public bool MoveNext();

}
//NameSpace:System.Security.Cryptography
internal static class CAPI
{
	// Methods
	public static string CryptFindOIDInfoNameFromKey(string key, OidGroup oidGroup);
	public static string CryptFindOIDInfoKeyFromName(string name, OidGroup oidGroup);

}
//NameSpace:System.Security.Cryptography
internal enum AsnDecodeStatus
{
	// Fields
	public int value__;
	public const AsnDecodeStatus NotDecoded;
	public const AsnDecodeStatus Ok;
	public const AsnDecodeStatus BadAsn;
	public const AsnDecodeStatus BadTag;
	public const AsnDecodeStatus BadLength;
	public const AsnDecodeStatus InformationNotAvailable;

}
//NameSpace:System.Security.Cryptography
public class AsnEncodedData
{
	// Fields
	internal Oid _oid;
	internal byte[] _raw;

	// Properties
	public void Oid { set; }
	public byte[] RawData { get; set; }

	// Methods
	protected void .ctor();
	public void set_Oid(Oid value);
	public byte[] get_RawData();
	public void set_RawData(byte[] value);
	public virtual void CopyFrom(AsnEncodedData asnEncodedData);
	internal virtual string ToString(bool multiLine);
	internal string Default(bool multiLine);
	internal string BasicConstraintsExtension(bool multiLine);
	internal string EnhancedKeyUsageExtension(bool multiLine);
	internal string KeyUsageExtension(bool multiLine);
	internal string SubjectKeyIdentifierExtension(bool multiLine);
	internal string SubjectAltName(bool multiLine);
	internal string NetscapeCertType(bool multiLine);

}
//NameSpace:System.Security.Cryptography.X509Certificates
public enum StoreLocation
{
	// Fields
	public int value__;
	public const StoreLocation CurrentUser;
	public const StoreLocation LocalMachine;

}
//NameSpace:System.Security.Cryptography.X509Certificates
public enum X509ChainStatusFlags
{
	// Fields
	public int value__;
	public const X509ChainStatusFlags NoError;
	public const X509ChainStatusFlags NotTimeValid;
	public const X509ChainStatusFlags NotTimeNested;
	public const X509ChainStatusFlags Revoked;
	public const X509ChainStatusFlags NotSignatureValid;
	public const X509ChainStatusFlags NotValidForUsage;
	public const X509ChainStatusFlags UntrustedRoot;
	public const X509ChainStatusFlags RevocationStatusUnknown;
	public const X509ChainStatusFlags Cyclic;
	public const X509ChainStatusFlags InvalidExtension;
	public const X509ChainStatusFlags InvalidPolicyConstraints;
	public const X509ChainStatusFlags InvalidBasicConstraints;
	public const X509ChainStatusFlags InvalidNameConstraints;
	public const X509ChainStatusFlags HasNotSupportedNameConstraint;
	public const X509ChainStatusFlags HasNotDefinedNameConstraint;
	public const X509ChainStatusFlags HasNotPermittedNameConstraint;
	public const X509ChainStatusFlags HasExcludedNameConstraint;
	public const X509ChainStatusFlags PartialChain;
	public const X509ChainStatusFlags CtlNotTimeValid;
	public const X509ChainStatusFlags CtlNotSignatureValid;
	public const X509ChainStatusFlags CtlNotValidForUsage;
	public const X509ChainStatusFlags OfflineRevocation;
	public const X509ChainStatusFlags NoIssuanceChainPolicy;
	public const X509ChainStatusFlags ExplicitDistrust;
	public const X509ChainStatusFlags HasNotSupportedCriticalExtension;
	public const X509ChainStatusFlags HasWeakSignature;

}
//NameSpace:System.Security.Cryptography.X509Certificates
public enum X509KeyUsageFlags
{
	// Fields
	public int value__;
	public const X509KeyUsageFlags None;
	public const X509KeyUsageFlags EncipherOnly;
	public const X509KeyUsageFlags CrlSign;
	public const X509KeyUsageFlags KeyCertSign;
	public const X509KeyUsageFlags KeyAgreement;
	public const X509KeyUsageFlags DataEncipherment;
	public const X509KeyUsageFlags KeyEncipherment;
	public const X509KeyUsageFlags NonRepudiation;
	public const X509KeyUsageFlags DigitalSignature;
	public const X509KeyUsageFlags DecipherOnly;

}
//NameSpace:System.Security.Cryptography.X509Certificates
public enum X509RevocationFlag
{
	// Fields
	public int value__;
	public const X509RevocationFlag EndCertificateOnly;
	public const X509RevocationFlag EntireChain;
	public const X509RevocationFlag ExcludeRoot;

}
//NameSpace:System.Security.Cryptography.X509Certificates
public enum X509RevocationMode
{
	// Fields
	public int value__;
	public const X509RevocationMode NoCheck;
	public const X509RevocationMode Online;
	public const X509RevocationMode Offline;

}
//NameSpace:System.Security.Cryptography.X509Certificates
public enum X509SubjectKeyIdentifierHashAlgorithm
{
	// Fields
	public int value__;
	public const X509SubjectKeyIdentifierHashAlgorithm Sha1;
	public const X509SubjectKeyIdentifierHashAlgorithm ShortSha1;
	public const X509SubjectKeyIdentifierHashAlgorithm CapiSha1;

}
//NameSpace:System.Security.Cryptography.X509Certificates
public enum X509VerificationFlags
{
	// Fields
	public int value__;
	public const X509VerificationFlags NoFlag;
	public const X509VerificationFlags IgnoreNotTimeValid;
	public const X509VerificationFlags IgnoreCtlNotTimeValid;
	public const X509VerificationFlags IgnoreNotTimeNested;
	public const X509VerificationFlags IgnoreInvalidBasicConstraints;
	public const X509VerificationFlags AllowUnknownCertificateAuthority;
	public const X509VerificationFlags IgnoreWrongUsage;
	public const X509VerificationFlags IgnoreInvalidName;
	public const X509VerificationFlags IgnoreInvalidPolicy;
	public const X509VerificationFlags IgnoreEndRevocationUnknown;
	public const X509VerificationFlags IgnoreCtlSignerRevocationUnknown;
	public const X509VerificationFlags IgnoreCertificateAuthorityRevocationUnknown;
	public const X509VerificationFlags IgnoreRootRevocationUnknown;
	public const X509VerificationFlags AllFlags;

}
//NameSpace:System.Security.Cryptography.X509Certificates
internal class X509Utils
{
	// Methods
	internal static string FindOidInfo(uint keyType, string keyValue, OidGroup oidGroup);
	internal static string FindOidInfoWithFallback(uint key, string value, OidGroup group);

}
//NameSpace:System.Security.Cryptography.X509Certificates
public sealed class PublicKey
{
	// Fields
	private AsnEncodedData _keyValue;
	private AsnEncodedData _params;
	private Oid _oid;
	private static byte[] Empty;

	// Properties
	public AsnEncodedData EncodedKeyValue { get; }
	public AsnEncodedData EncodedParameters { get; }
	public Oid Oid { get; }

	// Methods
	public AsnEncodedData get_EncodedKeyValue();
	public AsnEncodedData get_EncodedParameters();
	public Oid get_Oid();
	private static void .cctor();

}
//NameSpace:System.Security.Cryptography.X509Certificates
public sealed class X509BasicConstraintsExtension : X509Extension
{
	// Fields
	internal const string oid;
	internal const string friendlyName;
	private bool _certificateAuthority;
	private bool _hasPathLengthConstraint;
	private int _pathLengthConstraint;
	private AsnDecodeStatus _status;

	// Properties
	public bool CertificateAuthority { get; }
	public bool HasPathLengthConstraint { get; }
	public int PathLengthConstraint { get; }

	// Methods
	public void .ctor();
	public void .ctor(AsnEncodedData encodedBasicConstraints, bool critical);
	public void .ctor(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint, bool critical);
	public bool get_CertificateAuthority();
	public bool get_HasPathLengthConstraint();
	public int get_PathLengthConstraint();
	public override void CopyFrom(AsnEncodedData asnEncodedData);
	internal AsnDecodeStatus Decode(byte[] extension);
	internal byte[] Encode();
	internal override string ToString(bool multiLine);

}
//NameSpace:System.Security.Cryptography.X509Certificates
public class X509Certificate2Collection : X509CertificateCollection
{
	// Fields
	private static string[] newline_split;

	// Methods
	private static void .cctor();

}
//NameSpace:System.Security.Cryptography.X509Certificates
internal abstract class X509Certificate2Impl : X509CertificateImpl
{
	// Properties
	internal abstract X509CertificateImplCollection IntermediateCertificates { get; }

	// Methods
	internal abstract X509CertificateImplCollection get_IntermediateCertificates();

}
//NameSpace:System.Security.Cryptography.X509Certificates
public class X509CertificateCollection : CollectionBase
{
	// Methods
	public void .ctor();
	public X509CertificateCollection.X509CertificateEnumerator GetEnumerator();
	public override int GetHashCode();

}
//NameSpace:
public class X509CertificateCollection.X509CertificateEnumerator : IEnumerator
{
	// Fields
	private IEnumerator enumerator;

	// Properties
	public X509Certificate Current { get; }
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	public void .ctor(X509CertificateCollection mappings);
	public X509Certificate get_Current();
	private object System.Collections.IEnumerator.get_Current();
	private bool System.Collections.IEnumerator.MoveNext();
	public bool MoveNext();

}
//NameSpace:System.Security.Cryptography.X509Certificates
internal class X509CertificateImplCollection : IDisposable
{
	// Fields
	private List`1<X509CertificateImpl> list;

	// Properties
	public int Count { get; }
	public X509CertificateImpl Item { get; }

	// Methods
	public int get_Count();
	public X509CertificateImpl get_Item(int index);
	public void Dispose();
	protected virtual void Dispose(bool disposing);
	protected override void Finalize();

}
//NameSpace:System.Security.Cryptography.X509Certificates
public class X509Chain : IDisposable
{
	// Fields
	private X509ChainImpl impl;

	// Properties
	internal X509ChainImpl Impl { get; }
	public void ChainPolicy { set; }

	// Methods
	internal X509ChainImpl get_Impl();
	public void .ctor();
	public void .ctor(bool useMachineContext);
	public void set_ChainPolicy(X509ChainPolicy value);
	public void Dispose();
	protected virtual void Dispose(bool disposing);
	protected override void Finalize();

}
//NameSpace:System.Security.Cryptography.X509Certificates
public sealed class X509ChainElementCollection : ICollection, IEnumerable
{
	// Fields
	private ArrayList _list;

	// Properties
	public int Count { get; }
	public bool IsSynchronized { get; }
	public object SyncRoot { get; }

	// Methods
	internal void .ctor();
	public int get_Count();
	public bool get_IsSynchronized();
	public object get_SyncRoot();
	private void System.Collections.ICollection.CopyTo(Array array, int index);
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();

}
//NameSpace:System.Security.Cryptography.X509Certificates
public sealed class X509ChainElementEnumerator : IEnumerator
{
	// Fields
	private IEnumerator enumerator;

	// Properties
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	internal void .ctor(IEnumerable enumerable);
	private object System.Collections.IEnumerator.get_Current();
	public bool MoveNext();

}
//NameSpace:System.Security.Cryptography.X509Certificates
internal abstract class X509ChainImpl : IDisposable
{
	// Properties
	public abstract bool IsValid { get; }
	public abstract void ChainPolicy { set; }

	// Methods
	public abstract bool get_IsValid();
	public abstract void set_ChainPolicy(X509ChainPolicy value);
	public void Dispose();
	protected virtual void Dispose(bool disposing);
	protected override void Finalize();
	protected void .ctor();

}
//NameSpace:System.Security.Cryptography.X509Certificates
internal class X509ChainImplMono : X509ChainImpl
{
	// Fields
	private StoreLocation location;
	private X509ChainElementCollection elements;
	private X509ChainPolicy policy;
	private static X509ChainStatus[] Empty;

	// Properties
	public override bool IsValid { get; }
	public override void ChainPolicy { set; }

	// Methods
	public void .ctor(bool useMachineContext);
	public override bool get_IsValid();
	public override void set_ChainPolicy(X509ChainPolicy value);
	private static void .cctor();

}
//NameSpace:System.Security.Cryptography.X509Certificates
public sealed class X509ChainPolicy
{
	// Fields
	private OidCollection apps;
	private OidCollection cert;
	private X509CertificateCollection store;
	private X509Certificate2Collection store2;
	private X509RevocationFlag rflag;
	private X509RevocationMode mode;
	private TimeSpan timeout;
	private X509VerificationFlags vflags;
	private DateTime vtime;

	// Methods
	public void .ctor();
	internal void .ctor(X509CertificateCollection store);
	public void Reset();

}
//NameSpace:System.Security.Cryptography.X509Certificates
public struct X509ChainStatus
{
	// Fields
	private X509ChainStatusFlags status;
	private string info;

}
//NameSpace:System.Security.Cryptography.X509Certificates
public sealed class X509EnhancedKeyUsageExtension : X509Extension
{
	// Fields
	private OidCollection _enhKeyUsage;
	private AsnDecodeStatus _status;

	// Methods
	public void .ctor(AsnEncodedData encodedEnhancedKeyUsages, bool critical);
	public override void CopyFrom(AsnEncodedData asnEncodedData);
	internal AsnDecodeStatus Decode(byte[] extension);
	internal override string ToString(bool multiLine);

}
//NameSpace:System.Security.Cryptography.X509Certificates
public class X509Extension : AsnEncodedData
{
	// Fields
	private bool _critical;

	// Properties
	public bool Critical { get; set; }

	// Methods
	protected void .ctor();
	public bool get_Critical();
	public void set_Critical(bool value);
	public override void CopyFrom(AsnEncodedData asnEncodedData);
	internal string FormatUnkownData(byte[] data);

}
//NameSpace:System.Security.Cryptography.X509Certificates
internal static class X509Helper2
{
	// Methods
	internal static X509ChainImpl CreateChainImpl(bool useMachineContext);
	public static bool IsValid(X509ChainImpl impl);
	internal static void ThrowIfContextInvalid(X509ChainImpl impl);
	internal static Exception GetInvalidChainContextException();

}
//NameSpace:System.Security.Cryptography.X509Certificates
public sealed class X509KeyUsageExtension : X509Extension
{
	// Fields
	internal const string oid;
	internal const string friendlyName;
	internal const X509KeyUsageFlags all;
	private X509KeyUsageFlags _keyUsages;
	private AsnDecodeStatus _status;

	// Properties
	public X509KeyUsageFlags KeyUsages { get; }

	// Methods
	public void .ctor();
	public void .ctor(AsnEncodedData encodedKeyUsage, bool critical);
	public void .ctor(X509KeyUsageFlags keyUsages, bool critical);
	public X509KeyUsageFlags get_KeyUsages();
	public override void CopyFrom(AsnEncodedData asnEncodedData);
	internal X509KeyUsageFlags GetValidFlags(X509KeyUsageFlags flags);
	internal AsnDecodeStatus Decode(byte[] extension);
	internal byte[] Encode();
	internal override string ToString(bool multiLine);

}
//NameSpace:System.Security.Cryptography.X509Certificates
public sealed class X509SubjectKeyIdentifierExtension : X509Extension
{
	// Fields
	internal const string oid;
	internal const string friendlyName;
	private byte[] _subjectKeyIdentifier;
	private string _ski;
	private AsnDecodeStatus _status;

	// Properties
	public string SubjectKeyIdentifier { get; }

	// Methods
	public void .ctor();
	public void .ctor(AsnEncodedData encodedSubjectKeyIdentifier, bool critical);
	public void .ctor(byte[] subjectKeyIdentifier, bool critical);
	public void .ctor(string subjectKeyIdentifier, bool critical);
	public void .ctor(PublicKey key, bool critical);
	public void .ctor(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm, bool critical);
	public string get_SubjectKeyIdentifier();
	public override void CopyFrom(AsnEncodedData asnEncodedData);
	internal static byte FromHexChar(char c);
	internal static byte FromHexChars(char c1, char c2);
	internal static byte[] FromHex(string hex);
	internal AsnDecodeStatus Decode(byte[] extension);
	internal byte[] Encode();
	internal override string ToString(bool multiLine);

}
//NameSpace:System.Net
public abstract class EndPoint
{
	// Methods
	protected void .ctor();

}
//NameSpace:System.Net
public class IPAddress
{
	// Fields
	public static readonly IPAddress Any;
	public static readonly IPAddress Loopback;
	public static readonly IPAddress Broadcast;
	public static readonly IPAddress None;
	internal const long LoopbackMask;
	internal long m_Address;
	internal string m_ToString;
	public static readonly IPAddress IPv6Any;
	public static readonly IPAddress IPv6Loopback;
	public static readonly IPAddress IPv6None;
	private AddressFamily m_Family;
	private ushort[] m_Numbers;
	private long m_ScopeId;
	private int m_HashCode;
	internal const int IPv4AddressBytes;
	internal const int IPv6AddressBytes;
	internal const int NumberOfLabels;

	// Properties
	public long ScopeId { get; }

	// Methods
	public void .ctor(long newAddress);
	public void .ctor(byte[] address, long scopeid);
	internal void .ctor(int newAddress);
	public long get_ScopeId();
	public override string ToString();
	internal bool Equals(object comparandObj, bool compareScopeId);
	public override bool Equals(object comparand);
	public override int GetHashCode();
	private static void .cctor();

}
//NameSpace:System.Net
internal struct IPv6AddressFormatter
{
	// Fields
	private ushort[] address;
	private long scopeId;

	// Methods
	public void .ctor(ushort[] addr, long scopeId);
	private static ushort SwapUShort(ushort number);
	private uint AsIPv4Int();
	private bool IsIPv4Compatible();
	private bool IsIPv4Mapped();
	public override string ToString();

}
//NameSpace:System.Net.Sockets
public class SocketException : Win32Exception
{
	// Fields
	private EndPoint m_EndPoint;

	// Properties
	public override string Message { get; }

	// Methods
	private static int WSAGetLastError_internal();
	public void .ctor();
	internal void .ctor(SocketError socketError);
	protected void .ctor(SerializationInfo serializationInfo, StreamingContext streamingContext);
	public override string get_Message();

}
//NameSpace:System.Net.Sockets
public enum AddressFamily
{
	// Fields
	public int value__;
	public const AddressFamily Unknown;
	public const AddressFamily Unspecified;
	public const AddressFamily Unix;
	public const AddressFamily InterNetwork;
	public const AddressFamily ImpLink;
	public const AddressFamily Pup;
	public const AddressFamily Chaos;
	public const AddressFamily NS;
	public const AddressFamily Ipx;
	public const AddressFamily Iso;
	public const AddressFamily Osi;
	public const AddressFamily Ecma;
	public const AddressFamily DataKit;
	public const AddressFamily Ccitt;
	public const AddressFamily Sna;
	public const AddressFamily DecNet;
	public const AddressFamily DataLink;
	public const AddressFamily Lat;
	public const AddressFamily HyperChannel;
	public const AddressFamily AppleTalk;
	public const AddressFamily NetBios;
	public const AddressFamily VoiceView;
	public const AddressFamily FireFox;
	public const AddressFamily Banyan;
	public const AddressFamily Atm;
	public const AddressFamily InterNetworkV6;
	public const AddressFamily Cluster;
	public const AddressFamily Ieee12844;
	public const AddressFamily Irda;
	public const AddressFamily NetworkDesigners;
	public const AddressFamily Max;

}
//NameSpace:System.Net.Sockets
public enum SocketError
{
	// Fields
	public int value__;
	public const SocketError Success;
	public const SocketError SocketError;
	public const SocketError Interrupted;
	public const SocketError AccessDenied;
	public const SocketError Fault;
	public const SocketError InvalidArgument;
	public const SocketError TooManyOpenSockets;
	public const SocketError WouldBlock;
	public const SocketError InProgress;
	public const SocketError AlreadyInProgress;
	public const SocketError NotSocket;
	public const SocketError DestinationAddressRequired;
	public const SocketError MessageSize;
	public const SocketError ProtocolType;
	public const SocketError ProtocolOption;
	public const SocketError ProtocolNotSupported;
	public const SocketError SocketNotSupported;
	public const SocketError OperationNotSupported;
	public const SocketError ProtocolFamilyNotSupported;
	public const SocketError AddressFamilyNotSupported;
	public const SocketError AddressAlreadyInUse;
	public const SocketError AddressNotAvailable;
	public const SocketError NetworkDown;
	public const SocketError NetworkUnreachable;
	public const SocketError NetworkReset;
	public const SocketError ConnectionAborted;
	public const SocketError ConnectionReset;
	public const SocketError NoBufferSpaceAvailable;
	public const SocketError IsConnected;
	public const SocketError NotConnected;
	public const SocketError Shutdown;
	public const SocketError TimedOut;
	public const SocketError ConnectionRefused;
	public const SocketError HostDown;
	public const SocketError HostUnreachable;
	public const SocketError ProcessLimit;
	public const SocketError SystemNotReady;
	public const SocketError VersionNotSupported;
	public const SocketError NotInitialized;
	public const SocketError Disconnecting;
	public const SocketError TypeNotFound;
	public const SocketError HostNotFound;
	public const SocketError TryAgain;
	public const SocketError NoRecovery;
	public const SocketError NoData;
	public const SocketError IOPending;
	public const SocketError OperationAborted;

}
//NameSpace:System.Net.Security
public abstract class AuthenticatedStream : Stream
{
	// Fields
	private Stream _InnerStream;
	private bool _LeaveStreamOpen;

	// Properties
	protected Stream InnerStream { get; }
	public abstract bool IsAuthenticated { get; }

	// Methods
	protected void .ctor(Stream innerStream, bool leaveInnerStreamOpen);
	protected Stream get_InnerStream();
	protected override void Dispose(bool disposing);
	public abstract bool get_IsAuthenticated();

}
//NameSpace:System.Net.Security
public class SslStream : AuthenticatedStream
{
	// Fields
	private MonoTlsProvider provider;
	private IMonoSslStream impl;

	// Properties
	internal IMonoSslStream Impl { get; }
	public override bool IsAuthenticated { get; }
	public override bool CanSeek { get; }
	public override bool CanRead { get; }
	public override bool CanWrite { get; }
	public override long Length { get; }
	public override long Position { get; set; }

	// Methods
	internal IMonoSslStream get_Impl();
	internal void .ctor(Stream innerStream, bool leaveInnerStreamOpen, MonoTlsProvider provider, MonoTlsSettings settings);
	internal static IMonoSslStream CreateMonoSslStream(Stream innerStream, bool leaveInnerStreamOpen, MonoTlsProvider provider, MonoTlsSettings settings);
	public override bool get_IsAuthenticated();
	public override bool get_CanSeek();
	public override bool get_CanRead();
	public override bool get_CanWrite();
	public override long get_Length();
	public override long get_Position();
	public override void set_Position(long value);
	public override long Seek(long offset, SeekOrigin origin);
	public override void Flush();
	private void CheckDisposed();
	protected override void Dispose(bool disposing);
	public override int Read(byte[] buffer, int offset, int count);
	public override void Write(byte[] buffer, int offset, int count);
	public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
	public override int EndRead(IAsyncResult asyncResult);
	public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
	public override void EndWrite(IAsyncResult asyncResult);

}
//NameSpace:System.Collections.Generic
internal sealed class ICollectionDebugView`1
{
}
//NameSpace:System.Collections.Generic
public class LinkedList`1 : ICollection`1<T>, IEnumerable`1<T>, IEnumerable, ICollection, IReadOnlyCollection`1<T>, ISerializable, IDeserializationCallback
{
	// Fields
	internal LinkedListNode`1<T> head;
	internal int count;
	internal int version;
	private object _syncRoot;
	private SerializationInfo _siInfo;

	// Properties
	public int Count { get; }
	public LinkedListNode`1<T> First { get; }
	private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
	private bool System.Collections.ICollection.IsSynchronized { get; }
	private object System.Collections.ICollection.SyncRoot { get; }

	// Methods
	public void .ctor();
	protected void .ctor(SerializationInfo info, StreamingContext context);
	public int get_Count();
	public LinkedListNode`1<T> get_First();
	private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
	private void System.Collections.Generic.ICollection<T>.Add(T value);
	public LinkedListNode`1<T> AddFirst(T value);
	public void AddFirst(LinkedListNode`1<T> node);
	public LinkedListNode`1<T> AddLast(T value);
	public void Clear();
	public bool Contains(T value);
	public void CopyTo(T[] array, int index);
	public LinkedListNode`1<T> Find(T value);
	public Enumerator<T> GetEnumerator();
	private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
	public bool Remove(T value);
	public void Remove(LinkedListNode`1<T> node);
	public void RemoveLast();
	public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
	public virtual void OnDeserialization(object sender);
	private void InternalInsertNodeBefore(LinkedListNode`1<T> node, LinkedListNode`1<T> newNode);
	private void InternalInsertNodeToEmptyList(LinkedListNode`1<T> newNode);
	internal void InternalRemoveNode(LinkedListNode`1<T> node);
	internal void ValidateNewNode(LinkedListNode`1<T> node);
	internal void ValidateNode(LinkedListNode`1<T> node);
	private bool System.Collections.ICollection.get_IsSynchronized();
	private object System.Collections.ICollection.get_SyncRoot();
	private void System.Collections.ICollection.CopyTo(Array array, int index);
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();

}
//NameSpace:
public struct LinkedList`1.Enumerator : IEnumerator`1<T>, IDisposable, IEnumerator, ISerializable, IDeserializationCallback
{
	// Fields
	private LinkedList`1<T> _list;
	private LinkedListNode`1<T> _node;
	private int _version;
	private T _current;
	private int _index;

	// Properties
	public T Current { get; }
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	internal void .ctor(LinkedList`1<T> list);
	private void .ctor(SerializationInfo info, StreamingContext context);
	public T get_Current();
	private object System.Collections.IEnumerator.get_Current();
	public bool MoveNext();
	public void Dispose();
	private void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
	private void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);

}
//NameSpace:System.Collections.Generic
public sealed class LinkedListNode`1
{
	// Fields
	internal LinkedList`1<T> list;
	internal LinkedListNode`1<T> next;
	internal LinkedListNode`1<T> prev;
	internal T item;

	// Properties
	public LinkedListNode`1<T> Next { get; }
	public T Value { get; }

	// Methods
	internal void .ctor(LinkedList`1<T> list, T value);
	public LinkedListNode`1<T> get_Next();
	public T get_Value();
	internal void Invalidate();

}
//NameSpace:System.Collections.Generic
public class Stack`1 : IEnumerable`1<T>, IEnumerable, ICollection, IReadOnlyCollection`1<T>
{
	// Fields
	private T[] _array;
	private int _size;
	private int _version;
	private object _syncRoot;

	// Properties
	public int Count { get; }
	private bool System.Collections.ICollection.IsSynchronized { get; }
	private object System.Collections.ICollection.SyncRoot { get; }

	// Methods
	public void .ctor();
	public int get_Count();
	private bool System.Collections.ICollection.get_IsSynchronized();
	private object System.Collections.ICollection.get_SyncRoot();
	private void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
	private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();
	public T Peek();
	public T Pop();
	public void Push(T item);
	private void ThrowForEmptyStack();

}
//NameSpace:
public struct Stack`1.Enumerator : IEnumerator`1<T>, IDisposable, IEnumerator
{
	// Fields
	private readonly Stack`1<T> _stack;
	private readonly int _version;
	private int _index;
	private T _currentElement;

	// Properties
	public T Current { get; }
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	internal void .ctor(Stack`1<T> stack);
	public void Dispose();
	public bool MoveNext();
	public T get_Current();
	private void ThrowEnumerationNotStartedOrEnded();
	private object System.Collections.IEnumerator.get_Current();

}
//NameSpace:System.Collections.Generic
internal sealed class StackDebugView`1
{
}
//NameSpace:System.Collections.Generic
public interface ISet`1 : ICollection`1<T>, IEnumerable`1<T>, IEnumerable
{
}
//NameSpace:
internal sealed class <PrivateImplementationDetails>
{
	// Fields
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=32 59F5BD34B6C013DEACC784F69C67E95150033A84;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=32 C02C28AFEBE998F767E4AF43E3BE8F5E9FA11536;
	internal static readonly <PrivateImplementationDetails>.__StaticArrayInitTypeSize=128 CCEEADA43268372341F81AE0C9208C6856441C04;
	internal static readonly long E5BC1BAFADE1862DD6E0B9FB632BFAA6C3873A78;

	// Methods
	internal static uint ComputeStringHash(string s);

}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=32
{
}
//NameSpace:
private struct <PrivateImplementationDetails>.__StaticArrayInitTypeSize=128
{
}
//NameSpace:System.Configuration
public interface IConfigurationSectionHandler
{
}
//NameSpace:System.Net.Configuration
public sealed class BypassElement : ConfigurationElement
{
	// Properties
	protected override ConfigurationPropertyCollection Properties { get; }

	// Methods
	protected override ConfigurationPropertyCollection get_Properties();

}
//NameSpace:System.Net.Configuration
public sealed class BypassElementCollection : ConfigurationElementCollection
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Net.Configuration
public sealed class ConnectionManagementElement : ConfigurationElement
{
	// Properties
	protected override ConfigurationPropertyCollection Properties { get; }

	// Methods
	protected override ConfigurationPropertyCollection get_Properties();

}
//NameSpace:System.Net.Configuration
public sealed class ConnectionManagementElementCollection : ConfigurationElementCollection
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Net.Configuration
public sealed class ConnectionManagementSection : ConfigurationSection
{
	// Properties
	protected override ConfigurationPropertyCollection Properties { get; }

	// Methods
	public void .ctor();
	protected override ConfigurationPropertyCollection get_Properties();

}
//NameSpace:System.Net.Configuration
public sealed class DefaultProxySection : ConfigurationSection
{
	// Properties
	protected override ConfigurationPropertyCollection Properties { get; }

	// Methods
	public void .ctor();
	protected override ConfigurationPropertyCollection get_Properties();
	protected override void Reset(ConfigurationElement parentElement);

}
//NameSpace:System.Net.Configuration
public sealed class ProxyElement : ConfigurationElement
{
	// Properties
	protected override ConfigurationPropertyCollection Properties { get; }

	// Methods
	public void .ctor();
	protected override ConfigurationPropertyCollection get_Properties();

}
//NameSpace:System.Net.Configuration
public sealed class HttpWebRequestElement : ConfigurationElement
{
	// Properties
	protected override ConfigurationPropertyCollection Properties { get; }

	// Methods
	public void .ctor();
	protected override ConfigurationPropertyCollection get_Properties();

}
//NameSpace:System.Net.Configuration
public sealed class Ipv6Element : ConfigurationElement
{
	// Properties
	protected override ConfigurationPropertyCollection Properties { get; }

	// Methods
	public void .ctor();
	protected override ConfigurationPropertyCollection get_Properties();

}
//NameSpace:System.Net.Configuration
public sealed class NetSectionGroup : ConfigurationSectionGroup
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Net.Configuration
public sealed class SettingsSection : ConfigurationSection
{
	// Properties
	protected override ConfigurationPropertyCollection Properties { get; }

	// Methods
	public void .ctor();
	protected override ConfigurationPropertyCollection get_Properties();

}
//NameSpace:System.Net.Configuration
public sealed class PerformanceCountersElement : ConfigurationElement
{
	// Properties
	protected override ConfigurationPropertyCollection Properties { get; }

	// Methods
	public void .ctor();
	protected override ConfigurationPropertyCollection get_Properties();

}
//NameSpace:System.Net.Configuration
public sealed class ServicePointManagerElement : ConfigurationElement
{
	// Properties
	protected override ConfigurationPropertyCollection Properties { get; }

	// Methods
	public void .ctor();
	protected override ConfigurationPropertyCollection get_Properties();

}
//NameSpace:System.Net.Configuration
public sealed class SocketElement : ConfigurationElement
{
	// Properties
	protected override ConfigurationPropertyCollection Properties { get; }

	// Methods
	public void .ctor();
	protected override ConfigurationPropertyCollection get_Properties();

}
//NameSpace:System.Net.Configuration
public sealed class WebProxyScriptElement : ConfigurationElement
{
	// Properties
	protected override ConfigurationPropertyCollection Properties { get; }

	// Methods
	public void .ctor();
	protected override ConfigurationPropertyCollection get_Properties();

}
//NameSpace:System.Net.Configuration
public sealed class WebRequestModulesSection : ConfigurationSection
{
	// Properties
	protected override ConfigurationPropertyCollection Properties { get; }

	// Methods
	public void .ctor();
	protected override ConfigurationPropertyCollection get_Properties();

}
//NameSpace:System.Net.Configuration
public sealed class WebRequestModuleElementCollection : ConfigurationElementCollection
{
	// Methods
	public void .ctor();

}
//NameSpace:System.Net.Configuration
public sealed class WebRequestModuleElement : ConfigurationElement
{
	// Properties
	protected override ConfigurationPropertyCollection Properties { get; }

	// Methods
	protected override ConfigurationPropertyCollection get_Properties();

}
//NameSpace:System.Diagnostics
public class DiagnosticsConfigurationHandler : IConfigurationSectionHandler
{
	// Methods
	public void .ctor();
	public virtual object Create(object parent, object configContext, XmlNode section);

}
//NameSpace:Unity
internal sealed class ThrowStub : ObjectDisposedException
{
	// Methods
	public static void ThrowNotSupportedException();

}
//NameSpace:
internal class <Module>
{
}
//NameSpace:System.Linq
internal static class Error
{
	// Methods
	internal static Exception ArgumentNull(string s);
	internal static Exception MoreThanOneMatch();

}
//NameSpace:System.Linq
public static class Enumerable
{
	// Methods
	public static IEnumerable`1<T> Where(IEnumerable`1<T> source, Func`2<Tbool> predicate);
	private static Func`2<Tbool> CombinePredicates(Func`2<Tbool> predicate1, Func`2<Tbool> predicate2);
	public static T SingleOrDefault(IEnumerable`1<T> source, Func`2<Tbool> predicate);
	public static bool Any(IEnumerable`1<T> source);
	public static bool Any(IEnumerable`1<T> source, Func`2<Tbool> predicate);

}
//NameSpace:
private abstract class Enumerable.Iterator`1 : IEnumerable`1<T>, IEnumerable, IEnumerator`1<T>, IDisposable, IEnumerator
{
	// Fields
	private int threadId;
	internal int state;
	internal T current;

	// Properties
	public T Current { get; }
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	public void .ctor();
	public T get_Current();
	public abstract Iterator`1<T> Clone();
	public virtual void Dispose();
	public IEnumerator`1<T> GetEnumerator();
	public abstract bool MoveNext();
	public abstract IEnumerable`1<T> Where(Func`2<Tbool> predicate);
	private object System.Collections.IEnumerator.get_Current();
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();

}
//NameSpace:
private class Enumerable.WhereEnumerableIterator`1 : Iterator`1<T>
{
	// Fields
	private IEnumerable`1<T> source;
	private Func`2<Tbool> predicate;
	private IEnumerator`1<T> enumerator;

	// Methods
	public void .ctor(IEnumerable`1<T> source, Func`2<Tbool> predicate);
	public override Iterator`1<T> Clone();
	public override void Dispose();
	public override bool MoveNext();
	public override IEnumerable`1<T> Where(Func`2<Tbool> predicate);

}
//NameSpace:
private class Enumerable.WhereArrayIterator`1 : Iterator`1<T>
{
	// Fields
	private T[] source;
	private Func`2<Tbool> predicate;
	private int index;

	// Methods
	public void .ctor(T[] source, Func`2<Tbool> predicate);
	public override Iterator`1<T> Clone();
	public override bool MoveNext();
	public override IEnumerable`1<T> Where(Func`2<Tbool> predicate);

}
//NameSpace:
private class Enumerable.WhereListIterator`1 : Iterator`1<T>
{
	// Fields
	private List`1<T> source;
	private Func`2<Tbool> predicate;
	private Enumerator<T> enumerator;

	// Methods
	public void .ctor(List`1<T> source, Func`2<Tbool> predicate);
	public override Iterator`1<T> Clone();
	public override bool MoveNext();
	public override IEnumerable`1<T> Where(Func`2<Tbool> predicate);

}
//NameSpace:
private sealed class Enumerable.<>c__DisplayClass6_0`1
{
	// Fields
	public Func`2<Tbool> predicate1;
	public Func`2<Tbool> predicate2;

	// Methods
	public void .ctor();
	internal bool <CombinePredicates>b__0(T x);

}
//NameSpace:System.Collections.Generic
public class HashSet`1 : ICollection`1<T>, IEnumerable`1<T>, IEnumerable, ISet`1<T>, IReadOnlyCollection`1<T>, ISerializable, IDeserializationCallback
{
	// Fields
	private const int Lower31BitMask;
	private const int StackAllocThreshold;
	private const int ShrinkThreshold;
	private const string CapacityName;
	private const string ElementsName;
	private const string ComparerName;
	private const string VersionName;
	private int[] _buckets;
	private Slot<T>[] _slots;
	private int _count;
	private int _lastIndex;
	private int _freeList;
	private IEqualityComparer`1<T> _comparer;
	private int _version;
	private SerializationInfo _siInfo;

	// Properties
	public int Count { get; }
	private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }

	// Methods
	public void .ctor();
	public void .ctor(IEqualityComparer`1<T> comparer);
	protected void .ctor(SerializationInfo info, StreamingContext context);
	private void System.Collections.Generic.ICollection<T>.Add(T item);
	public void Clear();
	public bool Contains(T item);
	public void CopyTo(T[] array, int arrayIndex);
	public bool Remove(T item);
	public int get_Count();
	private bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
	public Enumerator<T> GetEnumerator();
	private IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();
	public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
	public virtual void OnDeserialization(object sender);
	public bool Add(T item);
	public void CopyTo(T[] array);
	public void CopyTo(T[] array, int arrayIndex, int count);
	private void Initialize(int capacity);
	private void IncreaseCapacity();
	private void SetCapacity(int newSize);
	private bool AddIfNotPresent(T value);
	private int InternalGetHashCode(T item);

}
//NameSpace:
internal struct HashSet`1.Slot
{
	// Fields
	internal int hashCode;
	internal int next;
	internal T value;

}
//NameSpace:
public struct HashSet`1.Enumerator : IEnumerator`1<T>, IDisposable, IEnumerator
{
	// Fields
	private HashSet`1<T> _set;
	private int _index;
	private int _version;
	private T _current;

	// Properties
	public T Current { get; }
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	internal void .ctor(HashSet`1<T> set);
	public void Dispose();
	public bool MoveNext();
	public T get_Current();
	private object System.Collections.IEnumerator.get_Current();

}
//NameSpace:System.Collections.Generic
internal sealed class ICollectionDebugView`1
{
}
//NameSpace:
internal class <Module>
{
}
//NameSpace:UnityEngine.Scripting
internal class UsedByNativeCodeAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine.Scripting
internal class RequiredByNativeCodeAttribute : Attribute
{
	// Fields
	private bool <Optional>k__BackingField;
	private bool <GenerateProxy>k__BackingField;

	// Properties
	public void Optional { set; }
	public void GenerateProxy { set; }

	// Methods
	public void .ctor();
	public void set_Optional(bool value);
	public void set_GenerateProxy(bool value);

}
//NameSpace:UnityEngine.Scripting
internal class GeneratedByOldBindingsGeneratorAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine
internal sealed class AssetFileNameExtensionAttribute : Attribute
{
	// Fields
	private readonly string <preferredExtension>k__BackingField;
	private readonly IEnumerable`1<string> <otherExtensions>k__BackingField;

	// Methods
	public void .ctor(string preferredExtension, string[] otherExtensions);

}
//NameSpace:UnityEngine
internal class ThreadAndSerializationSafeAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine
internal class WritableAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine
internal class UnityEngineModuleAssembly : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine
internal sealed class NativeClassAttribute : Attribute
{
	// Fields
	private string <QualifiedNativeName>k__BackingField;
	private string <Declaration>k__BackingField;

	// Properties
	private void QualifiedNativeName { set; }
	private void Declaration { set; }

	// Methods
	public void .ctor(string qualifiedCppName);
	public void .ctor(string qualifiedCppName, string declaration);
	private void set_QualifiedNativeName(string value);
	private void set_Declaration(string value);

}
//NameSpace:UnityEngine.Bindings
internal class VisibleToOtherModulesAttribute : Attribute
{
	// Methods
	public void .ctor();
	public void .ctor(string[] modules);

}
//NameSpace:UnityEngine.Bindings
internal interface IBindingsAttribute
{
}
//NameSpace:UnityEngine.Bindings
internal interface IBindingsNameProviderAttribute : IBindingsAttribute
{
}
//NameSpace:UnityEngine.Bindings
internal interface IBindingsHeaderProviderAttribute : IBindingsAttribute
{
}
//NameSpace:UnityEngine.Bindings
internal interface IBindingsIsThreadSafeProviderAttribute : IBindingsAttribute
{
}
//NameSpace:UnityEngine.Bindings
internal interface IBindingsIsFreeFunctionProviderAttribute : IBindingsAttribute
{
}
//NameSpace:UnityEngine.Bindings
internal interface IBindingsThrowsProviderAttribute : IBindingsAttribute
{
}
//NameSpace:UnityEngine.Bindings
internal interface IBindingsGenerateMarshallingTypeAttribute : IBindingsAttribute
{
}
//NameSpace:UnityEngine.Bindings
internal interface IBindingsWritableSelfProviderAttribute : IBindingsAttribute
{
}
//NameSpace:UnityEngine.Bindings
internal class NativeConditionalAttribute : Attribute, IBindingsAttribute
{
	// Fields
	private string <Condition>k__BackingField;
	private bool <Enabled>k__BackingField;

	// Properties
	public void Condition { set; }
	public void Enabled { set; }

	// Methods
	public void .ctor(string condition);
	public void set_Condition(string value);
	public void set_Enabled(bool value);

}
//NameSpace:UnityEngine.Bindings
internal class NativeHeaderAttribute : Attribute, IBindingsHeaderProviderAttribute, IBindingsAttribute
{
	// Fields
	private string <Header>k__BackingField;

	// Properties
	public void Header { set; }

	// Methods
	public void .ctor(string header);
	public void set_Header(string value);

}
//NameSpace:UnityEngine.Bindings
internal class NativeNameAttribute : Attribute, IBindingsNameProviderAttribute, IBindingsAttribute
{
	// Fields
	private string <Name>k__BackingField;

	// Properties
	public void Name { set; }

	// Methods
	public void .ctor(string name);
	public void set_Name(string value);

}
//NameSpace:UnityEngine.Bindings
internal sealed class NativeWritableSelfAttribute : Attribute, IBindingsWritableSelfProviderAttribute, IBindingsAttribute
{
	// Fields
	private bool <WritableSelf>k__BackingField;

	// Properties
	public void WritableSelf { set; }

	// Methods
	public void .ctor();
	public void set_WritableSelf(bool value);

}
//NameSpace:UnityEngine.Bindings
internal class NativeMethodAttribute : Attribute, IBindingsNameProviderAttribute, IBindingsIsThreadSafeProviderAttribute, IBindingsIsFreeFunctionProviderAttribute, IBindingsThrowsProviderAttribute, IBindingsAttribute
{
	// Fields
	private string <Name>k__BackingField;
	private bool <IsThreadSafe>k__BackingField;
	private bool <IsFreeFunction>k__BackingField;
	private bool <ThrowsException>k__BackingField;
	private bool <HasExplicitThis>k__BackingField;

	// Properties
	public void Name { set; }
	public void IsThreadSafe { set; }
	public void IsFreeFunction { set; }
	public void ThrowsException { set; }
	public void HasExplicitThis { set; }

	// Methods
	public void .ctor();
	public void .ctor(string name);
	public void .ctor(string name, bool isFreeFunction);
	public void .ctor(string name, bool isFreeFunction, bool isThreadSafe);
	public void set_Name(string value);
	public void set_IsThreadSafe(bool value);
	public void set_IsFreeFunction(bool value);
	public void set_ThrowsException(bool value);
	public void set_HasExplicitThis(bool value);

}
//NameSpace:UnityEngine.Bindings
internal enum TargetType
{
	// Fields
	public int value__;
	public const TargetType Function;
	public const TargetType Field;

}
//NameSpace:UnityEngine.Bindings
internal class NativePropertyAttribute : NativeMethodAttribute
{
	// Fields
	private TargetType <TargetType>k__BackingField;

	// Properties
	public void TargetType { set; }

	// Methods
	public void .ctor();
	public void .ctor(string name);
	public void .ctor(string name, bool isFree, TargetType targetType);
	public void set_TargetType(TargetType value);

}
//NameSpace:UnityEngine.Bindings
internal enum CodegenOptions
{
	// Fields
	public int value__;
	public const CodegenOptions Auto;
	public const CodegenOptions Custom;
	public const CodegenOptions Force;

}
//NameSpace:UnityEngine.Bindings
internal class NativeTypeAttribute : Attribute, IBindingsHeaderProviderAttribute, IBindingsGenerateMarshallingTypeAttribute, IBindingsAttribute
{
	// Fields
	private string <Header>k__BackingField;
	private string <IntermediateScriptingStructName>k__BackingField;
	private CodegenOptions <CodegenOptions>k__BackingField;

	// Properties
	public void Header { set; }
	public void IntermediateScriptingStructName { set; }
	public void CodegenOptions { set; }

	// Methods
	public void .ctor();
	public void .ctor(CodegenOptions codegenOptions);
	public void .ctor(string header);
	public void .ctor(CodegenOptions codegenOptions, string intermediateStructName);
	public void set_Header(string value);
	public void set_IntermediateScriptingStructName(string value);
	public void set_CodegenOptions(CodegenOptions value);

}
//NameSpace:UnityEngine.Bindings
internal class NotNullAttribute : Attribute, IBindingsAttribute
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine.Bindings
internal class UnmarshalledAttribute : Attribute, IBindingsAttribute
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine.Bindings
internal class FreeFunctionAttribute : NativeMethodAttribute
{
	// Methods
	public void .ctor();
	public void .ctor(string name);
	public void .ctor(string name, bool isThreadSafe);

}
//NameSpace:UnityEngine.Bindings
internal class ThreadSafeAttribute : NativeMethodAttribute
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine.Bindings
internal enum StaticAccessorType
{
	// Fields
	public int value__;
	public const StaticAccessorType Dot;
	public const StaticAccessorType Arrow;
	public const StaticAccessorType DoubleColon;
	public const StaticAccessorType ArrowWithDefaultReturnIfNull;

}
//NameSpace:UnityEngine.Bindings
internal class StaticAccessorAttribute : Attribute, IBindingsAttribute
{
	// Fields
	private string <Name>k__BackingField;
	private StaticAccessorType <Type>k__BackingField;

	// Properties
	public void Name { set; }
	public void Type { set; }

	// Methods
	internal void .ctor(string name);
	public void .ctor(string name, StaticAccessorType type);
	public void set_Name(string value);
	public void set_Type(StaticAccessorType value);

}
//NameSpace:UnityEngine.Bindings
internal class NativeThrowsAttribute : Attribute, IBindingsThrowsProviderAttribute, IBindingsAttribute
{
	// Fields
	private bool <ThrowsException>k__BackingField;

	// Properties
	public void ThrowsException { set; }

	// Methods
	public void .ctor();
	public void set_ThrowsException(bool value);

}
//NameSpace:UnityEngine.Bindings
internal class IgnoreAttribute : Attribute, IBindingsAttribute
{
	// Fields
	private bool <DoesNotContributeToSize>k__BackingField;

	// Properties
	public void DoesNotContributeToSize { set; }

	// Methods
	public void .ctor();
	public void set_DoesNotContributeToSize(bool value);

}
//NameSpace:UnityEngine
internal sealed class UnityString
{
	// Methods
	public static string Format(string fmt, object[] args);

}
//NameSpace:
internal class <Module>
{
}
//NameSpace:UnityEngine
public struct Keyframe
{
	// Fields
	private float m_Time;
	private float m_Value;
	private float m_InTangent;
	private float m_OutTangent;
	private int m_WeightedMode;
	private float m_InWeight;
	private float m_OutWeight;

}
//NameSpace:UnityEngine
public class AnimationCurve : IEquatable`1<AnimationCurve>
{
	// Fields
	internal IntPtr m_Ptr;

	// Methods
	public void .ctor(Keyframe[] keys);
	public void .ctor();
	private static void Internal_Destroy(IntPtr ptr);
	private static IntPtr Internal_Create(Keyframe[] keys);
	private bool Internal_Equals(IntPtr other);
	protected override void Finalize();
	public override bool Equals(object o);
	public bool Equals(AnimationCurve other);
	public override int GetHashCode();

}
//NameSpace:UnityEngine
public class Application
{
	// Fields
	private static Application.LowMemoryCallback lowMemory;
	private static Application.LogCallback s_LogCallbackHandler;
	private static Application.LogCallback s_LogCallbackHandlerThreaded;
	private static Action`1<bool> focusChanged;
	private static Func`1<bool> wantsToQuit;
	private static Action quitting;

	// Properties
	public static bool isPlaying { get; }
	public static RuntimePlatform platform { get; }
	public static bool isEditor { get; }

	// Methods
	public static bool get_isPlaying();
	public static RuntimePlatform get_platform();
	private static void CallLowMemory();
	private static void CallLogCallback(string logString, string stackTrace, LogType type, bool invokedOnMainThread);
	public static bool get_isEditor();
	private static bool Internal_ApplicationWantsToQuit();
	private static void Internal_ApplicationQuit();
	internal static void InvokeOnBeforeRender();
	internal static void InvokeFocusChanged(bool focus);

}
//NameSpace:
public sealed class Application.LowMemoryCallback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke();
	public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class Application.LogCallback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(string condition, string stackTrace, LogType type);
	public virtual IAsyncResult BeginInvoke(string condition, string stackTrace, LogType type, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine
public class AsyncOperation : YieldInstruction
{
	// Fields
	internal IntPtr m_Ptr;
	private Action`1<AsyncOperation> m_completeCallback;

	// Methods
	private static void InternalDestroy(IntPtr ptr);
	protected override void Finalize();
	internal void InvokeCompletionEvent();

}
//NameSpace:UnityEngine
internal class AttributeHelperEngine
{
	// Fields
	public static DisallowMultipleComponent[] _disallowMultipleComponentArray;
	public static ExecuteInEditMode[] _executeInEditModeArray;
	public static RequireComponent[] _requireComponentArray;

	// Methods
	private static Type GetParentTypeDisallowingMultipleInclusion(Type type);
	private static Type[] GetRequiredComponents(Type klass);
	private static int GetExecuteMode(Type klass);
	private static int CheckIsEditorScript(Type klass);
	private static int GetDefaultExecutionOrderFor(Type klass);
	private static T GetCustomAttributeOfType(Type klass);
	private static void .cctor();

}
//NameSpace:UnityEngine
public sealed class DisallowMultipleComponent : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine
public sealed class RequireComponent : Attribute
{
	// Fields
	public Type m_Type0;
	public Type m_Type1;
	public Type m_Type2;

	// Methods
	public void .ctor(Type requiredComponent);

}
//NameSpace:UnityEngine
public sealed class AddComponentMenu : Attribute
{
	// Fields
	private string m_AddComponentMenu;
	private int m_Ordering;

	// Methods
	public void .ctor(string menuName);
	public void .ctor(string menuName, int order);

}
//NameSpace:UnityEngine
public sealed class ContextMenu : Attribute
{
}
//NameSpace:UnityEngine
public sealed class ExecuteInEditMode : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine
public sealed class ExecuteAlways : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine
public class DefaultExecutionOrder : Attribute
{
	// Fields
	private int <order>k__BackingField;

	// Properties
	public int order { get; }

	// Methods
	public int get_order();

}
//NameSpace:UnityEngine
public class AssemblyIsEditorAssembly : Attribute
{
}
//NameSpace:UnityEngine
public class ExcludeFromPresetAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine
public enum SendMessageOptions
{
	// Fields
	public int value__;
	public const SendMessageOptions RequireReceiver;
	public const SendMessageOptions DontRequireReceiver;

}
//NameSpace:UnityEngine
public enum RuntimePlatform
{
	// Fields
	public int value__;
	public const RuntimePlatform OSXEditor;
	public const RuntimePlatform OSXPlayer;
	public const RuntimePlatform WindowsPlayer;
	public const RuntimePlatform OSXWebPlayer;
	public const RuntimePlatform OSXDashboardPlayer;
	public const RuntimePlatform WindowsWebPlayer;
	public const RuntimePlatform WindowsEditor;
	public const RuntimePlatform IPhonePlayer;
	public const RuntimePlatform XBOX360;
	public const RuntimePlatform PS3;
	public const RuntimePlatform Android;
	public const RuntimePlatform NaCl;
	public const RuntimePlatform FlashPlayer;
	public const RuntimePlatform LinuxPlayer;
	public const RuntimePlatform LinuxEditor;
	public const RuntimePlatform WebGLPlayer;
	public const RuntimePlatform MetroPlayerX86;
	public const RuntimePlatform WSAPlayerX86;
	public const RuntimePlatform MetroPlayerX64;
	public const RuntimePlatform WSAPlayerX64;
	public const RuntimePlatform MetroPlayerARM;
	public const RuntimePlatform WSAPlayerARM;
	public const RuntimePlatform WP8Player;
	public const RuntimePlatform BlackBerryPlayer;
	public const RuntimePlatform TizenPlayer;
	public const RuntimePlatform PSP2;
	public const RuntimePlatform PS4;
	public const RuntimePlatform PSM;
	public const RuntimePlatform XboxOne;
	public const RuntimePlatform SamsungTVPlayer;
	public const RuntimePlatform WiiU;
	public const RuntimePlatform tvOS;
	public const RuntimePlatform Switch;
	public const RuntimePlatform Lumin;

}
//NameSpace:UnityEngine
public enum LogType
{
	// Fields
	public int value__;
	public const LogType Error;
	public const LogType Assert;
	public const LogType Warning;
	public const LogType Log;
	public const LogType Exception;

}
//NameSpace:UnityEngine
internal static class BeforeRenderHelper
{
	// Fields
	private static List`1<BeforeRenderHelper.OrderBlock> s_OrderBlocks;

	// Methods
	public static void Invoke();
	private static void .cctor();

}
//NameSpace:
private struct BeforeRenderHelper.OrderBlock
{
	// Fields
	internal int order;
	internal UnityAction callback;

}
//NameSpace:UnityEngine
public class Behaviour : Component
{
	// Properties
	public bool enabled { get; set; }
	public bool isActiveAndEnabled { get; }

	// Methods
	public void .ctor();
	public bool get_enabled();
	public void set_enabled(bool value);
	public bool get_isActiveAndEnabled();

}
//NameSpace:UnityEngine
internal class BootConfigData
{
	// Fields
	private IntPtr m_Ptr;

	// Methods
	private void .ctor(IntPtr nativeHandle);
	private static BootConfigData WrapBootConfigData(IntPtr nativeHandle);

}
//NameSpace:UnityEngine
public struct Bounds : IEquatable`1<Bounds>
{
	// Fields
	private Vector3 m_Center;
	private Vector3 m_Extents;

	// Properties
	public Vector3 center { get; set; }
	public Vector3 size { get; set; }
	public Vector3 extents { get; set; }
	public Vector3 min { get; }
	public Vector3 max { get; }

	// Methods
	public void .ctor(Vector3 center, Vector3 size);
	public override int GetHashCode();
	public override bool Equals(object other);
	public bool Equals(Bounds other);
	public Vector3 get_center();
	public void set_center(Vector3 value);
	public Vector3 get_size();
	public void set_size(Vector3 value);
	public Vector3 get_extents();
	public void set_extents(Vector3 value);
	public Vector3 get_min();
	public Vector3 get_max();
	public static bool op_Equality(Bounds lhs, Bounds rhs);
	public static bool op_Inequality(Bounds lhs, Bounds rhs);
	public void SetMinMax(Vector3 min, Vector3 max);
	public void Encapsulate(Vector3 point);
	public override string ToString();

}
//NameSpace:UnityEngine
public sealed class Camera : Behaviour
{
	// Fields
	public static Camera.CameraCallback onPreCull;
	public static Camera.CameraCallback onPreRender;
	public static Camera.CameraCallback onPostRender;

	// Properties
	public float nearClipPlane { get; }
	public float farClipPlane { get; }
	public float depth { get; }
	public int cullingMask { get; }
	public int eventMask { get; }
	public CameraClearFlags clearFlags { get; }
	public Rect pixelRect { get; }
	public RenderTexture targetTexture { get; }
	public int targetDisplay { get; }
	public static Camera main { get; }
	public static int allCamerasCount { get; }

	// Methods
	public void .ctor();
	public float get_nearClipPlane();
	public float get_farClipPlane();
	public float get_depth();
	public int get_cullingMask();
	public int get_eventMask();
	public CameraClearFlags get_clearFlags();
	public Rect get_pixelRect();
	public RenderTexture get_targetTexture();
	public int get_targetDisplay();
	public Vector3 WorldToScreenPoint(Vector3 position, Camera.MonoOrStereoscopicEye eye);
	public Vector3 WorldToScreenPoint(Vector3 position);
	public Vector3 ScreenToViewportPoint(Vector3 position);
	private Ray ScreenPointToRay(Vector2 pos, Camera.MonoOrStereoscopicEye eye);
	public Ray ScreenPointToRay(Vector3 pos, Camera.MonoOrStereoscopicEye eye);
	public Ray ScreenPointToRay(Vector3 pos);
	internal GameObject RaycastTry(Ray ray, float distance, int layerMask);
	internal GameObject RaycastTry2D(Ray ray, float distance, int layerMask);
	public static Camera get_main();
	private static int GetAllCamerasCount();
	private static int GetAllCamerasImpl(out Camera[] cam);
	public static int get_allCamerasCount();
	public static int GetAllCameras(Camera[] cameras);
	private static void FireOnPreCull(Camera cam);
	private static void FireOnPreRender(Camera cam);
	private static void FireOnPostRender(Camera cam);
	private void get_pixelRect_Injected(out Rect ret);
	private void WorldToScreenPoint_Injected(Vector3 position, Camera.MonoOrStereoscopicEye eye, out Vector3 ret);
	private void ScreenToViewportPoint_Injected(Vector3 position, out Vector3 ret);
	private void ScreenPointToRay_Injected(Vector2 pos, Camera.MonoOrStereoscopicEye eye, out Ray ret);
	private GameObject RaycastTry_Injected(Ray ray, float distance, int layerMask);
	private GameObject RaycastTry2D_Injected(Ray ray, float distance, int layerMask);

}
//NameSpace:
public enum Camera.MonoOrStereoscopicEye
{
	// Fields
	public int value__;
	public const Camera.MonoOrStereoscopicEye Left;
	public const Camera.MonoOrStereoscopicEye Right;
	public const Camera.MonoOrStereoscopicEye Mono;

}
//NameSpace:
public sealed class Camera.CameraCallback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(Camera cam);
	public virtual IAsyncResult BeginInvoke(Camera cam, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine
internal struct CastHelper`1
{
	// Fields
	public T t;
	public IntPtr onePointerFurtherThanT;

}
//NameSpace:UnityEngine
internal static class ClassLibraryInitializer
{
	// Methods
	private static void Init();

}
//NameSpace:UnityEngine
internal class LowerResBlitTexture : Object
{
	// Methods
	internal void LowerResBlitTextureDontStripMe();

}
//NameSpace:UnityEngine
internal class PreloadData : Object
{
	// Methods
	internal void PreloadDataDontStripMe();

}
//NameSpace:UnityEngine
public struct Color : IEquatable`1<Color>
{
	// Fields
	public float r;
	public float g;
	public float b;
	public float a;

	// Properties
	public static Color red { get; }
	public static Color white { get; }
	public static Color black { get; }
	public static Color clear { get; }

	// Methods
	public void .ctor(float r, float g, float b, float a);
	public void .ctor(float r, float g, float b);
	public override string ToString();
	public override int GetHashCode();
	public override bool Equals(object other);
	public bool Equals(Color other);
	public static Color op_Multiply(Color a, float b);
	public static bool op_Equality(Color lhs, Color rhs);
	public static Color Lerp(Color a, Color b, float t);
	public static Color get_red();
	public static Color get_white();
	public static Color get_black();
	public static Color get_clear();
	public static Vector4 op_Implicit(Color c);

}
//NameSpace:UnityEngine
public struct Color32
{
	// Fields
	private int rgba;
	public byte r;
	public byte g;
	public byte b;
	public byte a;

	// Methods
	public void .ctor(byte r, byte g, byte b, byte a);
	public static Color32 op_Implicit(Color c);
	public static Color op_Implicit(Color32 c);
	public override string ToString();

}
//NameSpace:UnityEngine
public class Component : Object
{
	// Properties
	public Transform transform { get; }
	public GameObject gameObject { get; }

	// Methods
	public void .ctor();
	public Transform get_transform();
	public GameObject get_gameObject();
	public Component GetComponent(Type type);
	internal void GetComponentFastPath(Type type, IntPtr oneFurtherThanResultValue);
	public T GetComponent();
	public Component GetComponentInChildren(Type t, bool includeInactive);
	public T GetComponentInChildren();
	public void GetComponentsInChildren(bool includeInactive, List`1<T> result);
	public void GetComponentsInChildren(List`1<T> results);
	public Component GetComponentInParent(Type t);
	public T GetComponentInParent();
	public void GetComponentsInParent(bool includeInactive, List`1<T> results);
	private void GetComponentsForListInternal(Type searchType, object resultList);
	public void GetComponents(Type type, List`1<Component> results);
	public void GetComponents(List`1<T> results);
	public T[] GetComponents();

}
//NameSpace:UnityEngine
public sealed class Coroutine : YieldInstruction
{
	// Fields
	internal IntPtr m_Ptr;

	// Methods
	private void .ctor();
	protected override void Finalize();
	private static void ReleaseCoroutine(IntPtr ptr);

}
//NameSpace:UnityEngine
internal class SetupCoroutine
{
	// Methods
	public static void InvokeMoveNext(IEnumerator enumerator, IntPtr returnValueAddress);
	public static object InvokeMember(object behaviour, string name, object variable);

}
//NameSpace:UnityEngine
public struct CullingGroupEvent
{
	// Fields
	private int m_Index;
	private byte m_PrevState;
	private byte m_ThisState;

}
//NameSpace:UnityEngine
public class CullingGroup : IDisposable
{
	// Fields
	internal IntPtr m_Ptr;
	private CullingGroup.StateChanged m_OnStateChanged;

	// Methods
	protected override void Finalize();
	private void DisposeInternal();
	public void Dispose();
	private static void SendEvents(CullingGroup cullingGroup, IntPtr eventsPtr, int count);
	private void FinalizerFailure();

}
//NameSpace:
public sealed class CullingGroup.StateChanged : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(CullingGroupEvent sphere);
	public virtual IAsyncResult BeginInvoke(CullingGroupEvent sphere, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine
public enum CursorLockMode
{
	// Fields
	public int value__;
	public const CursorLockMode None;
	public const CursorLockMode Locked;
	public const CursorLockMode Confined;

}
//NameSpace:UnityEngine
public class Cursor
{
	// Properties
	public static CursorLockMode lockState { get; }

	// Methods
	public static CursorLockMode get_lockState();

}
//NameSpace:UnityEngine
public abstract class CustomYieldInstruction : IEnumerator
{
	// Properties
	public abstract bool keepWaiting { get; }
	public object Current { get; }

	// Methods
	protected void .ctor();
	public abstract bool get_keepWaiting();
	public object get_Current();
	public bool MoveNext();

}
//NameSpace:UnityEngine
internal sealed class DebugLogHandler : ILogHandler
{
	// Methods
	public void .ctor();
	internal static void Internal_Log(LogType level, string msg, Object obj);
	internal static void Internal_LogException(Exception exception, Object obj);
	public void LogFormat(LogType logType, Object context, string format, object[] args);
	public void LogException(Exception exception, Object context);

}
//NameSpace:UnityEngine
public class Debug
{
	// Fields
	internal static ILogger s_Logger;

	// Properties
	public static ILogger unityLogger { get; }

	// Methods
	public static ILogger get_unityLogger();
	public static void Log(object message);
	public static void LogError(object message);
	public static void LogError(object message, Object context);
	public static void LogErrorFormat(Object context, string format, object[] args);
	public static void LogException(Exception exception);
	public static void LogException(Exception exception, Object context);
	public static void LogWarning(object message);
	public static void LogWarning(object message, Object context);
	public static void LogWarningFormat(Object context, string format, object[] args);
	public static void LogAssertion(object message);
	private static void .cctor();

}
//NameSpace:UnityEngine
public class Display
{
	// Fields
	internal IntPtr nativeDisplay;
	public static Display[] displays;
	private static Display _mainDisplay;
	private static Display.DisplaysUpdatedDelegate onDisplaysUpdated;

	// Properties
	public int renderingWidth { get; }
	public int renderingHeight { get; }
	public int systemWidth { get; }
	public int systemHeight { get; }

	// Methods
	internal void .ctor();
	internal void .ctor(IntPtr nativeDisplay);
	public int get_renderingWidth();
	public int get_renderingHeight();
	public int get_systemWidth();
	public int get_systemHeight();
	public static Vector3 RelativeMouseAt(Vector3 inputMouseCoordinates);
	private static void RecreateDisplayList(IntPtr[] nativeDisplay);
	private static void FireDisplaysUpdated();
	private static void GetSystemExtImpl(IntPtr nativeDisplay, out int w, out int h);
	private static void GetRenderingExtImpl(IntPtr nativeDisplay, out int w, out int h);
	private static int RelativeMouseAtImpl(int x, int y, out int rx, out int ry);
	private static void .cctor();

}
//NameSpace:
public sealed class Display.DisplaysUpdatedDelegate : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke();
	public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine
public class ExcludeFromObjectFactoryAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine
internal class FailedToLoadScriptObject : Object
{
}
//NameSpace:UnityEngine
public class RectOffset
{
	// Fields
	internal IntPtr m_Ptr;
	private readonly object m_SourceStyle;

	// Properties
	public int left { get; }
	public int right { get; }
	public int top { get; }
	public int bottom { get; }
	public int horizontal { get; }
	public int vertical { get; }

	// Methods
	public void .ctor();
	internal void .ctor(object sourceStyle, IntPtr source);
	private static IntPtr InternalCreate();
	private static void InternalDestroy(IntPtr ptr);
	public int get_left();
	public int get_right();
	public int get_top();
	public int get_bottom();
	public int get_horizontal();
	public int get_vertical();
	protected override void Finalize();
	public override string ToString();
	private void Destroy();

}
//NameSpace:UnityEngine
public class GUIElement : Behaviour
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine
public class GUILayer : Behaviour
{
	// Methods
	public GUIElement HitTest(Vector3 screenPosition);
	private GUIElement HitTest(Vector2 screenPosition);
	private GUIElement HitTest_Injected(Vector2 screenPosition);

}
//NameSpace:UnityEngine
public sealed class GameObject : Object
{
	// Properties
	public Transform transform { get; }
	public int layer { get; set; }
	public bool activeSelf { get; }
	public bool activeInHierarchy { get; }

	// Methods
	public void .ctor(string name);
	public void .ctor();
	public void .ctor(string name, Type[] components);
	public T GetComponent();
	public Component GetComponent(Type type);
	internal void GetComponentFastPath(Type type, IntPtr oneFurtherThanResultValue);
	public Component GetComponentInChildren(Type type, bool includeInactive);
	public T GetComponentInChildren();
	public T GetComponentInChildren(bool includeInactive);
	public Component GetComponentInParent(Type type);
	private Array GetComponentsInternal(Type type, bool useSearchTypeAsArrayReturnType, bool recursive, bool includeInactive, bool reverse, object resultList);
	public T[] GetComponents();
	public void GetComponents(List`1<T> results);
	public void GetComponentsInChildren(bool includeInactive, List`1<T> results);
	public void GetComponentsInParent(bool includeInactive, List`1<T> results);
	private Component Internal_AddComponentWithType(Type componentType);
	public Component AddComponent(Type componentType);
	public T AddComponent();
	public Transform get_transform();
	public int get_layer();
	public void set_layer(int value);
	public void SetActive(bool value);
	public bool get_activeSelf();
	public bool get_activeInHierarchy();
	public void SendMessage(string methodName, object value, SendMessageOptions options);
	private static void Internal_CreateGameObject(GameObject self, string name);
	public static GameObject Find(string name);

}
//NameSpace:UnityEngine
public class Gradient : IEquatable`1<Gradient>
{
	// Fields
	internal IntPtr m_Ptr;

	// Methods
	public void .ctor();
	private static IntPtr Init();
	private void Cleanup();
	private bool Internal_Equals(IntPtr other);
	protected override void Finalize();
	public override bool Equals(object o);
	public bool Equals(Gradient other);
	public override int GetHashCode();

}
//NameSpace:UnityEngine
public sealed class Screen
{
	// Properties
	public static int width { get; }
	public static int height { get; }
	public static float dpi { get; }

	// Methods
	public static int get_width();
	public static int get_height();
	public static float get_dpi();

}
//NameSpace:UnityEngine
public struct Resolution
{
	// Fields
	private int m_Width;
	private int m_Height;
	private int m_RefreshRate;

	// Methods
	public override string ToString();

}
//NameSpace:UnityEngine
public sealed class QualitySettings : Object
{
	// Properties
	public static ColorSpace activeColorSpace { get; }

	// Methods
	public static ColorSpace get_activeColorSpace();

}
//NameSpace:UnityEngine
public class Renderer : Component
{
	// Properties
	public int sortingLayerID { get; }
	public int sortingOrder { get; }

	// Methods
	public int get_sortingLayerID();
	public int get_sortingOrder();

}
//NameSpace:UnityEngine
public sealed class Shader : Object
{
	// Methods
	public static int PropertyToID(string name);

}
//NameSpace:UnityEngine
public class Material : Object
{
	// Properties
	public Texture mainTexture { get; }

	// Methods
	public void .ctor(Shader shader);
	public void .ctor(Material source);
	public void .ctor(string contents);
	private static void CreateWithShader(Material self, Shader shader);
	private static void CreateWithMaterial(Material self, Material source);
	private static void CreateWithString(Material self);
	public Texture get_mainTexture();
	public bool HasProperty(int nameID);
	public bool HasProperty(string name);
	public void EnableKeyword(string keyword);
	public void DisableKeyword(string keyword);
	private void SetFloatImpl(int name, float value);
	private Texture GetTextureImpl(int name);
	public void SetInt(string name, int value);
	public Texture GetTexture(string name);

}
//NameSpace:UnityEngine
public sealed class MeshFilter : Component
{
	// Methods
	private void DontStripMeshFilter();

}
//NameSpace:UnityEngine
public enum LightmapBakeType
{
	// Fields
	public int value__;
	public const LightmapBakeType Realtime;
	public const LightmapBakeType Baked;
	public const LightmapBakeType Mixed;

}
//NameSpace:UnityEngine
public enum MixedLightingMode
{
	// Fields
	public int value__;
	public const MixedLightingMode IndirectOnly;
	public const MixedLightingMode Shadowmask;
	public const MixedLightingMode Subtractive;

}
//NameSpace:UnityEngine
public enum CameraClearFlags
{
	// Fields
	public int value__;
	public const CameraClearFlags Skybox;
	public const CameraClearFlags Color;
	public const CameraClearFlags SolidColor;
	public const CameraClearFlags Depth;
	public const CameraClearFlags Nothing;

}
//NameSpace:UnityEngine
public enum MeshTopology
{
	// Fields
	public int value__;
	public const MeshTopology Triangles;
	public const MeshTopology Quads;
	public const MeshTopology Lines;
	public const MeshTopology LineStrip;
	public const MeshTopology Points;

}
//NameSpace:UnityEngine
public enum ColorSpace
{
	// Fields
	public int value__;
	public const ColorSpace Uninitialized;
	public const ColorSpace Gamma;
	public const ColorSpace Linear;

}
//NameSpace:UnityEngine
public enum TextureWrapMode
{
	// Fields
	public int value__;
	public const TextureWrapMode Repeat;
	public const TextureWrapMode Clamp;
	public const TextureWrapMode Mirror;
	public const TextureWrapMode MirrorOnce;

}
//NameSpace:UnityEngine
public enum TextureFormat
{
	// Fields
	public int value__;
	public const TextureFormat Alpha8;
	public const TextureFormat ARGB4444;
	public const TextureFormat RGB24;
	public const TextureFormat RGBA32;
	public const TextureFormat ARGB32;
	public const TextureFormat RGB565;
	public const TextureFormat R16;
	public const TextureFormat DXT1;
	public const TextureFormat DXT5;
	public const TextureFormat RGBA4444;
	public const TextureFormat BGRA32;
	public const TextureFormat RHalf;
	public const TextureFormat RGHalf;
	public const TextureFormat RGBAHalf;
	public const TextureFormat RFloat;
	public const TextureFormat RGFloat;
	public const TextureFormat RGBAFloat;
	public const TextureFormat YUY2;
	public const TextureFormat RGB9e5Float;
	public const TextureFormat BC4;
	public const TextureFormat BC5;
	public const TextureFormat BC6H;
	public const TextureFormat BC7;
	public const TextureFormat PVRTC_RGB2;
	public const TextureFormat PVRTC_RGBA2;
	public const TextureFormat PVRTC_RGB4;
	public const TextureFormat PVRTC_RGBA4;
	public const TextureFormat ETC_RGB4;
	public const TextureFormat EAC_R;
	public const TextureFormat EAC_R_SIGNED;
	public const TextureFormat EAC_RG;
	public const TextureFormat EAC_RG_SIGNED;
	public const TextureFormat ETC2_RGB;
	public const TextureFormat ETC2_RGBA1;
	public const TextureFormat ETC2_RGBA8;
	public const TextureFormat ASTC_RGB_4x4;
	public const TextureFormat ASTC_RGB_5x5;
	public const TextureFormat ASTC_RGB_6x6;
	public const TextureFormat ASTC_RGB_8x8;
	public const TextureFormat ASTC_RGB_10x10;
	public const TextureFormat ASTC_RGB_12x12;
	public const TextureFormat ASTC_RGBA_4x4;
	public const TextureFormat ASTC_RGBA_5x5;
	public const TextureFormat ASTC_RGBA_6x6;
	public const TextureFormat ASTC_RGBA_8x8;
	public const TextureFormat ASTC_RGBA_10x10;
	public const TextureFormat ASTC_RGBA_12x12;
	public const TextureFormat ETC_RGB4_3DS;
	public const TextureFormat ETC_RGBA8_3DS;
	public const TextureFormat RG16;
	public const TextureFormat R8;

}
//NameSpace:UnityEngine
public enum RenderTextureFormat
{
	// Fields
	public int value__;
	public const RenderTextureFormat ARGB32;
	public const RenderTextureFormat Depth;
	public const RenderTextureFormat ARGBHalf;
	public const RenderTextureFormat Shadowmap;
	public const RenderTextureFormat RGB565;
	public const RenderTextureFormat ARGB4444;
	public const RenderTextureFormat ARGB1555;
	public const RenderTextureFormat Default;
	public const RenderTextureFormat ARGB2101010;
	public const RenderTextureFormat DefaultHDR;
	public const RenderTextureFormat ARGB64;
	public const RenderTextureFormat ARGBFloat;
	public const RenderTextureFormat RGFloat;
	public const RenderTextureFormat RGHalf;
	public const RenderTextureFormat RFloat;
	public const RenderTextureFormat RHalf;
	public const RenderTextureFormat R8;
	public const RenderTextureFormat ARGBInt;
	public const RenderTextureFormat RGInt;
	public const RenderTextureFormat RInt;
	public const RenderTextureFormat BGRA32;
	public const RenderTextureFormat RGB111110Float;
	public const RenderTextureFormat RG32;
	public const RenderTextureFormat RGBAUShort;
	public const RenderTextureFormat RG16;
	public const RenderTextureFormat BGRA10101010_XR;
	public const RenderTextureFormat BGR101010_XR;
	public const RenderTextureFormat R16;

}
//NameSpace:UnityEngine
public enum VRTextureUsage
{
	// Fields
	public int value__;
	public const VRTextureUsage None;
	public const VRTextureUsage OneEye;
	public const VRTextureUsage TwoEyes;

}
//NameSpace:UnityEngine
public enum RenderTextureCreationFlags
{
	// Fields
	public int value__;
	public const RenderTextureCreationFlags MipMap;
	public const RenderTextureCreationFlags AutoGenerateMips;
	public const RenderTextureCreationFlags SRGB;
	public const RenderTextureCreationFlags EyeTexture;
	public const RenderTextureCreationFlags EnableRandomWrite;
	public const RenderTextureCreationFlags CreatedFromScript;
	public const RenderTextureCreationFlags AllowVerticalFlip;
	public const RenderTextureCreationFlags NoResolvedColorSurface;
	public const RenderTextureCreationFlags DynamicallyScalable;
	public const RenderTextureCreationFlags BindMS;

}
//NameSpace:UnityEngine
public enum RenderTextureReadWrite
{
	// Fields
	public int value__;
	public const RenderTextureReadWrite Default;
	public const RenderTextureReadWrite Linear;
	public const RenderTextureReadWrite sRGB;

}
//NameSpace:UnityEngine
public enum RenderTextureMemoryless
{
	// Fields
	public int value__;
	public const RenderTextureMemoryless None;
	public const RenderTextureMemoryless Color;
	public const RenderTextureMemoryless Depth;
	public const RenderTextureMemoryless MSAA;

}
//NameSpace:UnityEngine.Experimental.Rendering
public enum TextureCreationFlags
{
	// Fields
	public int value__;
	public const TextureCreationFlags None;
	public const TextureCreationFlags MipChain;
	public const TextureCreationFlags Crunch;

}
//NameSpace:UnityEngine.Experimental.Rendering
public enum FormatUsage
{
	// Fields
	public int value__;
	public const FormatUsage Sample;
	public const FormatUsage Linear;
	public const FormatUsage Render;
	public const FormatUsage Blend;
	public const FormatUsage LoadStore;
	public const FormatUsage MSAA2x;
	public const FormatUsage MSAA4x;
	public const FormatUsage MSAA8x;

}
//NameSpace:UnityEngine.Experimental.Rendering
public enum GraphicsFormat
{
	// Fields
	public int value__;
	public const GraphicsFormat None;
	public const GraphicsFormat R8_SRGB;
	public const GraphicsFormat R8G8_SRGB;
	public const GraphicsFormat R8G8B8_SRGB;
	public const GraphicsFormat R8G8B8A8_SRGB;
	public const GraphicsFormat R8_UNorm;
	public const GraphicsFormat R8G8_UNorm;
	public const GraphicsFormat R8G8B8_UNorm;
	public const GraphicsFormat R8G8B8A8_UNorm;
	public const GraphicsFormat R8_SNorm;
	public const GraphicsFormat R8G8_SNorm;
	public const GraphicsFormat R8G8B8_SNorm;
	public const GraphicsFormat R8G8B8A8_SNorm;
	public const GraphicsFormat R8_UInt;
	public const GraphicsFormat R8G8_UInt;
	public const GraphicsFormat R8G8B8_UInt;
	public const GraphicsFormat R8G8B8A8_UInt;
	public const GraphicsFormat R8_SInt;
	public const GraphicsFormat R8G8_SInt;
	public const GraphicsFormat R8G8B8_SInt;
	public const GraphicsFormat R8G8B8A8_SInt;
	public const GraphicsFormat R16_UNorm;
	public const GraphicsFormat R16G16_UNorm;
	public const GraphicsFormat R16G16B16_UNorm;
	public const GraphicsFormat R16G16B16A16_UNorm;
	public const GraphicsFormat R16_SNorm;
	public const GraphicsFormat R16G16_SNorm;
	public const GraphicsFormat R16G16B16_SNorm;
	public const GraphicsFormat R16G16B16A16_SNorm;
	public const GraphicsFormat R16_UInt;
	public const GraphicsFormat R16G16_UInt;
	public const GraphicsFormat R16G16B16_UInt;
	public const GraphicsFormat R16G16B16A16_UInt;
	public const GraphicsFormat R16_SInt;
	public const GraphicsFormat R16G16_SInt;
	public const GraphicsFormat R16G16B16_SInt;
	public const GraphicsFormat R16G16B16A16_SInt;
	public const GraphicsFormat R32_UInt;
	public const GraphicsFormat R32G32_UInt;
	public const GraphicsFormat R32G32B32_UInt;
	public const GraphicsFormat R32G32B32A32_UInt;
	public const GraphicsFormat R32_SInt;
	public const GraphicsFormat R32G32_SInt;
	public const GraphicsFormat R32G32B32_SInt;
	public const GraphicsFormat R32G32B32A32_SInt;
	public const GraphicsFormat R16_SFloat;
	public const GraphicsFormat R16G16_SFloat;
	public const GraphicsFormat R16G16B16_SFloat;
	public const GraphicsFormat R16G16B16A16_SFloat;
	public const GraphicsFormat R32_SFloat;
	public const GraphicsFormat R32G32_SFloat;
	public const GraphicsFormat R32G32B32_SFloat;
	public const GraphicsFormat R32G32B32A32_SFloat;
	public const GraphicsFormat B8G8R8_SRGB;
	public const GraphicsFormat B8G8R8A8_SRGB;
	public const GraphicsFormat B8G8R8_UNorm;
	public const GraphicsFormat B8G8R8A8_UNorm;
	public const GraphicsFormat B8G8R8_SNorm;
	public const GraphicsFormat B8G8R8A8_SNorm;
	public const GraphicsFormat B8G8R8_UInt;
	public const GraphicsFormat B8G8R8A8_UInt;
	public const GraphicsFormat B8G8R8_SInt;
	public const GraphicsFormat B8G8R8A8_SInt;
	public const GraphicsFormat R4G4B4A4_UNormPack16;
	public const GraphicsFormat B4G4R4A4_UNormPack16;
	public const GraphicsFormat R5G6B5_UNormPack16;
	public const GraphicsFormat B5G6R5_UNormPack16;
	public const GraphicsFormat R5G5B5A1_UNormPack16;
	public const GraphicsFormat B5G5R5A1_UNormPack16;
	public const GraphicsFormat A1R5G5B5_UNormPack16;
	public const GraphicsFormat E5B9G9R9_UFloatPack32;
	public const GraphicsFormat B10G11R11_UFloatPack32;
	public const GraphicsFormat A2B10G10R10_UNormPack32;
	public const GraphicsFormat A2B10G10R10_UIntPack32;
	public const GraphicsFormat A2B10G10R10_SIntPack32;
	public const GraphicsFormat A2R10G10B10_UNormPack32;
	public const GraphicsFormat A2R10G10B10_UIntPack32;
	public const GraphicsFormat A2R10G10B10_SIntPack32;
	public const GraphicsFormat A2R10G10B10_XRSRGBPack32;
	public const GraphicsFormat A2R10G10B10_XRUNormPack32;
	public const GraphicsFormat R10G10B10_XRSRGBPack32;
	public const GraphicsFormat R10G10B10_XRUNormPack32;
	public const GraphicsFormat A10R10G10B10_XRSRGBPack32;
	public const GraphicsFormat A10R10G10B10_XRUNormPack32;
	public const GraphicsFormat D16_UNorm;
	public const GraphicsFormat D24_UNorm;
	public const GraphicsFormat D24_UNorm_S8_UInt;
	public const GraphicsFormat D32_SFloat;
	public const GraphicsFormat D32_SFloat_S8_Uint;
	public const GraphicsFormat S8_Uint;
	public const GraphicsFormat RGB_DXT1_SRGB;
	public const GraphicsFormat RGBA_DXT1_SRGB;
	public const GraphicsFormat RGB_DXT1_UNorm;
	public const GraphicsFormat RGBA_DXT1_UNorm;
	public const GraphicsFormat RGBA_DXT3_SRGB;
	public const GraphicsFormat RGBA_DXT3_UNorm;
	public const GraphicsFormat RGBA_DXT5_SRGB;
	public const GraphicsFormat RGBA_DXT5_UNorm;
	public const GraphicsFormat R_BC4_UNorm;
	public const GraphicsFormat R_BC4_SNorm;
	public const GraphicsFormat RG_BC5_UNorm;
	public const GraphicsFormat RG_BC5_SNorm;
	public const GraphicsFormat RGB_BC6H_UFloat;
	public const GraphicsFormat RGB_BC6H_SFloat;
	public const GraphicsFormat RGBA_BC7_SRGB;
	public const GraphicsFormat RGBA_BC7_UNorm;
	public const GraphicsFormat RGB_PVRTC_2Bpp_SRGB;
	public const GraphicsFormat RGB_PVRTC_2Bpp_UNorm;
	public const GraphicsFormat RGB_PVRTC_4Bpp_SRGB;
	public const GraphicsFormat RGB_PVRTC_4Bpp_UNorm;
	public const GraphicsFormat RGBA_PVRTC_2Bpp_SRGB;
	public const GraphicsFormat RGBA_PVRTC_2Bpp_UNorm;
	public const GraphicsFormat RGBA_PVRTC_4Bpp_SRGB;
	public const GraphicsFormat RGBA_PVRTC_4Bpp_UNorm;
	public const GraphicsFormat RGB_ETC_UNorm;
	public const GraphicsFormat RGB_ETC2_SRGB;
	public const GraphicsFormat RGB_ETC2_UNorm;
	public const GraphicsFormat RGB_A1_ETC2_SRGB;
	public const GraphicsFormat RGB_A1_ETC2_UNorm;
	public const GraphicsFormat RGBA_ETC2_SRGB;
	public const GraphicsFormat RGBA_ETC2_UNorm;
	public const GraphicsFormat R_EAC_UNorm;
	public const GraphicsFormat R_EAC_SNorm;
	public const GraphicsFormat RG_EAC_UNorm;
	public const GraphicsFormat RG_EAC_SNorm;
	public const GraphicsFormat RGBA_ASTC4X4_SRGB;
	public const GraphicsFormat RGBA_ASTC4X4_UNorm;
	public const GraphicsFormat RGBA_ASTC5X5_SRGB;
	public const GraphicsFormat RGBA_ASTC5X5_UNorm;
	public const GraphicsFormat RGBA_ASTC6X6_SRGB;
	public const GraphicsFormat RGBA_ASTC6X6_UNorm;
	public const GraphicsFormat RGBA_ASTC8X8_SRGB;
	public const GraphicsFormat RGBA_ASTC8X8_UNorm;
	public const GraphicsFormat RGBA_ASTC10X10_SRGB;
	public const GraphicsFormat RGBA_ASTC10X10_UNorm;
	public const GraphicsFormat RGBA_ASTC12X12_SRGB;
	public const GraphicsFormat RGBA_ASTC12X12_UNorm;

}
//NameSpace:UnityEngine
public enum LightmapsMode
{
	// Fields
	public int value__;
	public const LightmapsMode NonDirectional;
	public const LightmapsMode CombinedDirectional;

}
//NameSpace:UnityEngine.Rendering
public enum VertexAttribute
{
	// Fields
	public int value__;
	public const VertexAttribute Position;
	public const VertexAttribute Normal;
	public const VertexAttribute Tangent;
	public const VertexAttribute Color;
	public const VertexAttribute TexCoord0;
	public const VertexAttribute TexCoord1;
	public const VertexAttribute TexCoord2;
	public const VertexAttribute TexCoord3;
	public const VertexAttribute TexCoord4;
	public const VertexAttribute TexCoord5;
	public const VertexAttribute TexCoord6;
	public const VertexAttribute TexCoord7;
	public const VertexAttribute BlendWeight;
	public const VertexAttribute BlendIndices;

}
//NameSpace:UnityEngine.Rendering
public enum CompareFunction
{
	// Fields
	public int value__;
	public const CompareFunction Disabled;
	public const CompareFunction Never;
	public const CompareFunction Less;
	public const CompareFunction Equal;
	public const CompareFunction LessEqual;
	public const CompareFunction Greater;
	public const CompareFunction NotEqual;
	public const CompareFunction GreaterEqual;
	public const CompareFunction Always;

}
//NameSpace:UnityEngine.Rendering
public enum ColorWriteMask
{
	// Fields
	public int value__;
	public const ColorWriteMask Alpha;
	public const ColorWriteMask Blue;
	public const ColorWriteMask Green;
	public const ColorWriteMask Red;
	public const ColorWriteMask All;

}
//NameSpace:UnityEngine.Rendering
public enum StencilOp
{
	// Fields
	public int value__;
	public const StencilOp Keep;
	public const StencilOp Zero;
	public const StencilOp Replace;
	public const StencilOp IncrementSaturate;
	public const StencilOp DecrementSaturate;
	public const StencilOp Invert;
	public const StencilOp IncrementWrap;
	public const StencilOp DecrementWrap;

}
//NameSpace:UnityEngine.Rendering
public enum ShadowSamplingMode
{
	// Fields
	public int value__;
	public const ShadowSamplingMode CompareDepths;
	public const ShadowSamplingMode RawDepth;
	public const ShadowSamplingMode None;

}
//NameSpace:UnityEngine.Rendering
public enum TextureDimension
{
	// Fields
	public int value__;
	public const TextureDimension Unknown;
	public const TextureDimension None;
	public const TextureDimension Any;
	public const TextureDimension Tex2D;
	public const TextureDimension Tex3D;
	public const TextureDimension Cube;
	public const TextureDimension Tex2DArray;
	public const TextureDimension CubeArray;

}
//NameSpace:UnityEngine.Experimental.Rendering
public class GraphicsFormatUtility
{
	// Methods
	public static GraphicsFormat GetGraphicsFormat(TextureFormat format, bool isSRGB);
	private static GraphicsFormat GetGraphicsFormat_Native_TextureFormat(TextureFormat format, bool isSRGB);
	public static bool IsSRGBFormat(GraphicsFormat format);
	public static RenderTextureFormat GetRenderTextureFormat(GraphicsFormat format);
	internal static bool IsCompressedTextureFormat(TextureFormat format);
	public static bool IsCrunchFormat(TextureFormat format);

}
//NameSpace:UnityEngine
public class MeshRenderer : Renderer
{
	// Methods
	private void DontStripMeshRenderer();

}
//NameSpace:UnityEngine
internal struct TouchScreenKeyboard_InternalConstructorHelperArguments
{
	// Fields
	public uint keyboardType;
	public uint autocorrection;
	public uint multiline;
	public uint secure;
	public uint alert;
	public int characterLimit;

}
//NameSpace:UnityEngine
public class TouchScreenKeyboard
{
	// Fields
	internal IntPtr m_Ptr;
	private readonly bool <canGetSelection>k__BackingField;
	private readonly bool <canSetSelection>k__BackingField;
	private readonly TouchScreenKeyboardType <type>k__BackingField;

	// Properties
	public static bool isSupported { get; }
	public string text { get; set; }
	public static void hideInput { set; }
	public bool active { get; set; }
	public TouchScreenKeyboard.Status status { get; }
	public void characterLimit { set; }
	public bool canGetSelection { get; }
	public bool canSetSelection { get; }
	public RangeInt selection { get; set; }

	// Methods
	public void .ctor(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline, bool secure, bool alert, string textPlaceholder, int characterLimit);
	private static void Internal_Destroy(IntPtr ptr);
	private void Destroy();
	protected override void Finalize();
	private static IntPtr TouchScreenKeyboard_InternalConstructorHelper(TouchScreenKeyboard_InternalConstructorHelperArguments arguments, string text, string textPlaceholder);
	public static bool get_isSupported();
	public static TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType, bool autocorrection, bool multiline, bool secure, bool alert, string textPlaceholder, int characterLimit);
	public string get_text();
	public void set_text(string value);
	public static void set_hideInput(bool value);
	public bool get_active();
	public void set_active(bool value);
	public TouchScreenKeyboard.Status get_status();
	public void set_characterLimit(int value);
	public bool get_canGetSelection();
	public bool get_canSetSelection();
	public RangeInt get_selection();
	public void set_selection(RangeInt value);
	private static void GetSelection(out int start, out int length);
	private static void SetSelection(int start, int length);

}
//NameSpace:
public enum TouchScreenKeyboard.Status
{
	// Fields
	public int value__;
	public const TouchScreenKeyboard.Status Visible;
	public const TouchScreenKeyboard.Status Done;
	public const TouchScreenKeyboard.Status Canceled;
	public const TouchScreenKeyboard.Status LostFocus;

}
//NameSpace:UnityEngine
public enum TouchPhase
{
	// Fields
	public int value__;
	public const TouchPhase Began;
	public const TouchPhase Moved;
	public const TouchPhase Stationary;
	public const TouchPhase Ended;
	public const TouchPhase Canceled;

}
//NameSpace:UnityEngine
public enum IMECompositionMode
{
	// Fields
	public int value__;
	public const IMECompositionMode Auto;
	public const IMECompositionMode On;
	public const IMECompositionMode Off;

}
//NameSpace:UnityEngine
public enum TouchType
{
	// Fields
	public int value__;
	public const TouchType Direct;
	public const TouchType Indirect;
	public const TouchType Stylus;

}
//NameSpace:UnityEngine
public struct Touch
{
	// Fields
	private int m_FingerId;
	private Vector2 m_Position;
	private Vector2 m_RawPosition;
	private Vector2 m_PositionDelta;
	private float m_TimeDelta;
	private int m_TapCount;
	private TouchPhase m_Phase;
	private TouchType m_Type;
	private float m_Pressure;
	private float m_maximumPossiblePressure;
	private float m_Radius;
	private float m_RadiusVariance;
	private float m_AltitudeAngle;
	private float m_AzimuthAngle;

	// Properties
	public int fingerId { get; }
	public Vector2 position { get; }
	public TouchPhase phase { get; }
	public TouchType type { get; }

	// Methods
	public int get_fingerId();
	public Vector2 get_position();
	public TouchPhase get_phase();
	public TouchType get_type();

}
//NameSpace:UnityEngine
public class Input
{
	// Properties
	public static Vector3 mousePosition { get; }
	public static Vector2 mouseScrollDelta { get; }
	public static IMECompositionMode imeCompositionMode { get; set; }
	public static string compositionString { get; }
	public static Vector2 compositionCursorPos { get; set; }
	public static bool mousePresent { get; }
	public static int touchCount { get; }
	public static bool touchSupported { get; }

	// Methods
	public static float GetAxisRaw(string axisName);
	public static bool GetButtonDown(string buttonName);
	public static bool GetMouseButton(int button);
	public static bool GetMouseButtonDown(int button);
	public static bool GetMouseButtonUp(int button);
	public static Touch GetTouch(int index);
	public static Vector3 get_mousePosition();
	public static Vector2 get_mouseScrollDelta();
	public static IMECompositionMode get_imeCompositionMode();
	public static void set_imeCompositionMode(IMECompositionMode value);
	public static string get_compositionString();
	public static Vector2 get_compositionCursorPos();
	public static void set_compositionCursorPos(Vector2 value);
	public static bool get_mousePresent();
	public static int get_touchCount();
	public static bool get_touchSupported();
	private static void GetTouch_Injected(int index, out Touch ret);
	private static void get_mousePosition_Injected(out Vector3 ret);
	private static void get_mouseScrollDelta_Injected(out Vector2 ret);
	private static void get_compositionCursorPos_Injected(out Vector2 ret);
	private static void set_compositionCursorPos_Injected(Vector2 value);

}
//NameSpace:UnityEngine
public enum KeyCode
{
	// Fields
	public int value__;
	public const KeyCode None;
	public const KeyCode Backspace;
	public const KeyCode Delete;
	public const KeyCode Tab;
	public const KeyCode Clear;
	public const KeyCode Return;
	public const KeyCode Pause;
	public const KeyCode Escape;
	public const KeyCode Space;
	public const KeyCode Keypad0;
	public const KeyCode Keypad1;
	public const KeyCode Keypad2;
	public const KeyCode Keypad3;
	public const KeyCode Keypad4;
	public const KeyCode Keypad5;
	public const KeyCode Keypad6;
	public const KeyCode Keypad7;
	public const KeyCode Keypad8;
	public const KeyCode Keypad9;
	public const KeyCode KeypadPeriod;
	public const KeyCode KeypadDivide;
	public const KeyCode KeypadMultiply;
	public const KeyCode KeypadMinus;
	public const KeyCode KeypadPlus;
	public const KeyCode KeypadEnter;
	public const KeyCode KeypadEquals;
	public const KeyCode UpArrow;
	public const KeyCode DownArrow;
	public const KeyCode RightArrow;
	public const KeyCode LeftArrow;
	public const KeyCode Insert;
	public const KeyCode Home;
	public const KeyCode End;
	public const KeyCode PageUp;
	public const KeyCode PageDown;
	public const KeyCode F1;
	public const KeyCode F2;
	public const KeyCode F3;
	public const KeyCode F4;
	public const KeyCode F5;
	public const KeyCode F6;
	public const KeyCode F7;
	public const KeyCode F8;
	public const KeyCode F9;
	public const KeyCode F10;
	public const KeyCode F11;
	public const KeyCode F12;
	public const KeyCode F13;
	public const KeyCode F14;
	public const KeyCode F15;
	public const KeyCode Alpha0;
	public const KeyCode Alpha1;
	public const KeyCode Alpha2;
	public const KeyCode Alpha3;
	public const KeyCode Alpha4;
	public const KeyCode Alpha5;
	public const KeyCode Alpha6;
	public const KeyCode Alpha7;
	public const KeyCode Alpha8;
	public const KeyCode Alpha9;
	public const KeyCode Exclaim;
	public const KeyCode DoubleQuote;
	public const KeyCode Hash;
	public const KeyCode Dollar;
	public const KeyCode Percent;
	public const KeyCode Ampersand;
	public const KeyCode Quote;
	public const KeyCode LeftParen;
	public const KeyCode RightParen;
	public const KeyCode Asterisk;
	public const KeyCode Plus;
	public const KeyCode Comma;
	public const KeyCode Minus;
	public const KeyCode Period;
	public const KeyCode Slash;
	public const KeyCode Colon;
	public const KeyCode Semicolon;
	public const KeyCode Less;
	public const KeyCode Equals;
	public const KeyCode Greater;
	public const KeyCode Question;
	public const KeyCode At;
	public const KeyCode LeftBracket;
	public const KeyCode Backslash;
	public const KeyCode RightBracket;
	public const KeyCode Caret;
	public const KeyCode Underscore;
	public const KeyCode BackQuote;
	public const KeyCode A;
	public const KeyCode B;
	public const KeyCode C;
	public const KeyCode D;
	public const KeyCode E;
	public const KeyCode F;
	public const KeyCode G;
	public const KeyCode H;
	public const KeyCode I;
	public const KeyCode J;
	public const KeyCode K;
	public const KeyCode L;
	public const KeyCode M;
	public const KeyCode N;
	public const KeyCode O;
	public const KeyCode P;
	public const KeyCode Q;
	public const KeyCode R;
	public const KeyCode S;
	public const KeyCode T;
	public const KeyCode U;
	public const KeyCode V;
	public const KeyCode W;
	public const KeyCode X;
	public const KeyCode Y;
	public const KeyCode Z;
	public const KeyCode LeftCurlyBracket;
	public const KeyCode Pipe;
	public const KeyCode RightCurlyBracket;
	public const KeyCode Tilde;
	public const KeyCode Numlock;
	public const KeyCode CapsLock;
	public const KeyCode ScrollLock;
	public const KeyCode RightShift;
	public const KeyCode LeftShift;
	public const KeyCode RightControl;
	public const KeyCode LeftControl;
	public const KeyCode RightAlt;
	public const KeyCode LeftAlt;
	public const KeyCode LeftCommand;
	public const KeyCode LeftApple;
	public const KeyCode LeftWindows;
	public const KeyCode RightCommand;
	public const KeyCode RightApple;
	public const KeyCode RightWindows;
	public const KeyCode AltGr;
	public const KeyCode Help;
	public const KeyCode Print;
	public const KeyCode SysReq;
	public const KeyCode Break;
	public const KeyCode Menu;
	public const KeyCode Mouse0;
	public const KeyCode Mouse1;
	public const KeyCode Mouse2;
	public const KeyCode Mouse3;
	public const KeyCode Mouse4;
	public const KeyCode Mouse5;
	public const KeyCode Mouse6;
	public const KeyCode JoystickButton0;
	public const KeyCode JoystickButton1;
	public const KeyCode JoystickButton2;
	public const KeyCode JoystickButton3;
	public const KeyCode JoystickButton4;
	public const KeyCode JoystickButton5;
	public const KeyCode JoystickButton6;
	public const KeyCode JoystickButton7;
	public const KeyCode JoystickButton8;
	public const KeyCode JoystickButton9;
	public const KeyCode JoystickButton10;
	public const KeyCode JoystickButton11;
	public const KeyCode JoystickButton12;
	public const KeyCode JoystickButton13;
	public const KeyCode JoystickButton14;
	public const KeyCode JoystickButton15;
	public const KeyCode JoystickButton16;
	public const KeyCode JoystickButton17;
	public const KeyCode JoystickButton18;
	public const KeyCode JoystickButton19;
	public const KeyCode Joystick1Button0;
	public const KeyCode Joystick1Button1;
	public const KeyCode Joystick1Button2;
	public const KeyCode Joystick1Button3;
	public const KeyCode Joystick1Button4;
	public const KeyCode Joystick1Button5;
	public const KeyCode Joystick1Button6;
	public const KeyCode Joystick1Button7;
	public const KeyCode Joystick1Button8;
	public const KeyCode Joystick1Button9;
	public const KeyCode Joystick1Button10;
	public const KeyCode Joystick1Button11;
	public const KeyCode Joystick1Button12;
	public const KeyCode Joystick1Button13;
	public const KeyCode Joystick1Button14;
	public const KeyCode Joystick1Button15;
	public const KeyCode Joystick1Button16;
	public const KeyCode Joystick1Button17;
	public const KeyCode Joystick1Button18;
	public const KeyCode Joystick1Button19;
	public const KeyCode Joystick2Button0;
	public const KeyCode Joystick2Button1;
	public const KeyCode Joystick2Button2;
	public const KeyCode Joystick2Button3;
	public const KeyCode Joystick2Button4;
	public const KeyCode Joystick2Button5;
	public const KeyCode Joystick2Button6;
	public const KeyCode Joystick2Button7;
	public const KeyCode Joystick2Button8;
	public const KeyCode Joystick2Button9;
	public const KeyCode Joystick2Button10;
	public const KeyCode Joystick2Button11;
	public const KeyCode Joystick2Button12;
	public const KeyCode Joystick2Button13;
	public const KeyCode Joystick2Button14;
	public const KeyCode Joystick2Button15;
	public const KeyCode Joystick2Button16;
	public const KeyCode Joystick2Button17;
	public const KeyCode Joystick2Button18;
	public const KeyCode Joystick2Button19;
	public const KeyCode Joystick3Button0;
	public const KeyCode Joystick3Button1;
	public const KeyCode Joystick3Button2;
	public const KeyCode Joystick3Button3;
	public const KeyCode Joystick3Button4;
	public const KeyCode Joystick3Button5;
	public const KeyCode Joystick3Button6;
	public const KeyCode Joystick3Button7;
	public const KeyCode Joystick3Button8;
	public const KeyCode Joystick3Button9;
	public const KeyCode Joystick3Button10;
	public const KeyCode Joystick3Button11;
	public const KeyCode Joystick3Button12;
	public const KeyCode Joystick3Button13;
	public const KeyCode Joystick3Button14;
	public const KeyCode Joystick3Button15;
	public const KeyCode Joystick3Button16;
	public const KeyCode Joystick3Button17;
	public const KeyCode Joystick3Button18;
	public const KeyCode Joystick3Button19;
	public const KeyCode Joystick4Button0;
	public const KeyCode Joystick4Button1;
	public const KeyCode Joystick4Button2;
	public const KeyCode Joystick4Button3;
	public const KeyCode Joystick4Button4;
	public const KeyCode Joystick4Button5;
	public const KeyCode Joystick4Button6;
	public const KeyCode Joystick4Button7;
	public const KeyCode Joystick4Button8;
	public const KeyCode Joystick4Button9;
	public const KeyCode Joystick4Button10;
	public const KeyCode Joystick4Button11;
	public const KeyCode Joystick4Button12;
	public const KeyCode Joystick4Button13;
	public const KeyCode Joystick4Button14;
	public const KeyCode Joystick4Button15;
	public const KeyCode Joystick4Button16;
	public const KeyCode Joystick4Button17;
	public const KeyCode Joystick4Button18;
	public const KeyCode Joystick4Button19;
	public const KeyCode Joystick5Button0;
	public const KeyCode Joystick5Button1;
	public const KeyCode Joystick5Button2;
	public const KeyCode Joystick5Button3;
	public const KeyCode Joystick5Button4;
	public const KeyCode Joystick5Button5;
	public const KeyCode Joystick5Button6;
	public const KeyCode Joystick5Button7;
	public const KeyCode Joystick5Button8;
	public const KeyCode Joystick5Button9;
	public const KeyCode Joystick5Button10;
	public const KeyCode Joystick5Button11;
	public const KeyCode Joystick5Button12;
	public const KeyCode Joystick5Button13;
	public const KeyCode Joystick5Button14;
	public const KeyCode Joystick5Button15;
	public const KeyCode Joystick5Button16;
	public const KeyCode Joystick5Button17;
	public const KeyCode Joystick5Button18;
	public const KeyCode Joystick5Button19;
	public const KeyCode Joystick6Button0;
	public const KeyCode Joystick6Button1;
	public const KeyCode Joystick6Button2;
	public const KeyCode Joystick6Button3;
	public const KeyCode Joystick6Button4;
	public const KeyCode Joystick6Button5;
	public const KeyCode Joystick6Button6;
	public const KeyCode Joystick6Button7;
	public const KeyCode Joystick6Button8;
	public const KeyCode Joystick6Button9;
	public const KeyCode Joystick6Button10;
	public const KeyCode Joystick6Button11;
	public const KeyCode Joystick6Button12;
	public const KeyCode Joystick6Button13;
	public const KeyCode Joystick6Button14;
	public const KeyCode Joystick6Button15;
	public const KeyCode Joystick6Button16;
	public const KeyCode Joystick6Button17;
	public const KeyCode Joystick6Button18;
	public const KeyCode Joystick6Button19;
	public const KeyCode Joystick7Button0;
	public const KeyCode Joystick7Button1;
	public const KeyCode Joystick7Button2;
	public const KeyCode Joystick7Button3;
	public const KeyCode Joystick7Button4;
	public const KeyCode Joystick7Button5;
	public const KeyCode Joystick7Button6;
	public const KeyCode Joystick7Button7;
	public const KeyCode Joystick7Button8;
	public const KeyCode Joystick7Button9;
	public const KeyCode Joystick7Button10;
	public const KeyCode Joystick7Button11;
	public const KeyCode Joystick7Button12;
	public const KeyCode Joystick7Button13;
	public const KeyCode Joystick7Button14;
	public const KeyCode Joystick7Button15;
	public const KeyCode Joystick7Button16;
	public const KeyCode Joystick7Button17;
	public const KeyCode Joystick7Button18;
	public const KeyCode Joystick7Button19;
	public const KeyCode Joystick8Button0;
	public const KeyCode Joystick8Button1;
	public const KeyCode Joystick8Button2;
	public const KeyCode Joystick8Button3;
	public const KeyCode Joystick8Button4;
	public const KeyCode Joystick8Button5;
	public const KeyCode Joystick8Button6;
	public const KeyCode Joystick8Button7;
	public const KeyCode Joystick8Button8;
	public const KeyCode Joystick8Button9;
	public const KeyCode Joystick8Button10;
	public const KeyCode Joystick8Button11;
	public const KeyCode Joystick8Button12;
	public const KeyCode Joystick8Button13;
	public const KeyCode Joystick8Button14;
	public const KeyCode Joystick8Button15;
	public const KeyCode Joystick8Button16;
	public const KeyCode Joystick8Button17;
	public const KeyCode Joystick8Button18;
	public const KeyCode Joystick8Button19;

}
//NameSpace:UnityEngine
public struct LayerMask
{
	// Fields
	private int m_Mask;

	// Methods
	public static int op_Implicit(LayerMask mask);
	public static LayerMask op_Implicit(int intVal);

}
//NameSpace:UnityEngine
internal static class ManagedStreamHelpers
{
	// Methods
	internal static void ValidateLoadFromStream(Stream stream);
	internal static void ManagedStreamRead(byte[] buffer, int offset, int count, Stream stream, IntPtr returnValueAddress);
	internal static void ManagedStreamSeek(long offset, uint origin, Stream stream, IntPtr returnValueAddress);
	internal static void ManagedStreamLength(Stream stream, IntPtr returnValueAddress);

}
//NameSpace:UnityEngine
public struct Matrix4x4 : IEquatable`1<Matrix4x4>
{
	// Fields
	public float m00;
	public float m10;
	public float m20;
	public float m30;
	public float m01;
	public float m11;
	public float m21;
	public float m31;
	public float m02;
	public float m12;
	public float m22;
	public float m32;
	public float m03;
	public float m13;
	public float m23;
	public float m33;
	private static readonly Matrix4x4 zeroMatrix;
	private static readonly Matrix4x4 identityMatrix;

	// Methods
	public void .ctor(Vector4 column0, Vector4 column1, Vector4 column2, Vector4 column3);
	public override int GetHashCode();
	public override bool Equals(object other);
	public bool Equals(Matrix4x4 other);
	public Vector4 GetColumn(int index);
	public Vector3 MultiplyPoint(Vector3 point);
	public Vector3 MultiplyPoint3x4(Vector3 point);
	public override string ToString();
	private static void .cctor();

}
//NameSpace:UnityEngine
public struct Vector3 : IEquatable`1<Vector3>
{
	// Fields
	public const float kEpsilon;
	public const float kEpsilonNormalSqrt;
	public float x;
	public float y;
	public float z;
	private static readonly Vector3 zeroVector;
	private static readonly Vector3 oneVector;
	private static readonly Vector3 upVector;
	private static readonly Vector3 downVector;
	private static readonly Vector3 leftVector;
	private static readonly Vector3 rightVector;
	private static readonly Vector3 forwardVector;
	private static readonly Vector3 backVector;
	private static readonly Vector3 positiveInfinityVector;
	private static readonly Vector3 negativeInfinityVector;

	// Properties
	public float Item { get; set; }
	public Vector3 normalized { get; }
	public float sqrMagnitude { get; }
	public static Vector3 zero { get; }
	public static Vector3 one { get; }
	public static Vector3 forward { get; }
	public static Vector3 back { get; }
	public static Vector3 up { get; }
	public static Vector3 down { get; }
	public static Vector3 left { get; }
	public static Vector3 right { get; }

	// Methods
	public void .ctor(float x, float y, float z);
	public void .ctor(float x, float y);
	public static Vector3 Lerp(Vector3 a, Vector3 b, float t);
	public float get_Item(int index);
	public void set_Item(int index, float value);
	public override int GetHashCode();
	public override bool Equals(object other);
	public bool Equals(Vector3 other);
	public static Vector3 Normalize(Vector3 value);
	public Vector3 get_normalized();
	public static float Dot(Vector3 lhs, Vector3 rhs);
	public static float Distance(Vector3 a, Vector3 b);
	public static float Magnitude(Vector3 vector);
	public static float SqrMagnitude(Vector3 vector);
	public float get_sqrMagnitude();
	public static Vector3 Min(Vector3 lhs, Vector3 rhs);
	public static Vector3 Max(Vector3 lhs, Vector3 rhs);
	public static Vector3 get_zero();
	public static Vector3 get_one();
	public static Vector3 get_forward();
	public static Vector3 get_back();
	public static Vector3 get_up();
	public static Vector3 get_down();
	public static Vector3 get_left();
	public static Vector3 get_right();
	public static Vector3 op_Addition(Vector3 a, Vector3 b);
	public static Vector3 op_Subtraction(Vector3 a, Vector3 b);
	public static Vector3 op_Multiply(Vector3 a, float d);
	public static Vector3 op_Division(Vector3 a, float d);
	public static bool op_Equality(Vector3 lhs, Vector3 rhs);
	public static bool op_Inequality(Vector3 lhs, Vector3 rhs);
	public override string ToString();
	private static void .cctor();

}
//NameSpace:UnityEngine
public struct Quaternion : IEquatable`1<Quaternion>
{
	// Fields
	public float x;
	public float y;
	public float z;
	public float w;
	private static readonly Quaternion identityQuaternion;

	// Methods
	public void .ctor(float x, float y, float z, float w);
	public static Quaternion Inverse(Quaternion rotation);
	public static Vector3 op_Multiply(Quaternion rotation, Vector3 point);
	private static bool IsEqualUsingDot(float dot);
	public static bool op_Equality(Quaternion lhs, Quaternion rhs);
	public static bool op_Inequality(Quaternion lhs, Quaternion rhs);
	public static float Dot(Quaternion a, Quaternion b);
	public override int GetHashCode();
	public override bool Equals(object other);
	public bool Equals(Quaternion other);
	public override string ToString();
	private static void .cctor();
	private static void Inverse_Injected(Quaternion rotation, out Quaternion ret);

}
//NameSpace:UnityEngine
public struct Mathf
{
	// Fields
	public static readonly float Epsilon;

	// Methods
	public static float Sin(float f);
	public static float Cos(float f);
	public static float Sqrt(float f);
	public static float Abs(float f);
	public static float Min(float a, float b);
	public static int Min(int a, int b);
	public static float Max(float a, float b);
	public static int Max(int a, int b);
	public static float Pow(float f, float p);
	public static float Log(float f, float p);
	public static float Floor(float f);
	public static float Round(float f);
	public static int CeilToInt(float f);
	public static int FloorToInt(float f);
	public static int RoundToInt(float f);
	public static float Sign(float f);
	public static float Clamp(float value, float min, float max);
	public static int Clamp(int value, int min, int max);
	public static float Clamp01(float value);
	public static float Lerp(float a, float b, float t);
	public static bool Approximately(float a, float b);
	public static float SmoothDamp(float current, float target, float currentVelocity, float smoothTime, float maxSpeed, float deltaTime);
	public static float Repeat(float t, float length);
	public static float InverseLerp(float a, float b, float value);
	private static void .cctor();

}
//NameSpace:UnityEngineInternal
public struct MathfInternal
{
	// Fields
	public static float FloatMinNormal;
	public static float FloatMinDenormal;
	public static bool IsFlushToZeroEnabled;

	// Methods
	private static void .cctor();

}
//NameSpace:UnityEngine
public sealed class Mesh : Object
{
	// Properties
	internal bool canAccess { get; }
	public int subMeshCount { get; }
	public Vector3[] vertices { get; }
	public Vector3[] normals { get; }
	public Vector4[] tangents { get; }
	public Vector2[] uv { get; }
	public Vector2[] uv2 { get; }
	public Vector2[] uv3 { get; }
	public Vector2[] uv4 { get; }
	public Color32[] colors32 { get; }

	// Methods
	public void .ctor();
	private static void Internal_Create(Mesh mono);
	private int[] GetIndicesImpl(int submesh, bool applyBaseVertex);
	private void SetIndicesImpl(int submesh, MeshTopology topology, Array indices, int arraySize, bool calculateBounds, int baseVertex);
	private void PrintErrorCantAccessChannel(VertexAttribute ch);
	internal bool HasChannel(VertexAttribute ch);
	private void SetArrayForChannelImpl(VertexAttribute channel, Mesh.InternalVertexChannelType format, int dim, Array values, int arraySize);
	private Array GetAllocArrayFromChannelImpl(VertexAttribute channel, Mesh.InternalVertexChannelType format, int dim);
	internal bool get_canAccess();
	public int get_subMeshCount();
	private void ClearImpl(bool keepVertexLayout);
	private void RecalculateBoundsImpl();
	internal VertexAttribute GetUVChannel(int uvIndex);
	internal static int DefaultDimensionForChannel(VertexAttribute channel);
	private T[] GetAllocArrayFromChannel(VertexAttribute channel, Mesh.InternalVertexChannelType format, int dim);
	private T[] GetAllocArrayFromChannel(VertexAttribute channel);
	private void SetSizedArrayForChannel(VertexAttribute channel, Mesh.InternalVertexChannelType format, int dim, Array values, int valuesCount);
	private void SetListForChannel(VertexAttribute channel, Mesh.InternalVertexChannelType format, int dim, List`1<T> values);
	private void SetListForChannel(VertexAttribute channel, List`1<T> values);
	public Vector3[] get_vertices();
	public Vector3[] get_normals();
	public Vector4[] get_tangents();
	public Vector2[] get_uv();
	public Vector2[] get_uv2();
	public Vector2[] get_uv3();
	public Vector2[] get_uv4();
	public Color32[] get_colors32();
	public void SetVertices(List`1<Vector3> inVertices);
	public void SetNormals(List`1<Vector3> inNormals);
	public void SetTangents(List`1<Vector4> inTangents);
	public void SetColors(List`1<Color32> inColors);
	private void SetUvsImpl(int uvIndex, int dim, List`1<T> uvs);
	public void SetUVs(int channel, List`1<Vector2> uvs);
	private void PrintErrorCantAccessIndices();
	private bool CheckCanAccessSubmesh(int submesh, bool errorAboutTriangles);
	private bool CheckCanAccessSubmeshTriangles(int submesh);
	private bool CheckCanAccessSubmeshIndices(int submesh);
	public int[] GetIndices(int submesh);
	public int[] GetIndices(int submesh, bool applyBaseVertex);
	private void SetTrianglesImpl(int submesh, Array triangles, int arraySize, bool calculateBounds, int baseVertex);
	public void SetTriangles(List`1<int> triangles, int submesh);
	public void SetTriangles(List`1<int> triangles, int submesh, bool calculateBounds, int baseVertex);
	public void Clear();
	public void RecalculateBounds();

}
//NameSpace:
internal enum Mesh.InternalVertexChannelType
{
	// Fields
	public int value__;
	public const Mesh.InternalVertexChannelType Float;
	public const Mesh.InternalVertexChannelType Color;

}
//NameSpace:UnityEngineInternal
public class ScriptingUtils
{
	// Methods
	public static Delegate CreateDelegate(Type type, MethodInfo methodInfo);

}
//NameSpace:UnityEngine
public class MonoBehaviour : Behaviour
{
	// Properties
	public bool useGUILayout { get; set; }

	// Methods
	public void .ctor();
	public bool IsInvoking();
	public void CancelInvoke();
	public void Invoke(string methodName, float time);
	public void InvokeRepeating(string methodName, float time, float repeatRate);
	public void CancelInvoke(string methodName);
	public bool IsInvoking(string methodName);
	public Coroutine StartCoroutine(string methodName);
	public Coroutine StartCoroutine(string methodName, object value);
	public Coroutine StartCoroutine(IEnumerator routine);
	public Coroutine StartCoroutine_Auto(IEnumerator routine);
	public void StopCoroutine(IEnumerator routine);
	public void StopCoroutine(Coroutine routine);
	public void StopCoroutine(string methodName);
	public void StopAllCoroutines();
	public bool get_useGUILayout();
	public void set_useGUILayout(bool value);
	public static void print(object message);
	private static void Internal_CancelInvokeAll(MonoBehaviour self);
	private static bool Internal_IsInvokingAll(MonoBehaviour self);
	private static void InvokeDelayed(MonoBehaviour self, string methodName, float time, float repeatRate);
	private static void CancelInvoke(MonoBehaviour self, string methodName);
	private static bool IsInvoking(MonoBehaviour self, string methodName);
	private static bool IsObjectMonoBehaviour(Object obj);
	private Coroutine StartCoroutineManaged(string methodName, object value);
	private Coroutine StartCoroutineManaged2(IEnumerator enumerator);
	private void StopCoroutineManaged(Coroutine routine);
	private void StopCoroutineFromEnumeratorManaged(IEnumerator routine);
	internal string GetScriptClassName();

}
//NameSpace:UnityEngine
internal class SendMouseEvents
{
	// Fields
	private static bool s_MouseUsed;
	private static readonly SendMouseEvents.HitInfo[] m_LastHit;
	private static readonly SendMouseEvents.HitInfo[] m_MouseDownHit;
	private static readonly SendMouseEvents.HitInfo[] m_CurrentHit;
	private static Camera[] m_Cameras;

	// Methods
	private static void SetMouseMoved();
	private static void HitTestLegacyGUI(Camera camera, Vector3 mousePosition, SendMouseEvents.HitInfo hitInfo);
	private static void DoSendMouseEvents(int skipRTCameras);
	private static void SendEvents(int i, SendMouseEvents.HitInfo hit);
	private static void .cctor();

}
//NameSpace:
private struct SendMouseEvents.HitInfo
{
	// Fields
	public GameObject target;
	public Camera camera;

	// Methods
	public void SendMessage(string name);
	public static bool op_Implicit(SendMouseEvents.HitInfo exists);
	public static bool Compare(SendMouseEvents.HitInfo lhs, SendMouseEvents.HitInfo rhs);

}
//NameSpace:UnityEngine
internal sealed class NoAllocHelpers
{
	// Methods
	public static int SafeLength(List`1<T> values);
	public static Array ExtractArrayFromList(object list);

}
//NameSpace:UnityEngine
public struct Plane
{
	// Fields
	private Vector3 m_Normal;
	private float m_Distance;

	// Methods
	public void .ctor(Vector3 inNormal, Vector3 inPoint);
	public bool Raycast(Ray ray, out float enter);
	public override string ToString();

}
//NameSpace:UnityEngine
internal interface IPlayerEditorConnectionNative
{
	// Methods
	public abstract void Initialize();
	public abstract void DisconnectAll();
	public abstract void SendMessage(Guid messageId, byte[] data, int playerId);
	public abstract void Poll();
	public abstract void RegisterInternal(Guid messageId);
	public abstract void UnregisterInternal(Guid messageId);
	public abstract bool IsConnected();

}
//NameSpace:UnityEngine
internal class PlayerConnectionInternal : IPlayerEditorConnectionNative
{
	// Methods
	public void .ctor();
	private void UnityEngine.IPlayerEditorConnectionNative.SendMessage(Guid messageId, byte[] data, int playerId);
	private void UnityEngine.IPlayerEditorConnectionNative.Poll();
	private void UnityEngine.IPlayerEditorConnectionNative.RegisterInternal(Guid messageId);
	private void UnityEngine.IPlayerEditorConnectionNative.UnregisterInternal(Guid messageId);
	private void UnityEngine.IPlayerEditorConnectionNative.Initialize();
	private bool UnityEngine.IPlayerEditorConnectionNative.IsConnected();
	private void UnityEngine.IPlayerEditorConnectionNative.DisconnectAll();
	private static bool IsConnected();
	private static void Initialize();
	private static void RegisterInternal(string messageId);
	private static void UnregisterInternal(string messageId);
	private static void SendMessage(string messageId, byte[] data, int playerId);
	private static void PollInternal();
	private static void DisconnectAll();

}
//NameSpace:UnityEngine.Experimental.PlayerLoop
public struct Initialization
{
}
//NameSpace:
public struct Initialization.PlayerUpdateTime
{
}
//NameSpace:
public struct Initialization.AsyncUploadTimeSlicedUpdate
{
}
//NameSpace:
public struct Initialization.SynchronizeState
{
}
//NameSpace:
public struct Initialization.SynchronizeInputs
{
}
//NameSpace:
public struct Initialization.XREarlyUpdate
{
}
//NameSpace:UnityEngine.Experimental.PlayerLoop
public struct EarlyUpdate
{
}
//NameSpace:
public struct EarlyUpdate.PollPlayerConnection
{
}
//NameSpace:
public struct EarlyUpdate.ProfilerStartFrame
{
}
//NameSpace:
public struct EarlyUpdate.PollHtcsPlayerConnection
{
}
//NameSpace:
public struct EarlyUpdate.GpuTimestamp
{
}
//NameSpace:
public struct EarlyUpdate.AnalyticsCoreStatsUpdate
{
}
//NameSpace:
public struct EarlyUpdate.UnityWebRequestUpdate
{
}
//NameSpace:
public struct EarlyUpdate.UpdateStreamingManager
{
}
//NameSpace:
public struct EarlyUpdate.ExecuteMainThreadJobs
{
}
//NameSpace:
public struct EarlyUpdate.ProcessMouseInWindow
{
}
//NameSpace:
public struct EarlyUpdate.ClearIntermediateRenderers
{
}
//NameSpace:
public struct EarlyUpdate.ClearLines
{
}
//NameSpace:
public struct EarlyUpdate.PresentBeforeUpdate
{
}
//NameSpace:
public struct EarlyUpdate.ResetFrameStatsAfterPresent
{
}
//NameSpace:
public struct EarlyUpdate.UpdateAllUnityWebStreams
{
}
//NameSpace:
public struct EarlyUpdate.UpdateAsyncReadbackManager
{
}
//NameSpace:
public struct EarlyUpdate.UpdateTextureStreamingManager
{
}
//NameSpace:
public struct EarlyUpdate.UpdatePreloading
{
}
//NameSpace:
public struct EarlyUpdate.RendererNotifyInvisible
{
}
//NameSpace:
public struct EarlyUpdate.PlayerCleanupCachedData
{
}
//NameSpace:
public struct EarlyUpdate.UpdateMainGameViewRect
{
}
//NameSpace:
public struct EarlyUpdate.UpdateCanvasRectTransform
{
}
//NameSpace:
public struct EarlyUpdate.UpdateInputManager
{
}
//NameSpace:
public struct EarlyUpdate.ProcessRemoteInput
{
}
//NameSpace:
public struct EarlyUpdate.XRUpdate
{
}
//NameSpace:
public struct EarlyUpdate.ScriptRunDelayedStartupFrame
{
}
//NameSpace:
public struct EarlyUpdate.UpdateKinect
{
}
//NameSpace:
public struct EarlyUpdate.DeliverIosPlatformEvents
{
}
//NameSpace:
public struct EarlyUpdate.DispatchEventQueueEvents
{
}
//NameSpace:
public struct EarlyUpdate.DirectorSampleTime
{
}
//NameSpace:
public struct EarlyUpdate.PhysicsResetInterpolatedTransformPosition
{
}
//NameSpace:
public struct EarlyUpdate.SpriteAtlasManagerUpdate
{
}
//NameSpace:
public struct EarlyUpdate.TangoUpdate
{
}
//NameSpace:
public struct EarlyUpdate.PerformanceAnalyticsUpdate
{
}
//NameSpace:UnityEngine.Experimental.PlayerLoop
public struct FixedUpdate
{
}
//NameSpace:
public struct FixedUpdate.ClearLines
{
}
//NameSpace:
public struct FixedUpdate.DirectorFixedSampleTime
{
}
//NameSpace:
public struct FixedUpdate.AudioFixedUpdate
{
}
//NameSpace:
public struct FixedUpdate.ScriptRunBehaviourFixedUpdate
{
}
//NameSpace:
public struct FixedUpdate.DirectorFixedUpdate
{
}
//NameSpace:
public struct FixedUpdate.LegacyFixedAnimationUpdate
{
}
//NameSpace:
public struct FixedUpdate.XRFixedUpdate
{
}
//NameSpace:
public struct FixedUpdate.PhysicsFixedUpdate
{
}
//NameSpace:
public struct FixedUpdate.Physics2DFixedUpdate
{
}
//NameSpace:
public struct FixedUpdate.DirectorFixedUpdatePostPhysics
{
}
//NameSpace:
public struct FixedUpdate.ScriptRunDelayedFixedFrameRate
{
}
//NameSpace:
public struct FixedUpdate.NewInputFixedUpdate
{
}
//NameSpace:UnityEngine.Experimental.PlayerLoop
public struct PreUpdate
{
}
//NameSpace:
public struct PreUpdate.PhysicsUpdate
{
}
//NameSpace:
public struct PreUpdate.Physics2DUpdate
{
}
//NameSpace:
public struct PreUpdate.CheckTexFieldInput
{
}
//NameSpace:
public struct PreUpdate.IMGUISendQueuedEvents
{
}
//NameSpace:
public struct PreUpdate.SendMouseEvents
{
}
//NameSpace:
public struct PreUpdate.AIUpdate
{
}
//NameSpace:
public struct PreUpdate.WindUpdate
{
}
//NameSpace:
public struct PreUpdate.UpdateVideo
{
}
//NameSpace:
public struct PreUpdate.NewInputUpdate
{
}
//NameSpace:UnityEngine.Experimental.PlayerLoop
public struct Update
{
}
//NameSpace:
public struct Update.ScriptRunBehaviourUpdate
{
}
//NameSpace:
public struct Update.DirectorUpdate
{
}
//NameSpace:
public struct Update.ScriptRunDelayedDynamicFrameRate
{
}
//NameSpace:
public struct Update.ScriptRunDelayedTasks
{
}
//NameSpace:UnityEngine.Experimental.PlayerLoop
public struct PreLateUpdate
{
}
//NameSpace:
public struct PreLateUpdate.AIUpdatePostScript
{
}
//NameSpace:
public struct PreLateUpdate.DirectorUpdateAnimationBegin
{
}
//NameSpace:
public struct PreLateUpdate.LegacyAnimationUpdate
{
}
//NameSpace:
public struct PreLateUpdate.DirectorUpdateAnimationEnd
{
}
//NameSpace:
public struct PreLateUpdate.DirectorDeferredEvaluate
{
}
//NameSpace:
public struct PreLateUpdate.UpdateNetworkManager
{
}
//NameSpace:
public struct PreLateUpdate.UpdateMasterServerInterface
{
}
//NameSpace:
public struct PreLateUpdate.UNetUpdate
{
}
//NameSpace:
public struct PreLateUpdate.EndGraphicsJobsAfterScriptUpdate
{
}
//NameSpace:
public struct PreLateUpdate.ParticleSystemBeginUpdateAll
{
}
//NameSpace:
public struct PreLateUpdate.ScriptRunBehaviourLateUpdate
{
}
//NameSpace:
public struct PreLateUpdate.ConstraintManagerUpdate
{
}
//NameSpace:UnityEngine.Experimental.PlayerLoop
public struct PostLateUpdate
{
}
//NameSpace:
public struct PostLateUpdate.PlayerSendFrameStarted
{
}
//NameSpace:
public struct PostLateUpdate.UpdateRectTransform
{
}
//NameSpace:
public struct PostLateUpdate.UpdateCanvasRectTransform
{
}
//NameSpace:
public struct PostLateUpdate.PlayerUpdateCanvases
{
}
//NameSpace:
public struct PostLateUpdate.UpdateAudio
{
}
//NameSpace:
public struct PostLateUpdate.UpdateVideo
{
}
//NameSpace:
public struct PostLateUpdate.DirectorLateUpdate
{
}
//NameSpace:
public struct PostLateUpdate.ScriptRunDelayedDynamicFrameRate
{
}
//NameSpace:
public struct PostLateUpdate.VFXUpdate
{
}
//NameSpace:
public struct PostLateUpdate.ParticleSystemEndUpdateAll
{
}
//NameSpace:
public struct PostLateUpdate.EndGraphicsJobsAfterScriptLateUpdate
{
}
//NameSpace:
public struct PostLateUpdate.UpdateSubstance
{
}
//NameSpace:
public struct PostLateUpdate.UpdateCustomRenderTextures
{
}
//NameSpace:
public struct PostLateUpdate.UpdateAllRenderers
{
}
//NameSpace:
public struct PostLateUpdate.EnlightenRuntimeUpdate
{
}
//NameSpace:
public struct PostLateUpdate.UpdateAllSkinnedMeshes
{
}
//NameSpace:
public struct PostLateUpdate.ProcessWebSendMessages
{
}
//NameSpace:
public struct PostLateUpdate.SortingGroupsUpdate
{
}
//NameSpace:
public struct PostLateUpdate.UpdateVideoTextures
{
}
//NameSpace:
public struct PostLateUpdate.DirectorRenderImage
{
}
//NameSpace:
public struct PostLateUpdate.PlayerEmitCanvasGeometry
{
}
//NameSpace:
public struct PostLateUpdate.FinishFrameRendering
{
}
//NameSpace:
public struct PostLateUpdate.BatchModeUpdate
{
}
//NameSpace:
public struct PostLateUpdate.PlayerSendFrameComplete
{
}
//NameSpace:
public struct PostLateUpdate.UpdateCaptureScreenshot
{
}
//NameSpace:
public struct PostLateUpdate.PresentAfterDraw
{
}
//NameSpace:
public struct PostLateUpdate.ClearImmediateRenderers
{
}
//NameSpace:
public struct PostLateUpdate.XRPostPresent
{
}
//NameSpace:
public struct PostLateUpdate.UpdateResolution
{
}
//NameSpace:
public struct PostLateUpdate.InputEndFrame
{
}
//NameSpace:
public struct PostLateUpdate.GUIClearEvents
{
}
//NameSpace:
public struct PostLateUpdate.ShaderHandleErrors
{
}
//NameSpace:
public struct PostLateUpdate.ResetInputAxis
{
}
//NameSpace:
public struct PostLateUpdate.ThreadedLoadingDebug
{
}
//NameSpace:
public struct PostLateUpdate.ProfilerSynchronizeStats
{
}
//NameSpace:
public struct PostLateUpdate.MemoryFrameMaintenance
{
}
//NameSpace:
public struct PostLateUpdate.ExecuteGameCenterCallbacks
{
}
//NameSpace:
public struct PostLateUpdate.ProfilerEndFrame
{
}
//NameSpace:
public struct PostLateUpdate.PlayerSendFramePostPresent
{
}
//NameSpace:
public struct PostLateUpdate.PhysicsSkinnedClothBeginUpdate
{
}
//NameSpace:
public struct PostLateUpdate.PhysicsSkinnedClothFinishUpdate
{
}
//NameSpace:
public struct PostLateUpdate.TriggerEndOfFrameCallbacks
{
}
//NameSpace:UnityEngine.Experimental.LowLevel
internal struct PlayerLoopSystemInternal
{
	// Fields
	public Type type;
	public PlayerLoopSystem.UpdateFunction updateDelegate;
	public IntPtr updateFunction;
	public IntPtr loopConditionFunction;
	public int numSubSystems;

}
//NameSpace:UnityEngine.Experimental.LowLevel
public struct PlayerLoopSystem
{
	// Fields
	public Type type;
	public PlayerLoopSystem[] subSystemList;
	public PlayerLoopSystem.UpdateFunction updateDelegate;
	public IntPtr updateFunction;
	public IntPtr loopConditionFunction;

}
//NameSpace:
public sealed class PlayerLoopSystem.UpdateFunction : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke();
	public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine
public abstract class PropertyAttribute : Attribute
{
	// Methods
	protected void .ctor();

}
//NameSpace:UnityEngine
public class TooltipAttribute : PropertyAttribute
{
	// Fields
	public readonly string tooltip;

	// Methods
	public void .ctor(string tooltip);

}
//NameSpace:UnityEngine
public class SpaceAttribute : PropertyAttribute
{
	// Fields
	public readonly float height;

	// Methods
	public void .ctor();
	public void .ctor(float height);

}
//NameSpace:UnityEngine
public sealed class RangeAttribute : PropertyAttribute
{
	// Fields
	public readonly float min;
	public readonly float max;

	// Methods
	public void .ctor(float min, float max);

}
//NameSpace:UnityEngine
public sealed class TextAreaAttribute : PropertyAttribute
{
	// Fields
	public readonly int minLines;
	public readonly int maxLines;

	// Methods
	public void .ctor(int minLines, int maxLines);

}
//NameSpace:UnityEngine
internal class PropertyNameUtils
{
	// Methods
	public static PropertyName PropertyNameFromString(string name);
	private static void PropertyNameFromString_Injected(string name, out PropertyName ret);

}
//NameSpace:UnityEngine
public struct PropertyName : IEquatable`1<PropertyName>
{
	// Fields
	internal int id;

	// Methods
	public void .ctor(string name);
	public void .ctor(PropertyName other);
	public void .ctor(int id);
	public static bool op_Equality(PropertyName lhs, PropertyName rhs);
	public override int GetHashCode();
	public override bool Equals(object other);
	public bool Equals(PropertyName other);
	public static PropertyName op_Implicit(string name);
	public static PropertyName op_Implicit(int id);
	public override string ToString();

}
//NameSpace:UnityEngine
public struct RangeInt
{
	// Fields
	public int start;
	public int length;

	// Properties
	public int end { get; }

	// Methods
	public void .ctor(int start, int length);
	public int get_end();

}
//NameSpace:UnityEngine
public struct Ray
{
	// Fields
	private Vector3 m_Origin;
	private Vector3 m_Direction;

	// Properties
	public Vector3 origin { get; }
	public Vector3 direction { get; }

	// Methods
	public void .ctor(Vector3 origin, Vector3 direction);
	public Vector3 get_origin();
	public Vector3 get_direction();
	public Vector3 GetPoint(float distance);
	public override string ToString();

}
//NameSpace:UnityEngine
public struct Rect : IEquatable`1<Rect>
{
	// Fields
	private float m_XMin;
	private float m_YMin;
	private float m_Width;
	private float m_Height;

	// Properties
	public static Rect zero { get; }
	public float x { get; set; }
	public float y { get; set; }
	public Vector2 position { get; }
	public Vector2 center { get; }
	public Vector2 min { get; }
	public Vector2 max { get; }
	public float width { get; set; }
	public float height { get; set; }
	public Vector2 size { get; }
	public float xMin { get; set; }
	public float yMin { get; set; }
	public float xMax { get; set; }
	public float yMax { get; set; }

	// Methods
	public void .ctor(float x, float y, float width, float height);
	public static Rect get_zero();
	public float get_x();
	public void set_x(float value);
	public float get_y();
	public void set_y(float value);
	public Vector2 get_position();
	public Vector2 get_center();
	public Vector2 get_min();
	public Vector2 get_max();
	public float get_width();
	public void set_width(float value);
	public float get_height();
	public void set_height(float value);
	public Vector2 get_size();
	public float get_xMin();
	public void set_xMin(float value);
	public float get_yMin();
	public void set_yMin(float value);
	public float get_xMax();
	public void set_xMax(float value);
	public float get_yMax();
	public void set_yMax(float value);
	public bool Contains(Vector3 point);
	private static Rect OrderMinMax(Rect rect);
	public bool Overlaps(Rect other);
	public bool Overlaps(Rect other, bool allowInverse);
	public static bool op_Inequality(Rect lhs, Rect rhs);
	public static bool op_Equality(Rect lhs, Rect rhs);
	public override int GetHashCode();
	public override bool Equals(object other);
	public bool Equals(Rect other);
	public override string ToString();

}
//NameSpace:UnityEngine
public sealed class ReflectionProbe : Behaviour
{
	// Fields
	private static Action`2<ReflectionProbeReflectionProbe.ReflectionProbeEvent> reflectionProbeChanged;
	private static Action`1<Cubemap> defaultReflectionSet;

	// Methods
	private static void CallReflectionProbeEvent(ReflectionProbe probe, ReflectionProbe.ReflectionProbeEvent probeEvent);
	private static void CallSetDefaultReflection(Cubemap defaultReflectionCubemap);

}
//NameSpace:
public enum ReflectionProbe.ReflectionProbeEvent
{
	// Fields
	public int value__;
	public const ReflectionProbe.ReflectionProbeEvent ReflectionProbeAdded;
	public const ReflectionProbe.ReflectionProbeEvent ReflectionProbeRemoved;

}
//NameSpace:UnityEngine
public class ResourceRequest : AsyncOperation
{
	// Fields
	internal string m_Path;
	internal Type m_Type;

}
//NameSpace:UnityEngine
public sealed class Resources
{
	// Methods
	public static Object GetBuiltinResource(Type type, string path);
	public static T GetBuiltinResource(string path);

}
//NameSpace:UnityEngine
public enum RuntimeInitializeLoadType
{
	// Fields
	public int value__;
	public const RuntimeInitializeLoadType AfterSceneLoad;
	public const RuntimeInitializeLoadType BeforeSceneLoad;

}
//NameSpace:UnityEngine
public class RuntimeInitializeOnLoadMethodAttribute : PreserveAttribute
{
	// Fields
	private RuntimeInitializeLoadType <loadType>k__BackingField;

	// Properties
	private void loadType { set; }

	// Methods
	public void .ctor(RuntimeInitializeLoadType loadType);
	private void set_loadType(RuntimeInitializeLoadType value);

}
//NameSpace:UnityEngine
public class ScriptableObject : Object
{
	// Methods
	public void .ctor();
	public static ScriptableObject CreateInstance(Type type);
	public static T CreateInstance();
	private static void CreateScriptableObject(ScriptableObject self);
	private static ScriptableObject CreateScriptableObjectInstanceFromType(Type type);

}
//NameSpace:UnityEngine.Experimental.Rendering
public struct ScriptableRenderContext
{
	// Fields
	private IntPtr m_Ptr;

	// Methods
	internal void .ctor(IntPtr ptr);

}
//NameSpace:UnityEngine
public class SelectionBaseAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine
public sealed class SerializePrivateVariables : Attribute
{
}
//NameSpace:UnityEngine
public sealed class SerializeField : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine
public sealed class PreferBinarySerialization : Attribute
{
}
//NameSpace:UnityEngine
public interface ISerializationCallbackReceiver
{
	// Methods
	public abstract void OnBeforeSerialize();
	public abstract void OnAfterDeserialize();

}
//NameSpace:UnityEngine
public sealed class ComputeShader : Object
{
	// Methods
	public int FindKernel(string name);

}
//NameSpace:UnityEngine
public struct SortingLayer
{
	// Fields
	private int m_Id;

	// Methods
	public static int GetLayerValueFromID(int id);

}
//NameSpace:UnityEngine
public static class StackTraceUtility
{
	// Fields
	private static string projectFolder;

	// Methods
	internal static void SetProjectFolder(string folder);
	public static string ExtractStackTrace();
	private static bool IsSystemStacktraceType(object name);
	internal static void ExtractStringFromExceptionInternal(object exceptiono, out string message, out string stackTrace);
	internal static string PostprocessStacktrace(string oldString, bool stripEngineInternalInformation);
	internal static string ExtractFormattedStackTrace(StackTrace stackTrace);
	private static void .cctor();

}
//NameSpace:UnityEngine
public class UnityException : Exception
{
	// Methods
	public void .ctor();
	public void .ctor(string message);
	protected void .ctor(SerializationInfo info, StreamingContext context);

}
//NameSpace:UnityEngine
public enum OperatingSystemFamily
{
	// Fields
	public int value__;
	public const OperatingSystemFamily Other;
	public const OperatingSystemFamily MacOSX;
	public const OperatingSystemFamily Windows;
	public const OperatingSystemFamily Linux;

}
//NameSpace:UnityEngine
public sealed class SystemInfo
{
	// Properties
	public static OperatingSystemFamily operatingSystemFamily { get; }

	// Methods
	public static OperatingSystemFamily get_operatingSystemFamily();
	private static bool IsValidEnumValue(Enum value);
	public static bool SupportsRenderTextureFormat(RenderTextureFormat format);
	public static bool SupportsTextureFormat(TextureFormat format);
	private static OperatingSystemFamily GetOperatingSystemFamily();
	private static bool HasRenderTextureNative(RenderTextureFormat format);
	private static bool SupportsTextureFormatNative(TextureFormat format);
	public static bool IsFormatSupported(GraphicsFormat format, FormatUsage usage);

}
//NameSpace:UnityEngine
public class Texture : Object
{
	// Properties
	public virtual int width { get; set; }
	public virtual int height { get; set; }
	public virtual bool isReadable { get; }
	public TextureWrapMode wrapMode { get; }
	public Vector2 texelSize { get; }

	// Methods
	protected void .ctor();
	private int GetDataWidth();
	private int GetDataHeight();
	public virtual int get_width();
	public virtual void set_width(int value);
	public virtual int get_height();
	public virtual void set_height(int value);
	public virtual bool get_isReadable();
	public TextureWrapMode get_wrapMode();
	public Vector2 get_texelSize();
	internal bool ValidateFormat(RenderTextureFormat format);
	internal bool ValidateFormat(TextureFormat format);
	internal bool ValidateFormat(GraphicsFormat format, FormatUsage usage);
	internal UnityException CreateNonReadableException(Texture t);
	private void get_texelSize_Injected(out Vector2 ret);

}
//NameSpace:UnityEngine
public sealed class Texture2D : Texture
{
	// Properties
	public TextureFormat format { get; }
	public static Texture2D whiteTexture { get; }
	public override bool isReadable { get; }

	// Methods
	internal void .ctor(int width, int height, TextureFormat textureFormat, bool mipChain, bool linear, IntPtr nativeTex);
	public void .ctor(int width, int height);
	public TextureFormat get_format();
	public static Texture2D get_whiteTexture();
	private static bool Internal_CreateImpl(Texture2D mono, int w, int h, GraphicsFormat format, TextureCreationFlags flags, IntPtr nativeTex);
	private static void Internal_Create(Texture2D mono, int w, int h, GraphicsFormat format, TextureCreationFlags flags, IntPtr nativeTex);
	public override bool get_isReadable();
	private Color GetPixelBilinearImpl(int image, float x, float y);
	public byte[] GetRawTextureData();
	public Color GetPixelBilinear(float x, float y);
	private void GetPixelBilinearImpl_Injected(int image, float x, float y, out Color ret);

}
//NameSpace:UnityEngine
public sealed class Cubemap : Texture
{
	// Properties
	public override bool isReadable { get; }

	// Methods
	public void .ctor(int width, GraphicsFormat format, TextureCreationFlags flags);
	internal void .ctor(int width, TextureFormat textureFormat, bool mipChain, IntPtr nativeTex);
	public void .ctor(int width, TextureFormat textureFormat, bool mipChain);
	private static bool Internal_CreateImpl(Cubemap mono, int ext, GraphicsFormat format, TextureCreationFlags flags, IntPtr nativeTex);
	private static void Internal_Create(Cubemap mono, int ext, GraphicsFormat format, TextureCreationFlags flags, IntPtr nativeTex);
	public override bool get_isReadable();

}
//NameSpace:UnityEngine
public sealed class Texture3D : Texture
{
	// Properties
	public override bool isReadable { get; }

	// Methods
	public void .ctor(int width, int height, int depth, GraphicsFormat format, TextureCreationFlags flags);
	public void .ctor(int width, int height, int depth, TextureFormat textureFormat, bool mipChain);
	public override bool get_isReadable();
	private static bool Internal_CreateImpl(Texture3D mono, int w, int h, int d, GraphicsFormat format, TextureCreationFlags flags);
	private static void Internal_Create(Texture3D mono, int w, int h, int d, GraphicsFormat format, TextureCreationFlags flags);

}
//NameSpace:UnityEngine
public sealed class Texture2DArray : Texture
{
	// Properties
	public override bool isReadable { get; }

	// Methods
	public void .ctor(int width, int height, int depth, GraphicsFormat format, TextureCreationFlags flags);
	public void .ctor(int width, int height, int depth, TextureFormat textureFormat, bool mipChain, bool linear);
	public void .ctor(int width, int height, int depth, TextureFormat textureFormat, bool mipChain);
	public override bool get_isReadable();
	private static bool Internal_CreateImpl(Texture2DArray mono, int w, int h, int d, GraphicsFormat format, TextureCreationFlags flags);
	private static void Internal_Create(Texture2DArray mono, int w, int h, int d, GraphicsFormat format, TextureCreationFlags flags);

}
//NameSpace:UnityEngine
public sealed class CubemapArray : Texture
{
	// Properties
	public override bool isReadable { get; }

	// Methods
	public void .ctor(int width, int cubemapCount, GraphicsFormat format, TextureCreationFlags flags);
	public void .ctor(int width, int cubemapCount, TextureFormat textureFormat, bool mipChain, bool linear);
	public void .ctor(int width, int cubemapCount, TextureFormat textureFormat, bool mipChain);
	public override bool get_isReadable();
	private static bool Internal_CreateImpl(CubemapArray mono, int ext, int count, GraphicsFormat format, TextureCreationFlags flags);
	private static void Internal_Create(CubemapArray mono, int ext, int count, GraphicsFormat format, TextureCreationFlags flags);

}
//NameSpace:UnityEngine
public class RenderTexture : Texture
{
	// Properties
	public override int width { get; set; }
	public override int height { get; set; }
	public void format { set; }
	public void depth { set; }
	public RenderTextureDescriptor descriptor { get; }

	// Methods
	protected internal void .ctor();
	public void .ctor(RenderTextureDescriptor desc);
	public void .ctor(RenderTexture textureToCopy);
	public void .ctor(int width, int height, int depth, GraphicsFormat format);
	public void .ctor(int width, int height, int depth, RenderTextureFormat format, RenderTextureReadWrite readWrite);
	public void .ctor(int width, int height, int depth, RenderTextureFormat format);
	public void .ctor(int width, int height, int depth);
	public override int get_width();
	public override void set_width(int value);
	public override int get_height();
	public override void set_height(int value);
	public void set_format(RenderTextureFormat value);
	internal void SetSRGBReadWrite(bool srgb);
	private static void Internal_Create(RenderTexture rt);
	private void SetRenderTextureDescriptor(RenderTextureDescriptor desc);
	private RenderTextureDescriptor GetDescriptor();
	public void set_depth(int value);
	public RenderTextureDescriptor get_descriptor();
	private static void ValidateRenderTextureDesc(RenderTextureDescriptor desc);
	private void SetRenderTextureDescriptor_Injected(RenderTextureDescriptor desc);
	private void GetDescriptor_Injected(out RenderTextureDescriptor ret);

}
//NameSpace:UnityEngine
public struct RenderTextureDescriptor
{
	// Fields
	private int <width>k__BackingField;
	private int <height>k__BackingField;
	private int <msaaSamples>k__BackingField;
	private int <volumeDepth>k__BackingField;
	private RenderTextureFormat <colorFormat>k__BackingField;
	private int _depthBufferBits;
	private static int[] depthFormatBits;
	private TextureDimension <dimension>k__BackingField;
	private ShadowSamplingMode <shadowSamplingMode>k__BackingField;
	private VRTextureUsage <vrUsage>k__BackingField;
	private RenderTextureCreationFlags _flags;
	private RenderTextureMemoryless <memoryless>k__BackingField;

	// Properties
	public int width { get; }
	public int height { get; }
	public int msaaSamples { get; }
	public int volumeDepth { get; }
	public int depthBufferBits { get; }

	// Methods
	public int get_width();
	public int get_height();
	public int get_msaaSamples();
	public int get_volumeDepth();
	public int get_depthBufferBits();
	private static void .cctor();

}
//NameSpace:UnityEngine
public class Time
{
	// Properties
	public static float deltaTime { get; }
	public static float unscaledTime { get; }
	public static float unscaledDeltaTime { get; }
	public static float realtimeSinceStartup { get; }

	// Methods
	public static float get_deltaTime();
	public static float get_unscaledTime();
	public static float get_unscaledDeltaTime();
	public static float get_realtimeSinceStartup();

}
//NameSpace:UnityEngine
public enum TouchScreenKeyboardType
{
	// Fields
	public int value__;
	public const TouchScreenKeyboardType Default;
	public const TouchScreenKeyboardType ASCIICapable;
	public const TouchScreenKeyboardType NumbersAndPunctuation;
	public const TouchScreenKeyboardType URL;
	public const TouchScreenKeyboardType NumberPad;
	public const TouchScreenKeyboardType PhonePad;
	public const TouchScreenKeyboardType NamePhonePad;
	public const TouchScreenKeyboardType EmailAddress;
	public const TouchScreenKeyboardType NintendoNetworkAccount;
	public const TouchScreenKeyboardType Social;
	public const TouchScreenKeyboardType Search;

}
//NameSpace:UnityEngine
public class TrackedReference
{
	// Fields
	internal IntPtr m_Ptr;

	// Methods
	public static bool op_Equality(TrackedReference x, TrackedReference y);
	public override bool Equals(object o);
	public override int GetHashCode();

}
//NameSpace:UnityEngine
internal sealed class UnhandledExceptionHandler
{
	// Fields
	private static UnhandledExceptionEventHandler <>f__mg$cache0;

	// Methods
	private static void RegisterUECatcher();
	private static void HandleUnhandledException(object sender, UnhandledExceptionEventArgs args);
	private static void PrintException(string title, Exception e);
	private static void iOSNativeUnhandledExceptionHandler(string managedExceptionType, string managedExceptionMessage, string managedExceptionStack);

}
//NameSpace:UnityEngine
public class UnityAPICompatibilityVersionAttribute : Attribute
{
	// Fields
	private string _version;

	// Methods
	public void .ctor(string version);

}
//NameSpace:UnityEngine
public enum HideFlags
{
	// Fields
	public int value__;
	public const HideFlags None;
	public const HideFlags HideInHierarchy;
	public const HideFlags HideInInspector;
	public const HideFlags DontSaveInEditor;
	public const HideFlags NotEditable;
	public const HideFlags DontSaveInBuild;
	public const HideFlags DontUnloadUnusedAsset;
	public const HideFlags DontSave;
	public const HideFlags HideAndDontSave;

}
//NameSpace:UnityEngine
public class Object
{
	// Fields
	private IntPtr m_CachedPtr;
	internal static int OffsetOfInstanceIDInCPlusPlusObject;
	private const string objectIsNullMessage;
	private const string cloneDestroyedMessage;

	// Properties
	public string name { get; set; }
	public void hideFlags { set; }

	// Methods
	public void .ctor();
	public override int GetHashCode();
	public override bool Equals(object other);
	public static bool op_Implicit(Object exists);
	private static bool CompareBaseObjects(Object lhs, Object rhs);
	private static bool IsNativeObjectAlive(Object o);
	private IntPtr GetCachedPtr();
	public string get_name();
	public void set_name(string value);
	public static T Instantiate(T original);
	public static void Destroy(Object obj, float t);
	public static void Destroy(Object obj);
	public static void DestroyImmediate(Object obj, bool allowDestroyingAssets);
	public static void DestroyImmediate(Object obj);
	public void set_hideFlags(HideFlags value);
	private static void CheckNullArgument(object arg, string message);
	public override string ToString();
	public static bool op_Equality(Object x, Object y);
	public static bool op_Inequality(Object x, Object y);
	private static Object Internal_CloneSingle(Object data);
	private static string ToString(Object obj);
	private static string GetName(Object obj);
	private static void SetName(Object obj, string name);
	internal static Object FindObjectFromInstanceID(int instanceID);
	private static void .cctor();

}
//NameSpace:UnityEngine.Events
public enum PersistentListenerMode
{
	// Fields
	public int value__;
	public const PersistentListenerMode EventDefined;
	public const PersistentListenerMode Void;
	public const PersistentListenerMode Object;
	public const PersistentListenerMode Int;
	public const PersistentListenerMode Float;
	public const PersistentListenerMode String;
	public const PersistentListenerMode Bool;

}
//NameSpace:UnityEngine.Events
internal class ArgumentCache : ISerializationCallbackReceiver
{
	// Fields
	private Object m_ObjectArgument;
	private string m_ObjectArgumentAssemblyTypeName;
	private int m_IntArgument;
	private float m_FloatArgument;
	private string m_StringArgument;
	private bool m_BoolArgument;

	// Properties
	public Object unityObjectArgument { get; }
	public string unityObjectArgumentAssemblyTypeName { get; }
	public int intArgument { get; }
	public float floatArgument { get; }
	public string stringArgument { get; }
	public bool boolArgument { get; }

	// Methods
	public void .ctor();
	public Object get_unityObjectArgument();
	public string get_unityObjectArgumentAssemblyTypeName();
	public int get_intArgument();
	public float get_floatArgument();
	public string get_stringArgument();
	public bool get_boolArgument();
	private void TidyAssemblyTypeName();
	public void OnBeforeSerialize();
	public void OnAfterDeserialize();

}
//NameSpace:UnityEngine.Events
internal abstract class BaseInvokableCall
{
	// Methods
	protected void .ctor();
	protected void .ctor(object target, MethodInfo function);
	public abstract void Invoke(object[] args);
	protected static void ThrowOnInvalidArg(object arg);
	protected static bool AllowInvoke(Delegate delegate);
	public abstract bool Find(object targetObj, MethodInfo method);

}
//NameSpace:UnityEngine.Events
internal class InvokableCall : BaseInvokableCall
{
	// Fields
	private UnityAction Delegate;

	// Methods
	public void .ctor(object target, MethodInfo theFunction);
	public void .ctor(UnityAction action);
	private void add_Delegate(UnityAction value);
	private void remove_Delegate(UnityAction value);
	public override void Invoke(object[] args);
	public void Invoke();
	public override bool Find(object targetObj, MethodInfo method);

}
//NameSpace:UnityEngine.Events
internal class InvokableCall`1 : BaseInvokableCall
{
	// Fields
	private UnityAction`1<T> Delegate;

	// Methods
	public void .ctor(object target, MethodInfo theFunction);
	public void .ctor(UnityAction`1<T> action);
	protected void add_Delegate(UnityAction`1<T> value);
	protected void remove_Delegate(UnityAction`1<T> value);
	public override void Invoke(object[] args);
	public virtual void Invoke(T args0);
	public override bool Find(object targetObj, MethodInfo method);

}
//NameSpace:UnityEngine.Events
internal class InvokableCall`2 : BaseInvokableCall
{
	// Fields
	private UnityAction`2<TT> Delegate;

	// Methods
	public void .ctor(object target, MethodInfo theFunction);
	public override void Invoke(object[] args);
	public override bool Find(object targetObj, MethodInfo method);

}
//NameSpace:UnityEngine.Events
internal class InvokableCall`3 : BaseInvokableCall
{
	// Fields
	private UnityAction`3<TTT> Delegate;

	// Methods
	public void .ctor(object target, MethodInfo theFunction);
	public override void Invoke(object[] args);
	public override bool Find(object targetObj, MethodInfo method);

}
//NameSpace:UnityEngine.Events
internal class InvokableCall`4 : BaseInvokableCall
{
	// Fields
	private UnityAction`4<TTTT> Delegate;

	// Methods
	public void .ctor(object target, MethodInfo theFunction);
	public override void Invoke(object[] args);
	public override bool Find(object targetObj, MethodInfo method);

}
//NameSpace:UnityEngine.Events
internal class CachedInvokableCall`1 : InvokableCall`1<T>
{
	// Fields
	private readonly T m_Arg1;

	// Methods
	public void .ctor(Object target, MethodInfo theFunction, T argument);
	public override void Invoke(object[] args);
	public override void Invoke(T arg0);

}
//NameSpace:UnityEngine.Events
public enum UnityEventCallState
{
	// Fields
	public int value__;
	public const UnityEventCallState Off;
	public const UnityEventCallState EditorAndRuntime;
	public const UnityEventCallState RuntimeOnly;

}
//NameSpace:UnityEngine.Events
internal class PersistentCall
{
	// Fields
	private Object m_Target;
	private string m_MethodName;
	private PersistentListenerMode m_Mode;
	private ArgumentCache m_Arguments;
	private UnityEventCallState m_CallState;

	// Properties
	public Object target { get; }
	public string methodName { get; }
	public PersistentListenerMode mode { get; }
	public ArgumentCache arguments { get; }

	// Methods
	public void .ctor();
	public Object get_target();
	public string get_methodName();
	public PersistentListenerMode get_mode();
	public ArgumentCache get_arguments();
	public bool IsValid();
	public BaseInvokableCall GetRuntimeCall(UnityEventBase theEvent);
	private static BaseInvokableCall GetObjectCall(Object target, MethodInfo method, ArgumentCache arguments);

}
//NameSpace:UnityEngine.Events
internal class PersistentCallGroup
{
	// Fields
	private List`1<PersistentCall> m_Calls;

	// Methods
	public void .ctor();
	public void Initialize(InvokableCallList invokableList, UnityEventBase unityEventBase);

}
//NameSpace:UnityEngine.Events
internal class InvokableCallList
{
	// Fields
	private readonly List`1<BaseInvokableCall> m_PersistentCalls;
	private readonly List`1<BaseInvokableCall> m_RuntimeCalls;
	private readonly List`1<BaseInvokableCall> m_ExecutingCalls;
	private bool m_NeedsUpdate;

	// Methods
	public void .ctor();
	public void AddPersistentInvokableCall(BaseInvokableCall call);
	public void AddListener(BaseInvokableCall call);
	public void RemoveListener(object targetObj, MethodInfo method);
	public void ClearPersistent();
	public List`1<BaseInvokableCall> PrepareInvoke();

}
//NameSpace:UnityEngine.Events
public abstract class UnityEventBase : ISerializationCallbackReceiver
{
	// Fields
	private InvokableCallList m_Calls;
	private PersistentCallGroup m_PersistentCalls;
	private string m_TypeName;
	private bool m_CallsDirty;

	// Methods
	protected void .ctor();
	private void UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize();
	private void UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize();
	protected abstract MethodInfo FindMethod_Impl(string name, object targetObj);
	internal abstract BaseInvokableCall GetDelegate(object target, MethodInfo theFunction);
	internal MethodInfo FindMethod(PersistentCall call);
	internal MethodInfo FindMethod(string name, object listener, PersistentListenerMode mode, Type argumentType);
	private void DirtyPersistentCalls();
	private void RebuildPersistentCallsIfNeeded();
	internal void AddCall(BaseInvokableCall call);
	protected void RemoveListener(object targetObj, MethodInfo method);
	internal List`1<BaseInvokableCall> PrepareInvoke();
	public override string ToString();
	public static MethodInfo GetValidMethodInfo(object obj, string functionName, Type[] argumentTypes);

}
//NameSpace:UnityEngine.Events
public sealed class UnityAction : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke();
	public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine.Events
public class UnityEvent : UnityEventBase
{
	// Fields
	private object[] m_InvokeArray;

	// Methods
	public void .ctor();
	public void AddListener(UnityAction call);
	protected override MethodInfo FindMethod_Impl(string name, object targetObj);
	internal override BaseInvokableCall GetDelegate(object target, MethodInfo theFunction);
	private static BaseInvokableCall GetDelegate(UnityAction action);
	public void Invoke();

}
//NameSpace:UnityEngine.Events
public sealed class UnityAction`1 : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(T arg0);
	public virtual IAsyncResult BeginInvoke(T arg0, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine.Events
public abstract class UnityEvent`1 : UnityEventBase
{
	// Fields
	private object[] m_InvokeArray;

	// Methods
	public void .ctor();
	public void AddListener(UnityAction`1<T> call);
	public void RemoveListener(UnityAction`1<T> call);
	protected override MethodInfo FindMethod_Impl(string name, object targetObj);
	internal override BaseInvokableCall GetDelegate(object target, MethodInfo theFunction);
	private static BaseInvokableCall GetDelegate(UnityAction`1<T> action);
	public void Invoke(T arg0);

}
//NameSpace:UnityEngine.Events
public sealed class UnityAction`2 : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(T arg0, T arg1);
	public virtual IAsyncResult BeginInvoke(T arg0, T arg1, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine.Events
public abstract class UnityEvent`2 : UnityEventBase
{
	// Fields
	private object[] m_InvokeArray;

	// Methods
	public void .ctor();
	protected override MethodInfo FindMethod_Impl(string name, object targetObj);
	internal override BaseInvokableCall GetDelegate(object target, MethodInfo theFunction);

}
//NameSpace:UnityEngine.Events
public sealed class UnityAction`3 : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(T arg0, T arg1, T arg2);
	public virtual IAsyncResult BeginInvoke(T arg0, T arg1, T arg2, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine.Events
public abstract class UnityEvent`3 : UnityEventBase
{
	// Fields
	private object[] m_InvokeArray;

	// Methods
	public void .ctor();
	protected override MethodInfo FindMethod_Impl(string name, object targetObj);
	internal override BaseInvokableCall GetDelegate(object target, MethodInfo theFunction);

}
//NameSpace:UnityEngine.Events
public sealed class UnityAction`4 : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(T arg0, T arg1, T arg2, T arg3);
	public virtual IAsyncResult BeginInvoke(T arg0, T arg1, T arg2, T arg3, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine.Events
public abstract class UnityEvent`4 : UnityEventBase
{
	// Fields
	private object[] m_InvokeArray;

	// Methods
	public void .ctor();
	protected override MethodInfo FindMethod_Impl(string name, object targetObj);
	internal override BaseInvokableCall GetDelegate(object target, MethodInfo theFunction);

}
//NameSpace:UnityEngine
internal class UnityLogWriter : TextWriter
{
	// Methods
	public void .ctor();
	public static void WriteStringToUnityLog(string s);
	private static void WriteStringToUnityLogImpl(string s);
	public static void Init();
	public override void Write(char value);
	public override void Write(string s);
	public override void Write(char[] buffer, int index, int count);

}
//NameSpace:UnityEngine
internal sealed class UnitySynchronizationContext : SynchronizationContext
{
	// Fields
	private readonly List`1<UnitySynchronizationContext.WorkRequest> m_AsyncWorkQueue;
	private readonly List`1<UnitySynchronizationContext.WorkRequest> m_CurrentFrameWork;
	private readonly int m_MainThreadID;

	// Methods
	private void .ctor(int mainThreadID);
	private void .ctor(List`1<UnitySynchronizationContext.WorkRequest> queue, int mainThreadID);
	public override void Send(SendOrPostCallback callback, object state);
	public override void Post(SendOrPostCallback callback, object state);
	public override SynchronizationContext CreateCopy();
	private void Exec();
	private static void InitializeSynchronizationContext();
	private static void ExecuteTasks();

}
//NameSpace:
private struct UnitySynchronizationContext.WorkRequest
{
	// Fields
	private readonly SendOrPostCallback m_DelagateCallback;
	private readonly object m_DelagateState;
	private readonly ManualResetEvent m_WaitHandle;

	// Methods
	public void .ctor(SendOrPostCallback callback, object state, optional ManualResetEvent waitHandle);
	public void Invoke();

}
//NameSpace:UnityEngine
public struct Vector2 : IEquatable`1<Vector2>
{
	// Fields
	public float x;
	public float y;
	private static readonly Vector2 zeroVector;
	private static readonly Vector2 oneVector;
	private static readonly Vector2 upVector;
	private static readonly Vector2 downVector;
	private static readonly Vector2 leftVector;
	private static readonly Vector2 rightVector;
	private static readonly Vector2 positiveInfinityVector;
	private static readonly Vector2 negativeInfinityVector;
	public const float kEpsilon;
	public const float kEpsilonNormalSqrt;

	// Properties
	public float Item { get; set; }
	public float sqrMagnitude { get; }
	public static Vector2 zero { get; }
	public static Vector2 one { get; }
	public static Vector2 up { get; }
	public static Vector2 right { get; }

	// Methods
	public void .ctor(float x, float y);
	public float get_Item(int index);
	public void set_Item(int index, float value);
	public static Vector2 Scale(Vector2 a, Vector2 b);
	public override string ToString();
	public override int GetHashCode();
	public override bool Equals(object other);
	public bool Equals(Vector2 other);
	public static float Dot(Vector2 lhs, Vector2 rhs);
	public float get_sqrMagnitude();
	public static Vector2 op_Addition(Vector2 a, Vector2 b);
	public static Vector2 op_Subtraction(Vector2 a, Vector2 b);
	public static Vector2 op_Multiply(Vector2 a, Vector2 b);
	public static Vector2 op_Division(Vector2 a, Vector2 b);
	public static Vector2 op_Multiply(Vector2 a, float d);
	public static Vector2 op_Division(Vector2 a, float d);
	public static bool op_Equality(Vector2 lhs, Vector2 rhs);
	public static bool op_Inequality(Vector2 lhs, Vector2 rhs);
	public static Vector2 op_Implicit(Vector3 v);
	public static Vector3 op_Implicit(Vector2 v);
	public static Vector2 get_zero();
	public static Vector2 get_one();
	public static Vector2 get_up();
	public static Vector2 get_right();
	private static void .cctor();

}
//NameSpace:UnityEngine
public struct Vector4 : IEquatable`1<Vector4>
{
	// Fields
	public const float kEpsilon;
	public float x;
	public float y;
	public float z;
	public float w;
	private static readonly Vector4 zeroVector;
	private static readonly Vector4 oneVector;
	private static readonly Vector4 positiveInfinityVector;
	private static readonly Vector4 negativeInfinityVector;

	// Properties
	public float Item { get; set; }
	public float sqrMagnitude { get; }
	public static Vector4 zero { get; }

	// Methods
	public void .ctor(float x, float y, float z, float w);
	public float get_Item(int index);
	public void set_Item(int index, float value);
	public override int GetHashCode();
	public override bool Equals(object other);
	public bool Equals(Vector4 other);
	public static float Dot(Vector4 a, Vector4 b);
	public float get_sqrMagnitude();
	public static Vector4 get_zero();
	public static Vector4 op_Subtraction(Vector4 a, Vector4 b);
	public static Vector4 op_Division(Vector4 a, float d);
	public static bool op_Equality(Vector4 lhs, Vector4 rhs);
	public override string ToString();
	public static float SqrMagnitude(Vector4 a);
	private static void .cctor();

}
//NameSpace:UnityEngine
public sealed class WaitForEndOfFrame : YieldInstruction
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine
public sealed class WaitForFixedUpdate : YieldInstruction
{
}
//NameSpace:UnityEngine
public sealed class WaitForSeconds : YieldInstruction
{
	// Fields
	internal float m_Seconds;

}
//NameSpace:UnityEngine
public class WaitForSecondsRealtime : CustomYieldInstruction
{
	// Fields
	private float <waitTime>k__BackingField;
	private float m_WaitUntilTime;

	// Properties
	public float waitTime { get; set; }
	public override bool keepWaiting { get; }

	// Methods
	public void .ctor(float time);
	public float get_waitTime();
	public void set_waitTime(float value);
	public override bool get_keepWaiting();

}
//NameSpace:UnityEngine
public class YieldInstruction
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine.Assertions
public static class Assert
{
	// Fields
	public static bool raiseExceptions;

	// Methods
	private static void Fail(string message, string userMessage);
	public static void AreEqual(T expected, T actual, string message);
	public static void AreEqual(T expected, T actual, string message, IEqualityComparer`1<T> comparer);
	public static void AreEqual(Object expected, Object actual, string message);
	public static void AreEqual(int expected, int actual);
	private static void .cctor();

}
//NameSpace:UnityEngine.Assertions
public class AssertionException : Exception
{
	// Fields
	private string m_UserMessage;

	// Properties
	public override string Message { get; }

	// Methods
	public void .ctor(string message, string userMessage);
	public override string get_Message();

}
//NameSpace:UnityEngine.Assertions
internal class AssertionMessageUtil
{
	// Methods
	public static string GetMessage(string failureMessage);
	public static string GetMessage(string failureMessage, string expected);
	public static string GetEqualityMessage(object actual, object expected, bool expectEqual);

}
//NameSpace:UnityEngine.Experimental.Rendering
internal class BuiltinRuntimeReflectionSystem : IScriptableRuntimeReflectionSystem, IDisposable
{
	// Methods
	public void .ctor();
	public bool TickRealtimeProbes();
	public void Dispose();
	private void Dispose(bool disposing);
	private static bool BuiltinUpdate();
	private static BuiltinRuntimeReflectionSystem Internal_BuiltinRuntimeReflectionSystem_New();

}
//NameSpace:UnityEngine.Experimental.Rendering
public interface IScriptableRuntimeReflectionSystem : IDisposable
{
	// Methods
	public abstract bool TickRealtimeProbes();

}
//NameSpace:UnityEngine.Experimental.Rendering
public static class ScriptableRuntimeReflectionSystemSettings
{
	// Fields
	private static ScriptableRuntimeReflectionSystemWrapper s_Instance;

	// Properties
	private static void Internal_ScriptableRuntimeReflectionSystemSettings_system { set; }
	private static ScriptableRuntimeReflectionSystemWrapper Internal_ScriptableRuntimeReflectionSystemSettings_instance { get; }

	// Methods
	private static void set_Internal_ScriptableRuntimeReflectionSystemSettings_system(IScriptableRuntimeReflectionSystem value);
	private static ScriptableRuntimeReflectionSystemWrapper get_Internal_ScriptableRuntimeReflectionSystemSettings_instance();
	private static void ScriptingDirtyReflectionSystemInstance();
	private static void .cctor();

}
//NameSpace:UnityEngine.Experimental.Rendering
internal class ScriptableRuntimeReflectionSystemWrapper
{
	// Fields
	private IScriptableRuntimeReflectionSystem <implementation>k__BackingField;

	// Properties
	internal IScriptableRuntimeReflectionSystem implementation { get; set; }

	// Methods
	public void .ctor();
	internal IScriptableRuntimeReflectionSystem get_implementation();
	internal void set_implementation(IScriptableRuntimeReflectionSystem value);
	private bool Internal_ScriptableRuntimeReflectionSystemWrapper_TickRealtimeProbes_ReturnResult();
	private void Internal_ScriptableRuntimeReflectionSystemWrapper_TickRealtimeProbes(out bool result);

}
//NameSpace:Unity.Collections
public sealed class ReadOnlyAttribute : Attribute
{
}
//NameSpace:Unity.Collections
public sealed class WriteOnlyAttribute : Attribute
{
}
//NameSpace:Unity.Collections
public sealed class DeallocateOnJobCompletionAttribute : Attribute
{
}
//NameSpace:Unity.Collections
public sealed class NativeFixedLengthAttribute : Attribute
{
}
//NameSpace:Unity.Collections
public sealed class NativeMatchesParallelForLengthAttribute : Attribute
{
}
//NameSpace:Unity.Collections
public sealed class NativeDisableParallelForRestrictionAttribute : Attribute
{
}
//NameSpace:Unity.Collections.LowLevel.Unsafe
public sealed class NativeContainerAttribute : Attribute
{
}
//NameSpace:Unity.Collections.LowLevel.Unsafe
public sealed class NativeContainerIsReadOnlyAttribute : Attribute
{
}
//NameSpace:Unity.Collections.LowLevel.Unsafe
public sealed class NativeContainerIsAtomicWriteOnlyAttribute : Attribute
{
}
//NameSpace:Unity.Collections.LowLevel.Unsafe
public sealed class NativeContainerSupportsMinMaxWriteRestrictionAttribute : Attribute
{
}
//NameSpace:Unity.Collections.LowLevel.Unsafe
public sealed class NativeContainerSupportsDeallocateOnJobCompletionAttribute : Attribute
{
}
//NameSpace:Unity.Collections.LowLevel.Unsafe
public sealed class NativeContainerSupportsDeferredConvertListToArray : Attribute
{
}
//NameSpace:Unity.Collections.LowLevel.Unsafe
public sealed class NativeSetThreadIndexAttribute : Attribute
{
}
//NameSpace:Unity.Collections.LowLevel.Unsafe
public sealed class NativeContainerNeedsThreadIndexAttribute : Attribute
{
}
//NameSpace:Unity.Collections.LowLevel.Unsafe
public sealed class NativeDisableUnsafePtrRestrictionAttribute : Attribute
{
}
//NameSpace:Unity.Collections.LowLevel.Unsafe
public sealed class NativeDisableContainerSafetyRestrictionAttribute : Attribute
{
}
//NameSpace:Unity.Collections.LowLevel.Unsafe
public sealed class NativeSetClassTypeToNullOnScheduleAttribute : Attribute
{
}
//NameSpace:UnityEngine.Experimental.Playables
public struct CameraPlayable : IPlayable, IEquatable`1<CameraPlayable>
{
	// Fields
	private PlayableHandle m_Handle;

	// Methods
	public PlayableHandle GetHandle();
	public bool Equals(CameraPlayable other);

}
//NameSpace:UnityEngine.Playables
public interface INotificationReceiver
{
}
//NameSpace:UnityEngine.Playables
public interface IPlayable
{
}
//NameSpace:UnityEngine.Playables
public interface IPlayableBehaviour
{
}
//NameSpace:UnityEngine.Playables
public interface IPlayableOutput
{
}
//NameSpace:UnityEngine.Experimental.Playables
public struct MaterialEffectPlayable : IPlayable, IEquatable`1<MaterialEffectPlayable>
{
	// Fields
	private PlayableHandle m_Handle;

	// Methods
	public PlayableHandle GetHandle();
	public bool Equals(MaterialEffectPlayable other);

}
//NameSpace:UnityEngine.Playables
public struct Playable : IPlayable, IEquatable`1<Playable>
{
	// Fields
	private PlayableHandle m_Handle;
	private static readonly Playable m_NullPlayable;

	// Properties
	public static Playable Null { get; }

	// Methods
	internal void .ctor(PlayableHandle handle);
	public static Playable get_Null();
	public PlayableHandle GetHandle();
	public bool Equals(Playable other);
	private static void .cctor();

}
//NameSpace:UnityEngine.Playables
public interface IPlayableAsset
{
}
//NameSpace:UnityEngine.Playables
public abstract class PlayableAsset : ScriptableObject, IPlayableAsset
{
	// Properties
	public virtual double duration { get; }
	public virtual IEnumerable`1<PlayableBinding> outputs { get; }

	// Methods
	protected void .ctor();
	public abstract Playable CreatePlayable(PlayableGraph graph, GameObject owner);
	public virtual double get_duration();
	public virtual IEnumerable`1<PlayableBinding> get_outputs();
	internal static void Internal_CreatePlayable(PlayableAsset asset, PlayableGraph graph, GameObject go, IntPtr ptr);
	internal static void Internal_GetPlayableAssetDuration(PlayableAsset asset, IntPtr ptrToDouble);

}
//NameSpace:UnityEngine.Playables
public abstract class PlayableBehaviour : IPlayableBehaviour, ICloneable
{
	// Methods
	public void .ctor();
	public virtual object Clone();

}
//NameSpace:UnityEngine.Playables
public struct PlayableBinding
{
	// Fields
	private string m_StreamName;
	private Object m_SourceObject;
	private Type m_SourceBindingType;
	private PlayableBinding.CreateOutputMethod m_CreateOutputMethod;
	public static readonly PlayableBinding[] None;
	public static readonly double DefaultDuration;

	// Methods
	private static void .cctor();

}
//NameSpace:
internal sealed class PlayableBinding.CreateOutputMethod : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual PlayableOutput Invoke(PlayableGraph graph, string name);
	public virtual IAsyncResult BeginInvoke(PlayableGraph graph, string name, AsyncCallback callback, object object);
	public virtual PlayableOutput EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine.Playables
public struct PlayableGraph
{
	// Fields
	internal IntPtr m_Handle;
	internal uint m_Version;

}
//NameSpace:UnityEngine.Playables
public struct PlayableHandle : IEquatable`1<PlayableHandle>
{
	// Fields
	internal IntPtr m_Handle;
	internal uint m_Version;
	private static readonly PlayableHandle m_Null;

	// Properties
	public static PlayableHandle Null { get; }

	// Methods
	internal bool IsPlayableOfType();
	public static PlayableHandle get_Null();
	public static bool op_Equality(PlayableHandle x, PlayableHandle y);
	public override bool Equals(object p);
	public bool Equals(PlayableHandle other);
	public override int GetHashCode();
	internal static bool CompareVersion(PlayableHandle lhs, PlayableHandle rhs);
	internal bool IsValid();
	internal Type GetPlayableType();
	private static void .cctor();
	private static bool IsValid_Injected(PlayableHandle _unity_self);
	private static Type GetPlayableType_Injected(PlayableHandle _unity_self);

}
//NameSpace:UnityEngine.Playables
public struct PlayableOutput : IPlayableOutput, IEquatable`1<PlayableOutput>
{
	// Fields
	private PlayableOutputHandle m_Handle;
	private static readonly PlayableOutput m_NullPlayableOutput;

	// Methods
	internal void .ctor(PlayableOutputHandle handle);
	public PlayableOutputHandle GetHandle();
	public bool Equals(PlayableOutput other);
	private static void .cctor();

}
//NameSpace:UnityEngine.Playables
public struct PlayableOutputHandle : IEquatable`1<PlayableOutputHandle>
{
	// Fields
	internal IntPtr m_Handle;
	internal uint m_Version;
	private static readonly PlayableOutputHandle m_Null;

	// Properties
	public static PlayableOutputHandle Null { get; }

	// Methods
	public static PlayableOutputHandle get_Null();
	public override int GetHashCode();
	public static bool op_Equality(PlayableOutputHandle lhs, PlayableOutputHandle rhs);
	public override bool Equals(object p);
	public bool Equals(PlayableOutputHandle other);
	internal static bool CompareVersion(PlayableOutputHandle lhs, PlayableOutputHandle rhs);
	private static void .cctor();

}
//NameSpace:UnityEngine.Playables
public struct ScriptPlayableOutput : IPlayableOutput
{
	// Fields
	private PlayableOutputHandle m_Handle;

}
//NameSpace:UnityEngine.Experimental.Playables
public struct TextureMixerPlayable : IPlayable, IEquatable`1<TextureMixerPlayable>
{
	// Fields
	private PlayableHandle m_Handle;

	// Methods
	public PlayableHandle GetHandle();
	public bool Equals(TextureMixerPlayable other);

}
//NameSpace:UnityEngine.Experimental.Playables
public struct TexturePlayableOutput : IPlayableOutput
{
	// Fields
	private PlayableOutputHandle m_Handle;

}
//NameSpace:UnityEngine.Internal
public class DefaultValueAttribute : Attribute
{
	// Fields
	private object DefaultValue;

	// Properties
	public object Value { get; }

	// Methods
	public void .ctor(string value);
	public object get_Value();
	public override bool Equals(object obj);
	public override int GetHashCode();

}
//NameSpace:UnityEngine.Internal
public class ExcludeFromDocsAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine
public interface ILogHandler
{
	// Methods
	public abstract void LogFormat(LogType logType, Object context, string format, object[] args);
	public abstract void LogException(Exception exception, Object context);

}
//NameSpace:UnityEngine
public interface ILogger : ILogHandler
{
	// Methods
	public abstract void Log(LogType logType, object message);
	public abstract void Log(LogType logType, object message, Object context);

}
//NameSpace:UnityEngine
public class Logger : ILogger, ILogHandler
{
	// Fields
	private ILogHandler <logHandler>k__BackingField;
	private bool <logEnabled>k__BackingField;
	private LogType <filterLogType>k__BackingField;

	// Properties
	public ILogHandler logHandler { get; set; }
	public bool logEnabled { get; set; }
	public LogType filterLogType { get; set; }

	// Methods
	public void .ctor(ILogHandler logHandler);
	public ILogHandler get_logHandler();
	public void set_logHandler(ILogHandler value);
	public bool get_logEnabled();
	public void set_logEnabled(bool value);
	public LogType get_filterLogType();
	public void set_filterLogType(LogType value);
	public bool IsLogTypeAllowed(LogType logType);
	private static string GetString(object message);
	public void Log(LogType logType, object message);
	public void Log(LogType logType, object message, Object context);
	public void LogFormat(LogType logType, Object context, string format, object[] args);
	public void LogException(Exception exception, Object context);

}
//NameSpace:UnityEngine.Networking.PlayerConnection
public class MessageEventArgs
{
	// Fields
	public int playerId;
	public byte[] data;

	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine.Networking.PlayerConnection
public interface IEditorPlayerConnection
{
}
//NameSpace:UnityEngine.Networking.PlayerConnection
public class PlayerConnection : ScriptableObject, IEditorPlayerConnection
{
	// Fields
	internal static IPlayerEditorConnectionNative connectionNative;
	private PlayerEditorConnectionEvents m_PlayerEditorConnectionEvents;
	private List`1<int> m_connectedPlayers;
	private bool m_IsInitilized;
	private static PlayerConnection s_Instance;

	// Properties
	public static PlayerConnection instance { get; }
	public bool isConnected { get; }

	// Methods
	public void .ctor();
	public static PlayerConnection get_instance();
	public bool get_isConnected();
	private static PlayerConnection CreateInstance();
	public void OnEnable();
	private IPlayerEditorConnectionNative GetConnectionNativeApi();
	public void Register(Guid messageId, UnityAction`1<MessageEventArgs> callback);
	public void Unregister(Guid messageId, UnityAction`1<MessageEventArgs> callback);
	public void RegisterConnection(UnityAction`1<int> callback);
	public void RegisterDisconnection(UnityAction`1<int> callback);
	public void Send(Guid messageId, byte[] data);
	public bool BlockUntilRecvMsg(Guid messageId, int timeout);
	public void DisconnectAll();
	private static void MessageCallbackInternal(IntPtr data, ulong size, ulong guid, string messageId);
	private static void ConnectedCallbackInternal(int playerId);
	private static void DisconnectedCallback(int playerId);

}
//NameSpace:
private sealed class PlayerConnection.<Register>c__AnonStorey0
{
	// Fields
	internal Guid messageId;

	// Methods
	public void .ctor();
	internal bool <>m__0(PlayerEditorConnectionEvents.MessageTypeSubscribers x);

}
//NameSpace:
private sealed class PlayerConnection.<Unregister>c__AnonStorey1
{
	// Fields
	internal Guid messageId;

	// Methods
	public void .ctor();
	internal bool <>m__0(PlayerEditorConnectionEvents.MessageTypeSubscribers x);

}
//NameSpace:
private sealed class PlayerConnection.<BlockUntilRecvMsg>c__AnonStorey2
{
	// Fields
	internal bool msgReceived;

	// Methods
	public void .ctor();
	internal void <>m__0(MessageEventArgs args);

}
//NameSpace:UnityEngine.Networking.PlayerConnection
internal class PlayerEditorConnectionEvents
{
	// Fields
	public List`1<PlayerEditorConnectionEvents.MessageTypeSubscribers> messageTypeSubscribers;
	public PlayerEditorConnectionEvents.ConnectionChangeEvent connectionEvent;
	public PlayerEditorConnectionEvents.ConnectionChangeEvent disconnectionEvent;

	// Methods
	public void .ctor();
	public void InvokeMessageIdSubscribers(Guid messageId, byte[] data, int playerId);
	public UnityEvent`1<MessageEventArgs> AddAndCreate(Guid messageId);
	public void UnregisterManagedCallback(Guid messageId, UnityAction`1<MessageEventArgs> callback);

}
//NameSpace:
public class PlayerEditorConnectionEvents.MessageEvent : UnityEvent`1<MessageEventArgs>
{
	// Methods
	public void .ctor();

}
//NameSpace:
public class PlayerEditorConnectionEvents.ConnectionChangeEvent : UnityEvent`1<int>
{
	// Methods
	public void .ctor();

}
//NameSpace:
public class PlayerEditorConnectionEvents.MessageTypeSubscribers
{
	// Fields
	private string m_messageTypeId;
	public int subscriberCount;
	public PlayerEditorConnectionEvents.MessageEvent messageCallback;

	// Properties
	public Guid MessageTypeId { get; set; }

	// Methods
	public void .ctor();
	public Guid get_MessageTypeId();
	public void set_MessageTypeId(Guid value);

}
//NameSpace:
private sealed class PlayerEditorConnectionEvents.<InvokeMessageIdSubscribers>c__AnonStorey0
{
	// Fields
	internal Guid messageId;

	// Methods
	public void .ctor();
	internal bool <>m__0(PlayerEditorConnectionEvents.MessageTypeSubscribers x);

}
//NameSpace:
private sealed class PlayerEditorConnectionEvents.<AddAndCreate>c__AnonStorey1
{
	// Fields
	internal Guid messageId;

	// Methods
	public void .ctor();
	internal bool <>m__0(PlayerEditorConnectionEvents.MessageTypeSubscribers x);

}
//NameSpace:
private sealed class PlayerEditorConnectionEvents.<UnregisterManagedCallback>c__AnonStorey2
{
	// Fields
	internal Guid messageId;

	// Methods
	public void .ctor();
	internal bool <>m__0(PlayerEditorConnectionEvents.MessageTypeSubscribers x);

}
//NameSpace:UnityEngine.Experimental.Rendering
public interface IRenderPipeline : IDisposable
{
	// Properties
	public abstract bool disposed { get; }

	// Methods
	public abstract bool get_disposed();
	public abstract void Render(ScriptableRenderContext renderContext, Camera[] cameras);

}
//NameSpace:UnityEngine.Experimental.Rendering
public interface IRenderPipelineAsset
{
	// Methods
	public abstract void DestroyCreatedInstances();
	public abstract IRenderPipeline CreatePipeline();

}
//NameSpace:UnityEngine.Experimental.Rendering
public static class RenderPipelineManager
{
	// Fields
	private static IRenderPipelineAsset s_CurrentPipelineAsset;
	private static IRenderPipeline <currentPipeline>k__BackingField;

	// Properties
	public static IRenderPipeline currentPipeline { get; set; }

	// Methods
	public static IRenderPipeline get_currentPipeline();
	private static void set_currentPipeline(IRenderPipeline value);
	internal static void CleanupRenderPipeline();
	private static void DoRenderLoop_Internal(IRenderPipelineAsset pipe, Camera[] cameras, IntPtr loopPtr);
	private static void PrepareRenderPipeline(IRenderPipelineAsset pipe);

}
//NameSpace:UnityEngine.Experimental.Rendering
public class SupportedRenderingFeatures
{
	// Fields
	private static SupportedRenderingFeatures s_Active;
	private SupportedRenderingFeatures.ReflectionProbeSupportFlags <reflectionProbeSupportFlags>k__BackingField;
	private SupportedRenderingFeatures.LightmapMixedBakeMode <defaultMixedLightingMode>k__BackingField;
	private SupportedRenderingFeatures.LightmapMixedBakeMode <supportedMixedLightingModes>k__BackingField;
	private LightmapBakeType <supportedLightmapBakeTypes>k__BackingField;
	private LightmapsMode <supportedLightmapsModes>k__BackingField;
	private bool <rendererSupportsLightProbeProxyVolumes>k__BackingField;
	private bool <rendererSupportsMotionVectors>k__BackingField;
	private bool <rendererSupportsReceiveShadows>k__BackingField;
	private bool <rendererSupportsReflectionProbes>k__BackingField;
	private bool <rendererSupportsRendererPriority>k__BackingField;
	private bool <rendererOverridesEnvironmentLighting>k__BackingField;
	private bool <rendererOverridesFog>k__BackingField;
	private bool <rendererOverridesOtherLightingSettings>k__BackingField;

	// Properties
	public static SupportedRenderingFeatures active { get; set; }
	public SupportedRenderingFeatures.LightmapMixedBakeMode defaultMixedLightingMode { get; }
	public SupportedRenderingFeatures.LightmapMixedBakeMode supportedMixedLightingModes { get; }
	public LightmapBakeType supportedLightmapBakeTypes { get; }
	public LightmapsMode supportedLightmapsModes { get; }

	// Methods
	public void .ctor();
	public static SupportedRenderingFeatures get_active();
	public static void set_active(SupportedRenderingFeatures value);
	public SupportedRenderingFeatures.LightmapMixedBakeMode get_defaultMixedLightingMode();
	public SupportedRenderingFeatures.LightmapMixedBakeMode get_supportedMixedLightingModes();
	public LightmapBakeType get_supportedLightmapBakeTypes();
	public LightmapsMode get_supportedLightmapsModes();
	internal static void FallbackMixedLightingModeByRef(IntPtr fallbackModePtr);
	internal static bool IsMixedLightingModeSupported(MixedLightingMode mixedMode);
	internal static void IsMixedLightingModeSupportedByRef(MixedLightingMode mixedMode, IntPtr isSupportedPtr);
	internal static bool IsLightmapBakeTypeSupported(LightmapBakeType bakeType);
	internal static void IsLightmapBakeTypeSupportedByRef(LightmapBakeType bakeType, IntPtr isSupportedPtr);
	internal static void IsLightmapsModeSupportedByRef(LightmapsMode mode, IntPtr isSupportedPtr);
	private static void .cctor();

}
//NameSpace:
public enum SupportedRenderingFeatures.ReflectionProbeSupportFlags
{
	// Fields
	public int value__;
	public const SupportedRenderingFeatures.ReflectionProbeSupportFlags None;
	public const SupportedRenderingFeatures.ReflectionProbeSupportFlags Rotation;

}
//NameSpace:
public enum SupportedRenderingFeatures.LightmapMixedBakeMode
{
	// Fields
	public int value__;
	public const SupportedRenderingFeatures.LightmapMixedBakeMode None;
	public const SupportedRenderingFeatures.LightmapMixedBakeMode IndirectOnly;
	public const SupportedRenderingFeatures.LightmapMixedBakeMode Subtractive;
	public const SupportedRenderingFeatures.LightmapMixedBakeMode Shadowmask;

}
//NameSpace:UnityEngine.SceneManagement
public struct Scene
{
	// Fields
	private int m_Handle;

	// Properties
	public int handle { get; }

	// Methods
	public int get_handle();
	public override int GetHashCode();
	public override bool Equals(object other);

}
//NameSpace:UnityEngine.SceneManagement
public class SceneManager
{
	// Fields
	private static UnityAction`2<SceneLoadSceneMode> sceneLoaded;
	private static UnityAction`1<Scene> sceneUnloaded;
	private static UnityAction`2<SceneScene> activeSceneChanged;

	// Methods
	private static void Internal_SceneLoaded(Scene scene, LoadSceneMode mode);
	private static void Internal_SceneUnloaded(Scene scene);
	private static void Internal_ActiveSceneChanged(Scene previousActiveScene, Scene newActiveScene);

}
//NameSpace:UnityEngine.SceneManagement
public enum LoadSceneMode
{
	// Fields
	public int value__;
	public const LoadSceneMode Single;
	public const LoadSceneMode Additive;

}
//NameSpace:UnityEngine
internal sealed class ExtensionOfNativeClassAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine.Scripting
public class PreserveAttribute : Attribute
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine.Scripting.APIUpdating
public class MovedFromAttribute : Attribute
{
	// Fields
	private string <Namespace>k__BackingField;
	private bool <IsInDifferentAssembly>k__BackingField;

	// Properties
	private void Namespace { set; }
	private void IsInDifferentAssembly { set; }

	// Methods
	public void .ctor(string sourceNamespace);
	public void .ctor(string sourceNamespace, bool isInDifferentAssembly);
	private void set_Namespace(string value);
	private void set_IsInDifferentAssembly(bool value);

}
//NameSpace:UnityEngine.Serialization
public class FormerlySerializedAsAttribute : Attribute
{
	// Fields
	private string m_oldName;

	// Methods
	public void .ctor(string oldName);

}
//NameSpace:UnityEngineInternal
public enum TypeInferenceRules
{
	// Fields
	public int value__;
	public const TypeInferenceRules TypeReferencedByFirstArgument;
	public const TypeInferenceRules TypeReferencedBySecondArgument;
	public const TypeInferenceRules ArrayOfTypeReferencedByFirstArgument;
	public const TypeInferenceRules TypeOfFirstArgument;

}
//NameSpace:UnityEngineInternal
public class TypeInferenceRuleAttribute : Attribute
{
	// Fields
	private readonly string _rule;

	// Methods
	public void .ctor(TypeInferenceRules rule);
	public void .ctor(string rule);
	public override string ToString();

}
//NameSpace:UnityEngineInternal
public class GenericStack : Stack
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngineInternal
internal static class NetFxCoreExtensions
{
	// Methods
	public static Delegate CreateDelegate(MethodInfo self, Type delegateType, object target);
	public static MethodInfo GetMethodInfo(Delegate self);

}
//NameSpace:UnityEngine.iOS
internal sealed class NotificationHelper
{
	// Methods
	internal static void DestroyLocal(IntPtr target);
	internal static void DestroyRemote(IntPtr target);

}
//NameSpace:UnityEngine.iOS
public sealed class LocalNotification
{
	// Fields
	private IntPtr m_Ptr;
	private static long m_NSReferenceDateTicks;

	// Methods
	protected override void Finalize();
	private static void .cctor();

}
//NameSpace:UnityEngine.iOS
public sealed class RemoteNotification
{
	// Fields
	private IntPtr m_Ptr;

	// Methods
	protected override void Finalize();

}
//NameSpace:UnityEngine.Profiling.Memory.Experimental
public class MetaData
{
	// Fields
	public string content;
	public string platform;
	public Texture2D screenshot;

	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine.Profiling.Memory.Experimental
public sealed class MemoryProfiler
{
	// Fields
	private static Action`2<stringbool> snapshotFinished;
	private static Action`1<MetaData> createMetaData;

	// Methods
	private static byte[] PrepareMetadata();
	internal static int WriteIntToByteArray(byte[] array, int offset, int value);
	internal static int WriteStringToByteArray(byte[] array, int offset, string value);
	private static void FinalizeSnapshot(string path, bool result);

}
//NameSpace:UnityEngine
public enum DrivenTransformProperties
{
	// Fields
	public int value__;
	public const DrivenTransformProperties None;
	public const DrivenTransformProperties All;
	public const DrivenTransformProperties AnchoredPositionX;
	public const DrivenTransformProperties AnchoredPositionY;
	public const DrivenTransformProperties AnchoredPositionZ;
	public const DrivenTransformProperties Rotation;
	public const DrivenTransformProperties ScaleX;
	public const DrivenTransformProperties ScaleY;
	public const DrivenTransformProperties ScaleZ;
	public const DrivenTransformProperties AnchorMinX;
	public const DrivenTransformProperties AnchorMinY;
	public const DrivenTransformProperties AnchorMaxX;
	public const DrivenTransformProperties AnchorMaxY;
	public const DrivenTransformProperties SizeDeltaX;
	public const DrivenTransformProperties SizeDeltaY;
	public const DrivenTransformProperties PivotX;
	public const DrivenTransformProperties PivotY;
	public const DrivenTransformProperties AnchoredPosition;
	public const DrivenTransformProperties AnchoredPosition3D;
	public const DrivenTransformProperties Scale;
	public const DrivenTransformProperties AnchorMin;
	public const DrivenTransformProperties AnchorMax;
	public const DrivenTransformProperties Anchors;
	public const DrivenTransformProperties SizeDelta;
	public const DrivenTransformProperties Pivot;

}
//NameSpace:UnityEngine
public struct DrivenRectTransformTracker
{
	// Methods
	public void Add(Object driver, RectTransform rectTransform, DrivenTransformProperties drivenProperties);
	public void Clear();

}
//NameSpace:UnityEngine
public sealed class RectTransform : Transform
{
	// Fields
	private static RectTransform.ReapplyDrivenProperties reapplyDrivenProperties;

	// Properties
	public Rect rect { get; }
	public Vector2 anchorMin { get; set; }
	public Vector2 anchorMax { get; set; }
	public Vector2 anchoredPosition { get; set; }
	public Vector2 sizeDelta { get; set; }
	public Vector2 pivot { get; set; }
	public void offsetMin { set; }
	public void offsetMax { set; }

	// Methods
	public static void add_reapplyDrivenProperties(RectTransform.ReapplyDrivenProperties value);
	public static void remove_reapplyDrivenProperties(RectTransform.ReapplyDrivenProperties value);
	public Rect get_rect();
	public Vector2 get_anchorMin();
	public void set_anchorMin(Vector2 value);
	public Vector2 get_anchorMax();
	public void set_anchorMax(Vector2 value);
	public Vector2 get_anchoredPosition();
	public void set_anchoredPosition(Vector2 value);
	public Vector2 get_sizeDelta();
	public void set_sizeDelta(Vector2 value);
	public Vector2 get_pivot();
	public void set_pivot(Vector2 value);
	public void set_offsetMin(Vector2 value);
	public void set_offsetMax(Vector2 value);
	public void GetLocalCorners(Vector3[] fourCornersArray);
	public void GetWorldCorners(Vector3[] fourCornersArray);
	public void SetInsetAndSizeFromParentEdge(RectTransform.Edge edge, float inset, float size);
	public void SetSizeWithCurrentAnchors(RectTransform.Axis axis, float size);
	internal static void SendReapplyDrivenProperties(RectTransform driven);
	private Vector2 GetParentSize();
	private void get_rect_Injected(out Rect ret);
	private void get_anchorMin_Injected(out Vector2 ret);
	private void set_anchorMin_Injected(Vector2 value);
	private void get_anchorMax_Injected(out Vector2 ret);
	private void set_anchorMax_Injected(Vector2 value);
	private void get_anchoredPosition_Injected(out Vector2 ret);
	private void set_anchoredPosition_Injected(Vector2 value);
	private void get_sizeDelta_Injected(out Vector2 ret);
	private void set_sizeDelta_Injected(Vector2 value);
	private void get_pivot_Injected(out Vector2 ret);
	private void set_pivot_Injected(Vector2 value);

}
//NameSpace:
public enum RectTransform.Edge
{
	// Fields
	public int value__;
	public const RectTransform.Edge Left;
	public const RectTransform.Edge Right;
	public const RectTransform.Edge Top;
	public const RectTransform.Edge Bottom;

}
//NameSpace:
public enum RectTransform.Axis
{
	// Fields
	public int value__;
	public const RectTransform.Axis Horizontal;
	public const RectTransform.Axis Vertical;

}
//NameSpace:
public sealed class RectTransform.ReapplyDrivenProperties : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(RectTransform driven);
	public virtual IAsyncResult BeginInvoke(RectTransform driven, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine
public class Transform : Component, IEnumerable
{
	// Properties
	public Vector3 position { get; }
	public Vector3 localPosition { get; set; }
	public Vector3 forward { get; }
	public Quaternion rotation { get; }
	public Quaternion localRotation { get; set; }
	public Vector3 localScale { get; set; }
	public Transform parent { get; set; }
	internal Transform parentInternal { get; set; }
	public Matrix4x4 worldToLocalMatrix { get; }
	public Matrix4x4 localToWorldMatrix { get; }
	public int childCount { get; }

	// Methods
	protected void .ctor();
	public Vector3 get_position();
	public Vector3 get_localPosition();
	public void set_localPosition(Vector3 value);
	public Vector3 get_forward();
	public Quaternion get_rotation();
	public Quaternion get_localRotation();
	public void set_localRotation(Quaternion value);
	public Vector3 get_localScale();
	public void set_localScale(Vector3 value);
	public Transform get_parent();
	public void set_parent(Transform value);
	internal Transform get_parentInternal();
	internal void set_parentInternal(Transform value);
	private Transform GetParent();
	public void SetParent(Transform p);
	public void SetParent(Transform parent, bool worldPositionStays);
	public Matrix4x4 get_worldToLocalMatrix();
	public Matrix4x4 get_localToWorldMatrix();
	public Vector3 TransformPoint(Vector3 position);
	public Vector3 InverseTransformPoint(Vector3 position);
	public int get_childCount();
	public void SetAsFirstSibling();
	public bool IsChildOf(Transform parent);
	public IEnumerator GetEnumerator();
	public Transform GetChild(int index);
	private void get_position_Injected(out Vector3 ret);
	private void get_localPosition_Injected(out Vector3 ret);
	private void set_localPosition_Injected(Vector3 value);
	private void get_rotation_Injected(out Quaternion ret);
	private void get_localRotation_Injected(out Quaternion ret);
	private void set_localRotation_Injected(Quaternion value);
	private void get_localScale_Injected(out Vector3 ret);
	private void set_localScale_Injected(Vector3 value);
	private void get_worldToLocalMatrix_Injected(out Matrix4x4 ret);
	private void get_localToWorldMatrix_Injected(out Matrix4x4 ret);
	private void TransformPoint_Injected(Vector3 position, out Vector3 ret);
	private void InverseTransformPoint_Injected(Vector3 position, out Vector3 ret);

}
//NameSpace:
private class Transform.Enumerator : IEnumerator
{
	// Fields
	private Transform outer;
	private int currentIndex;

	// Properties
	public object Current { get; }

	// Methods
	internal void .ctor(Transform outer);
	public object get_Current();
	public bool MoveNext();

}
//NameSpace:UnityEngine.Experimental.U2D
public struct SpriteBone
{
	// Fields
	private string m_Name;
	private Vector3 m_Position;
	private Quaternion m_Rotation;
	private float m_Length;
	private int m_ParentId;

}
//NameSpace:UnityEngine.Sprites
public sealed class DataUtility
{
	// Methods
	public static Vector4 GetInnerUV(Sprite sprite);
	public static Vector4 GetOuterUV(Sprite sprite);
	public static Vector4 GetPadding(Sprite sprite);
	public static Vector2 GetMinSize(Sprite sprite);

}
//NameSpace:UnityEngine
public sealed class SpriteRenderer : Renderer
{
}
//NameSpace:UnityEngine
public enum SpritePackingMode
{
	// Fields
	public int value__;
	public const SpritePackingMode Tight;
	public const SpritePackingMode Rectangle;

}
//NameSpace:UnityEngine
public sealed class Sprite : Object
{
	// Properties
	public Bounds bounds { get; }
	public Rect rect { get; }
	public Vector4 border { get; }
	public Texture2D texture { get; }
	public float pixelsPerUnit { get; }
	public Texture2D associatedAlphaSplitTexture { get; }
	public Vector2 pivot { get; }
	public bool packed { get; }
	public SpritePackingMode packingMode { get; }
	public Rect textureRect { get; }
	public Vector2[] vertices { get; }
	public ushort[] triangles { get; }
	public Vector2[] uv { get; }

	// Methods
	private void .ctor();
	internal int GetPackingMode();
	internal int GetPacked();
	internal Rect GetTextureRect();
	internal Vector4 GetInnerUVs();
	internal Vector4 GetOuterUVs();
	internal Vector4 GetPadding();
	public Bounds get_bounds();
	public Rect get_rect();
	public Vector4 get_border();
	public Texture2D get_texture();
	public float get_pixelsPerUnit();
	public Texture2D get_associatedAlphaSplitTexture();
	public Vector2 get_pivot();
	public bool get_packed();
	public SpritePackingMode get_packingMode();
	public Rect get_textureRect();
	public Vector2[] get_vertices();
	public ushort[] get_triangles();
	public Vector2[] get_uv();
	private void GetTextureRect_Injected(out Rect ret);
	private void GetInnerUVs_Injected(out Vector4 ret);
	private void GetOuterUVs_Injected(out Vector4 ret);
	private void GetPadding_Injected(out Vector4 ret);
	private void get_bounds_Injected(out Bounds ret);
	private void get_rect_Injected(out Rect ret);
	private void get_border_Injected(out Vector4 ret);
	private void get_pivot_Injected(out Vector2 ret);

}
//NameSpace:UnityEngine.U2D
public class SpriteAtlasManager
{
	// Fields
	private static Action`2<stringAction`1<SpriteAtlas>> atlasRequested;
	private static Action`1<SpriteAtlas> atlasRegistered;
	private static Action`1<SpriteAtlas> <>f__mg$cache0;

	// Methods
	private static bool RequestAtlas(string tag);
	public static void add_atlasRegistered(Action`1<SpriteAtlas> value);
	public static void remove_atlasRegistered(Action`1<SpriteAtlas> value);
	private static void PostRegisteredAtlas(SpriteAtlas spriteAtlas);
	internal static void Register(SpriteAtlas spriteAtlas);
	private static void .cctor();

}
//NameSpace:UnityEngine.U2D
public class SpriteAtlas : Object
{
	// Methods
	public bool CanBindTo(Sprite sprite);

}
//NameSpace:
internal class <Module>
{
}
//NameSpace:UnityEngine
public enum FontStyle
{
	// Fields
	public int value__;
	public const FontStyle Normal;
	public const FontStyle Bold;
	public const FontStyle Italic;
	public const FontStyle BoldAndItalic;

}
//NameSpace:UnityEngine
internal enum TextGenerationError
{
	// Fields
	public int value__;
	public const TextGenerationError None;
	public const TextGenerationError CustomSizeOnNonDynamicFont;
	public const TextGenerationError CustomStyleOnNonDynamicFont;
	public const TextGenerationError NoFont;

}
//NameSpace:UnityEngine
public struct TextGenerationSettings
{
	// Fields
	public Font font;
	public Color color;
	public int fontSize;
	public float lineSpacing;
	public bool richText;
	public float scaleFactor;
	public FontStyle fontStyle;
	public TextAnchor textAnchor;
	public bool alignByGeometry;
	public bool resizeTextForBestFit;
	public int resizeTextMinSize;
	public int resizeTextMaxSize;
	public bool updateBounds;
	public VerticalWrapMode verticalOverflow;
	public HorizontalWrapMode horizontalOverflow;
	public Vector2 generationExtents;
	public Vector2 pivot;
	public bool generateOutOfBounds;

	// Methods
	private bool CompareColors(Color left, Color right);
	private bool CompareVector2(Vector2 left, Vector2 right);
	public bool Equals(TextGenerationSettings other);

}
//NameSpace:UnityEngine
public sealed class TextGenerator : IDisposable
{
	// Fields
	internal IntPtr m_Ptr;
	private string m_LastString;
	private TextGenerationSettings m_LastSettings;
	private bool m_HasGenerated;
	private TextGenerationError m_LastValid;
	private readonly List`1<UIVertex> m_Verts;
	private readonly List`1<UICharInfo> m_Characters;
	private readonly List`1<UILineInfo> m_Lines;
	private bool m_CachedVerts;
	private bool m_CachedCharacters;
	private bool m_CachedLines;

	// Properties
	public int characterCountVisible { get; }
	public IList`1<UIVertex> verts { get; }
	public IList`1<UICharInfo> characters { get; }
	public IList`1<UILineInfo> lines { get; }
	public Rect rectExtents { get; }
	public int characterCount { get; }
	public int lineCount { get; }

	// Methods
	public void .ctor();
	public void .ctor(int initialCapacity);
	protected override void Finalize();
	private void System.IDisposable.Dispose();
	public int get_characterCountVisible();
	private TextGenerationSettings ValidatedSettings(TextGenerationSettings settings);
	public void Invalidate();
	public void GetCharacters(List`1<UICharInfo> characters);
	public void GetLines(List`1<UILineInfo> lines);
	public void GetVertices(List`1<UIVertex> vertices);
	public float GetPreferredWidth(string str, TextGenerationSettings settings);
	public float GetPreferredHeight(string str, TextGenerationSettings settings);
	public bool PopulateWithErrors(string str, TextGenerationSettings settings, GameObject context);
	public bool Populate(string str, TextGenerationSettings settings);
	private TextGenerationError PopulateWithError(string str, TextGenerationSettings settings);
	private TextGenerationError PopulateAlways(string str, TextGenerationSettings settings);
	public IList`1<UIVertex> get_verts();
	public IList`1<UICharInfo> get_characters();
	public IList`1<UILineInfo> get_lines();
	public Rect get_rectExtents();
	public int get_characterCount();
	public int get_lineCount();
	private static IntPtr Internal_Create();
	private static void Internal_Destroy(IntPtr ptr);
	internal bool Populate_Internal(string str, Font font, Color color, int fontSize, float scaleFactor, float lineSpacing, FontStyle style, bool richText, bool resizeTextForBestFit, int resizeTextMinSize, int resizeTextMaxSize, int verticalOverFlow, int horizontalOverflow, bool updateBounds, TextAnchor anchor, float extentsX, float extentsY, float pivotX, float pivotY, bool generateOutOfBounds, bool alignByGeometry, out uint error);
	internal bool Populate_Internal(string str, Font font, Color color, int fontSize, float scaleFactor, float lineSpacing, FontStyle style, bool richText, bool resizeTextForBestFit, int resizeTextMinSize, int resizeTextMaxSize, VerticalWrapMode verticalOverFlow, HorizontalWrapMode horizontalOverflow, bool updateBounds, TextAnchor anchor, Vector2 extents, Vector2 pivot, bool generateOutOfBounds, bool alignByGeometry, out TextGenerationError error);
	private void GetVerticesInternal(object vertices);
	private void GetCharactersInternal(object characters);
	private void GetLinesInternal(object lines);
	private void get_rectExtents_Injected(out Rect ret);
	private bool Populate_Internal_Injected(string str, Font font, Color color, int fontSize, float scaleFactor, float lineSpacing, FontStyle style, bool richText, bool resizeTextForBestFit, int resizeTextMinSize, int resizeTextMaxSize, int verticalOverFlow, int horizontalOverflow, bool updateBounds, TextAnchor anchor, float extentsX, float extentsY, float pivotX, float pivotY, bool generateOutOfBounds, bool alignByGeometry, out uint error);

}
//NameSpace:UnityEngine
public enum TextAnchor
{
	// Fields
	public int value__;
	public const TextAnchor UpperLeft;
	public const TextAnchor UpperCenter;
	public const TextAnchor UpperRight;
	public const TextAnchor MiddleLeft;
	public const TextAnchor MiddleCenter;
	public const TextAnchor MiddleRight;
	public const TextAnchor LowerLeft;
	public const TextAnchor LowerCenter;
	public const TextAnchor LowerRight;

}
//NameSpace:UnityEngine
public enum HorizontalWrapMode
{
	// Fields
	public int value__;
	public const HorizontalWrapMode Wrap;
	public const HorizontalWrapMode Overflow;

}
//NameSpace:UnityEngine
public enum VerticalWrapMode
{
	// Fields
	public int value__;
	public const VerticalWrapMode Truncate;
	public const VerticalWrapMode Overflow;

}
//NameSpace:UnityEngine
public struct UICharInfo
{
	// Fields
	public Vector2 cursorPos;
	public float charWidth;

}
//NameSpace:UnityEngine
public struct UILineInfo
{
	// Fields
	public int startCharIdx;
	public int height;
	public float topY;
	public float leading;

}
//NameSpace:UnityEngine
public struct UIVertex
{
	// Fields
	public Vector3 position;
	public Vector3 normal;
	public Vector4 tangent;
	public Color32 color;
	public Vector2 uv0;
	public Vector2 uv1;
	public Vector2 uv2;
	public Vector2 uv3;
	private static readonly Color32 s_DefaultColor;
	private static readonly Vector4 s_DefaultTangent;
	public static UIVertex simpleVert;

	// Methods
	private static void .cctor();

}
//NameSpace:UnityEngine
public sealed class Font : Object
{
	// Fields
	private static Action`1<Font> textureRebuilt;
	private Font.FontTextureRebuildCallback m_FontTextureRebuildCallback;

	// Properties
	public Material material { get; }
	public bool dynamic { get; }
	public int fontSize { get; }

	// Methods
	public static void add_textureRebuilt(Action`1<Font> value);
	public static void remove_textureRebuilt(Action`1<Font> value);
	public Material get_material();
	public bool get_dynamic();
	public int get_fontSize();
	internal static void InvokeTextureRebuilt_Internal(Font font);
	public bool HasCharacter(char c);
	private bool HasCharacter(int c);

}
//NameSpace:
public sealed class Font.FontTextureRebuildCallback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke();
	public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:
internal class <Module>
{
}
//NameSpace:UnityEngine.Experimental.Animations
public interface IAnimationJobPlayable : IPlayable
{
}
//NameSpace:UnityEngine
public sealed class SharedBetweenAnimatorsAttribute : Attribute
{
}
//NameSpace:UnityEngine
public abstract class StateMachineBehaviour : ScriptableObject
{
	// Methods
	protected void .ctor();
	public virtual void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex);
	public virtual void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex);
	public virtual void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex);
	public virtual void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex);
	public virtual void OnStateIK(Animator animator, AnimatorStateInfo stateInfo, int layerIndex);
	public virtual void OnStateMachineEnter(Animator animator, int stateMachinePathHash);
	public virtual void OnStateMachineExit(Animator animator, int stateMachinePathHash);
	public virtual void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex, AnimatorControllerPlayable controller);
	public virtual void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex, AnimatorControllerPlayable controller);
	public virtual void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex, AnimatorControllerPlayable controller);
	public virtual void OnStateMove(Animator animator, AnimatorStateInfo stateInfo, int layerIndex, AnimatorControllerPlayable controller);
	public virtual void OnStateIK(Animator animator, AnimatorStateInfo stateInfo, int layerIndex, AnimatorControllerPlayable controller);
	public virtual void OnStateMachineEnter(Animator animator, int stateMachinePathHash, AnimatorControllerPlayable controller);
	public virtual void OnStateMachineExit(Animator animator, int stateMachinePathHash, AnimatorControllerPlayable controller);

}
//NameSpace:UnityEngine.Animations
public struct AnimationClipPlayable : IPlayable, IEquatable`1<AnimationClipPlayable>
{
	// Fields
	private PlayableHandle m_Handle;

	// Methods
	public PlayableHandle GetHandle();
	public bool Equals(AnimationClipPlayable other);

}
//NameSpace:UnityEngine.Experimental.Animations
public struct AnimationHumanStream
{
	// Fields
	private IntPtr stream;

}
//NameSpace:UnityEngine.Animations
public struct AnimationLayerMixerPlayable : IPlayable, IEquatable`1<AnimationLayerMixerPlayable>
{
	// Fields
	private PlayableHandle m_Handle;
	private static readonly AnimationLayerMixerPlayable m_NullPlayable;

	// Methods
	internal void .ctor(PlayableHandle handle);
	public PlayableHandle GetHandle();
	public bool Equals(AnimationLayerMixerPlayable other);
	private static void .cctor();

}
//NameSpace:UnityEngine.Animations
public struct AnimationMixerPlayable : IPlayable, IEquatable`1<AnimationMixerPlayable>
{
	// Fields
	private PlayableHandle m_Handle;
	private static readonly AnimationMixerPlayable m_NullPlayable;

	// Methods
	internal void .ctor(PlayableHandle handle);
	public PlayableHandle GetHandle();
	public bool Equals(AnimationMixerPlayable other);
	private static void .cctor();

}
//NameSpace:UnityEngine.Animations
internal struct AnimationMotionXToDeltaPlayable : IPlayable, IEquatable`1<AnimationMotionXToDeltaPlayable>
{
	// Fields
	private PlayableHandle m_Handle;
	private static readonly AnimationMotionXToDeltaPlayable m_NullPlayable;

	// Methods
	private void .ctor(PlayableHandle handle);
	public PlayableHandle GetHandle();
	public bool Equals(AnimationMotionXToDeltaPlayable other);
	private static void .cctor();

}
//NameSpace:UnityEngine.Animations
internal struct AnimationOffsetPlayable : IPlayable, IEquatable`1<AnimationOffsetPlayable>
{
	// Fields
	private PlayableHandle m_Handle;
	private static readonly AnimationOffsetPlayable m_NullPlayable;

	// Methods
	internal void .ctor(PlayableHandle handle);
	public PlayableHandle GetHandle();
	public bool Equals(AnimationOffsetPlayable other);
	private static void .cctor();

}
//NameSpace:UnityEngine.Animations
public struct AnimationPlayableOutput : IPlayableOutput
{
	// Fields
	private PlayableOutputHandle m_Handle;

}
//NameSpace:UnityEngine.Animations
internal struct AnimationPosePlayable : IPlayable, IEquatable`1<AnimationPosePlayable>
{
	// Fields
	private PlayableHandle m_Handle;
	private static readonly AnimationPosePlayable m_NullPlayable;

	// Methods
	internal void .ctor(PlayableHandle handle);
	public PlayableHandle GetHandle();
	public bool Equals(AnimationPosePlayable other);
	private static void .cctor();

}
//NameSpace:UnityEngine.Animations
internal struct AnimationRemoveScalePlayable : IPlayable, IEquatable`1<AnimationRemoveScalePlayable>
{
	// Fields
	private PlayableHandle m_Handle;
	private static readonly AnimationRemoveScalePlayable m_NullPlayable;

	// Methods
	internal void .ctor(PlayableHandle handle);
	public PlayableHandle GetHandle();
	public bool Equals(AnimationRemoveScalePlayable other);
	private static void .cctor();

}
//NameSpace:UnityEngine.Experimental.Animations
public struct AnimationScriptPlayable : IAnimationJobPlayable, IEquatable`1<AnimationScriptPlayable>, IPlayable
{
	// Fields
	private PlayableHandle m_Handle;
	private static readonly AnimationScriptPlayable m_NullPlayable;

	// Methods
	internal void .ctor(PlayableHandle handle);
	public PlayableHandle GetHandle();
	public bool Equals(AnimationScriptPlayable other);
	private static void .cctor();

}
//NameSpace:UnityEngine.Experimental.Animations
public struct AnimationStream
{
	// Fields
	private uint m_AnimatorBindingsVersion;
	private IntPtr constant;
	private IntPtr input;
	private IntPtr output;
	private IntPtr workspace;
	private IntPtr inputStreamAccessor;
	private IntPtr animationHandleBinder;

}
//NameSpace:UnityEngine
public struct AnimatorClipInfo
{
	// Fields
	private int m_ClipInstanceID;
	private float m_Weight;

}
//NameSpace:UnityEngine
public struct AnimatorStateInfo
{
	// Fields
	private int m_Name;
	private int m_Path;
	private int m_FullPath;
	private float m_NormalizedTime;
	private float m_Length;
	private float m_Speed;
	private float m_SpeedMultiplier;
	private int m_Tag;
	private int m_Loop;

}
//NameSpace:UnityEngine
public struct AnimatorTransitionInfo
{
	// Fields
	private int m_FullPath;
	private int m_UserName;
	private int m_Name;
	private bool m_HasFixedDuration;
	private float m_Duration;
	private float m_NormalizedTime;
	private bool m_AnyState;
	private int m_TransitionType;

}
//NameSpace:UnityEngine
public class Animator : Behaviour
{
	// Properties
	public bool hasBoundPlayables { get; }

	// Methods
	public void SetTrigger(string name);
	public void ResetTrigger(string name);
	public bool get_hasBoundPlayables();
	private void SetTriggerString(string name);
	private void ResetTriggerString(string name);

}
//NameSpace:UnityEngine.Animations
public struct AnimatorControllerPlayable : IPlayable, IEquatable`1<AnimatorControllerPlayable>
{
	// Fields
	private PlayableHandle m_Handle;
	private static readonly AnimatorControllerPlayable m_NullPlayable;

	// Methods
	internal void .ctor(PlayableHandle handle);
	public PlayableHandle GetHandle();
	public void SetHandle(PlayableHandle handle);
	public bool Equals(AnimatorControllerPlayable other);
	private static void .cctor();

}
//NameSpace:UnityEngine
public class AnimatorOverrideController : RuntimeAnimatorController
{
	// Fields
	internal AnimatorOverrideController.OnOverrideControllerDirtyCallback OnOverrideControllerDirty;

	// Methods
	internal static void OnInvalidateOverrideController(AnimatorOverrideController controller);

}
//NameSpace:
internal sealed class AnimatorOverrideController.OnOverrideControllerDirtyCallback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke();
	public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine
public struct SkeletonBone
{
	// Fields
	public string name;
	internal string parentName;
	public Vector3 position;
	public Quaternion rotation;
	public Vector3 scale;

}
//NameSpace:UnityEngine
public struct HumanLimit
{
	// Fields
	private Vector3 m_Min;
	private Vector3 m_Max;
	private Vector3 m_Center;
	private float m_AxisLength;
	private int m_UseDefaultValues;

}
//NameSpace:UnityEngine
public struct HumanBone
{
	// Fields
	private string m_BoneName;
	private string m_HumanName;
	public HumanLimit limit;

}
//NameSpace:UnityEngine
public class RuntimeAnimatorController : Object
{
}
//NameSpace:UnityEngine
internal enum AnimationEventSource
{
	// Fields
	public int value__;
	public const AnimationEventSource NoSource;
	public const AnimationEventSource Legacy;
	public const AnimationEventSource Animator;

}
//NameSpace:UnityEngine
public sealed class AnimationEvent
{
	// Fields
	internal float m_Time;
	internal string m_FunctionName;
	internal string m_StringParameter;
	internal Object m_ObjectReferenceParameter;
	internal float m_FloatParameter;
	internal int m_IntParameter;
	internal int m_MessageOptions;
	internal AnimationEventSource m_Source;
	internal AnimationState m_StateSender;
	internal AnimatorStateInfo m_AnimatorStateInfo;
	internal AnimatorClipInfo m_AnimatorClipInfo;

	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine
public sealed class AnimationState : TrackedReference
{
}
//NameSpace:
internal class <Module>
{
}
//NameSpace:UnityEngine
internal class AudioExtensionDefinition
{
	// Fields
	private string assemblyName;
	private string extensionNamespace;
	private string extensionTypeName;
	private Type extensionType;

	// Methods
	public Type GetExtensionType();

}
//NameSpace:UnityEngine
internal class AudioSpatializerExtensionDefinition
{
	// Fields
	public PropertyName spatializerName;
	public AudioExtensionDefinition definition;

}
//NameSpace:UnityEngine
internal class AudioAmbisonicExtensionDefinition
{
	// Fields
	public PropertyName ambisonicPluginName;
	public AudioExtensionDefinition definition;

}
//NameSpace:UnityEngine
internal class AudioListenerExtension : ScriptableObject
{
	// Fields
	private AudioListener m_audioListener;

	// Properties
	public AudioListener audioListener { get; set; }

	// Methods
	public void .ctor();
	public AudioListener get_audioListener();
	public void set_audioListener(AudioListener value);
	public virtual float ReadExtensionProperty(PropertyName propertyName);
	public virtual void WriteExtensionProperty(PropertyName propertyName, float propertyValue);
	public virtual void ExtensionUpdate();

}
//NameSpace:UnityEngine
internal class AudioSourceExtension : ScriptableObject
{
	// Fields
	private AudioSource m_audioSource;
	internal int m_ExtensionManagerUpdateIndex;

	// Properties
	public AudioSource audioSource { get; set; }

	// Methods
	public void .ctor();
	public AudioSource get_audioSource();
	public void set_audioSource(AudioSource value);
	public virtual float ReadExtensionProperty(PropertyName propertyName);
	public virtual void WriteExtensionProperty(PropertyName propertyName, float propertyValue);
	public virtual void Play();
	public virtual void Stop();
	public virtual void ExtensionUpdate();
	public void OnDestroy();

}
//NameSpace:UnityEngine
internal sealed class AudioExtensionManager
{
	// Fields
	private static List`1<AudioSpatializerExtensionDefinition> m_ListenerSpatializerExtensionDefinitions;
	private static List`1<AudioSpatializerExtensionDefinition> m_SourceSpatializerExtensionDefinitions;
	private static List`1<AudioAmbisonicExtensionDefinition> m_SourceAmbisonicDecoderExtensionDefinitions;
	private static List`1<AudioSourceExtension> m_SourceExtensionsToUpdate;
	private static int m_NextStopIndex;
	private static bool m_BuiltinDefinitionsRegistered;
	private static PropertyName m_SpatializerName;
	private static PropertyName m_SpatializerExtensionName;
	private static PropertyName m_ListenerSpatializerExtensionName;

	// Methods
	internal static AudioSourceExtension AddSpatializerExtension(AudioSource source);
	internal static AudioSourceExtension AddAmbisonicDecoderExtension(AudioSource source);
	internal static void WriteExtensionProperties(AudioSourceExtension extension, string extensionName);
	internal static AudioListenerExtension AddSpatializerExtension(AudioListener listener);
	internal static void WriteExtensionProperties(AudioListenerExtension extension, string extensionName);
	internal static void AddExtensionToManager(AudioSourceExtension extension);
	internal static void RemoveExtensionFromManager(AudioSourceExtension extension);
	internal static void Update();
	internal static void GetReadyToPlay(AudioSourceExtension extension);
	private static void RegisterBuiltinDefinitions();
	internal static Object GetAudioListener();
	private static void .cctor();

}
//NameSpace:UnityEngine.Audio
public struct AudioPlayableOutput : IPlayableOutput
{
	// Fields
	private PlayableOutputHandle m_Handle;

}
//NameSpace:UnityEngine.Audio
public struct AudioClipPlayable : IPlayable, IEquatable`1<AudioClipPlayable>
{
	// Fields
	private PlayableHandle m_Handle;

	// Methods
	public PlayableHandle GetHandle();
	public bool Equals(AudioClipPlayable other);

}
//NameSpace:UnityEngine.Audio
public struct AudioMixerPlayable : IPlayable, IEquatable`1<AudioMixerPlayable>
{
	// Fields
	private PlayableHandle m_Handle;

	// Methods
	public PlayableHandle GetHandle();
	public bool Equals(AudioMixerPlayable other);

}
//NameSpace:UnityEngine.Experimental.Audio
public class AudioSampleProvider : IDisposable
{
	// Fields
	private AudioSampleProvider.ConsumeSampleFramesNativeFunction m_ConsumeSampleFramesNativeFunction;
	private uint <id>k__BackingField;
	private ushort <trackIndex>k__BackingField;
	private Object <owner>k__BackingField;
	private ushort <channelCount>k__BackingField;
	private uint <sampleRate>k__BackingField;
	private AudioSampleProvider.SampleFramesHandler sampleFramesAvailable;
	private AudioSampleProvider.SampleFramesHandler sampleFramesOverflow;

	// Properties
	public uint id { get; set; }

	// Methods
	protected override void Finalize();
	public void Dispose();
	public uint get_id();
	private void set_id(uint value);
	private void InvokeSampleFramesAvailable(int sampleFrameCount);
	private void InvokeSampleFramesOverflow(int droppedSampleFrameCount);
	private static void InternalSetScriptingPtr(uint providerId, AudioSampleProvider provider);

}
//NameSpace:
public sealed class AudioSampleProvider.ConsumeSampleFramesNativeFunction : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual uint Invoke(uint providerId, IntPtr interleavedSampleFrames, uint sampleFrameCount);
	public virtual IAsyncResult BeginInvoke(uint providerId, IntPtr interleavedSampleFrames, uint sampleFrameCount, AsyncCallback callback, object object);
	public virtual uint EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class AudioSampleProvider.SampleFramesHandler : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(AudioSampleProvider provider, uint sampleFrameCount);
	public virtual IAsyncResult BeginInvoke(AudioSampleProvider provider, uint sampleFrameCount, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine
public sealed class AudioSettings
{
	// Fields
	private static AudioSettings.AudioConfigurationChangeHandler OnAudioConfigurationChanged;

	// Methods
	public static string GetSpatializerPluginName();
	internal static void InvokeOnAudioConfigurationChanged(bool deviceWasChanged);
	internal static void InvokeOnAudioManagerUpdate();
	internal static void InvokeOnAudioSourcePlay(AudioSource source);
	internal static string GetAmbisonicDecoderPluginName();

}
//NameSpace:
public sealed class AudioSettings.AudioConfigurationChangeHandler : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(bool deviceWasChanged);
	public virtual IAsyncResult BeginInvoke(bool deviceWasChanged, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine
public sealed class AudioClip : Object
{
	// Fields
	private AudioClip.PCMReaderCallback m_PCMReaderCallback;
	private AudioClip.PCMSetPositionCallback m_PCMSetPositionCallback;

	// Properties
	public bool ambisonic { get; }

	// Methods
	private void .ctor();
	public bool get_ambisonic();
	private void InvokePCMReaderCallback_Internal(float[] data);
	private void InvokePCMSetPositionCallback_Internal(int position);

}
//NameSpace:
public sealed class AudioClip.PCMReaderCallback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(float[] data);
	public virtual IAsyncResult BeginInvoke(float[] data, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class AudioClip.PCMSetPositionCallback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(int position);
	public virtual IAsyncResult BeginInvoke(int position, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine
public class AudioBehaviour : Behaviour
{
}
//NameSpace:UnityEngine
public sealed class AudioListener : AudioBehaviour
{
	// Fields
	internal AudioListenerExtension spatializerExtension;

	// Methods
	internal int GetNumExtensionProperties();
	internal PropertyName ReadExtensionName(int listenerIndex);
	private static void INTERNAL_CALL_ReadExtensionName(AudioListener self, int listenerIndex, out PropertyName value);
	internal PropertyName ReadExtensionPropertyName(int listenerIndex);
	private static void INTERNAL_CALL_ReadExtensionPropertyName(AudioListener self, int listenerIndex, out PropertyName value);
	internal float ReadExtensionPropertyValue(int listenerIndex);
	internal void ClearExtensionProperties(PropertyName extensionName);
	private static void INTERNAL_CALL_ClearExtensionProperties(AudioListener self, PropertyName extensionName);
	internal AudioListenerExtension AddExtension(Type extensionType);

}
//NameSpace:UnityEngine
public sealed class AudioSource : AudioBehaviour
{
	// Fields
	internal AudioSourceExtension spatializerExtension;
	internal AudioSourceExtension ambisonicExtension;

	// Properties
	public AudioClip clip { get; }
	public bool isPlaying { get; }
	internal bool spatializeInternal { get; }
	public bool spatialize { get; }

	// Methods
	public AudioClip get_clip();
	public bool get_isPlaying();
	internal bool get_spatializeInternal();
	public bool get_spatialize();
	internal int GetNumExtensionProperties();
	internal PropertyName ReadExtensionName(int sourceIndex);
	private static void INTERNAL_CALL_ReadExtensionName(AudioSource self, int sourceIndex, out PropertyName value);
	internal PropertyName ReadExtensionPropertyName(int sourceIndex);
	private static void INTERNAL_CALL_ReadExtensionPropertyName(AudioSource self, int sourceIndex, out PropertyName value);
	internal float ReadExtensionPropertyValue(int sourceIndex);
	internal void ClearExtensionProperties(PropertyName extensionName);
	private static void INTERNAL_CALL_ClearExtensionProperties(AudioSource self, PropertyName extensionName);
	internal AudioSourceExtension AddSpatializerExtension(Type extensionType);
	internal AudioSourceExtension AddAmbisonicExtension(Type extensionType);

}
//NameSpace:
internal class <Module>
{
}
//NameSpace:UnityEngine.SocialPlatforms.GameCenter
internal struct GcUserProfileData
{
	// Fields
	public string userName;
	public string userID;
	public int isFriend;
	public Texture2D image;

	// Methods
	public UserProfile ToUserProfile();
	public void AddToArray(UserProfile[] array, int number);

}
//NameSpace:UnityEngine.SocialPlatforms.GameCenter
internal struct GcAchievementDescriptionData
{
	// Fields
	public string m_Identifier;
	public string m_Title;
	public Texture2D m_Image;
	public string m_AchievedDescription;
	public string m_UnachievedDescription;
	public int m_Hidden;
	public int m_Points;

	// Methods
	public AchievementDescription ToAchievementDescription();

}
//NameSpace:UnityEngine.SocialPlatforms.GameCenter
internal struct GcAchievementData
{
	// Fields
	public string m_Identifier;
	public double m_PercentCompleted;
	public int m_Completed;
	public int m_Hidden;
	public int m_LastReportedDate;

	// Methods
	public Achievement ToAchievement();

}
//NameSpace:UnityEngine.SocialPlatforms.GameCenter
internal struct GcScoreData
{
	// Fields
	public string m_Category;
	public uint m_ValueLow;
	public int m_ValueHigh;
	public int m_Date;
	public string m_FormattedValue;
	public string m_PlayerID;
	public int m_Rank;

	// Methods
	public Score ToScore();

}
//NameSpace:UnityEngine.SocialPlatforms.GameCenter
public class GameCenterPlatform : ISocialPlatform
{
	// Fields
	private static Action`2<boolstring> s_AuthenticateCallback;
	private static AchievementDescription[] s_adCache;
	private static UserProfile[] s_friends;
	private static UserProfile[] s_users;
	private static Action`1<bool> s_ResetAchievements;
	private static LocalUser m_LocalUser;
	private static List`1<GcLeaderboard> m_GcBoards;

	// Properties
	public ILocalUser localUser { get; }

	// Methods
	public void .ctor();
	private static void ClearAchievementDescriptions(int size);
	private static void SetAchievementDescription(GcAchievementDescriptionData data, int number);
	private static void SetAchievementDescriptionImage(Texture2D texture, int number);
	private static void TriggerAchievementDescriptionCallback(Action`1<IAchievementDescription[]> callback);
	private static void AuthenticateCallbackWrapper(int result, string error);
	private static void ClearFriends(int size);
	private static void SetFriends(GcUserProfileData data, int number);
	private static void SetFriendImage(Texture2D texture, int number);
	private static void TriggerFriendsCallbackWrapper(Action`1<bool> callback, int result);
	private static void AchievementCallbackWrapper(Action`1<IAchievement[]> callback, GcAchievementData[] result);
	private static void ProgressCallbackWrapper(Action`1<bool> callback, bool success);
	private static void ScoreCallbackWrapper(Action`1<bool> callback, bool success);
	private static void ScoreLoaderCallbackWrapper(Action`1<IScore[]> callback, GcScoreData[] result);
	private void UnityEngine.SocialPlatforms.ISocialPlatform.LoadFriends(ILocalUser user, Action`1<bool> callback);
	private void UnityEngine.SocialPlatforms.ISocialPlatform.Authenticate(ILocalUser user, Action`1<bool> callback);
	private void UnityEngine.SocialPlatforms.ISocialPlatform.Authenticate(ILocalUser user, Action`2<boolstring> callback);
	public ILocalUser get_localUser();
	private static void PopulateLocalUser();
	public void LoadAchievementDescriptions(Action`1<IAchievementDescription[]> callback);
	public void ReportProgress(string id, double progress, Action`1<bool> callback);
	public void LoadAchievements(Action`1<IAchievement[]> callback);
	public void ReportScore(long score, string board, Action`1<bool> callback);
	public void LoadScores(string category, Action`1<IScore[]> callback);
	public void LoadScores(ILeaderboard board, Action`1<bool> callback);
	private static void LeaderboardCallbackWrapper(Action`1<bool> callback, bool success);
	public bool GetLoading(ILeaderboard board);
	private bool VerifyAuthentication();
	public void ShowAchievementsUI();
	public void ShowLeaderboardUI();
	private static void ClearUsers(int size);
	private static void SetUser(GcUserProfileData data, int number);
	private static void SetUserImage(Texture2D texture, int number);
	private static void TriggerUsersCallbackWrapper(Action`1<IUserProfile[]> callback);
	public void LoadUsers(string[] userIds, Action`1<IUserProfile[]> callback);
	private static void SafeSetUserImage(UserProfile[] array, Texture2D texture, int number);
	private static void SafeClearArray(UserProfile[] array, int size);
	public ILeaderboard CreateLeaderboard();
	public IAchievement CreateAchievement();
	private static void TriggerResetAchievementCallback(bool result);
	internal static void Authenticate();
	internal static bool GetAuthenticated();
	internal static string Internal_UserName();
	internal static string Internal_UserID();
	internal static bool GetIsUnderage();
	internal static Texture2D GetUserImage();
	internal static void LoadFriends(object callback);
	internal static void InternalLoadAchievementDescriptions(object callback);
	internal static void InternalLoadAchievements(object callback);
	internal static void InternalReportProgress(string id, double progress, object callback);
	internal static void InternalReportScore(long score, string category, object callback);
	internal static void InternalLoadScores(string category, object callback);
	internal static void Internal_ShowAchievementsUI();
	internal static void Internal_ShowLeaderboardUI();
	internal static void Internal_LoadUsers(string[] userIds, object callback);
	internal static void ResetAllAchievements();
	internal static void ShowDefaultAchievementBanner(bool value);
	public static void ResetAllAchievements(Action`1<bool> callback);
	public static void ShowDefaultAchievementCompletionBanner(bool value);
	public static void ShowLeaderboardUI(string leaderboardID, TimeScope timeScope);
	internal static void ShowSpecificLeaderboardUI(string leaderboardID, int timeScope);
	private static void .cctor();

}
//NameSpace:
private sealed class GameCenterPlatform.<UnityEngine_SocialPlatforms_ISocialPlatform_Authenticate>c__AnonStorey0
{
	// Fields
	internal Action`1<bool> callback;

	// Methods
	public void .ctor();
	internal void <>m__0(bool success, string error);

}
//NameSpace:UnityEngine.SocialPlatforms.Impl
public class LocalUser : UserProfile, ILocalUser, IUserProfile
{
	// Fields
	private IUserProfile[] m_Friends;
	private bool m_Authenticated;
	private bool m_Underage;

	// Properties
	public bool authenticated { get; }

	// Methods
	public void .ctor();
	public void SetFriends(IUserProfile[] friends);
	public void SetAuthenticated(bool value);
	public void SetUnderage(bool value);
	public bool get_authenticated();

}
//NameSpace:UnityEngine.SocialPlatforms.Impl
public class UserProfile : IUserProfile
{
	// Fields
	protected string m_UserName;
	protected string m_ID;
	protected bool m_IsFriend;
	protected UserState m_State;
	protected Texture2D m_Image;

	// Properties
	public string userName { get; }
	public string id { get; }
	public bool isFriend { get; }
	public UserState state { get; }

	// Methods
	public void .ctor();
	public void .ctor(string name, string id, bool friend, UserState state, Texture2D image);
	public override string ToString();
	public void SetUserName(string name);
	public void SetUserID(string id);
	public void SetImage(Texture2D image);
	public string get_userName();
	public string get_id();
	public bool get_isFriend();
	public UserState get_state();

}
//NameSpace:UnityEngine.SocialPlatforms.Impl
public class Achievement : IAchievement
{
	// Fields
	private bool m_Completed;
	private bool m_Hidden;
	private DateTime m_LastReportedDate;
	private string <id>k__BackingField;
	private double <percentCompleted>k__BackingField;

	// Properties
	public string id { get; set; }
	public double percentCompleted { get; set; }
	public bool completed { get; }
	public bool hidden { get; }
	public DateTime lastReportedDate { get; }

	// Methods
	public void .ctor(string id, double percentCompleted, bool completed, bool hidden, DateTime lastReportedDate);
	public void .ctor(string id, double percent);
	public void .ctor();
	public override string ToString();
	public string get_id();
	public void set_id(string value);
	public double get_percentCompleted();
	public void set_percentCompleted(double value);
	public bool get_completed();
	public bool get_hidden();
	public DateTime get_lastReportedDate();

}
//NameSpace:UnityEngine.SocialPlatforms.Impl
public class AchievementDescription : IAchievementDescription
{
	// Fields
	private string m_Title;
	private Texture2D m_Image;
	private string m_AchievedDescription;
	private string m_UnachievedDescription;
	private bool m_Hidden;
	private int m_Points;
	private string <id>k__BackingField;

	// Properties
	public string id { get; set; }
	public string title { get; }
	public string achievedDescription { get; }
	public string unachievedDescription { get; }
	public bool hidden { get; }
	public int points { get; }

	// Methods
	public void .ctor(string id, string title, Texture2D image, string achievedDescription, string unachievedDescription, bool hidden, int points);
	public override string ToString();
	public void SetImage(Texture2D image);
	public string get_id();
	public void set_id(string value);
	public string get_title();
	public string get_achievedDescription();
	public string get_unachievedDescription();
	public bool get_hidden();
	public int get_points();

}
//NameSpace:UnityEngine.SocialPlatforms.Impl
public class Score : IScore
{
	// Fields
	private DateTime m_Date;
	private string m_FormattedValue;
	private string m_UserID;
	private int m_Rank;
	private string <leaderboardID>k__BackingField;
	private long <value>k__BackingField;

	// Properties
	public string leaderboardID { get; set; }
	public long value { get; set; }

	// Methods
	public void .ctor(string leaderboardID, long value);
	public void .ctor(string leaderboardID, long value, string userID, DateTime date, string formattedValue, int rank);
	public override string ToString();
	public string get_leaderboardID();
	public void set_leaderboardID(string value);
	public long get_value();
	public void set_value(long value);

}
//NameSpace:UnityEngine.SocialPlatforms.Impl
public class Leaderboard : ILeaderboard
{
	// Fields
	private bool m_Loading;
	private IScore m_LocalUserScore;
	private uint m_MaxRange;
	private IScore[] m_Scores;
	private string m_Title;
	private string[] m_UserIDs;
	private string <id>k__BackingField;
	private UserScope <userScope>k__BackingField;
	private Range <range>k__BackingField;
	private TimeScope <timeScope>k__BackingField;

	// Properties
	public string id { get; set; }
	public UserScope userScope { get; set; }
	public Range range { get; set; }
	public TimeScope timeScope { get; set; }

	// Methods
	public void .ctor();
	public override string ToString();
	public void SetLocalUserScore(IScore score);
	public void SetMaxRange(uint maxRange);
	public void SetScores(IScore[] scores);
	public void SetTitle(string title);
	public string[] GetUserFilter();
	public string get_id();
	public void set_id(string value);
	public UserScope get_userScope();
	public void set_userScope(UserScope value);
	public Range get_range();
	public void set_range(Range value);
	public TimeScope get_timeScope();
	public void set_timeScope(TimeScope value);

}
//NameSpace:UnityEngine.SocialPlatforms
public interface ISocialPlatform
{
	// Methods
	public abstract void Authenticate(ILocalUser user, Action`1<bool> callback);
	public abstract void Authenticate(ILocalUser user, Action`2<boolstring> callback);
	public abstract void LoadFriends(ILocalUser user, Action`1<bool> callback);

}
//NameSpace:UnityEngine.SocialPlatforms
public interface ILocalUser : IUserProfile
{
	// Properties
	public abstract bool authenticated { get; }

	// Methods
	public abstract bool get_authenticated();

}
//NameSpace:UnityEngine.SocialPlatforms
public enum UserState
{
	// Fields
	public int value__;
	public const UserState Online;
	public const UserState OnlineAndAway;
	public const UserState OnlineAndBusy;
	public const UserState Offline;
	public const UserState Playing;

}
//NameSpace:UnityEngine.SocialPlatforms
public interface IUserProfile
{
}
//NameSpace:UnityEngine.SocialPlatforms
public interface IAchievement
{
}
//NameSpace:UnityEngine.SocialPlatforms
public interface IAchievementDescription
{
}
//NameSpace:UnityEngine.SocialPlatforms
public interface IScore
{
}
//NameSpace:UnityEngine.SocialPlatforms
public enum UserScope
{
	// Fields
	public int value__;
	public const UserScope Global;
	public const UserScope FriendsOnly;

}
//NameSpace:UnityEngine.SocialPlatforms
public enum TimeScope
{
	// Fields
	public int value__;
	public const TimeScope Today;
	public const TimeScope Week;
	public const TimeScope AllTime;

}
//NameSpace:UnityEngine.SocialPlatforms
public struct Range
{
	// Fields
	public int from;
	public int count;

	// Methods
	public void .ctor(int fromValue, int valueCount);

}
//NameSpace:UnityEngine.SocialPlatforms
public interface ILeaderboard
{
	// Properties
	public abstract string id { get; }
	public abstract UserScope userScope { get; }
	public abstract Range range { get; }
	public abstract TimeScope timeScope { get; }

	// Methods
	public abstract string get_id();
	public abstract UserScope get_userScope();
	public abstract Range get_range();
	public abstract TimeScope get_timeScope();

}
//NameSpace:UnityEngine.SocialPlatforms.GameCenter
internal class GcLeaderboard
{
	// Fields
	private IntPtr m_InternalLeaderboard;
	private Leaderboard m_GenericLeaderboard;

	// Methods
	internal void .ctor(Leaderboard board);
	protected override void Finalize();
	internal bool Contains(Leaderboard board);
	internal void SetScores(GcScoreData[] scoreDatas);
	internal void SetLocalScore(GcScoreData scoreData);
	internal void SetMaxRange(uint maxRange);
	internal void SetTitle(string title);
	internal void Internal_LoadScores(string category, int from, int count, string[] userIDs, int playerScope, int timeScope, object callback);
	private static IntPtr GcLeaderboard_LoadScores(object self, string category, int from, int count, string[] userIDs, int playerScope, int timeScope, object callback);
	internal bool Loading();
	private static bool GcLeaderboard_Loading(IntPtr leaderboard);
	internal void Dispose();
	private static void GcLeaderboard_Dispose(IntPtr leaderboard);

}
//NameSpace:
internal class <Module>
{
}
//NameSpace:UnityEngine
public sealed class Event
{
	// Fields
	internal IntPtr m_Ptr;
	private static Event s_Current;
	private static Event s_MasterEvent;
	private static Dictionary`2<stringint> <>f__switch$map0;

	// Properties
	public EventType rawType { get; }
	public Vector2 mousePosition { get; }
	public EventModifiers modifiers { get; }
	public char character { get; }
	public KeyCode keyCode { get; }
	public void displayIndex { set; }
	public EventType type { get; }
	public string commandName { get; }
	public static Event current { get; }
	public bool isKey { get; }
	public bool isMouse { get; }

	// Methods
	public void .ctor();
	public void .ctor(int displayIndex);
	public EventType get_rawType();
	public Vector2 get_mousePosition();
	public EventModifiers get_modifiers();
	public char get_character();
	public KeyCode get_keyCode();
	public void set_displayIndex(int value);
	public EventType get_type();
	public string get_commandName();
	private static IntPtr Internal_Create(int displayIndex);
	private static void Internal_Destroy(IntPtr ptr);
	public static bool PopEvent(Event outEvent);
	private static void Internal_SetNativeEvent(IntPtr ptr);
	internal static void Internal_MakeMasterEventCurrent(int displayIndex);
	protected override void Finalize();
	public static Event get_current();
	public bool get_isKey();
	public bool get_isMouse();
	public override int GetHashCode();
	public override bool Equals(object obj);
	public override string ToString();
	private void get_mousePosition_Injected(out Vector2 ret);

}
//NameSpace:UnityEngine
public enum EventType
{
	// Fields
	public int value__;
	public const EventType MouseDown;
	public const EventType MouseUp;
	public const EventType MouseMove;
	public const EventType MouseDrag;
	public const EventType KeyDown;
	public const EventType KeyUp;
	public const EventType ScrollWheel;
	public const EventType Repaint;
	public const EventType Layout;
	public const EventType DragUpdated;
	public const EventType DragPerform;
	public const EventType DragExited;
	public const EventType Ignore;
	public const EventType Used;
	public const EventType ValidateCommand;
	public const EventType ExecuteCommand;
	public const EventType ContextClick;
	public const EventType MouseEnterWindow;
	public const EventType MouseLeaveWindow;
	public const EventType mouseDown;
	public const EventType mouseUp;
	public const EventType mouseMove;
	public const EventType mouseDrag;
	public const EventType keyDown;
	public const EventType keyUp;
	public const EventType scrollWheel;
	public const EventType repaint;
	public const EventType layout;
	public const EventType dragUpdated;
	public const EventType dragPerform;
	public const EventType ignore;
	public const EventType used;

}
//NameSpace:UnityEngine
public enum EventModifiers
{
	// Fields
	public int value__;
	public const EventModifiers None;
	public const EventModifiers Shift;
	public const EventModifiers Control;
	public const EventModifiers Alt;
	public const EventModifiers Command;
	public const EventModifiers Numeric;
	public const EventModifiers CapsLock;
	public const EventModifiers FunctionKey;

}
//NameSpace:UnityEngine
public class GUI
{
	// Fields
	private static int s_HotTextField;
	private static readonly int s_BoxHash;
	private static readonly int s_ButonHash;
	private static readonly int s_RepeatButtonHash;
	private static readonly int s_ToggleHash;
	private static readonly int s_ButtonGridHash;
	private static readonly int s_SliderHash;
	private static readonly int s_BeginGroupHash;
	private static readonly int s_ScrollviewHash;
	private static DateTime <nextScrollStepTime>k__BackingField;
	private static GUISkin s_Skin;
	private static readonly GenericStack s_ScrollViewStates;

	// Properties
	public static void changed { set; }
	internal static void nextScrollStepTime { set; }
	public static GUISkin skin { get; set; }

	// Methods
	private static void .cctor();
	public static void set_changed(bool value);
	internal static void set_nextScrollStepTime(DateTime value);
	public static void set_skin(GUISkin value);
	public static GUISkin get_skin();
	internal static void DoSetSkin(GUISkin newSkin);
	internal static void CallWindowDelegate(GUI.WindowFunction func, int id, int instanceID, GUISkin _skin, int forceRect, float width, float height, GUIStyle style);

}
//NameSpace:
public sealed class GUI.WindowFunction : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(int id);
	public virtual IAsyncResult BeginInvoke(int id, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine
public class GUIContent
{
	// Fields
	private string m_Text;
	private Texture m_Image;
	private string m_Tooltip;
	private static readonly GUIContent s_Text;
	private static readonly GUIContent s_Image;
	private static readonly GUIContent s_TextImage;
	public static GUIContent none;

	// Properties
	public void text { set; }
	public void image { set; }
	public void tooltip { set; }

	// Methods
	public void .ctor();
	public void .ctor(string text);
	public void .ctor(string text, Texture image, string tooltip);
	public void set_text(string value);
	public void set_image(Texture value);
	public void set_tooltip(string value);
	internal static void ClearStaticCache();
	private static void .cctor();

}
//NameSpace:UnityEngine
public class GUILayout
{
	// Methods
	public static GUILayoutOption Width(float width);
	public static GUILayoutOption Height(float height);

}
//NameSpace:UnityEngine
public sealed class GUILayoutOption
{
	// Fields
	internal GUILayoutOption.Type type;
	internal object value;

	// Methods
	internal void .ctor(GUILayoutOption.Type type, object value);

}
//NameSpace:
internal enum GUILayoutOption.Type
{
	// Fields
	public int value__;
	public const GUILayoutOption.Type fixedWidth;
	public const GUILayoutOption.Type fixedHeight;
	public const GUILayoutOption.Type minWidth;
	public const GUILayoutOption.Type maxWidth;
	public const GUILayoutOption.Type minHeight;
	public const GUILayoutOption.Type maxHeight;
	public const GUILayoutOption.Type stretchWidth;
	public const GUILayoutOption.Type stretchHeight;
	public const GUILayoutOption.Type alignStart;
	public const GUILayoutOption.Type alignMiddle;
	public const GUILayoutOption.Type alignEnd;
	public const GUILayoutOption.Type alignJustify;
	public const GUILayoutOption.Type equalSize;
	public const GUILayoutOption.Type spacing;

}
//NameSpace:UnityEngine
public class GUILayoutUtility
{
	// Fields
	private static readonly Dictionary`2<intGUILayoutUtility.LayoutCache> s_StoredLayouts;
	private static readonly Dictionary`2<intGUILayoutUtility.LayoutCache> s_StoredWindows;
	internal static GUILayoutUtility.LayoutCache current;
	internal static readonly Rect kDummyRect;

	// Methods
	private static Rect Internal_GetWindowRect(int windowID);
	private static void Internal_MoveWindow(int windowID, Rect r);
	internal static GUILayoutUtility.LayoutCache SelectIDList(int instanceID, bool isWindow);
	internal static void Begin(int instanceID);
	internal static void BeginWindow(int windowID, GUIStyle style, GUILayoutOption[] options);
	internal static void Layout();
	internal static void LayoutFromEditorWindow();
	internal static void LayoutFreeGroup(GUILayoutGroup toplevel);
	private static void LayoutSingleGroup(GUILayoutGroup i);
	private static void .cctor();
	private static void Internal_GetWindowRect_Injected(int windowID, out Rect ret);
	private static void Internal_MoveWindow_Injected(int windowID, Rect r);

}
//NameSpace:
internal sealed class GUILayoutUtility.LayoutCache
{
	// Fields
	internal GUILayoutGroup topLevel;
	internal GenericStack layoutGroups;
	internal GUILayoutGroup windows;

	// Methods
	internal void .ctor();

}
//NameSpace:UnityEngine
public sealed class GUISettings
{
	// Fields
	private bool m_DoubleClickSelectsWord;
	private bool m_TripleClickSelectsLine;
	private Color m_CursorColor;
	private float m_CursorFlashSpeed;
	private Color m_SelectionColor;

	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine
public sealed class GUISkin : ScriptableObject
{
	// Fields
	private Font m_Font;
	private GUIStyle m_box;
	private GUIStyle m_button;
	private GUIStyle m_toggle;
	private GUIStyle m_label;
	private GUIStyle m_textField;
	private GUIStyle m_textArea;
	private GUIStyle m_window;
	private GUIStyle m_horizontalSlider;
	private GUIStyle m_horizontalSliderThumb;
	private GUIStyle m_verticalSlider;
	private GUIStyle m_verticalSliderThumb;
	private GUIStyle m_horizontalScrollbar;
	private GUIStyle m_horizontalScrollbarThumb;
	private GUIStyle m_horizontalScrollbarLeftButton;
	private GUIStyle m_horizontalScrollbarRightButton;
	private GUIStyle m_verticalScrollbar;
	private GUIStyle m_verticalScrollbarThumb;
	private GUIStyle m_verticalScrollbarUpButton;
	private GUIStyle m_verticalScrollbarDownButton;
	private GUIStyle m_ScrollView;
	internal GUIStyle[] m_CustomStyles;
	private GUISettings m_Settings;
	internal static GUIStyle ms_Error;
	private Dictionary`2<stringGUIStyle> m_Styles;
	internal static GUISkin.SkinChangedDelegate m_SkinChanged;
	internal static GUISkin current;

	// Properties
	public Font font { get; set; }
	public GUIStyle box { get; set; }
	public GUIStyle label { get; set; }
	public GUIStyle textField { get; set; }
	public GUIStyle textArea { get; set; }
	public GUIStyle button { get; set; }
	public GUIStyle toggle { get; set; }
	public GUIStyle window { get; set; }
	public GUIStyle horizontalSlider { get; set; }
	public GUIStyle horizontalSliderThumb { get; set; }
	public GUIStyle verticalSlider { get; set; }
	public GUIStyle verticalSliderThumb { get; set; }
	public GUIStyle horizontalScrollbar { get; set; }
	public GUIStyle horizontalScrollbarThumb { get; set; }
	public GUIStyle horizontalScrollbarLeftButton { get; set; }
	public GUIStyle horizontalScrollbarRightButton { get; set; }
	public GUIStyle verticalScrollbar { get; set; }
	public GUIStyle verticalScrollbarThumb { get; set; }
	public GUIStyle verticalScrollbarUpButton { get; set; }
	public GUIStyle verticalScrollbarDownButton { get; set; }
	public GUIStyle scrollView { get; set; }
	public GUIStyle[] customStyles { get; set; }
	public GUISettings settings { get; }
	internal static GUIStyle error { get; }

	// Methods
	public void .ctor();
	internal void OnEnable();
	internal static void CleanupRoots();
	public Font get_font();
	public void set_font(Font value);
	public GUIStyle get_box();
	public void set_box(GUIStyle value);
	public GUIStyle get_label();
	public void set_label(GUIStyle value);
	public GUIStyle get_textField();
	public void set_textField(GUIStyle value);
	public GUIStyle get_textArea();
	public void set_textArea(GUIStyle value);
	public GUIStyle get_button();
	public void set_button(GUIStyle value);
	public GUIStyle get_toggle();
	public void set_toggle(GUIStyle value);
	public GUIStyle get_window();
	public void set_window(GUIStyle value);
	public GUIStyle get_horizontalSlider();
	public void set_horizontalSlider(GUIStyle value);
	public GUIStyle get_horizontalSliderThumb();
	public void set_horizontalSliderThumb(GUIStyle value);
	public GUIStyle get_verticalSlider();
	public void set_verticalSlider(GUIStyle value);
	public GUIStyle get_verticalSliderThumb();
	public void set_verticalSliderThumb(GUIStyle value);
	public GUIStyle get_horizontalScrollbar();
	public void set_horizontalScrollbar(GUIStyle value);
	public GUIStyle get_horizontalScrollbarThumb();
	public void set_horizontalScrollbarThumb(GUIStyle value);
	public GUIStyle get_horizontalScrollbarLeftButton();
	public void set_horizontalScrollbarLeftButton(GUIStyle value);
	public GUIStyle get_horizontalScrollbarRightButton();
	public void set_horizontalScrollbarRightButton(GUIStyle value);
	public GUIStyle get_verticalScrollbar();
	public void set_verticalScrollbar(GUIStyle value);
	public GUIStyle get_verticalScrollbarThumb();
	public void set_verticalScrollbarThumb(GUIStyle value);
	public GUIStyle get_verticalScrollbarUpButton();
	public void set_verticalScrollbarUpButton(GUIStyle value);
	public GUIStyle get_verticalScrollbarDownButton();
	public void set_verticalScrollbarDownButton(GUIStyle value);
	public GUIStyle get_scrollView();
	public void set_scrollView(GUIStyle value);
	public GUIStyle[] get_customStyles();
	public void set_customStyles(GUIStyle[] value);
	public GUISettings get_settings();
	internal static GUIStyle get_error();
	internal void Apply();
	private void BuildStyleCache();
	public GUIStyle GetStyle(string styleName);
	public GUIStyle FindStyle(string styleName);
	internal void MakeCurrent();
	public IEnumerator GetEnumerator();

}
//NameSpace:
internal sealed class GUISkin.SkinChangedDelegate : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke();
	public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine
public sealed class GUIStyleState
{
	// Fields
	internal IntPtr m_Ptr;
	private readonly GUIStyle m_SourceStyle;

	// Properties
	public void textColor { set; }

	// Methods
	public void .ctor();
	private void .ctor(GUIStyle sourceStyle, IntPtr source);
	public void set_textColor(Color value);
	private static IntPtr Init();
	private void Cleanup();
	internal static GUIStyleState GetGUIStyleState(GUIStyle sourceStyle, IntPtr source);
	protected override void Finalize();
	private void set_textColor_Injected(Color value);

}
//NameSpace:UnityEngine
public sealed class GUIStyle
{
	// Fields
	internal IntPtr m_Ptr;
	private GUIStyleState m_Normal;
	private GUIStyleState m_Hover;
	private GUIStyleState m_Active;
	private GUIStyleState m_Focused;
	private GUIStyleState m_OnNormal;
	private GUIStyleState m_OnHover;
	private GUIStyleState m_OnActive;
	private GUIStyleState m_OnFocused;
	private RectOffset m_Border;
	private RectOffset m_Padding;
	private RectOffset m_Margin;
	private RectOffset m_Overflow;
	internal static bool showKeyboardFocus;
	private static GUIStyle s_None;

	// Properties
	public string name { get; set; }
	public float fixedWidth { get; }
	public float fixedHeight { get; }
	public bool stretchWidth { get; }
	public bool stretchHeight { get; set; }
	public GUIStyleState normal { get; }
	public RectOffset margin { get; }
	public RectOffset padding { get; }
	public static GUIStyle none { get; }

	// Methods
	public void .ctor();
	public string get_name();
	public void set_name(string value);
	public float get_fixedWidth();
	public float get_fixedHeight();
	public bool get_stretchWidth();
	public bool get_stretchHeight();
	public void set_stretchHeight(bool value);
	private static IntPtr Internal_Create(GUIStyle self);
	private static void Internal_Destroy(IntPtr self);
	private IntPtr GetStyleStatePtr(int idx);
	private IntPtr GetRectOffsetPtr(int idx);
	internal static void SetDefaultFont(Font font);
	protected override void Finalize();
	public GUIStyleState get_normal();
	public RectOffset get_margin();
	public RectOffset get_padding();
	public static GUIStyle get_none();
	public override string ToString();
	private static void .cctor();

}
//NameSpace:UnityEngine
public class GUITargetAttribute : Attribute
{
	// Fields
	internal int displayMask;

	// Methods
	private static int GetGUITargetAttrValue(Type klass, string methodName);

}
//NameSpace:UnityEngine
public class GUIUtility
{
	// Fields
	internal static int s_SkinMode;
	internal static int s_OriginalID;
	internal static Action takeCapture;
	internal static Action releaseCapture;
	internal static Func`3<intIntPtrbool> processEvent;
	internal static Func`2<Exceptionbool> endContainerGUIFromException;
	internal static Action enabledStateChanged;
	private static bool <guiIsExiting>k__BackingField;

	// Properties
	internal static float pixelsPerPoint { get; }
	internal static int guiDepth { get; }
	public static string systemCopyBuffer { get; set; }
	internal static void guiIsExiting { set; }

	// Methods
	internal static float get_pixelsPerPoint();
	internal static int get_guiDepth();
	public static string get_systemCopyBuffer();
	public static void set_systemCopyBuffer(string value);
	private static object Internal_GetDefaultSkin(int skinMode);
	private static void Internal_ExitGUI();
	private static void MarkGUIChanged();
	internal static void set_guiIsExiting(bool value);
	internal static void TakeCapture();
	internal static void RemoveCapture();
	internal static GUISkin GetDefaultSkin();
	internal static bool ProcessEvent(int instanceID, IntPtr nativeEventPtr);
	internal static void BeginGUI(int skinMode, int instanceID, int useGUILayout);
	internal static void EndGUI(int layoutType);
	internal static bool EndGUIFromException(Exception exception);
	internal static bool EndContainerGUIFromException(Exception exception);
	internal static void ResetGlobalState();
	internal static bool IsExitGUIException(Exception exception);
	internal static bool ShouldRethrowException(Exception exception);
	internal static void CheckOnGUI();

}
//NameSpace:UnityEngine
public sealed class ExitGUIException : Exception
{
}
//NameSpace:UnityEngine
internal class GUILayoutEntry
{
	// Fields
	public float minWidth;
	public float maxWidth;
	public float minHeight;
	public float maxHeight;
	public Rect rect;
	public int stretchWidth;
	public int stretchHeight;
	public bool consideredForMargin;
	private GUIStyle m_Style;
	internal static Rect kDummyRect;
	protected static int indent;

	// Properties
	public GUIStyle style { get; set; }
	public virtual int marginLeft { get; }
	public virtual int marginRight { get; }
	public virtual int marginTop { get; }
	public virtual int marginBottom { get; }
	public int marginHorizontal { get; }
	public int marginVertical { get; }

	// Methods
	public void .ctor(float _minWidth, float _maxWidth, float _minHeight, float _maxHeight, GUIStyle _style);
	public GUIStyle get_style();
	public void set_style(GUIStyle value);
	public virtual int get_marginLeft();
	public virtual int get_marginRight();
	public virtual int get_marginTop();
	public virtual int get_marginBottom();
	public int get_marginHorizontal();
	public int get_marginVertical();
	public virtual void CalcWidth();
	public virtual void CalcHeight();
	public virtual void SetHorizontal(float x, float width);
	public virtual void SetVertical(float y, float height);
	protected virtual void ApplyStyleSettings(GUIStyle style);
	public virtual void ApplyOptions(GUILayoutOption[] options);
	public override string ToString();
	private static void .cctor();

}
//NameSpace:UnityEngine
internal class GUILayoutGroup : GUILayoutEntry
{
	// Fields
	public List`1<GUILayoutEntry> entries;
	public bool isVertical;
	public bool resetCoords;
	public float spacing;
	public bool sameSize;
	public bool isWindow;
	public int windowID;
	private int m_Cursor;
	protected int m_StretchableCountX;
	protected int m_StretchableCountY;
	protected bool m_UserSpecifiedWidth;
	protected bool m_UserSpecifiedHeight;
	protected float m_ChildMinWidth;
	protected float m_ChildMaxWidth;
	protected float m_ChildMinHeight;
	protected float m_ChildMaxHeight;
	protected int m_MarginLeft;
	protected int m_MarginRight;
	protected int m_MarginTop;
	protected int m_MarginBottom;

	// Properties
	public override int marginLeft { get; }
	public override int marginRight { get; }
	public override int marginTop { get; }
	public override int marginBottom { get; }

	// Methods
	public void .ctor();
	public override int get_marginLeft();
	public override int get_marginRight();
	public override int get_marginTop();
	public override int get_marginBottom();
	public override void ApplyOptions(GUILayoutOption[] options);
	protected override void ApplyStyleSettings(GUIStyle style);
	public void ResetCursor();
	public override void CalcWidth();
	public override void SetHorizontal(float x, float width);
	public override void CalcHeight();
	public override void SetVertical(float y, float height);
	public override string ToString();

}
//NameSpace:UnityEngine
internal sealed class GUIScrollGroup : GUILayoutGroup
{
	// Fields
	public float calcMinWidth;
	public float calcMaxWidth;
	public float calcMinHeight;
	public float calcMaxHeight;
	public float clientWidth;
	public float clientHeight;
	public bool allowHorizontalScroll;
	public bool allowVerticalScroll;
	public bool needsHorizontalScrollbar;
	public bool needsVerticalScrollbar;
	public GUIStyle horizontalScrollbar;
	public GUIStyle verticalScrollbar;

	// Methods
	public void .ctor();
	public override void CalcWidth();
	public override void SetHorizontal(float x, float width);
	public override void CalcHeight();
	public override void SetVertical(float y, float height);

}
//NameSpace:UnityEngine
internal class ScrollViewState
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine
internal class SliderState
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine
public class TextEditor
{
	// Fields
	public TouchScreenKeyboard keyboardOnScreen;
	public int controlID;
	public GUIStyle style;
	public bool multiline;
	public bool hasHorizontalCursorPos;
	public bool isPasswordField;
	public Vector2 scrollOffset;
	private GUIContent m_Content;
	private int m_CursorIndex;
	private int m_SelectIndex;
	private bool m_RevealCursor;
	private bool m_MouseDragSelectsWholeWords;
	private int m_DblClickInitPos;
	private TextEditor.DblClickSnapping m_DblClickSnap;
	private bool m_bJustSelected;
	private int m_iAltCursorPos;

	// Methods
	public void .ctor();

}
//NameSpace:
public enum TextEditor.DblClickSnapping
{
	// Fields
	public byte value__;
	public const TextEditor.DblClickSnapping WORDS;
	public const TextEditor.DblClickSnapping PARAGRAPHS;

}
//NameSpace:
internal class <Module>
{
}
//NameSpace:UnityEngine
public class Physics2D
{
	// Fields
	private static List`1<Rigidbody2D> m_LastDisabledRigidbody2D;

	// Methods
	private static void .cctor();

}
//NameSpace:UnityEngine
public struct RaycastHit2D
{
	// Fields
	private Vector2 m_Centroid;
	private Vector2 m_Point;
	private Vector2 m_Normal;
	private float m_Distance;
	private float m_Fraction;
	private int m_Collider;

	// Properties
	public Vector2 point { get; }
	public Vector2 normal { get; }
	public float distance { get; }
	public Collider2D collider { get; }

	// Methods
	public Vector2 get_point();
	public Vector2 get_normal();
	public float get_distance();
	public Collider2D get_collider();

}
//NameSpace:UnityEngine
public sealed class Rigidbody2D : Component
{
}
//NameSpace:UnityEngine
public class Collider2D : Behaviour
{
}
//NameSpace:
internal class <Module>
{
}
//NameSpace:UnityEngine
public struct RaycastHit
{
	// Fields
	internal Vector3 m_Point;
	internal Vector3 m_Normal;
	internal uint m_FaceID;
	internal float m_Distance;
	internal Vector2 m_UV;
	internal int m_Collider;

	// Properties
	public Collider collider { get; }
	public Vector3 point { get; }
	public Vector3 normal { get; }
	public float distance { get; }

	// Methods
	public Collider get_collider();
	public Vector3 get_point();
	public Vector3 get_normal();
	public float get_distance();

}
//NameSpace:UnityEngine
public class Collider : Component
{
}
//NameSpace:UnityEngine
public class Physics
{
}
//NameSpace:
internal class <Module>
{
}
//NameSpace:UnityEngine
public enum RenderMode
{
	// Fields
	public int value__;
	public const RenderMode ScreenSpaceOverlay;
	public const RenderMode ScreenSpaceCamera;
	public const RenderMode WorldSpace;

}
//NameSpace:UnityEngine
public sealed class Canvas : Behaviour
{
	// Fields
	private static Canvas.WillRenderCanvases willRenderCanvases;

	// Properties
	public RenderMode renderMode { get; }
	public bool isRootCanvas { get; }
	public float scaleFactor { get; set; }
	public float referencePixelsPerUnit { get; set; }
	public bool pixelPerfect { get; }
	public int renderOrder { get; }
	public bool overrideSorting { get; set; }
	public int sortingOrder { get; set; }
	public int targetDisplay { get; }
	public int sortingLayerID { get; set; }
	public Canvas rootCanvas { get; }
	public Camera worldCamera { get; }

	// Methods
	public void .ctor();
	public static void add_willRenderCanvases(Canvas.WillRenderCanvases value);
	public static void remove_willRenderCanvases(Canvas.WillRenderCanvases value);
	public RenderMode get_renderMode();
	public bool get_isRootCanvas();
	public float get_scaleFactor();
	public void set_scaleFactor(float value);
	public float get_referencePixelsPerUnit();
	public void set_referencePixelsPerUnit(float value);
	public bool get_pixelPerfect();
	public int get_renderOrder();
	public bool get_overrideSorting();
	public void set_overrideSorting(bool value);
	public int get_sortingOrder();
	public void set_sortingOrder(int value);
	public int get_targetDisplay();
	public int get_sortingLayerID();
	public void set_sortingLayerID(int value);
	public Canvas get_rootCanvas();
	public Camera get_worldCamera();
	public static Material GetDefaultCanvasMaterial();
	public static Material GetETC1SupportedCanvasMaterial();
	public static void ForceUpdateCanvases();
	private static void SendWillRenderCanvases();

}
//NameSpace:
public sealed class Canvas.WillRenderCanvases : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke();
	public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine
public static class UISystemProfilerApi
{
	// Methods
	public static void BeginSample(UISystemProfilerApi.SampleType type);
	public static void EndSample(UISystemProfilerApi.SampleType type);
	public static void AddMarker(string name, Object obj);

}
//NameSpace:
public enum UISystemProfilerApi.SampleType
{
	// Fields
	public int value__;
	public const UISystemProfilerApi.SampleType Layout;
	public const UISystemProfilerApi.SampleType Render;

}
//NameSpace:UnityEngine
public interface ICanvasRaycastFilter
{
	// Methods
	public abstract bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera);

}
//NameSpace:UnityEngine
public sealed class CanvasGroup : Behaviour, ICanvasRaycastFilter
{
	// Properties
	public float alpha { get; set; }
	public bool interactable { get; }
	public bool blocksRaycasts { get; }
	public bool ignoreParentGroups { get; }

	// Methods
	public float get_alpha();
	public void set_alpha(float value);
	public bool get_interactable();
	public bool get_blocksRaycasts();
	public bool get_ignoreParentGroups();
	public bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera);

}
//NameSpace:UnityEngine
public sealed class CanvasRenderer : Component
{
	// Fields
	private bool <isMask>k__BackingField;

	// Properties
	public void hasPopInstruction { set; }
	public int materialCount { get; set; }
	public void popMaterialCount { set; }
	public int absoluteDepth { get; }
	public bool hasMoved { get; }
	public bool cull { get; set; }

	// Methods
	public void set_hasPopInstruction(bool value);
	public int get_materialCount();
	public void set_materialCount(int value);
	public void set_popMaterialCount(int value);
	public int get_absoluteDepth();
	public bool get_hasMoved();
	public bool get_cull();
	public void set_cull(bool value);
	public void SetColor(Color color);
	public Color GetColor();
	public void EnableRectClipping(Rect rect);
	public void DisableRectClipping();
	public void SetMaterial(Material material, int index);
	public void SetPopMaterial(Material material, int index);
	public void SetTexture(Texture texture);
	public void SetAlphaTexture(Texture texture);
	public void SetMesh(Mesh mesh);
	public void Clear();
	public void SetMaterial(Material material, Texture texture);
	public static void SplitUIVertexStreams(List`1<UIVertex> verts, List`1<Vector3> positions, List`1<Color32> colors, List`1<Vector2> uv0S, List`1<Vector2> uv1S, List`1<Vector2> uv2S, List`1<Vector2> uv3S, List`1<Vector3> normals, List`1<Vector4> tangents, List`1<int> indices);
	public static void CreateUIVertexStream(List`1<UIVertex> verts, List`1<Vector3> positions, List`1<Color32> colors, List`1<Vector2> uv0S, List`1<Vector2> uv1S, List`1<Vector2> uv2S, List`1<Vector2> uv3S, List`1<Vector3> normals, List`1<Vector4> tangents, List`1<int> indices);
	public static void AddUIVertexStream(List`1<UIVertex> verts, List`1<Vector3> positions, List`1<Color32> colors, List`1<Vector2> uv0S, List`1<Vector2> uv1S, List`1<Vector2> uv2S, List`1<Vector2> uv3S, List`1<Vector3> normals, List`1<Vector4> tangents);
	private static void SplitIndicesStreamsInternal(object verts, object indices);
	private static void SplitUIVertexStreamsInternal(object verts, object positions, object colors, object uv0S, object uv1S, object uv2S, object uv3S, object normals, object tangents);
	private static void CreateUIVertexStreamInternal(object verts, object positions, object colors, object uv0S, object uv1S, object uv2S, object uv3S, object normals, object tangents, object indices);
	private void SetColor_Injected(Color color);
	private void GetColor_Injected(out Color ret);
	private void EnableRectClipping_Injected(Rect rect);

}
//NameSpace:UnityEngine
public sealed class RectTransformUtility
{
	// Fields
	private static readonly Vector3[] s_Corners;

	// Methods
	public static bool RectangleContainsScreenPoint(RectTransform rect, Vector2 screenPoint, Camera cam);
	public static bool ScreenPointToWorldPointInRectangle(RectTransform rect, Vector2 screenPoint, Camera cam, out Vector3 worldPoint);
	public static bool ScreenPointToLocalPointInRectangle(RectTransform rect, Vector2 screenPoint, Camera cam, out Vector2 localPoint);
	public static Ray ScreenPointToRay(Camera cam, Vector2 screenPos);
	public static void FlipLayoutOnAxis(RectTransform rect, int axis, bool keepPositioning, bool recursive);
	public static void FlipLayoutAxes(RectTransform rect, bool keepPositioning, bool recursive);
	private static Vector2 GetTransposed(Vector2 input);
	public static Vector2 PixelAdjustPoint(Vector2 point, Transform elementTransform, Canvas canvas);
	public static Rect PixelAdjustRect(RectTransform rectTransform, Canvas canvas);
	private static bool PointInRectangle(Vector2 screenPoint, RectTransform rect, Camera cam);
	private static void .cctor();
	private static void PixelAdjustPoint_Injected(Vector2 point, Transform elementTransform, Canvas canvas, out Vector2 ret);
	private static void PixelAdjustRect_Injected(RectTransform rectTransform, Canvas canvas, out Rect ret);
	private static bool PointInRectangle_Injected(Vector2 screenPoint, RectTransform rect, Camera cam);

}
//NameSpace:
internal class <Module>
{
}
//NameSpace:UnityEngine.Analytics
internal class ContinuousEvent
{
}
//NameSpace:UnityEngine.Analytics
public enum AnalyticsSessionState
{
	// Fields
	public int value__;
	public const AnalyticsSessionState kSessionStopped;
	public const AnalyticsSessionState kSessionStarted;
	public const AnalyticsSessionState kSessionPaused;
	public const AnalyticsSessionState kSessionResumed;

}
//NameSpace:UnityEngine.Analytics
public static class AnalyticsSessionInfo
{
	// Fields
	private static AnalyticsSessionInfo.SessionStateChanged sessionStateChanged;

	// Methods
	internal static void CallSessionStateChanged(AnalyticsSessionState sessionState, long sessionId, long sessionElapsedTime, bool sessionChanged);

}
//NameSpace:
public sealed class AnalyticsSessionInfo.SessionStateChanged : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(AnalyticsSessionState sessionState, long sessionId, long sessionElapsedTime, bool sessionChanged);
	public virtual IAsyncResult BeginInvoke(AnalyticsSessionState sessionState, long sessionId, long sessionElapsedTime, bool sessionChanged, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine
public static class RemoteSettings
{
	// Fields
	private static RemoteSettings.UpdatedEventHandler Updated;
	private static Action BeforeFetchFromServer;
	private static Action`3<boolboolint> Completed;

	// Methods
	internal static void RemoteSettingsUpdated(bool wasLastUpdatedFromServer);
	internal static void RemoteSettingsBeforeFetchFromServer();
	internal static void RemoteSettingsUpdateCompleted(bool wasLastUpdatedFromServer, bool settingsChanged, int response);

}
//NameSpace:
public sealed class RemoteSettings.UpdatedEventHandler : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke();
	public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine
public class RemoteConfigSettings : IDisposable
{
	// Fields
	internal IntPtr m_Ptr;
	private Action`1<bool> Updated;

	// Methods
	protected override void Finalize();
	private void Destroy();
	public void Dispose();
	internal static void Internal_Destroy(IntPtr ptr);
	internal static void RemoteConfigSettingsUpdated(RemoteConfigSettings rcs, bool wasLastUpdatedFromServer);

}
//NameSpace:
internal class <Module>
{
}
//NameSpace:UnityEngineInternal
internal static class WebRequestUtils
{
	// Fields
	private static Regex domainRegex;

	// Methods
	internal static string RedirectTo(string baseUri, string redirectUri);
	private static void .cctor();

}
//NameSpace:UnityEngine.Networking
public class CertificateHandler : IDisposable
{
	// Fields
	internal IntPtr m_Ptr;

	// Methods
	private void Release();
	protected override void Finalize();
	protected virtual bool ValidateCertificate(byte[] certificateData);
	internal bool ValidateCertificateNative(byte[] certificateData);
	public void Dispose();

}
//NameSpace:
internal class <Module>
{
}
//NameSpace:
internal class <Module>
{
}
//NameSpace:
internal class <Module>
{
}
//NameSpace:
internal class <Module>
{
}
//NameSpace:UnityEngine.EventSystems
public enum EventHandle
{
	// Fields
	public int value__;
	public const EventHandle Unused;
	public const EventHandle Used;

}
//NameSpace:UnityEngine.EventSystems
public interface IEventSystemHandler
{
}
//NameSpace:UnityEngine.EventSystems
public interface IPointerEnterHandler : IEventSystemHandler
{
	// Methods
	public abstract void OnPointerEnter(PointerEventData eventData);

}
//NameSpace:UnityEngine.EventSystems
public interface IPointerExitHandler : IEventSystemHandler
{
	// Methods
	public abstract void OnPointerExit(PointerEventData eventData);

}
//NameSpace:UnityEngine.EventSystems
public interface IPointerDownHandler : IEventSystemHandler
{
	// Methods
	public abstract void OnPointerDown(PointerEventData eventData);

}
//NameSpace:UnityEngine.EventSystems
public interface IPointerUpHandler : IEventSystemHandler
{
	// Methods
	public abstract void OnPointerUp(PointerEventData eventData);

}
//NameSpace:UnityEngine.EventSystems
public interface IPointerClickHandler : IEventSystemHandler
{
	// Methods
	public abstract void OnPointerClick(PointerEventData eventData);

}
//NameSpace:UnityEngine.EventSystems
public interface IBeginDragHandler : IEventSystemHandler
{
	// Methods
	public abstract void OnBeginDrag(PointerEventData eventData);

}
//NameSpace:UnityEngine.EventSystems
public interface IInitializePotentialDragHandler : IEventSystemHandler
{
	// Methods
	public abstract void OnInitializePotentialDrag(PointerEventData eventData);

}
//NameSpace:UnityEngine.EventSystems
public interface IDragHandler : IEventSystemHandler
{
	// Methods
	public abstract void OnDrag(PointerEventData eventData);

}
//NameSpace:UnityEngine.EventSystems
public interface IEndDragHandler : IEventSystemHandler
{
	// Methods
	public abstract void OnEndDrag(PointerEventData eventData);

}
//NameSpace:UnityEngine.EventSystems
public interface IDropHandler : IEventSystemHandler
{
	// Methods
	public abstract void OnDrop(PointerEventData eventData);

}
//NameSpace:UnityEngine.EventSystems
public interface IScrollHandler : IEventSystemHandler
{
	// Methods
	public abstract void OnScroll(PointerEventData eventData);

}
//NameSpace:UnityEngine.EventSystems
public interface IUpdateSelectedHandler : IEventSystemHandler
{
	// Methods
	public abstract void OnUpdateSelected(BaseEventData eventData);

}
//NameSpace:UnityEngine.EventSystems
public interface ISelectHandler : IEventSystemHandler
{
	// Methods
	public abstract void OnSelect(BaseEventData eventData);

}
//NameSpace:UnityEngine.EventSystems
public interface IDeselectHandler : IEventSystemHandler
{
	// Methods
	public abstract void OnDeselect(BaseEventData eventData);

}
//NameSpace:UnityEngine.EventSystems
public interface IMoveHandler : IEventSystemHandler
{
	// Methods
	public abstract void OnMove(AxisEventData eventData);

}
//NameSpace:UnityEngine.EventSystems
public interface ISubmitHandler : IEventSystemHandler
{
	// Methods
	public abstract void OnSubmit(BaseEventData eventData);

}
//NameSpace:UnityEngine.EventSystems
public interface ICancelHandler : IEventSystemHandler
{
	// Methods
	public abstract void OnCancel(BaseEventData eventData);

}
//NameSpace:UnityEngine.EventSystems
public class EventSystem : UIBehaviour
{
	// Fields
	private List`1<BaseInputModule> m_SystemInputModules;
	private BaseInputModule m_CurrentInputModule;
	private static List`1<EventSystem> m_EventSystems;
	private GameObject m_FirstSelected;
	private bool m_sendNavigationEvents;
	private int m_DragThreshold;
	private GameObject m_CurrentSelected;
	private bool m_HasFocus;
	private bool m_SelectionGuard;
	private BaseEventData m_DummyData;
	private static readonly Comparison`1<RaycastResult> s_RaycastComparer;
	private static Comparison`1<RaycastResult> <>f__mg$cache0;

	// Properties
	public static EventSystem current { get; set; }
	public bool sendNavigationEvents { get; set; }
	public int pixelDragThreshold { get; set; }
	public BaseInputModule currentInputModule { get; }
	public GameObject firstSelectedGameObject { get; set; }
	public GameObject currentSelectedGameObject { get; }
	public GameObject lastSelectedGameObject { get; }
	public bool isFocused { get; }
	public bool alreadySelecting { get; }
	private BaseEventData baseEventDataCache { get; }

	// Methods
	protected void .ctor();
	public static EventSystem get_current();
	public static void set_current(EventSystem value);
	public bool get_sendNavigationEvents();
	public void set_sendNavigationEvents(bool value);
	public int get_pixelDragThreshold();
	public void set_pixelDragThreshold(int value);
	public BaseInputModule get_currentInputModule();
	public GameObject get_firstSelectedGameObject();
	public void set_firstSelectedGameObject(GameObject value);
	public GameObject get_currentSelectedGameObject();
	public GameObject get_lastSelectedGameObject();
	public bool get_isFocused();
	public void UpdateModules();
	public bool get_alreadySelecting();
	public void SetSelectedGameObject(GameObject selected, BaseEventData pointer);
	private BaseEventData get_baseEventDataCache();
	public void SetSelectedGameObject(GameObject selected);
	private static int RaycastComparer(RaycastResult lhs, RaycastResult rhs);
	public void RaycastAll(PointerEventData eventData, List`1<RaycastResult> raycastResults);
	public bool IsPointerOverGameObject();
	public bool IsPointerOverGameObject(int pointerId);
	protected override void OnEnable();
	protected override void OnDisable();
	private void TickModules();
	protected virtual void OnApplicationFocus(bool hasFocus);
	protected virtual void Update();
	private void ChangeEventModule(BaseInputModule module);
	public override string ToString();
	private static void .cctor();

}
//NameSpace:UnityEngine.EventSystems
public class EventTrigger : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerDownHandler, IPointerUpHandler, IPointerClickHandler, IInitializePotentialDragHandler, IBeginDragHandler, IDragHandler, IEndDragHandler, IDropHandler, IScrollHandler, IUpdateSelectedHandler, ISelectHandler, IDeselectHandler, IMoveHandler, ISubmitHandler, ICancelHandler, IEventSystemHandler
{
	// Fields
	private List`1<EventTrigger.Entry> m_Delegates;
	public List`1<EventTrigger.Entry> delegates;

	// Properties
	public List`1<EventTrigger.Entry> triggers { get; set; }

	// Methods
	protected void .ctor();
	public List`1<EventTrigger.Entry> get_triggers();
	public void set_triggers(List`1<EventTrigger.Entry> value);
	private void Execute(EventTriggerType id, BaseEventData eventData);
	public virtual void OnPointerEnter(PointerEventData eventData);
	public virtual void OnPointerExit(PointerEventData eventData);
	public virtual void OnDrag(PointerEventData eventData);
	public virtual void OnDrop(PointerEventData eventData);
	public virtual void OnPointerDown(PointerEventData eventData);
	public virtual void OnPointerUp(PointerEventData eventData);
	public virtual void OnPointerClick(PointerEventData eventData);
	public virtual void OnSelect(BaseEventData eventData);
	public virtual void OnDeselect(BaseEventData eventData);
	public virtual void OnScroll(PointerEventData eventData);
	public virtual void OnMove(AxisEventData eventData);
	public virtual void OnUpdateSelected(BaseEventData eventData);
	public virtual void OnInitializePotentialDrag(PointerEventData eventData);
	public virtual void OnBeginDrag(PointerEventData eventData);
	public virtual void OnEndDrag(PointerEventData eventData);
	public virtual void OnSubmit(BaseEventData eventData);
	public virtual void OnCancel(BaseEventData eventData);

}
//NameSpace:
public class EventTrigger.TriggerEvent : UnityEvent`1<BaseEventData>
{
	// Methods
	public void .ctor();

}
//NameSpace:
public class EventTrigger.Entry
{
	// Fields
	public EventTriggerType eventID;
	public EventTrigger.TriggerEvent callback;

	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine.EventSystems
public enum EventTriggerType
{
	// Fields
	public int value__;
	public const EventTriggerType PointerEnter;
	public const EventTriggerType PointerExit;
	public const EventTriggerType PointerDown;
	public const EventTriggerType PointerUp;
	public const EventTriggerType PointerClick;
	public const EventTriggerType Drag;
	public const EventTriggerType Drop;
	public const EventTriggerType Scroll;
	public const EventTriggerType UpdateSelected;
	public const EventTriggerType Select;
	public const EventTriggerType Deselect;
	public const EventTriggerType Move;
	public const EventTriggerType InitializePotentialDrag;
	public const EventTriggerType BeginDrag;
	public const EventTriggerType EndDrag;
	public const EventTriggerType Submit;
	public const EventTriggerType Cancel;

}
//NameSpace:UnityEngine.EventSystems
public static class ExecuteEvents
{
	// Fields
	private static readonly EventFunction`1<IPointerEnterHandler> s_PointerEnterHandler;
	private static readonly EventFunction`1<IPointerExitHandler> s_PointerExitHandler;
	private static readonly EventFunction`1<IPointerDownHandler> s_PointerDownHandler;
	private static readonly EventFunction`1<IPointerUpHandler> s_PointerUpHandler;
	private static readonly EventFunction`1<IPointerClickHandler> s_PointerClickHandler;
	private static readonly EventFunction`1<IInitializePotentialDragHandler> s_InitializePotentialDragHandler;
	private static readonly EventFunction`1<IBeginDragHandler> s_BeginDragHandler;
	private static readonly EventFunction`1<IDragHandler> s_DragHandler;
	private static readonly EventFunction`1<IEndDragHandler> s_EndDragHandler;
	private static readonly EventFunction`1<IDropHandler> s_DropHandler;
	private static readonly EventFunction`1<IScrollHandler> s_ScrollHandler;
	private static readonly EventFunction`1<IUpdateSelectedHandler> s_UpdateSelectedHandler;
	private static readonly EventFunction`1<ISelectHandler> s_SelectHandler;
	private static readonly EventFunction`1<IDeselectHandler> s_DeselectHandler;
	private static readonly EventFunction`1<IMoveHandler> s_MoveHandler;
	private static readonly EventFunction`1<ISubmitHandler> s_SubmitHandler;
	private static readonly EventFunction`1<ICancelHandler> s_CancelHandler;
	private static readonly ObjectPool`1<List`1<IEventSystemHandler>> s_HandlerListPool;
	private static readonly List`1<Transform> s_InternalTransformList;
	private static EventFunction`1<IPointerEnterHandler> <>f__mg$cache0;
	private static EventFunction`1<IPointerExitHandler> <>f__mg$cache1;
	private static EventFunction`1<IPointerDownHandler> <>f__mg$cache2;
	private static EventFunction`1<IPointerUpHandler> <>f__mg$cache3;
	private static EventFunction`1<IPointerClickHandler> <>f__mg$cache4;
	private static EventFunction`1<IInitializePotentialDragHandler> <>f__mg$cache5;
	private static EventFunction`1<IBeginDragHandler> <>f__mg$cache6;
	private static EventFunction`1<IDragHandler> <>f__mg$cache7;
	private static EventFunction`1<IEndDragHandler> <>f__mg$cache8;
	private static EventFunction`1<IDropHandler> <>f__mg$cache9;
	private static EventFunction`1<IScrollHandler> <>f__mg$cacheA;
	private static EventFunction`1<IUpdateSelectedHandler> <>f__mg$cacheB;
	private static EventFunction`1<ISelectHandler> <>f__mg$cacheC;
	private static EventFunction`1<IDeselectHandler> <>f__mg$cacheD;
	private static EventFunction`1<IMoveHandler> <>f__mg$cacheE;
	private static EventFunction`1<ISubmitHandler> <>f__mg$cacheF;
	private static EventFunction`1<ICancelHandler> <>f__mg$cache10;

	// Properties
	public static EventFunction`1<IPointerEnterHandler> pointerEnterHandler { get; }
	public static EventFunction`1<IPointerExitHandler> pointerExitHandler { get; }
	public static EventFunction`1<IPointerDownHandler> pointerDownHandler { get; }
	public static EventFunction`1<IPointerUpHandler> pointerUpHandler { get; }
	public static EventFunction`1<IPointerClickHandler> pointerClickHandler { get; }
	public static EventFunction`1<IInitializePotentialDragHandler> initializePotentialDrag { get; }
	public static EventFunction`1<IBeginDragHandler> beginDragHandler { get; }
	public static EventFunction`1<IDragHandler> dragHandler { get; }
	public static EventFunction`1<IEndDragHandler> endDragHandler { get; }
	public static EventFunction`1<IDropHandler> dropHandler { get; }
	public static EventFunction`1<IScrollHandler> scrollHandler { get; }
	public static EventFunction`1<IUpdateSelectedHandler> updateSelectedHandler { get; }
	public static EventFunction`1<ISelectHandler> selectHandler { get; }
	public static EventFunction`1<IDeselectHandler> deselectHandler { get; }
	public static EventFunction`1<IMoveHandler> moveHandler { get; }
	public static EventFunction`1<ISubmitHandler> submitHandler { get; }
	public static EventFunction`1<ICancelHandler> cancelHandler { get; }

	// Methods
	public static T ValidateEventData(BaseEventData data);
	private static void Execute(IPointerEnterHandler handler, BaseEventData eventData);
	private static void Execute(IPointerExitHandler handler, BaseEventData eventData);
	private static void Execute(IPointerDownHandler handler, BaseEventData eventData);
	private static void Execute(IPointerUpHandler handler, BaseEventData eventData);
	private static void Execute(IPointerClickHandler handler, BaseEventData eventData);
	private static void Execute(IInitializePotentialDragHandler handler, BaseEventData eventData);
	private static void Execute(IBeginDragHandler handler, BaseEventData eventData);
	private static void Execute(IDragHandler handler, BaseEventData eventData);
	private static void Execute(IEndDragHandler handler, BaseEventData eventData);
	private static void Execute(IDropHandler handler, BaseEventData eventData);
	private static void Execute(IScrollHandler handler, BaseEventData eventData);
	private static void Execute(IUpdateSelectedHandler handler, BaseEventData eventData);
	private static void Execute(ISelectHandler handler, BaseEventData eventData);
	private static void Execute(IDeselectHandler handler, BaseEventData eventData);
	private static void Execute(IMoveHandler handler, BaseEventData eventData);
	private static void Execute(ISubmitHandler handler, BaseEventData eventData);
	private static void Execute(ICancelHandler handler, BaseEventData eventData);
	public static EventFunction`1<IPointerEnterHandler> get_pointerEnterHandler();
	public static EventFunction`1<IPointerExitHandler> get_pointerExitHandler();
	public static EventFunction`1<IPointerDownHandler> get_pointerDownHandler();
	public static EventFunction`1<IPointerUpHandler> get_pointerUpHandler();
	public static EventFunction`1<IPointerClickHandler> get_pointerClickHandler();
	public static EventFunction`1<IInitializePotentialDragHandler> get_initializePotentialDrag();
	public static EventFunction`1<IBeginDragHandler> get_beginDragHandler();
	public static EventFunction`1<IDragHandler> get_dragHandler();
	public static EventFunction`1<IEndDragHandler> get_endDragHandler();
	public static EventFunction`1<IDropHandler> get_dropHandler();
	public static EventFunction`1<IScrollHandler> get_scrollHandler();
	public static EventFunction`1<IUpdateSelectedHandler> get_updateSelectedHandler();
	public static EventFunction`1<ISelectHandler> get_selectHandler();
	public static EventFunction`1<IDeselectHandler> get_deselectHandler();
	public static EventFunction`1<IMoveHandler> get_moveHandler();
	public static EventFunction`1<ISubmitHandler> get_submitHandler();
	public static EventFunction`1<ICancelHandler> get_cancelHandler();
	private static void GetEventChain(GameObject root, IList`1<Transform> eventChain);
	public static bool Execute(GameObject target, BaseEventData eventData, EventFunction`1<T> functor);
	public static GameObject ExecuteHierarchy(GameObject root, BaseEventData eventData, EventFunction`1<T> callbackFunction);
	private static bool ShouldSendToComponent(Component component);
	private static void GetEventList(GameObject go, IList`1<IEventSystemHandler> results);
	public static bool CanHandleEvent(GameObject go);
	public static GameObject GetEventHandler(GameObject root);
	private static void .cctor();
	private static void <s_HandlerListPool>m__0(List`1<IEventSystemHandler> l);

}
//NameSpace:
public sealed class ExecuteEvents.EventFunction`1 : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual void Invoke(T handler, BaseEventData eventData);
	public virtual IAsyncResult BeginInvoke(T handler, BaseEventData eventData, AsyncCallback callback, object object);
	public virtual void EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine.EventSystems
public enum MoveDirection
{
	// Fields
	public int value__;
	public const MoveDirection Left;
	public const MoveDirection Up;
	public const MoveDirection Right;
	public const MoveDirection Down;
	public const MoveDirection None;

}
//NameSpace:UnityEngine.EventSystems
public struct RaycastResult
{
	// Fields
	private GameObject m_GameObject;
	public BaseRaycaster module;
	public float distance;
	public float index;
	public int depth;
	public int sortingLayer;
	public int sortingOrder;
	public Vector3 worldPosition;
	public Vector3 worldNormal;
	public Vector2 screenPosition;

	// Properties
	public GameObject gameObject { get; set; }
	public bool isValid { get; }

	// Methods
	public GameObject get_gameObject();
	public void set_gameObject(GameObject value);
	public bool get_isValid();
	public void Clear();
	public override string ToString();

}
//NameSpace:UnityEngine.EventSystems
internal static class RaycasterManager
{
	// Fields
	private static readonly List`1<BaseRaycaster> s_Raycasters;

	// Methods
	public static void AddRaycaster(BaseRaycaster baseRaycaster);
	public static List`1<BaseRaycaster> GetRaycasters();
	public static void RemoveRaycasters(BaseRaycaster baseRaycaster);
	private static void .cctor();

}
//NameSpace:UnityEngine.EventSystems
public abstract class UIBehaviour : MonoBehaviour
{
	// Methods
	protected void .ctor();
	protected virtual void Awake();
	protected virtual void OnEnable();
	protected virtual void Start();
	protected virtual void OnDisable();
	protected virtual void OnDestroy();
	public virtual bool IsActive();
	protected virtual void OnRectTransformDimensionsChange();
	protected virtual void OnBeforeTransformParentChanged();
	protected virtual void OnTransformParentChanged();
	protected virtual void OnDidApplyAnimationProperties();
	protected virtual void OnCanvasGroupChanged();
	protected virtual void OnCanvasHierarchyChanged();
	public bool IsDestroyed();

}
//NameSpace:UnityEngine.EventSystems
public class AxisEventData : BaseEventData
{
	// Fields
	private Vector2 <moveVector>k__BackingField;
	private MoveDirection <moveDir>k__BackingField;

	// Properties
	public Vector2 moveVector { get; set; }
	public MoveDirection moveDir { get; set; }

	// Methods
	public void .ctor(EventSystem eventSystem);
	public Vector2 get_moveVector();
	public void set_moveVector(Vector2 value);
	public MoveDirection get_moveDir();
	public void set_moveDir(MoveDirection value);

}
//NameSpace:UnityEngine.EventSystems
public abstract class AbstractEventData
{
	// Fields
	protected bool m_Used;

	// Properties
	public virtual bool used { get; }

	// Methods
	protected void .ctor();
	public virtual void Reset();
	public virtual void Use();
	public virtual bool get_used();

}
//NameSpace:UnityEngine.EventSystems
public class BaseEventData : AbstractEventData
{
	// Fields
	private readonly EventSystem m_EventSystem;

	// Properties
	public BaseInputModule currentInputModule { get; }
	public GameObject selectedObject { get; set; }

	// Methods
	public void .ctor(EventSystem eventSystem);
	public BaseInputModule get_currentInputModule();
	public GameObject get_selectedObject();
	public void set_selectedObject(GameObject value);

}
//NameSpace:UnityEngine.EventSystems
public class PointerEventData : BaseEventData
{
	// Fields
	private GameObject <pointerEnter>k__BackingField;
	private GameObject m_PointerPress;
	private GameObject <lastPress>k__BackingField;
	private GameObject <rawPointerPress>k__BackingField;
	private GameObject <pointerDrag>k__BackingField;
	private RaycastResult <pointerCurrentRaycast>k__BackingField;
	private RaycastResult <pointerPressRaycast>k__BackingField;
	public List`1<GameObject> hovered;
	private bool <eligibleForClick>k__BackingField;
	private int <pointerId>k__BackingField;
	private Vector2 <position>k__BackingField;
	private Vector2 <delta>k__BackingField;
	private Vector2 <pressPosition>k__BackingField;
	private Vector3 <worldPosition>k__BackingField;
	private Vector3 <worldNormal>k__BackingField;
	private float <clickTime>k__BackingField;
	private int <clickCount>k__BackingField;
	private Vector2 <scrollDelta>k__BackingField;
	private bool <useDragThreshold>k__BackingField;
	private bool <dragging>k__BackingField;
	private PointerEventData.InputButton <button>k__BackingField;

	// Properties
	public GameObject pointerEnter { get; set; }
	public GameObject lastPress { get; set; }
	public GameObject rawPointerPress { get; set; }
	public GameObject pointerDrag { get; set; }
	public RaycastResult pointerCurrentRaycast { get; set; }
	public RaycastResult pointerPressRaycast { get; set; }
	public bool eligibleForClick { get; set; }
	public int pointerId { get; set; }
	public Vector2 position { get; set; }
	public Vector2 delta { get; set; }
	public Vector2 pressPosition { get; set; }
	public Vector3 worldPosition { get; set; }
	public Vector3 worldNormal { get; set; }
	public float clickTime { get; set; }
	public int clickCount { get; set; }
	public Vector2 scrollDelta { get; set; }
	public bool useDragThreshold { get; set; }
	public bool dragging { get; set; }
	public PointerEventData.InputButton button { get; set; }
	public Camera enterEventCamera { get; }
	public Camera pressEventCamera { get; }
	public GameObject pointerPress { get; set; }

	// Methods
	public void .ctor(EventSystem eventSystem);
	public GameObject get_pointerEnter();
	public void set_pointerEnter(GameObject value);
	public GameObject get_lastPress();
	private void set_lastPress(GameObject value);
	public GameObject get_rawPointerPress();
	public void set_rawPointerPress(GameObject value);
	public GameObject get_pointerDrag();
	public void set_pointerDrag(GameObject value);
	public RaycastResult get_pointerCurrentRaycast();
	public void set_pointerCurrentRaycast(RaycastResult value);
	public RaycastResult get_pointerPressRaycast();
	public void set_pointerPressRaycast(RaycastResult value);
	public bool get_eligibleForClick();
	public void set_eligibleForClick(bool value);
	public int get_pointerId();
	public void set_pointerId(int value);
	public Vector2 get_position();
	public void set_position(Vector2 value);
	public Vector2 get_delta();
	public void set_delta(Vector2 value);
	public Vector2 get_pressPosition();
	public void set_pressPosition(Vector2 value);
	public Vector3 get_worldPosition();
	public void set_worldPosition(Vector3 value);
	public Vector3 get_worldNormal();
	public void set_worldNormal(Vector3 value);
	public float get_clickTime();
	public void set_clickTime(float value);
	public int get_clickCount();
	public void set_clickCount(int value);
	public Vector2 get_scrollDelta();
	public void set_scrollDelta(Vector2 value);
	public bool get_useDragThreshold();
	public void set_useDragThreshold(bool value);
	public bool get_dragging();
	public void set_dragging(bool value);
	public PointerEventData.InputButton get_button();
	public void set_button(PointerEventData.InputButton value);
	public bool IsPointerMoving();
	public bool IsScrolling();
	public Camera get_enterEventCamera();
	public Camera get_pressEventCamera();
	public GameObject get_pointerPress();
	public void set_pointerPress(GameObject value);
	public override string ToString();

}
//NameSpace:
public enum PointerEventData.InputButton
{
	// Fields
	public int value__;
	public const PointerEventData.InputButton Left;
	public const PointerEventData.InputButton Right;
	public const PointerEventData.InputButton Middle;

}
//NameSpace:
public enum PointerEventData.FramePressState
{
	// Fields
	public int value__;
	public const PointerEventData.FramePressState Pressed;
	public const PointerEventData.FramePressState Released;
	public const PointerEventData.FramePressState PressedAndReleased;
	public const PointerEventData.FramePressState NotChanged;

}
//NameSpace:UnityEngine.EventSystems
public class BaseInput : UIBehaviour
{
	// Properties
	public virtual string compositionString { get; }
	public virtual IMECompositionMode imeCompositionMode { get; set; }
	public virtual Vector2 compositionCursorPos { get; set; }
	public virtual bool mousePresent { get; }
	public virtual Vector2 mousePosition { get; }
	public virtual Vector2 mouseScrollDelta { get; }
	public virtual bool touchSupported { get; }
	public virtual int touchCount { get; }

	// Methods
	public void .ctor();
	public virtual string get_compositionString();
	public virtual IMECompositionMode get_imeCompositionMode();
	public virtual void set_imeCompositionMode(IMECompositionMode value);
	public virtual Vector2 get_compositionCursorPos();
	public virtual void set_compositionCursorPos(Vector2 value);
	public virtual bool get_mousePresent();
	public virtual bool GetMouseButtonDown(int button);
	public virtual bool GetMouseButtonUp(int button);
	public virtual bool GetMouseButton(int button);
	public virtual Vector2 get_mousePosition();
	public virtual Vector2 get_mouseScrollDelta();
	public virtual bool get_touchSupported();
	public virtual int get_touchCount();
	public virtual Touch GetTouch(int index);
	public virtual float GetAxisRaw(string axisName);
	public virtual bool GetButtonDown(string buttonName);

}
//NameSpace:UnityEngine.EventSystems
public abstract class BaseInputModule : UIBehaviour
{
	// Fields
	protected List`1<RaycastResult> m_RaycastResultCache;
	private AxisEventData m_AxisEventData;
	private EventSystem m_EventSystem;
	private BaseEventData m_BaseEventData;
	protected BaseInput m_InputOverride;
	private BaseInput m_DefaultInput;

	// Properties
	public BaseInput input { get; }
	public BaseInput inputOverride { get; set; }
	protected EventSystem eventSystem { get; }

	// Methods
	protected void .ctor();
	public BaseInput get_input();
	public BaseInput get_inputOverride();
	public void set_inputOverride(BaseInput value);
	protected EventSystem get_eventSystem();
	protected override void OnEnable();
	protected override void OnDisable();
	public abstract void Process();
	protected static RaycastResult FindFirstRaycast(List`1<RaycastResult> candidates);
	protected static MoveDirection DetermineMoveDirection(float x, float y);
	protected static MoveDirection DetermineMoveDirection(float x, float y, float deadZone);
	protected static GameObject FindCommonRoot(GameObject g1, GameObject g2);
	protected void HandlePointerExitAndEnter(PointerEventData currentPointerData, GameObject newEnterTarget);
	protected virtual AxisEventData GetAxisEventData(float x, float y, float moveDeadZone);
	protected virtual BaseEventData GetBaseEventData();
	public virtual bool IsPointerOverGameObject(int pointerId);
	public virtual bool ShouldActivateModule();
	public virtual void DeactivateModule();
	public virtual void ActivateModule();
	public virtual void UpdateModule();
	public virtual bool IsModuleSupported();

}
//NameSpace:UnityEngine.EventSystems
public abstract class PointerInputModule : BaseInputModule
{
	// Fields
	public const int kMouseLeftId;
	public const int kMouseRightId;
	public const int kMouseMiddleId;
	public const int kFakeTouchesId;
	protected Dictionary`2<intPointerEventData> m_PointerData;
	private readonly PointerInputModule.MouseState m_MouseState;

	// Methods
	protected void .ctor();
	protected bool GetPointerData(int id, out PointerEventData data, bool create);
	protected void RemovePointerData(PointerEventData data);
	protected PointerEventData GetTouchPointerEventData(Touch input, out bool pressed, out bool released);
	protected void CopyFromTo(PointerEventData from, PointerEventData to);
	protected PointerEventData.FramePressState StateForMouseButton(int buttonId);
	protected virtual PointerInputModule.MouseState GetMousePointerEventData();
	protected virtual PointerInputModule.MouseState GetMousePointerEventData(int id);
	protected PointerEventData GetLastPointerEventData(int id);
	private static bool ShouldStartDrag(Vector2 pressPos, Vector2 currentPos, float threshold, bool useDragThreshold);
	protected virtual void ProcessMove(PointerEventData pointerEvent);
	protected virtual void ProcessDrag(PointerEventData pointerEvent);
	public override bool IsPointerOverGameObject(int pointerId);
	protected void ClearSelection();
	public override string ToString();
	protected void DeselectIfSelectionChanged(GameObject currentOverGo, BaseEventData pointerEvent);

}
//NameSpace:
protected class PointerInputModule.ButtonState
{
	// Fields
	private PointerEventData.InputButton m_Button;
	private PointerInputModule.MouseButtonEventData m_EventData;

	// Properties
	public PointerInputModule.MouseButtonEventData eventData { get; set; }
	public PointerEventData.InputButton button { get; set; }

	// Methods
	public void .ctor();
	public PointerInputModule.MouseButtonEventData get_eventData();
	public void set_eventData(PointerInputModule.MouseButtonEventData value);
	public PointerEventData.InputButton get_button();
	public void set_button(PointerEventData.InputButton value);

}
//NameSpace:
protected class PointerInputModule.MouseState
{
	// Fields
	private List`1<PointerInputModule.ButtonState> m_TrackedButtons;

	// Methods
	public void .ctor();
	public bool AnyPressesThisFrame();
	public bool AnyReleasesThisFrame();
	public PointerInputModule.ButtonState GetButtonState(PointerEventData.InputButton button);
	public void SetButtonState(PointerEventData.InputButton button, PointerEventData.FramePressState stateForMouseButton, PointerEventData data);

}
//NameSpace:
public class PointerInputModule.MouseButtonEventData
{
	// Fields
	public PointerEventData.FramePressState buttonState;
	public PointerEventData buttonData;

	// Methods
	public void .ctor();
	public bool PressedThisFrame();
	public bool ReleasedThisFrame();

}
//NameSpace:UnityEngine.EventSystems
public class StandaloneInputModule : PointerInputModule
{
	// Fields
	private float m_PrevActionTime;
	private Vector2 m_LastMoveVector;
	private int m_ConsecutiveMoveCount;
	private Vector2 m_LastMousePosition;
	private Vector2 m_MousePosition;
	private GameObject m_CurrentFocusedGameObject;
	private PointerEventData m_InputPointerEvent;
	private string m_HorizontalAxis;
	private string m_VerticalAxis;
	private string m_SubmitButton;
	private string m_CancelButton;
	private float m_InputActionsPerSecond;
	private float m_RepeatDelay;
	private bool m_ForceModuleActive;

	// Properties
	public StandaloneInputModule.InputMode inputMode { get; }
	public bool allowActivationOnMobileDevice { get; set; }
	public bool forceModuleActive { get; set; }
	public float inputActionsPerSecond { get; set; }
	public float repeatDelay { get; set; }
	public string horizontalAxis { get; set; }
	public string verticalAxis { get; set; }
	public string submitButton { get; set; }
	public string cancelButton { get; set; }

	// Methods
	protected void .ctor();
	public StandaloneInputModule.InputMode get_inputMode();
	public bool get_allowActivationOnMobileDevice();
	public void set_allowActivationOnMobileDevice(bool value);
	public bool get_forceModuleActive();
	public void set_forceModuleActive(bool value);
	public float get_inputActionsPerSecond();
	public void set_inputActionsPerSecond(float value);
	public float get_repeatDelay();
	public void set_repeatDelay(float value);
	public string get_horizontalAxis();
	public void set_horizontalAxis(string value);
	public string get_verticalAxis();
	public void set_verticalAxis(string value);
	public string get_submitButton();
	public void set_submitButton(string value);
	public string get_cancelButton();
	public void set_cancelButton(string value);
	private bool ShouldIgnoreEventsOnNoFocus();
	public override void UpdateModule();
	public override bool IsModuleSupported();
	public override bool ShouldActivateModule();
	public override void ActivateModule();
	public override void DeactivateModule();
	public override void Process();
	private bool ProcessTouchEvents();
	protected void ProcessTouchPress(PointerEventData pointerEvent, bool pressed, bool released);
	protected bool SendSubmitEventToSelectedObject();
	private Vector2 GetRawMoveVector();
	protected bool SendMoveEventToSelectedObject();
	protected void ProcessMouseEvent();
	protected virtual bool ForceAutoSelect();
	protected void ProcessMouseEvent(int id);
	protected bool SendUpdateEventToSelectedObject();
	protected void ProcessMousePress(PointerInputModule.MouseButtonEventData data);
	protected GameObject GetCurrentFocusedGameObject();

}
//NameSpace:
public enum StandaloneInputModule.InputMode
{
	// Fields
	public int value__;
	public const StandaloneInputModule.InputMode Mouse;
	public const StandaloneInputModule.InputMode Buttons;

}
//NameSpace:UnityEngine.EventSystems
public class TouchInputModule : PointerInputModule
{
	// Fields
	private Vector2 m_LastMousePosition;
	private Vector2 m_MousePosition;
	private PointerEventData m_InputPointerEvent;
	private bool m_ForceModuleActive;

	// Properties
	public bool allowActivationOnStandalone { get; set; }
	public bool forceModuleActive { get; set; }

	// Methods
	protected void .ctor();
	public bool get_allowActivationOnStandalone();
	public void set_allowActivationOnStandalone(bool value);
	public bool get_forceModuleActive();
	public void set_forceModuleActive(bool value);
	public override void UpdateModule();
	public override bool IsModuleSupported();
	public override bool ShouldActivateModule();
	private bool UseFakeInput();
	public override void Process();
	private void FakeTouches();
	private void ProcessTouchEvents();
	protected void ProcessTouchPress(PointerEventData pointerEvent, bool pressed, bool released);
	public override void DeactivateModule();
	public override string ToString();

}
//NameSpace:UnityEngine.EventSystems
public abstract class BaseRaycaster : UIBehaviour
{
	// Properties
	public abstract Camera eventCamera { get; }
	public virtual int priority { get; }
	public virtual int sortOrderPriority { get; }
	public virtual int renderOrderPriority { get; }

	// Methods
	protected void .ctor();
	public abstract void Raycast(PointerEventData eventData, List`1<RaycastResult> resultAppendList);
	public abstract Camera get_eventCamera();
	public virtual int get_priority();
	public virtual int get_sortOrderPriority();
	public virtual int get_renderOrderPriority();
	public override string ToString();
	protected override void OnEnable();
	protected override void OnDisable();

}
//NameSpace:UnityEngine.EventSystems
public class Physics2DRaycaster : PhysicsRaycaster
{
	// Fields
	private RaycastHit2D[] m_Hits;

	// Methods
	protected void .ctor();
	public override void Raycast(PointerEventData eventData, List`1<RaycastResult> resultAppendList);

}
//NameSpace:UnityEngine.EventSystems
public class PhysicsRaycaster : BaseRaycaster
{
	// Fields
	protected const int kNoEventMaskSet;
	protected Camera m_EventCamera;
	protected LayerMask m_EventMask;
	protected int m_MaxRayIntersections;
	protected int m_LastMaxRayIntersections;
	private RaycastHit[] m_Hits;
	private static Comparison`1<RaycastHit> <>f__am$cache0;

	// Properties
	public override Camera eventCamera { get; }
	public virtual int depth { get; }
	public int finalEventMask { get; }
	public LayerMask eventMask { get; set; }
	public int maxRayIntersections { get; set; }

	// Methods
	protected void .ctor();
	public override Camera get_eventCamera();
	public virtual int get_depth();
	public int get_finalEventMask();
	public LayerMask get_eventMask();
	public void set_eventMask(LayerMask value);
	public int get_maxRayIntersections();
	public void set_maxRayIntersections(int value);
	protected bool ComputeRayAndDistance(PointerEventData eventData, Ray ray, float distanceToClipPlane);
	public override void Raycast(PointerEventData eventData, List`1<RaycastResult> resultAppendList);
	private static int <Raycast>m__0(RaycastHit r1, RaycastHit r2);

}
//NameSpace:UnityEngine.UI.CoroutineTween
internal interface ITweenValue
{
	// Properties
	public abstract bool ignoreTimeScale { get; }
	public abstract float duration { get; }

	// Methods
	public abstract void TweenValue(float floatPercentage);
	public abstract bool get_ignoreTimeScale();
	public abstract float get_duration();
	public abstract bool ValidTarget();

}
//NameSpace:UnityEngine.UI.CoroutineTween
internal struct ColorTween : ITweenValue
{
	// Fields
	private ColorTween.ColorTweenCallback m_Target;
	private Color m_StartColor;
	private Color m_TargetColor;
	private ColorTween.ColorTweenMode m_TweenMode;
	private float m_Duration;
	private bool m_IgnoreTimeScale;

	// Properties
	public Color startColor { get; set; }
	public Color targetColor { get; set; }
	public ColorTween.ColorTweenMode tweenMode { get; set; }
	public float duration { get; set; }
	public bool ignoreTimeScale { get; set; }

	// Methods
	public Color get_startColor();
	public void set_startColor(Color value);
	public Color get_targetColor();
	public void set_targetColor(Color value);
	public ColorTween.ColorTweenMode get_tweenMode();
	public void set_tweenMode(ColorTween.ColorTweenMode value);
	public float get_duration();
	public void set_duration(float value);
	public bool get_ignoreTimeScale();
	public void set_ignoreTimeScale(bool value);
	public void TweenValue(float floatPercentage);
	public void AddOnChangedCallback(UnityAction`1<Color> callback);
	public bool GetIgnoreTimescale();
	public float GetDuration();
	public bool ValidTarget();

}
//NameSpace:
public enum ColorTween.ColorTweenMode
{
	// Fields
	public int value__;
	public const ColorTween.ColorTweenMode All;
	public const ColorTween.ColorTweenMode RGB;
	public const ColorTween.ColorTweenMode Alpha;

}
//NameSpace:
public class ColorTween.ColorTweenCallback : UnityEvent`1<Color>
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine.UI.CoroutineTween
internal struct FloatTween : ITweenValue
{
	// Fields
	private FloatTween.FloatTweenCallback m_Target;
	private float m_StartValue;
	private float m_TargetValue;
	private float m_Duration;
	private bool m_IgnoreTimeScale;

	// Properties
	public float startValue { get; set; }
	public float targetValue { get; set; }
	public float duration { get; set; }
	public bool ignoreTimeScale { get; set; }

	// Methods
	public float get_startValue();
	public void set_startValue(float value);
	public float get_targetValue();
	public void set_targetValue(float value);
	public float get_duration();
	public void set_duration(float value);
	public bool get_ignoreTimeScale();
	public void set_ignoreTimeScale(bool value);
	public void TweenValue(float floatPercentage);
	public void AddOnChangedCallback(UnityAction`1<float> callback);
	public bool GetIgnoreTimescale();
	public float GetDuration();
	public bool ValidTarget();

}
//NameSpace:
public class FloatTween.FloatTweenCallback : UnityEvent`1<float>
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine.UI.CoroutineTween
internal class TweenRunner`1
{
	// Fields
	protected MonoBehaviour m_CoroutineContainer;
	protected IEnumerator m_Tween;

	// Methods
	public void .ctor();
	private static IEnumerator Start(T tweenInfo);
	public void Init(MonoBehaviour coroutineContainer);
	public void StartTween(T info);
	public void StopTween();

}
//NameSpace:
private sealed class TweenRunner`1.<Start>c__Iterator0 : IEnumerator, IDisposable, IEnumerator`1<object>
{
	// Fields
	internal T tweenInfo;
	internal float <elapsedTime>__0;
	internal float <percentage>__1;
	internal object $current;
	internal bool $disposing;
	internal int $PC;

	// Properties
	private object System.Collections.Generic.IEnumerator<object>.Current { get; }
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	public void .ctor();
	public bool MoveNext();
	private object System.Collections.Generic.IEnumerator<object>.get_Current();
	private object System.Collections.IEnumerator.get_Current();
	public void Dispose();
	public void Reset();

}
//NameSpace:UnityEngine.UI
public class AnimationTriggers
{
	// Fields
	private const string kDefaultNormalAnimName;
	private const string kDefaultSelectedAnimName;
	private const string kDefaultPressedAnimName;
	private const string kDefaultDisabledAnimName;
	private string m_NormalTrigger;
	private string m_HighlightedTrigger;
	private string m_PressedTrigger;
	private string m_DisabledTrigger;

	// Properties
	public string normalTrigger { get; set; }
	public string highlightedTrigger { get; set; }
	public string pressedTrigger { get; set; }
	public string disabledTrigger { get; set; }

	// Methods
	public void .ctor();
	public string get_normalTrigger();
	public void set_normalTrigger(string value);
	public string get_highlightedTrigger();
	public void set_highlightedTrigger(string value);
	public string get_pressedTrigger();
	public void set_pressedTrigger(string value);
	public string get_disabledTrigger();
	public void set_disabledTrigger(string value);

}
//NameSpace:UnityEngine.UI
public class Button : Selectable, IPointerClickHandler, ISubmitHandler, IEventSystemHandler
{
	// Fields
	private Button.ButtonClickedEvent m_OnClick;

	// Properties
	public Button.ButtonClickedEvent onClick { get; set; }

	// Methods
	protected void .ctor();
	public Button.ButtonClickedEvent get_onClick();
	public void set_onClick(Button.ButtonClickedEvent value);
	private void Press();
	public virtual void OnPointerClick(PointerEventData eventData);
	public virtual void OnSubmit(BaseEventData eventData);
	private IEnumerator OnFinishSubmit();

}
//NameSpace:
public class Button.ButtonClickedEvent : UnityEvent
{
	// Methods
	public void .ctor();

}
//NameSpace:
private sealed class Button.<OnFinishSubmit>c__Iterator0 : IEnumerator, IDisposable, IEnumerator`1<object>
{
	// Fields
	internal float <fadeTime>__0;
	internal float <elapsedTime>__0;
	internal Button $this;
	internal object $current;
	internal bool $disposing;
	internal int $PC;

	// Properties
	private object System.Collections.Generic.IEnumerator<object>.Current { get; }
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	public void .ctor();
	public bool MoveNext();
	private object System.Collections.Generic.IEnumerator<object>.get_Current();
	private object System.Collections.IEnumerator.get_Current();
	public void Dispose();
	public void Reset();

}
//NameSpace:UnityEngine.UI
public enum CanvasUpdate
{
	// Fields
	public int value__;
	public const CanvasUpdate Prelayout;
	public const CanvasUpdate Layout;
	public const CanvasUpdate PostLayout;
	public const CanvasUpdate PreRender;
	public const CanvasUpdate LatePreRender;
	public const CanvasUpdate MaxUpdateValue;

}
//NameSpace:UnityEngine.UI
public interface ICanvasElement
{
	// Properties
	public abstract Transform transform { get; }

	// Methods
	public abstract void Rebuild(CanvasUpdate executing);
	public abstract Transform get_transform();
	public abstract void LayoutComplete();
	public abstract void GraphicUpdateComplete();
	public abstract bool IsDestroyed();

}
//NameSpace:UnityEngine.UI
public class CanvasUpdateRegistry
{
	// Fields
	private static CanvasUpdateRegistry s_Instance;
	private bool m_PerformingLayoutUpdate;
	private bool m_PerformingGraphicUpdate;
	private readonly IndexedSet`1<ICanvasElement> m_LayoutRebuildQueue;
	private readonly IndexedSet`1<ICanvasElement> m_GraphicRebuildQueue;
	private static readonly Comparison`1<ICanvasElement> s_SortLayoutFunction;
	private static Comparison`1<ICanvasElement> <>f__mg$cache0;

	// Properties
	public static CanvasUpdateRegistry instance { get; }

	// Methods
	protected void .ctor();
	public static CanvasUpdateRegistry get_instance();
	private bool ObjectValidForUpdate(ICanvasElement element);
	private void CleanInvalidItems();
	private void PerformUpdate();
	private static int ParentCount(Transform child);
	private static int SortLayoutList(ICanvasElement x, ICanvasElement y);
	public static void RegisterCanvasElementForLayoutRebuild(ICanvasElement element);
	public static bool TryRegisterCanvasElementForLayoutRebuild(ICanvasElement element);
	private bool InternalRegisterCanvasElementForLayoutRebuild(ICanvasElement element);
	public static void RegisterCanvasElementForGraphicRebuild(ICanvasElement element);
	public static bool TryRegisterCanvasElementForGraphicRebuild(ICanvasElement element);
	private bool InternalRegisterCanvasElementForGraphicRebuild(ICanvasElement element);
	public static void UnRegisterCanvasElementForRebuild(ICanvasElement element);
	private void InternalUnRegisterCanvasElementForLayoutRebuild(ICanvasElement element);
	private void InternalUnRegisterCanvasElementForGraphicRebuild(ICanvasElement element);
	public static bool IsRebuildingLayout();
	public static bool IsRebuildingGraphics();
	private static void .cctor();

}
//NameSpace:UnityEngine.UI
public struct ColorBlock : IEquatable`1<ColorBlock>
{
	// Fields
	private Color m_NormalColor;
	private Color m_HighlightedColor;
	private Color m_PressedColor;
	private Color m_DisabledColor;
	private float m_ColorMultiplier;
	private float m_FadeDuration;

	// Properties
	public Color normalColor { get; set; }
	public Color highlightedColor { get; set; }
	public Color pressedColor { get; set; }
	public Color disabledColor { get; set; }
	public float colorMultiplier { get; set; }
	public float fadeDuration { get; set; }
	public static ColorBlock defaultColorBlock { get; }

	// Methods
	public Color get_normalColor();
	public void set_normalColor(Color value);
	public Color get_highlightedColor();
	public void set_highlightedColor(Color value);
	public Color get_pressedColor();
	public void set_pressedColor(Color value);
	public Color get_disabledColor();
	public void set_disabledColor(Color value);
	public float get_colorMultiplier();
	public void set_colorMultiplier(float value);
	public float get_fadeDuration();
	public void set_fadeDuration(float value);
	public static ColorBlock get_defaultColorBlock();
	public override bool Equals(object obj);
	public bool Equals(ColorBlock other);
	public static bool op_Equality(ColorBlock point1, ColorBlock point2);
	public static bool op_Inequality(ColorBlock point1, ColorBlock point2);
	public override int GetHashCode();

}
//NameSpace:UnityEngine.UI
public static class DefaultControls
{
	// Fields
	private const float kWidth;
	private const float kThickHeight;
	private const float kThinHeight;
	private static Vector2 s_ThickElementSize;
	private static Vector2 s_ThinElementSize;
	private static Vector2 s_ImageElementSize;
	private static Color s_DefaultSelectableColor;
	private static Color s_PanelColor;
	private static Color s_TextColor;

	// Methods
	private static GameObject CreateUIElementRoot(string name, Vector2 size);
	private static GameObject CreateUIObject(string name, GameObject parent);
	private static void SetDefaultTextValues(Text lbl);
	private static void SetDefaultColorTransitionValues(Selectable slider);
	private static void SetParentAndAlign(GameObject child, GameObject parent);
	private static void SetLayerRecursively(GameObject go, int layer);
	public static GameObject CreatePanel(DefaultControls.Resources resources);
	public static GameObject CreateButton(DefaultControls.Resources resources);
	public static GameObject CreateText(DefaultControls.Resources resources);
	public static GameObject CreateImage(DefaultControls.Resources resources);
	public static GameObject CreateRawImage(DefaultControls.Resources resources);
	public static GameObject CreateSlider(DefaultControls.Resources resources);
	public static GameObject CreateScrollbar(DefaultControls.Resources resources);
	public static GameObject CreateToggle(DefaultControls.Resources resources);
	public static GameObject CreateInputField(DefaultControls.Resources resources);
	public static GameObject CreateDropdown(DefaultControls.Resources resources);
	public static GameObject CreateScrollView(DefaultControls.Resources resources);
	private static void .cctor();

}
//NameSpace:
public struct DefaultControls.Resources
{
	// Fields
	public Sprite standard;
	public Sprite background;
	public Sprite inputField;
	public Sprite knob;
	public Sprite checkmark;
	public Sprite dropdown;
	public Sprite mask;

}
//NameSpace:UnityEngine.UI
public class Dropdown : Selectable, IPointerClickHandler, ISubmitHandler, ICancelHandler, IEventSystemHandler
{
	// Fields
	private RectTransform m_Template;
	private Text m_CaptionText;
	private Image m_CaptionImage;
	private Text m_ItemText;
	private Image m_ItemImage;
	private int m_Value;
	private Dropdown.OptionDataList m_Options;
	private Dropdown.DropdownEvent m_OnValueChanged;
	private GameObject m_Dropdown;
	private GameObject m_Blocker;
	private List`1<Dropdown.DropdownItem> m_Items;
	private TweenRunner`1<FloatTween> m_AlphaTweenRunner;
	private bool validTemplate;
	private static Dropdown.OptionData s_NoOptionData;

	// Properties
	public RectTransform template { get; set; }
	public Text captionText { get; set; }
	public Image captionImage { get; set; }
	public Text itemText { get; set; }
	public Image itemImage { get; set; }
	public List`1<Dropdown.OptionData> options { get; set; }
	public Dropdown.DropdownEvent onValueChanged { get; set; }
	public int value { get; set; }

	// Methods
	protected void .ctor();
	public RectTransform get_template();
	public void set_template(RectTransform value);
	public Text get_captionText();
	public void set_captionText(Text value);
	public Image get_captionImage();
	public void set_captionImage(Image value);
	public Text get_itemText();
	public void set_itemText(Text value);
	public Image get_itemImage();
	public void set_itemImage(Image value);
	public List`1<Dropdown.OptionData> get_options();
	public void set_options(List`1<Dropdown.OptionData> value);
	public Dropdown.DropdownEvent get_onValueChanged();
	public void set_onValueChanged(Dropdown.DropdownEvent value);
	public int get_value();
	public void set_value(int value);
	protected override void Awake();
	protected override void Start();
	public void RefreshShownValue();
	public void AddOptions(List`1<Dropdown.OptionData> options);
	public void AddOptions(List`1<string> options);
	public void AddOptions(List`1<Sprite> options);
	public void ClearOptions();
	private void SetupTemplate();
	private static T GetOrAddComponent(GameObject go);
	public virtual void OnPointerClick(PointerEventData eventData);
	public virtual void OnSubmit(BaseEventData eventData);
	public virtual void OnCancel(BaseEventData eventData);
	public void Show();
	protected virtual GameObject CreateBlocker(Canvas rootCanvas);
	protected virtual void DestroyBlocker(GameObject blocker);
	protected virtual GameObject CreateDropdownList(GameObject template);
	protected virtual void DestroyDropdownList(GameObject dropdownList);
	protected virtual Dropdown.DropdownItem CreateItem(Dropdown.DropdownItem itemTemplate);
	protected virtual void DestroyItem(Dropdown.DropdownItem item);
	private Dropdown.DropdownItem AddItem(Dropdown.OptionData data, bool selected, Dropdown.DropdownItem itemTemplate, List`1<Dropdown.DropdownItem> items);
	private void AlphaFadeList(float duration, float alpha);
	private void AlphaFadeList(float duration, float start, float end);
	private void SetAlpha(float alpha);
	public void Hide();
	private IEnumerator DelayedDestroyDropdownList(float delay);
	private void OnSelectItem(Toggle toggle);
	private static void .cctor();

}
//NameSpace:
protected internal class Dropdown.DropdownItem : MonoBehaviour, IPointerEnterHandler, ICancelHandler, IEventSystemHandler
{
	// Fields
	private Text m_Text;
	private Image m_Image;
	private RectTransform m_RectTransform;
	private Toggle m_Toggle;

	// Properties
	public Text text { get; set; }
	public Image image { get; set; }
	public RectTransform rectTransform { get; set; }
	public Toggle toggle { get; set; }

	// Methods
	public void .ctor();
	public Text get_text();
	public void set_text(Text value);
	public Image get_image();
	public void set_image(Image value);
	public RectTransform get_rectTransform();
	public void set_rectTransform(RectTransform value);
	public Toggle get_toggle();
	public void set_toggle(Toggle value);
	public virtual void OnPointerEnter(PointerEventData eventData);
	public virtual void OnCancel(BaseEventData eventData);

}
//NameSpace:
public class Dropdown.OptionData
{
	// Fields
	private string m_Text;
	private Sprite m_Image;

	// Properties
	public string text { get; set; }
	public Sprite image { get; set; }

	// Methods
	public void .ctor();
	public void .ctor(string text);
	public void .ctor(Sprite image);
	public void .ctor(string text, Sprite image);
	public string get_text();
	public void set_text(string value);
	public Sprite get_image();
	public void set_image(Sprite value);

}
//NameSpace:
public class Dropdown.OptionDataList
{
	// Fields
	private List`1<Dropdown.OptionData> m_Options;

	// Properties
	public List`1<Dropdown.OptionData> options { get; set; }

	// Methods
	public void .ctor();
	public List`1<Dropdown.OptionData> get_options();
	public void set_options(List`1<Dropdown.OptionData> value);

}
//NameSpace:
public class Dropdown.DropdownEvent : UnityEvent`1<int>
{
	// Methods
	public void .ctor();

}
//NameSpace:
private sealed class Dropdown.<Show>c__AnonStorey1
{
	// Fields
	internal Dropdown.DropdownItem item;
	internal Dropdown $this;

	// Methods
	public void .ctor();
	internal void <>m__0(bool x);

}
//NameSpace:
private sealed class Dropdown.<DelayedDestroyDropdownList>c__Iterator0 : IEnumerator, IDisposable, IEnumerator`1<object>
{
	// Fields
	internal float delay;
	internal Dropdown $this;
	internal object $current;
	internal bool $disposing;
	internal int $PC;

	// Properties
	private object System.Collections.Generic.IEnumerator<object>.Current { get; }
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	public void .ctor();
	public bool MoveNext();
	private object System.Collections.Generic.IEnumerator<object>.get_Current();
	private object System.Collections.IEnumerator.get_Current();
	public void Dispose();
	public void Reset();

}
//NameSpace:UnityEngine.UI
public class FontData : ISerializationCallbackReceiver
{
	// Fields
	private Font m_Font;
	private int m_FontSize;
	private FontStyle m_FontStyle;
	private bool m_BestFit;
	private int m_MinSize;
	private int m_MaxSize;
	private TextAnchor m_Alignment;
	private bool m_AlignByGeometry;
	private bool m_RichText;
	private HorizontalWrapMode m_HorizontalOverflow;
	private VerticalWrapMode m_VerticalOverflow;
	private float m_LineSpacing;

	// Properties
	public static FontData defaultFontData { get; }
	public Font font { get; set; }
	public int fontSize { get; set; }
	public FontStyle fontStyle { get; set; }
	public bool bestFit { get; set; }
	public int minSize { get; set; }
	public int maxSize { get; set; }
	public TextAnchor alignment { get; set; }
	public bool alignByGeometry { get; set; }
	public bool richText { get; set; }
	public HorizontalWrapMode horizontalOverflow { get; set; }
	public VerticalWrapMode verticalOverflow { get; set; }
	public float lineSpacing { get; set; }

	// Methods
	public void .ctor();
	public static FontData get_defaultFontData();
	public Font get_font();
	public void set_font(Font value);
	public int get_fontSize();
	public void set_fontSize(int value);
	public FontStyle get_fontStyle();
	public void set_fontStyle(FontStyle value);
	public bool get_bestFit();
	public void set_bestFit(bool value);
	public int get_minSize();
	public void set_minSize(int value);
	public int get_maxSize();
	public void set_maxSize(int value);
	public TextAnchor get_alignment();
	public void set_alignment(TextAnchor value);
	public bool get_alignByGeometry();
	public void set_alignByGeometry(bool value);
	public bool get_richText();
	public void set_richText(bool value);
	public HorizontalWrapMode get_horizontalOverflow();
	public void set_horizontalOverflow(HorizontalWrapMode value);
	public VerticalWrapMode get_verticalOverflow();
	public void set_verticalOverflow(VerticalWrapMode value);
	public float get_lineSpacing();
	public void set_lineSpacing(float value);
	private void UnityEngine.ISerializationCallbackReceiver.OnBeforeSerialize();
	private void UnityEngine.ISerializationCallbackReceiver.OnAfterDeserialize();

}
//NameSpace:UnityEngine.UI
public static class FontUpdateTracker
{
	// Fields
	private static Dictionary`2<FontHashSet`1<Text>> m_Tracked;
	private static Action`1<Font> <>f__mg$cache0;
	private static Action`1<Font> <>f__mg$cache1;

	// Methods
	public static void TrackText(Text t);
	private static void RebuildForFont(Font f);
	public static void UntrackText(Text t);
	private static void .cctor();

}
//NameSpace:UnityEngine.UI
public abstract class Graphic : UIBehaviour, ICanvasElement
{
	// Fields
	protected static Material s_DefaultUI;
	protected static Texture2D s_WhiteTexture;
	protected Material m_Material;
	private Color m_Color;
	private bool m_RaycastTarget;
	private RectTransform m_RectTransform;
	private CanvasRenderer m_CanvasRenderer;
	private Canvas m_Canvas;
	private bool m_VertsDirty;
	private bool m_MaterialDirty;
	protected UnityAction m_OnDirtyLayoutCallback;
	protected UnityAction m_OnDirtyVertsCallback;
	protected UnityAction m_OnDirtyMaterialCallback;
	protected static Mesh s_Mesh;
	private static readonly VertexHelper s_VertexHelper;
	private readonly TweenRunner`1<ColorTween> m_ColorTweenRunner;
	private bool <useLegacyMeshGeneration>k__BackingField;

	// Properties
	public static Material defaultGraphicMaterial { get; }
	public virtual Color color { get; set; }
	public virtual bool raycastTarget { get; set; }
	protected bool useLegacyMeshGeneration { get; set; }
	public int depth { get; }
	public RectTransform rectTransform { get; }
	public Canvas canvas { get; }
	public CanvasRenderer canvasRenderer { get; }
	public virtual Material defaultMaterial { get; }
	public virtual Material material { get; set; }
	public virtual Material materialForRendering { get; }
	public virtual Texture mainTexture { get; }
	protected static Mesh workerMesh { get; }

	// Methods
	protected void .ctor();
	public static Material get_defaultGraphicMaterial();
	public virtual Color get_color();
	public virtual void set_color(Color value);
	public virtual bool get_raycastTarget();
	public virtual void set_raycastTarget(bool value);
	protected bool get_useLegacyMeshGeneration();
	protected void set_useLegacyMeshGeneration(bool value);
	public virtual void SetAllDirty();
	public virtual void SetLayoutDirty();
	public virtual void SetVerticesDirty();
	public virtual void SetMaterialDirty();
	protected override void OnRectTransformDimensionsChange();
	protected override void OnBeforeTransformParentChanged();
	protected override void OnTransformParentChanged();
	public int get_depth();
	public RectTransform get_rectTransform();
	public Canvas get_canvas();
	private void CacheCanvas();
	public CanvasRenderer get_canvasRenderer();
	public virtual Material get_defaultMaterial();
	public virtual Material get_material();
	public virtual void set_material(Material value);
	public virtual Material get_materialForRendering();
	public virtual Texture get_mainTexture();
	protected override void OnEnable();
	protected override void OnDisable();
	protected override void OnCanvasHierarchyChanged();
	public virtual void OnCullingChanged();
	public virtual void Rebuild(CanvasUpdate update);
	public virtual void LayoutComplete();
	public virtual void GraphicUpdateComplete();
	protected virtual void UpdateMaterial();
	protected virtual void UpdateGeometry();
	private void DoMeshGeneration();
	private void DoLegacyMeshGeneration();
	protected static Mesh get_workerMesh();
	protected virtual void OnFillVBO(List`1<UIVertex> vbo);
	protected virtual void OnPopulateMesh(Mesh m);
	protected virtual void OnPopulateMesh(VertexHelper vh);
	protected override void OnDidApplyAnimationProperties();
	public virtual void SetNativeSize();
	public virtual bool Raycast(Vector2 sp, Camera eventCamera);
	public Vector2 PixelAdjustPoint(Vector2 point);
	public Rect GetPixelAdjustedRect();
	public virtual void CrossFadeColor(Color targetColor, float duration, bool ignoreTimeScale, bool useAlpha);
	public virtual void CrossFadeColor(Color targetColor, float duration, bool ignoreTimeScale, bool useAlpha, bool useRGB);
	private static Color CreateColorFromAlpha(float alpha);
	public virtual void CrossFadeAlpha(float alpha, float duration, bool ignoreTimeScale);
	public void RegisterDirtyLayoutCallback(UnityAction action);
	public void UnregisterDirtyLayoutCallback(UnityAction action);
	public void RegisterDirtyVerticesCallback(UnityAction action);
	public void UnregisterDirtyVerticesCallback(UnityAction action);
	public void RegisterDirtyMaterialCallback(UnityAction action);
	public void UnregisterDirtyMaterialCallback(UnityAction action);
	private static void .cctor();
	private Transform UnityEngine.UI.ICanvasElement.get_transform();

}
//NameSpace:UnityEngine.UI
public class GraphicRaycaster : BaseRaycaster
{
	// Fields
	protected const int kNoEventMaskSet;
	private bool m_IgnoreReversedGraphics;
	private GraphicRaycaster.BlockingObjects m_BlockingObjects;
	protected LayerMask m_BlockingMask;
	private Canvas m_Canvas;
	private List`1<Graphic> m_RaycastResults;
	private static readonly List`1<Graphic> s_SortedGraphics;
	private static Comparison`1<Graphic> <>f__am$cache0;

	// Properties
	public override int sortOrderPriority { get; }
	public override int renderOrderPriority { get; }
	public bool ignoreReversedGraphics { get; set; }
	public GraphicRaycaster.BlockingObjects blockingObjects { get; set; }
	private Canvas canvas { get; }
	public override Camera eventCamera { get; }

	// Methods
	protected void .ctor();
	public override int get_sortOrderPriority();
	public override int get_renderOrderPriority();
	public bool get_ignoreReversedGraphics();
	public void set_ignoreReversedGraphics(bool value);
	public GraphicRaycaster.BlockingObjects get_blockingObjects();
	public void set_blockingObjects(GraphicRaycaster.BlockingObjects value);
	private Canvas get_canvas();
	public override void Raycast(PointerEventData eventData, List`1<RaycastResult> resultAppendList);
	public override Camera get_eventCamera();
	private static void Raycast(Canvas canvas, Camera eventCamera, Vector2 pointerPosition, IList`1<Graphic> foundGraphics, List`1<Graphic> results);
	private static void .cctor();
	private static int <Raycast>m__0(Graphic g1, Graphic g2);

}
//NameSpace:
public enum GraphicRaycaster.BlockingObjects
{
	// Fields
	public int value__;
	public const GraphicRaycaster.BlockingObjects None;
	public const GraphicRaycaster.BlockingObjects TwoD;
	public const GraphicRaycaster.BlockingObjects ThreeD;
	public const GraphicRaycaster.BlockingObjects All;

}
//NameSpace:UnityEngine.UI
public class GraphicRegistry
{
	// Fields
	private static GraphicRegistry s_Instance;
	private readonly Dictionary`2<CanvasIndexedSet`1<Graphic>> m_Graphics;
	private static readonly List`1<Graphic> s_EmptyList;

	// Properties
	public static GraphicRegistry instance { get; }

	// Methods
	protected void .ctor();
	public static GraphicRegistry get_instance();
	public static void RegisterGraphicForCanvas(Canvas c, Graphic graphic);
	public static void UnregisterGraphicForCanvas(Canvas c, Graphic graphic);
	public static IList`1<Graphic> GetGraphicsForCanvas(Canvas canvas);
	private static void .cctor();

}
//NameSpace:UnityEngine.UI
internal interface IGraphicEnabledDisabled
{
	// Methods
	public abstract void OnSiblingGraphicEnabledDisabled();

}
//NameSpace:UnityEngine.UI
public interface IMask
{
	// Properties
	public abstract RectTransform rectTransform { get; }

	// Methods
	public abstract bool Enabled();
	public abstract RectTransform get_rectTransform();

}
//NameSpace:UnityEngine.UI
public interface IMaskable
{
	// Methods
	public abstract void RecalculateMasking();

}
//NameSpace:UnityEngine.UI
public class Image : MaskableGraphic, ISerializationCallbackReceiver, ILayoutElement, ICanvasRaycastFilter
{
	// Fields
	protected static Material s_ETC1DefaultUI;
	private Sprite m_Sprite;
	private Sprite m_OverrideSprite;
	private Image.Type m_Type;
	private bool m_PreserveAspect;
	private bool m_FillCenter;
	private Image.FillMethod m_FillMethod;
	private float m_FillAmount;
	private bool m_FillClockwise;
	private int m_FillOrigin;
	private float m_AlphaHitTestMinimumThreshold;
	private bool m_Tracked;
	private bool m_UseSpriteMesh;
	private static readonly Vector2[] s_VertScratch;
	private static readonly Vector2[] s_UVScratch;
	private static readonly Vector3[] s_Xy;
	private static readonly Vector3[] s_Uv;
	private static List`1<Image> m_TrackedTexturelessImages;
	private static bool s_Initialized;
	private static Action`1<SpriteAtlas> <>f__mg$cache0;

	// Properties
	public Sprite sprite { get; set; }
	public Sprite overrideSprite { get; set; }
	private Sprite activeSprite { get; }
	public Image.Type type { get; set; }
	public bool preserveAspect { get; set; }
	public bool fillCenter { get; set; }
	public Image.FillMethod fillMethod { get; set; }
	public float fillAmount { get; set; }
	public bool fillClockwise { get; set; }
	public int fillOrigin { get; set; }
	public float eventAlphaThreshold { get; set; }
	public float alphaHitTestMinimumThreshold { get; set; }
	public bool useSpriteMesh { get; set; }
	public static Material defaultETC1GraphicMaterial { get; }
	public override Texture mainTexture { get; }
	public bool hasBorder { get; }
	public float pixelsPerUnit { get; }
	public override Material material { get; set; }
	public virtual float minWidth { get; }
	public virtual float preferredWidth { get; }
	public virtual float flexibleWidth { get; }
	public virtual float minHeight { get; }
	public virtual float preferredHeight { get; }
	public virtual float flexibleHeight { get; }
	public virtual int layoutPriority { get; }

	// Methods
	protected void .ctor();
	public Sprite get_sprite();
	public void set_sprite(Sprite value);
	public Sprite get_overrideSprite();
	public void set_overrideSprite(Sprite value);
	private Sprite get_activeSprite();
	public Image.Type get_type();
	public void set_type(Image.Type value);
	public bool get_preserveAspect();
	public void set_preserveAspect(bool value);
	public bool get_fillCenter();
	public void set_fillCenter(bool value);
	public Image.FillMethod get_fillMethod();
	public void set_fillMethod(Image.FillMethod value);
	public float get_fillAmount();
	public void set_fillAmount(float value);
	public bool get_fillClockwise();
	public void set_fillClockwise(bool value);
	public int get_fillOrigin();
	public void set_fillOrigin(int value);
	public float get_eventAlphaThreshold();
	public void set_eventAlphaThreshold(float value);
	public float get_alphaHitTestMinimumThreshold();
	public void set_alphaHitTestMinimumThreshold(float value);
	public bool get_useSpriteMesh();
	public void set_useSpriteMesh(bool value);
	public static Material get_defaultETC1GraphicMaterial();
	public override Texture get_mainTexture();
	public bool get_hasBorder();
	public float get_pixelsPerUnit();
	public override Material get_material();
	public override void set_material(Material value);
	public virtual void OnBeforeSerialize();
	public virtual void OnAfterDeserialize();
	private void PreserveSpriteAspectRatio(Rect rect, Vector2 spriteSize);
	private Vector4 GetDrawingDimensions(bool shouldPreserveAspect);
	public override void SetNativeSize();
	protected override void OnPopulateMesh(VertexHelper toFill);
	private void TrackSprite();
	protected override void OnEnable();
	protected override void OnDisable();
	protected override void UpdateMaterial();
	private void GenerateSimpleSprite(VertexHelper vh, bool lPreserveAspect);
	private void GenerateSprite(VertexHelper vh, bool lPreserveAspect);
	private void GenerateSlicedSprite(VertexHelper toFill);
	private void GenerateTiledSprite(VertexHelper toFill);
	private static void AddQuad(VertexHelper vertexHelper, Vector3[] quadPositions, Color32 color, Vector3[] quadUVs);
	private static void AddQuad(VertexHelper vertexHelper, Vector2 posMin, Vector2 posMax, Color32 color, Vector2 uvMin, Vector2 uvMax);
	private Vector4 GetAdjustedBorders(Vector4 border, Rect adjustedRect);
	private void GenerateFilledSprite(VertexHelper toFill, bool preserveAspect);
	private static bool RadialCut(Vector3[] xy, Vector3[] uv, float fill, bool invert, int corner);
	private static void RadialCut(Vector3[] xy, float cos, float sin, bool invert, int corner);
	public virtual void CalculateLayoutInputHorizontal();
	public virtual void CalculateLayoutInputVertical();
	public virtual float get_minWidth();
	public virtual float get_preferredWidth();
	public virtual float get_flexibleWidth();
	public virtual float get_minHeight();
	public virtual float get_preferredHeight();
	public virtual float get_flexibleHeight();
	public virtual int get_layoutPriority();
	public virtual bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera);
	private Vector2 MapCoordinate(Vector2 local, Rect rect);
	private static void RebuildImage(SpriteAtlas spriteAtlas);
	private static void TrackImage(Image g);
	private static void UnTrackImage(Image g);
	private static void .cctor();

}
//NameSpace:
public enum Image.Type
{
	// Fields
	public int value__;
	public const Image.Type Simple;
	public const Image.Type Sliced;
	public const Image.Type Tiled;
	public const Image.Type Filled;

}
//NameSpace:
public enum Image.FillMethod
{
	// Fields
	public int value__;
	public const Image.FillMethod Horizontal;
	public const Image.FillMethod Vertical;
	public const Image.FillMethod Radial90;
	public const Image.FillMethod Radial180;
	public const Image.FillMethod Radial360;

}
//NameSpace:
public enum Image.OriginHorizontal
{
	// Fields
	public int value__;
	public const Image.OriginHorizontal Left;
	public const Image.OriginHorizontal Right;

}
//NameSpace:
public enum Image.OriginVertical
{
	// Fields
	public int value__;
	public const Image.OriginVertical Bottom;
	public const Image.OriginVertical Top;

}
//NameSpace:
public enum Image.Origin90
{
	// Fields
	public int value__;
	public const Image.Origin90 BottomLeft;
	public const Image.Origin90 TopLeft;
	public const Image.Origin90 TopRight;
	public const Image.Origin90 BottomRight;

}
//NameSpace:
public enum Image.Origin180
{
	// Fields
	public int value__;
	public const Image.Origin180 Bottom;
	public const Image.Origin180 Left;
	public const Image.Origin180 Top;
	public const Image.Origin180 Right;

}
//NameSpace:
public enum Image.Origin360
{
	// Fields
	public int value__;
	public const Image.Origin360 Bottom;
	public const Image.Origin360 Right;
	public const Image.Origin360 Top;
	public const Image.Origin360 Left;

}
//NameSpace:UnityEngine.UI
public class InputField : Selectable, IUpdateSelectedHandler, IBeginDragHandler, IDragHandler, IEndDragHandler, IPointerClickHandler, ISubmitHandler, ICanvasElement, ILayoutElement, IEventSystemHandler
{
	// Fields
	protected TouchScreenKeyboard m_Keyboard;
	private static readonly char[] kSeparators;
	protected Text m_TextComponent;
	protected Graphic m_Placeholder;
	private InputField.ContentType m_ContentType;
	private InputField.InputType m_InputType;
	private char m_AsteriskChar;
	private TouchScreenKeyboardType m_KeyboardType;
	private InputField.LineType m_LineType;
	private bool m_HideMobileInput;
	private InputField.CharacterValidation m_CharacterValidation;
	private int m_CharacterLimit;
	private InputField.SubmitEvent m_OnEndEdit;
	private InputField.OnChangeEvent m_OnValueChanged;
	private InputField.OnValidateInput m_OnValidateInput;
	private Color m_CaretColor;
	private bool m_CustomCaretColor;
	private Color m_SelectionColor;
	protected string m_Text;
	private float m_CaretBlinkRate;
	private int m_CaretWidth;
	private bool m_ReadOnly;
	protected int m_CaretPosition;
	protected int m_CaretSelectPosition;
	private RectTransform caretRectTrans;
	protected UIVertex[] m_CursorVerts;
	private TextGenerator m_InputTextCache;
	private CanvasRenderer m_CachedInputRenderer;
	private bool m_PreventFontCallback;
	protected Mesh m_Mesh;
	private bool m_AllowInput;
	private bool m_ShouldActivateNextUpdate;
	private bool m_UpdateDrag;
	private bool m_DragPositionOutOfBounds;
	private const float kHScrollSpeed;
	private const float kVScrollSpeed;
	protected bool m_CaretVisible;
	private Coroutine m_BlinkCoroutine;
	private float m_BlinkStartTime;
	protected int m_DrawStart;
	protected int m_DrawEnd;
	private Coroutine m_DragCoroutine;
	private string m_OriginalText;
	private bool m_WasCanceled;
	private bool m_HasDoneFocusTransition;
	private WaitForSecondsRealtime m_WaitForSecondsRealtime;
	private const string kEmailSpecialCharacters;
	private Event m_ProcessingEvent;
	private const int k_MaxTextLength;

	// Properties
	private BaseInput input { get; }
	private string compositionString { get; }
	protected Mesh mesh { get; }
	protected TextGenerator cachedInputTextGenerator { get; }
	public bool shouldHideMobileInput { get; set; }
	private bool shouldActivateOnSelect { get; }
	public string text { get; set; }
	public bool isFocused { get; }
	public float caretBlinkRate { get; set; }
	public int caretWidth { get; set; }
	public Text textComponent { get; set; }
	public Graphic placeholder { get; set; }
	public Color caretColor { get; set; }
	public bool customCaretColor { get; set; }
	public Color selectionColor { get; set; }
	public InputField.SubmitEvent onEndEdit { get; set; }
	public InputField.OnChangeEvent onValueChange { get; set; }
	public InputField.OnChangeEvent onValueChanged { get; set; }
	public InputField.OnValidateInput onValidateInput { get; set; }
	public int characterLimit { get; set; }
	public InputField.ContentType contentType { get; set; }
	public InputField.LineType lineType { get; set; }
	public InputField.InputType inputType { get; set; }
	public TouchScreenKeyboard touchScreenKeyboard { get; }
	public TouchScreenKeyboardType keyboardType { get; set; }
	public InputField.CharacterValidation characterValidation { get; set; }
	public bool readOnly { get; set; }
	public bool multiLine { get; }
	public char asteriskChar { get; set; }
	public bool wasCanceled { get; }
	protected int caretPositionInternal { get; set; }
	protected int caretSelectPositionInternal { get; set; }
	private bool hasSelection { get; }
	public int caretPosition { get; set; }
	public int selectionAnchorPosition { get; set; }
	public int selectionFocusPosition { get; set; }
	private static string clipboard { get; set; }
	public virtual float minWidth { get; }
	public virtual float preferredWidth { get; }
	public virtual float flexibleWidth { get; }
	public virtual float minHeight { get; }
	public virtual float preferredHeight { get; }
	public virtual float flexibleHeight { get; }
	public virtual int layoutPriority { get; }

	// Methods
	protected void .ctor();
	private BaseInput get_input();
	private string get_compositionString();
	protected Mesh get_mesh();
	protected TextGenerator get_cachedInputTextGenerator();
	public void set_shouldHideMobileInput(bool value);
	public bool get_shouldHideMobileInput();
	private bool get_shouldActivateOnSelect();
	public string get_text();
	public void set_text(string value);
	public bool get_isFocused();
	public float get_caretBlinkRate();
	public void set_caretBlinkRate(float value);
	public int get_caretWidth();
	public void set_caretWidth(int value);
	public Text get_textComponent();
	public void set_textComponent(Text value);
	public Graphic get_placeholder();
	public void set_placeholder(Graphic value);
	public Color get_caretColor();
	public void set_caretColor(Color value);
	public bool get_customCaretColor();
	public void set_customCaretColor(bool value);
	public Color get_selectionColor();
	public void set_selectionColor(Color value);
	public InputField.SubmitEvent get_onEndEdit();
	public void set_onEndEdit(InputField.SubmitEvent value);
	public InputField.OnChangeEvent get_onValueChange();
	public void set_onValueChange(InputField.OnChangeEvent value);
	public InputField.OnChangeEvent get_onValueChanged();
	public void set_onValueChanged(InputField.OnChangeEvent value);
	public InputField.OnValidateInput get_onValidateInput();
	public void set_onValidateInput(InputField.OnValidateInput value);
	public int get_characterLimit();
	public void set_characterLimit(int value);
	public InputField.ContentType get_contentType();
	public void set_contentType(InputField.ContentType value);
	public InputField.LineType get_lineType();
	public void set_lineType(InputField.LineType value);
	public InputField.InputType get_inputType();
	public void set_inputType(InputField.InputType value);
	public TouchScreenKeyboard get_touchScreenKeyboard();
	public TouchScreenKeyboardType get_keyboardType();
	public void set_keyboardType(TouchScreenKeyboardType value);
	public InputField.CharacterValidation get_characterValidation();
	public void set_characterValidation(InputField.CharacterValidation value);
	public bool get_readOnly();
	public void set_readOnly(bool value);
	public bool get_multiLine();
	public char get_asteriskChar();
	public void set_asteriskChar(char value);
	public bool get_wasCanceled();
	protected void ClampPos(int pos);
	protected int get_caretPositionInternal();
	protected void set_caretPositionInternal(int value);
	protected int get_caretSelectPositionInternal();
	protected void set_caretSelectPositionInternal(int value);
	private bool get_hasSelection();
	public int get_caretPosition();
	public void set_caretPosition(int value);
	public int get_selectionAnchorPosition();
	public void set_selectionAnchorPosition(int value);
	public int get_selectionFocusPosition();
	public void set_selectionFocusPosition(int value);
	protected override void OnEnable();
	protected override void OnDisable();
	private IEnumerator CaretBlink();
	private void SetCaretVisible();
	private void SetCaretActive();
	private void UpdateCaretMaterial();
	protected void OnFocus();
	protected void SelectAll();
	public void MoveTextEnd(bool shift);
	public void MoveTextStart(bool shift);
	private static string get_clipboard();
	private static void set_clipboard(string value);
	private bool InPlaceEditing();
	private void UpdateCaretFromKeyboard();
	protected virtual void LateUpdate();
	public Vector2 ScreenToLocal(Vector2 screen);
	private int GetUnclampedCharacterLineFromPosition(Vector2 pos, TextGenerator generator);
	protected int GetCharacterIndexFromPosition(Vector2 pos);
	private bool MayDrag(PointerEventData eventData);
	public virtual void OnBeginDrag(PointerEventData eventData);
	public virtual void OnDrag(PointerEventData eventData);
	private IEnumerator MouseDragOutsideRect(PointerEventData eventData);
	public virtual void OnEndDrag(PointerEventData eventData);
	public override void OnPointerDown(PointerEventData eventData);
	protected InputField.EditState KeyPressed(Event evt);
	private bool IsValidChar(char c);
	public void ProcessEvent(Event e);
	public virtual void OnUpdateSelected(BaseEventData eventData);
	private string GetSelectedString();
	private int FindtNextWordBegin();
	private void MoveRight(bool shift, bool ctrl);
	private int FindtPrevWordBegin();
	private void MoveLeft(bool shift, bool ctrl);
	private int DetermineCharacterLine(int charPos, TextGenerator generator);
	private int LineUpCharacterPosition(int originalPos, bool goToFirstChar);
	private int LineDownCharacterPosition(int originalPos, bool goToLastChar);
	private void MoveDown(bool shift);
	private void MoveDown(bool shift, bool goToLastChar);
	private void MoveUp(bool shift);
	private void MoveUp(bool shift, bool goToFirstChar);
	private void Delete();
	private void ForwardSpace();
	private void Backspace();
	private void Insert(char c);
	private void SendOnValueChangedAndUpdateLabel();
	private void SendOnValueChanged();
	protected void SendOnSubmit();
	protected virtual void Append(string input);
	protected virtual void Append(char input);
	protected void UpdateLabel();
	private bool IsSelectionVisible();
	private static int GetLineStartPosition(TextGenerator gen, int line);
	private static int GetLineEndPosition(TextGenerator gen, int line);
	private void SetDrawRangeToContainCaretPosition(int caretPos);
	public void ForceLabelUpdate();
	private void MarkGeometryAsDirty();
	public virtual void Rebuild(CanvasUpdate update);
	public virtual void LayoutComplete();
	public virtual void GraphicUpdateComplete();
	private void UpdateGeometry();
	private void AssignPositioningIfNeeded();
	private void OnFillVBO(Mesh vbo);
	private void GenerateCaret(VertexHelper vbo, Vector2 roundingOffset);
	private void CreateCursorVerts();
	private void GenerateHightlight(VertexHelper vbo, Vector2 roundingOffset);
	protected char Validate(string text, int pos, char ch);
	public void ActivateInputField();
	private void ActivateInputFieldInternal();
	public override void OnSelect(BaseEventData eventData);
	public virtual void OnPointerClick(PointerEventData eventData);
	public void DeactivateInputField();
	public override void OnDeselect(BaseEventData eventData);
	public virtual void OnSubmit(BaseEventData eventData);
	private void EnforceContentType();
	private void EnforceTextHOverflow();
	private void SetToCustomIfContentTypeIsNot(InputField.ContentType[] allowedContentTypes);
	private void SetToCustom();
	protected override void DoStateTransition(Selectable.SelectionState state, bool instant);
	public virtual void CalculateLayoutInputHorizontal();
	public virtual void CalculateLayoutInputVertical();
	public virtual float get_minWidth();
	public virtual float get_preferredWidth();
	public virtual float get_flexibleWidth();
	public virtual float get_minHeight();
	public virtual float get_preferredHeight();
	public virtual float get_flexibleHeight();
	public virtual int get_layoutPriority();
	private static void .cctor();
	private Transform UnityEngine.UI.ICanvasElement.get_transform();

}
//NameSpace:
public enum InputField.ContentType
{
	// Fields
	public int value__;
	public const InputField.ContentType Standard;
	public const InputField.ContentType Autocorrected;
	public const InputField.ContentType IntegerNumber;
	public const InputField.ContentType DecimalNumber;
	public const InputField.ContentType Alphanumeric;
	public const InputField.ContentType Name;
	public const InputField.ContentType EmailAddress;
	public const InputField.ContentType Password;
	public const InputField.ContentType Pin;
	public const InputField.ContentType Custom;

}
//NameSpace:
public enum InputField.InputType
{
	// Fields
	public int value__;
	public const InputField.InputType Standard;
	public const InputField.InputType AutoCorrect;
	public const InputField.InputType Password;

}
//NameSpace:
public enum InputField.CharacterValidation
{
	// Fields
	public int value__;
	public const InputField.CharacterValidation None;
	public const InputField.CharacterValidation Integer;
	public const InputField.CharacterValidation Decimal;
	public const InputField.CharacterValidation Alphanumeric;
	public const InputField.CharacterValidation Name;
	public const InputField.CharacterValidation EmailAddress;

}
//NameSpace:
public enum InputField.LineType
{
	// Fields
	public int value__;
	public const InputField.LineType SingleLine;
	public const InputField.LineType MultiLineSubmit;
	public const InputField.LineType MultiLineNewline;

}
//NameSpace:
public sealed class InputField.OnValidateInput : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual char Invoke(string text, int charIndex, char addedChar);
	public virtual IAsyncResult BeginInvoke(string text, int charIndex, char addedChar, AsyncCallback callback, object object);
	public virtual char EndInvoke(IAsyncResult result);

}
//NameSpace:
public class InputField.SubmitEvent : UnityEvent`1<string>
{
	// Methods
	public void .ctor();

}
//NameSpace:
public class InputField.OnChangeEvent : UnityEvent`1<string>
{
	// Methods
	public void .ctor();

}
//NameSpace:
protected enum InputField.EditState
{
	// Fields
	public int value__;
	public const InputField.EditState Continue;
	public const InputField.EditState Finish;

}
//NameSpace:
private sealed class InputField.<CaretBlink>c__Iterator0 : IEnumerator, IDisposable, IEnumerator`1<object>
{
	// Fields
	internal float <blinkPeriod>__1;
	internal bool <blinkState>__1;
	internal InputField $this;
	internal object $current;
	internal bool $disposing;
	internal int $PC;

	// Properties
	private object System.Collections.Generic.IEnumerator<object>.Current { get; }
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	public void .ctor();
	public bool MoveNext();
	private object System.Collections.Generic.IEnumerator<object>.get_Current();
	private object System.Collections.IEnumerator.get_Current();
	public void Dispose();
	public void Reset();

}
//NameSpace:
private sealed class InputField.<MouseDragOutsideRect>c__Iterator1 : IEnumerator, IDisposable, IEnumerator`1<object>
{
	// Fields
	internal PointerEventData eventData;
	internal Vector2 <localMousePos>__1;
	internal Rect <rect>__1;
	internal float <delay>__1;
	internal InputField $this;
	internal object $current;
	internal bool $disposing;
	internal int $PC;

	// Properties
	private object System.Collections.Generic.IEnumerator<object>.Current { get; }
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	public void .ctor();
	public bool MoveNext();
	private object System.Collections.Generic.IEnumerator<object>.get_Current();
	private object System.Collections.IEnumerator.get_Current();
	public void Dispose();
	public void Reset();

}
//NameSpace:UnityEngine.UI
public class Mask : UIBehaviour, ICanvasRaycastFilter, IMaterialModifier
{
	// Fields
	private RectTransform m_RectTransform;
	private bool m_ShowMaskGraphic;
	private Graphic m_Graphic;
	private Material m_MaskMaterial;
	private Material m_UnmaskMaterial;

	// Properties
	public RectTransform rectTransform { get; }
	public bool showMaskGraphic { get; set; }
	public Graphic graphic { get; }

	// Methods
	protected void .ctor();
	public RectTransform get_rectTransform();
	public bool get_showMaskGraphic();
	public void set_showMaskGraphic(bool value);
	public Graphic get_graphic();
	public virtual bool MaskEnabled();
	public virtual void OnSiblingGraphicEnabledDisabled();
	protected override void OnEnable();
	protected override void OnDisable();
	public virtual bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera);
	public virtual Material GetModifiedMaterial(Material baseMaterial);

}
//NameSpace:UnityEngine.UI
public class MaskUtilities
{
	// Methods
	public void .ctor();
	public static void Notify2DMaskStateChanged(Component mask);
	public static void NotifyStencilStateChanged(Component mask);
	public static Transform FindRootSortOverrideCanvas(Transform start);
	public static int GetStencilDepth(Transform transform, Transform stopAfter);
	public static bool IsDescendantOrSelf(Transform father, Transform child);
	public static RectMask2D GetRectMaskForClippable(IClippable clippable);
	public static void GetRectMasksForClip(RectMask2D clipper, List`1<RectMask2D> masks);

}
//NameSpace:UnityEngine.UI
public abstract class MaskableGraphic : Graphic, IClippable, IMaskable, IMaterialModifier
{
	// Fields
	protected bool m_ShouldRecalculateStencil;
	protected Material m_MaskMaterial;
	private RectMask2D m_ParentMask;
	private bool m_Maskable;
	protected bool m_IncludeForMasking;
	private MaskableGraphic.CullStateChangedEvent m_OnCullStateChanged;
	protected bool m_ShouldRecalculate;
	protected int m_StencilValue;
	private readonly Vector3[] m_Corners;

	// Properties
	public MaskableGraphic.CullStateChangedEvent onCullStateChanged { get; set; }
	public bool maskable { get; set; }
	private Rect rootCanvasRect { get; }

	// Methods
	protected void .ctor();
	public MaskableGraphic.CullStateChangedEvent get_onCullStateChanged();
	public void set_onCullStateChanged(MaskableGraphic.CullStateChangedEvent value);
	public bool get_maskable();
	public void set_maskable(bool value);
	public virtual Material GetModifiedMaterial(Material baseMaterial);
	public virtual void Cull(Rect clipRect, bool validRect);
	private void UpdateCull(bool cull);
	public virtual void SetClipRect(Rect clipRect, bool validRect);
	protected override void OnEnable();
	protected override void OnDisable();
	protected override void OnTransformParentChanged();
	public virtual void ParentMaskStateChanged();
	protected override void OnCanvasHierarchyChanged();
	private Rect get_rootCanvasRect();
	private void UpdateClipParent();
	public virtual void RecalculateClipping();
	public virtual void RecalculateMasking();
	private GameObject UnityEngine.UI.IClippable.get_gameObject();

}
//NameSpace:
public class MaskableGraphic.CullStateChangedEvent : UnityEvent`1<bool>
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine.UI
internal static class Misc
{
	// Methods
	public static void Destroy(Object obj);
	public static void DestroyImmediate(Object obj);

}
//NameSpace:UnityEngine.UI
public struct Navigation : IEquatable`1<Navigation>
{
	// Fields
	private Navigation.Mode m_Mode;
	private Selectable m_SelectOnUp;
	private Selectable m_SelectOnDown;
	private Selectable m_SelectOnLeft;
	private Selectable m_SelectOnRight;

	// Properties
	public Navigation.Mode mode { get; set; }
	public Selectable selectOnUp { get; set; }
	public Selectable selectOnDown { get; set; }
	public Selectable selectOnLeft { get; set; }
	public Selectable selectOnRight { get; set; }
	public static Navigation defaultNavigation { get; }

	// Methods
	public Navigation.Mode get_mode();
	public void set_mode(Navigation.Mode value);
	public Selectable get_selectOnUp();
	public void set_selectOnUp(Selectable value);
	public Selectable get_selectOnDown();
	public void set_selectOnDown(Selectable value);
	public Selectable get_selectOnLeft();
	public void set_selectOnLeft(Selectable value);
	public Selectable get_selectOnRight();
	public void set_selectOnRight(Selectable value);
	public static Navigation get_defaultNavigation();
	public bool Equals(Navigation other);

}
//NameSpace:
public enum Navigation.Mode
{
	// Fields
	public int value__;
	public const Navigation.Mode None;
	public const Navigation.Mode Horizontal;
	public const Navigation.Mode Vertical;
	public const Navigation.Mode Automatic;
	public const Navigation.Mode Explicit;

}
//NameSpace:UnityEngine.UI
public class RawImage : MaskableGraphic
{
	// Fields
	private Texture m_Texture;
	private Rect m_UVRect;

	// Properties
	public override Texture mainTexture { get; }
	public Texture texture { get; set; }
	public Rect uvRect { get; set; }

	// Methods
	protected void .ctor();
	public override Texture get_mainTexture();
	public Texture get_texture();
	public void set_texture(Texture value);
	public Rect get_uvRect();
	public void set_uvRect(Rect value);
	public override void SetNativeSize();
	protected override void OnPopulateMesh(VertexHelper vh);

}
//NameSpace:UnityEngine.UI
public class RectMask2D : UIBehaviour, IClipper, ICanvasRaycastFilter
{
	// Fields
	private readonly RectangularVertexClipper m_VertexClipper;
	private RectTransform m_RectTransform;
	private HashSet`1<IClippable> m_ClipTargets;
	private bool m_ShouldRecalculateClipRects;
	private List`1<RectMask2D> m_Clippers;
	private Rect m_LastClipRectCanvasSpace;
	private bool m_ForceClip;
	private Canvas m_Canvas;
	private Vector3[] m_Corners;

	// Properties
	private Canvas Canvas { get; }
	public Rect canvasRect { get; }
	public RectTransform rectTransform { get; }
	private Rect rootCanvasRect { get; }

	// Methods
	protected void .ctor();
	private Canvas get_Canvas();
	public Rect get_canvasRect();
	public RectTransform get_rectTransform();
	protected override void OnEnable();
	protected override void OnDisable();
	public virtual bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera);
	private Rect get_rootCanvasRect();
	public virtual void PerformClipping();
	public void AddClippable(IClippable clippable);
	public void RemoveClippable(IClippable clippable);
	protected override void OnTransformParentChanged();
	protected override void OnCanvasHierarchyChanged();

}
//NameSpace:UnityEngine.UI
public class ScrollRect : UIBehaviour, IInitializePotentialDragHandler, IBeginDragHandler, IEndDragHandler, IDragHandler, IScrollHandler, ICanvasElement, ILayoutElement, ILayoutGroup, IEventSystemHandler, ILayoutController
{
	// Fields
	private RectTransform m_Content;
	private bool m_Horizontal;
	private bool m_Vertical;
	private ScrollRect.MovementType m_MovementType;
	private float m_Elasticity;
	private bool m_Inertia;
	private float m_DecelerationRate;
	private float m_ScrollSensitivity;
	private RectTransform m_Viewport;
	private Scrollbar m_HorizontalScrollbar;
	private Scrollbar m_VerticalScrollbar;
	private ScrollRect.ScrollbarVisibility m_HorizontalScrollbarVisibility;
	private ScrollRect.ScrollbarVisibility m_VerticalScrollbarVisibility;
	private float m_HorizontalScrollbarSpacing;
	private float m_VerticalScrollbarSpacing;
	private ScrollRect.ScrollRectEvent m_OnValueChanged;
	private Vector2 m_PointerStartLocalCursor;
	protected Vector2 m_ContentStartPosition;
	private RectTransform m_ViewRect;
	protected Bounds m_ContentBounds;
	private Bounds m_ViewBounds;
	private Vector2 m_Velocity;
	private bool m_Dragging;
	private bool m_Scrolling;
	private Vector2 m_PrevPosition;
	private Bounds m_PrevContentBounds;
	private Bounds m_PrevViewBounds;
	private bool m_HasRebuiltLayout;
	private bool m_HSliderExpand;
	private bool m_VSliderExpand;
	private float m_HSliderHeight;
	private float m_VSliderWidth;
	private RectTransform m_Rect;
	private RectTransform m_HorizontalScrollbarRect;
	private RectTransform m_VerticalScrollbarRect;
	private DrivenRectTransformTracker m_Tracker;
	private readonly Vector3[] m_Corners;

	// Properties
	public RectTransform content { get; set; }
	public bool horizontal { get; set; }
	public bool vertical { get; set; }
	public ScrollRect.MovementType movementType { get; set; }
	public float elasticity { get; set; }
	public bool inertia { get; set; }
	public float decelerationRate { get; set; }
	public float scrollSensitivity { get; set; }
	public RectTransform viewport { get; set; }
	public Scrollbar horizontalScrollbar { get; set; }
	public Scrollbar verticalScrollbar { get; set; }
	public ScrollRect.ScrollbarVisibility horizontalScrollbarVisibility { get; set; }
	public ScrollRect.ScrollbarVisibility verticalScrollbarVisibility { get; set; }
	public float horizontalScrollbarSpacing { get; set; }
	public float verticalScrollbarSpacing { get; set; }
	public ScrollRect.ScrollRectEvent onValueChanged { get; set; }
	protected RectTransform viewRect { get; }
	public Vector2 velocity { get; set; }
	private RectTransform rectTransform { get; }
	public Vector2 normalizedPosition { get; set; }
	public float horizontalNormalizedPosition { get; set; }
	public float verticalNormalizedPosition { get; set; }
	private bool hScrollingNeeded { get; }
	private bool vScrollingNeeded { get; }
	public virtual float minWidth { get; }
	public virtual float preferredWidth { get; }
	public virtual float flexibleWidth { get; }
	public virtual float minHeight { get; }
	public virtual float preferredHeight { get; }
	public virtual float flexibleHeight { get; }
	public virtual int layoutPriority { get; }

	// Methods
	protected void .ctor();
	public RectTransform get_content();
	public void set_content(RectTransform value);
	public bool get_horizontal();
	public void set_horizontal(bool value);
	public bool get_vertical();
	public void set_vertical(bool value);
	public ScrollRect.MovementType get_movementType();
	public void set_movementType(ScrollRect.MovementType value);
	public float get_elasticity();
	public void set_elasticity(float value);
	public bool get_inertia();
	public void set_inertia(bool value);
	public float get_decelerationRate();
	public void set_decelerationRate(float value);
	public float get_scrollSensitivity();
	public void set_scrollSensitivity(float value);
	public RectTransform get_viewport();
	public void set_viewport(RectTransform value);
	public Scrollbar get_horizontalScrollbar();
	public void set_horizontalScrollbar(Scrollbar value);
	public Scrollbar get_verticalScrollbar();
	public void set_verticalScrollbar(Scrollbar value);
	public ScrollRect.ScrollbarVisibility get_horizontalScrollbarVisibility();
	public void set_horizontalScrollbarVisibility(ScrollRect.ScrollbarVisibility value);
	public ScrollRect.ScrollbarVisibility get_verticalScrollbarVisibility();
	public void set_verticalScrollbarVisibility(ScrollRect.ScrollbarVisibility value);
	public float get_horizontalScrollbarSpacing();
	public void set_horizontalScrollbarSpacing(float value);
	public float get_verticalScrollbarSpacing();
	public void set_verticalScrollbarSpacing(float value);
	public ScrollRect.ScrollRectEvent get_onValueChanged();
	public void set_onValueChanged(ScrollRect.ScrollRectEvent value);
	protected RectTransform get_viewRect();
	public Vector2 get_velocity();
	public void set_velocity(Vector2 value);
	private RectTransform get_rectTransform();
	public virtual void Rebuild(CanvasUpdate executing);
	public virtual void LayoutComplete();
	public virtual void GraphicUpdateComplete();
	private void UpdateCachedData();
	protected override void OnEnable();
	protected override void OnDisable();
	public override bool IsActive();
	private void EnsureLayoutHasRebuilt();
	public virtual void StopMovement();
	public virtual void OnScroll(PointerEventData data);
	public virtual void OnInitializePotentialDrag(PointerEventData eventData);
	public virtual void OnBeginDrag(PointerEventData eventData);
	public virtual void OnEndDrag(PointerEventData eventData);
	public virtual void OnDrag(PointerEventData eventData);
	protected virtual void SetContentAnchoredPosition(Vector2 position);
	protected virtual void LateUpdate();
	protected void UpdatePrevData();
	private void UpdateScrollbars(Vector2 offset);
	public Vector2 get_normalizedPosition();
	public void set_normalizedPosition(Vector2 value);
	public float get_horizontalNormalizedPosition();
	public void set_horizontalNormalizedPosition(float value);
	public float get_verticalNormalizedPosition();
	public void set_verticalNormalizedPosition(float value);
	private void SetHorizontalNormalizedPosition(float value);
	private void SetVerticalNormalizedPosition(float value);
	protected virtual void SetNormalizedPosition(float value, int axis);
	private static float RubberDelta(float overStretching, float viewSize);
	protected override void OnRectTransformDimensionsChange();
	private bool get_hScrollingNeeded();
	private bool get_vScrollingNeeded();
	public virtual void CalculateLayoutInputHorizontal();
	public virtual void CalculateLayoutInputVertical();
	public virtual float get_minWidth();
	public virtual float get_preferredWidth();
	public virtual float get_flexibleWidth();
	public virtual float get_minHeight();
	public virtual float get_preferredHeight();
	public virtual float get_flexibleHeight();
	public virtual int get_layoutPriority();
	public virtual void SetLayoutHorizontal();
	public virtual void SetLayoutVertical();
	private void UpdateScrollbarVisibility();
	private static void UpdateOneScrollbarVisibility(bool xScrollingNeeded, bool xAxisEnabled, ScrollRect.ScrollbarVisibility scrollbarVisibility, Scrollbar scrollbar);
	private void UpdateScrollbarLayout();
	protected void UpdateBounds();
	internal static void AdjustBounds(Bounds viewBounds, Vector2 contentPivot, Vector3 contentSize, Vector3 contentPos);
	private Bounds GetBounds();
	internal static Bounds InternalGetBounds(Vector3[] corners, Matrix4x4 viewWorldToLocalMatrix);
	private Vector2 CalculateOffset(Vector2 delta);
	internal static Vector2 InternalCalculateOffset(Bounds viewBounds, Bounds contentBounds, bool horizontal, bool vertical, ScrollRect.MovementType movementType, Vector2 delta);
	protected void SetDirty();
	protected void SetDirtyCaching();
	private Transform UnityEngine.UI.ICanvasElement.get_transform();

}
//NameSpace:
public enum ScrollRect.MovementType
{
	// Fields
	public int value__;
	public const ScrollRect.MovementType Unrestricted;
	public const ScrollRect.MovementType Elastic;
	public const ScrollRect.MovementType Clamped;

}
//NameSpace:
public enum ScrollRect.ScrollbarVisibility
{
	// Fields
	public int value__;
	public const ScrollRect.ScrollbarVisibility Permanent;
	public const ScrollRect.ScrollbarVisibility AutoHide;
	public const ScrollRect.ScrollbarVisibility AutoHideAndExpandViewport;

}
//NameSpace:
public class ScrollRect.ScrollRectEvent : UnityEvent`1<Vector2>
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine.UI
public class Scrollbar : Selectable, IBeginDragHandler, IDragHandler, IInitializePotentialDragHandler, ICanvasElement, IEventSystemHandler
{
	// Fields
	private RectTransform m_HandleRect;
	private Scrollbar.Direction m_Direction;
	private float m_Value;
	private float m_Size;
	private int m_NumberOfSteps;
	private Scrollbar.ScrollEvent m_OnValueChanged;
	private RectTransform m_ContainerRect;
	private Vector2 m_Offset;
	private DrivenRectTransformTracker m_Tracker;
	private Coroutine m_PointerDownRepeat;
	private bool isPointerDownAndNotDragging;

	// Properties
	public RectTransform handleRect { get; set; }
	public Scrollbar.Direction direction { get; set; }
	public float value { get; set; }
	public float size { get; set; }
	public int numberOfSteps { get; set; }
	public Scrollbar.ScrollEvent onValueChanged { get; set; }
	private float stepSize { get; }
	private Scrollbar.Axis axis { get; }
	private bool reverseValue { get; }

	// Methods
	protected void .ctor();
	public RectTransform get_handleRect();
	public void set_handleRect(RectTransform value);
	public Scrollbar.Direction get_direction();
	public void set_direction(Scrollbar.Direction value);
	public float get_value();
	public void set_value(float value);
	public float get_size();
	public void set_size(float value);
	public int get_numberOfSteps();
	public void set_numberOfSteps(int value);
	public Scrollbar.ScrollEvent get_onValueChanged();
	public void set_onValueChanged(Scrollbar.ScrollEvent value);
	private float get_stepSize();
	public virtual void Rebuild(CanvasUpdate executing);
	public virtual void LayoutComplete();
	public virtual void GraphicUpdateComplete();
	protected override void OnEnable();
	protected override void OnDisable();
	private void UpdateCachedReferences();
	private void Set(float input);
	private void Set(float input, bool sendCallback);
	protected override void OnRectTransformDimensionsChange();
	private Scrollbar.Axis get_axis();
	private bool get_reverseValue();
	private void UpdateVisuals();
	private void UpdateDrag(PointerEventData eventData);
	private bool MayDrag(PointerEventData eventData);
	public virtual void OnBeginDrag(PointerEventData eventData);
	public virtual void OnDrag(PointerEventData eventData);
	public override void OnPointerDown(PointerEventData eventData);
	protected IEnumerator ClickRepeat(PointerEventData eventData);
	public override void OnPointerUp(PointerEventData eventData);
	public override void OnMove(AxisEventData eventData);
	public override Selectable FindSelectableOnLeft();
	public override Selectable FindSelectableOnRight();
	public override Selectable FindSelectableOnUp();
	public override Selectable FindSelectableOnDown();
	public virtual void OnInitializePotentialDrag(PointerEventData eventData);
	public void SetDirection(Scrollbar.Direction direction, bool includeRectLayouts);
	private Transform UnityEngine.UI.ICanvasElement.get_transform();

}
//NameSpace:
public enum Scrollbar.Direction
{
	// Fields
	public int value__;
	public const Scrollbar.Direction LeftToRight;
	public const Scrollbar.Direction RightToLeft;
	public const Scrollbar.Direction BottomToTop;
	public const Scrollbar.Direction TopToBottom;

}
//NameSpace:
public class Scrollbar.ScrollEvent : UnityEvent`1<float>
{
	// Methods
	public void .ctor();

}
//NameSpace:
private enum Scrollbar.Axis
{
	// Fields
	public int value__;
	public const Scrollbar.Axis Horizontal;
	public const Scrollbar.Axis Vertical;

}
//NameSpace:
private sealed class Scrollbar.<ClickRepeat>c__Iterator0 : IEnumerator, IDisposable, IEnumerator`1<object>
{
	// Fields
	internal PointerEventData eventData;
	internal Scrollbar $this;
	internal object $current;
	internal bool $disposing;
	internal int $PC;

	// Properties
	private object System.Collections.Generic.IEnumerator<object>.Current { get; }
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	public void .ctor();
	public bool MoveNext();
	private object System.Collections.Generic.IEnumerator<object>.get_Current();
	private object System.Collections.IEnumerator.get_Current();
	public void Dispose();
	public void Reset();

}
//NameSpace:UnityEngine.UI
public class Selectable : UIBehaviour, IMoveHandler, IPointerDownHandler, IPointerUpHandler, IPointerEnterHandler, IPointerExitHandler, ISelectHandler, IDeselectHandler, IEventSystemHandler
{
	// Fields
	private static List`1<Selectable> s_List;
	private Navigation m_Navigation;
	private Selectable.Transition m_Transition;
	private ColorBlock m_Colors;
	private SpriteState m_SpriteState;
	private AnimationTriggers m_AnimationTriggers;
	private bool m_Interactable;
	private Graphic m_TargetGraphic;
	private bool m_GroupsAllowInteraction;
	private Selectable.SelectionState m_CurrentSelectionState;
	private bool <isPointerInside>k__BackingField;
	private bool <isPointerDown>k__BackingField;
	private bool <hasSelection>k__BackingField;
	private readonly List`1<CanvasGroup> m_CanvasGroupCache;

	// Properties
	public static List`1<Selectable> allSelectables { get; }
	public Navigation navigation { get; set; }
	public Selectable.Transition transition { get; set; }
	public ColorBlock colors { get; set; }
	public SpriteState spriteState { get; set; }
	public AnimationTriggers animationTriggers { get; set; }
	public Graphic targetGraphic { get; set; }
	public bool interactable { get; set; }
	private bool isPointerInside { get; set; }
	private bool isPointerDown { get; set; }
	private bool hasSelection { get; set; }
	public Image image { get; set; }
	public Animator animator { get; }
	protected Selectable.SelectionState currentSelectionState { get; }

	// Methods
	protected void .ctor();
	public static List`1<Selectable> get_allSelectables();
	public Navigation get_navigation();
	public void set_navigation(Navigation value);
	public Selectable.Transition get_transition();
	public void set_transition(Selectable.Transition value);
	public ColorBlock get_colors();
	public void set_colors(ColorBlock value);
	public SpriteState get_spriteState();
	public void set_spriteState(SpriteState value);
	public AnimationTriggers get_animationTriggers();
	public void set_animationTriggers(AnimationTriggers value);
	public Graphic get_targetGraphic();
	public void set_targetGraphic(Graphic value);
	public bool get_interactable();
	public void set_interactable(bool value);
	private bool get_isPointerInside();
	private void set_isPointerInside(bool value);
	private bool get_isPointerDown();
	private void set_isPointerDown(bool value);
	private bool get_hasSelection();
	private void set_hasSelection(bool value);
	public Image get_image();
	public void set_image(Image value);
	public Animator get_animator();
	protected override void Awake();
	protected override void OnCanvasGroupChanged();
	public virtual bool IsInteractable();
	protected override void OnDidApplyAnimationProperties();
	protected override void OnEnable();
	private void OnSetProperty();
	protected override void OnDisable();
	protected Selectable.SelectionState get_currentSelectionState();
	protected virtual void InstantClearState();
	protected virtual void DoStateTransition(Selectable.SelectionState state, bool instant);
	public Selectable FindSelectable(Vector3 dir);
	private static Vector3 GetPointOnRectEdge(RectTransform rect, Vector2 dir);
	private void Navigate(AxisEventData eventData, Selectable sel);
	public virtual Selectable FindSelectableOnLeft();
	public virtual Selectable FindSelectableOnRight();
	public virtual Selectable FindSelectableOnUp();
	public virtual Selectable FindSelectableOnDown();
	public virtual void OnMove(AxisEventData eventData);
	private void StartColorTween(Color targetColor, bool instant);
	private void DoSpriteSwap(Sprite newSprite);
	private void TriggerAnimation(string triggername);
	protected bool IsHighlighted(BaseEventData eventData);
	protected bool IsPressed(BaseEventData eventData);
	protected bool IsPressed();
	protected void UpdateSelectionState(BaseEventData eventData);
	private void EvaluateAndTransitionToSelectionState(BaseEventData eventData);
	private void InternalEvaluateAndTransitionToSelectionState(bool instant);
	public virtual void OnPointerDown(PointerEventData eventData);
	public virtual void OnPointerUp(PointerEventData eventData);
	public virtual void OnPointerEnter(PointerEventData eventData);
	public virtual void OnPointerExit(PointerEventData eventData);
	public virtual void OnSelect(BaseEventData eventData);
	public virtual void OnDeselect(BaseEventData eventData);
	public virtual void Select();
	private static void .cctor();

}
//NameSpace:
public enum Selectable.Transition
{
	// Fields
	public int value__;
	public const Selectable.Transition None;
	public const Selectable.Transition ColorTint;
	public const Selectable.Transition SpriteSwap;
	public const Selectable.Transition Animation;

}
//NameSpace:
protected enum Selectable.SelectionState
{
	// Fields
	public int value__;
	public const Selectable.SelectionState Normal;
	public const Selectable.SelectionState Highlighted;
	public const Selectable.SelectionState Pressed;
	public const Selectable.SelectionState Disabled;

}
//NameSpace:UnityEngine.UI
internal static class SetPropertyUtility
{
	// Methods
	public static bool SetColor(Color currentValue, Color newValue);
	public static bool SetStruct(T currentValue, T newValue);
	public static bool SetClass(T currentValue, T newValue);

}
//NameSpace:UnityEngine.UI
public class Slider : Selectable, IDragHandler, IInitializePotentialDragHandler, ICanvasElement, IEventSystemHandler
{
	// Fields
	private RectTransform m_FillRect;
	private RectTransform m_HandleRect;
	private Slider.Direction m_Direction;
	private float m_MinValue;
	private float m_MaxValue;
	private bool m_WholeNumbers;
	protected float m_Value;
	private Slider.SliderEvent m_OnValueChanged;
	private Image m_FillImage;
	private Transform m_FillTransform;
	private RectTransform m_FillContainerRect;
	private Transform m_HandleTransform;
	private RectTransform m_HandleContainerRect;
	private Vector2 m_Offset;
	private DrivenRectTransformTracker m_Tracker;

	// Properties
	public RectTransform fillRect { get; set; }
	public RectTransform handleRect { get; set; }
	public Slider.Direction direction { get; set; }
	public float minValue { get; set; }
	public float maxValue { get; set; }
	public bool wholeNumbers { get; set; }
	public virtual float value { get; set; }
	public float normalizedValue { get; set; }
	public Slider.SliderEvent onValueChanged { get; set; }
	private float stepSize { get; }
	private Slider.Axis axis { get; }
	private bool reverseValue { get; }

	// Methods
	protected void .ctor();
	public RectTransform get_fillRect();
	public void set_fillRect(RectTransform value);
	public RectTransform get_handleRect();
	public void set_handleRect(RectTransform value);
	public Slider.Direction get_direction();
	public void set_direction(Slider.Direction value);
	public float get_minValue();
	public void set_minValue(float value);
	public float get_maxValue();
	public void set_maxValue(float value);
	public bool get_wholeNumbers();
	public void set_wholeNumbers(bool value);
	public virtual float get_value();
	public virtual void set_value(float value);
	public float get_normalizedValue();
	public void set_normalizedValue(float value);
	public Slider.SliderEvent get_onValueChanged();
	public void set_onValueChanged(Slider.SliderEvent value);
	private float get_stepSize();
	public virtual void Rebuild(CanvasUpdate executing);
	public virtual void LayoutComplete();
	public virtual void GraphicUpdateComplete();
	protected override void OnEnable();
	protected override void OnDisable();
	protected override void OnDidApplyAnimationProperties();
	private void UpdateCachedReferences();
	private float ClampValue(float input);
	private void Set(float input);
	protected virtual void Set(float input, bool sendCallback);
	protected override void OnRectTransformDimensionsChange();
	private Slider.Axis get_axis();
	private bool get_reverseValue();
	private void UpdateVisuals();
	private void UpdateDrag(PointerEventData eventData, Camera cam);
	private bool MayDrag(PointerEventData eventData);
	public override void OnPointerDown(PointerEventData eventData);
	public virtual void OnDrag(PointerEventData eventData);
	public override void OnMove(AxisEventData eventData);
	public override Selectable FindSelectableOnLeft();
	public override Selectable FindSelectableOnRight();
	public override Selectable FindSelectableOnUp();
	public override Selectable FindSelectableOnDown();
	public virtual void OnInitializePotentialDrag(PointerEventData eventData);
	public void SetDirection(Slider.Direction direction, bool includeRectLayouts);
	private Transform UnityEngine.UI.ICanvasElement.get_transform();

}
//NameSpace:
public enum Slider.Direction
{
	// Fields
	public int value__;
	public const Slider.Direction LeftToRight;
	public const Slider.Direction RightToLeft;
	public const Slider.Direction BottomToTop;
	public const Slider.Direction TopToBottom;

}
//NameSpace:
public class Slider.SliderEvent : UnityEvent`1<float>
{
	// Methods
	public void .ctor();

}
//NameSpace:
private enum Slider.Axis
{
	// Fields
	public int value__;
	public const Slider.Axis Horizontal;
	public const Slider.Axis Vertical;

}
//NameSpace:UnityEngine.UI
public struct SpriteState : IEquatable`1<SpriteState>
{
	// Fields
	private Sprite m_HighlightedSprite;
	private Sprite m_PressedSprite;
	private Sprite m_DisabledSprite;

	// Properties
	public Sprite highlightedSprite { get; set; }
	public Sprite pressedSprite { get; set; }
	public Sprite disabledSprite { get; set; }

	// Methods
	public Sprite get_highlightedSprite();
	public void set_highlightedSprite(Sprite value);
	public Sprite get_pressedSprite();
	public void set_pressedSprite(Sprite value);
	public Sprite get_disabledSprite();
	public void set_disabledSprite(Sprite value);
	public bool Equals(SpriteState other);

}
//NameSpace:UnityEngine.UI
public static class StencilMaterial
{
	// Fields
	private static List`1<StencilMaterial.MatEntry> m_List;

	// Methods
	public static Material Add(Material baseMat, int stencilID);
	public static Material Add(Material baseMat, int stencilID, StencilOp operation, CompareFunction compareFunction, ColorWriteMask colorWriteMask);
	public static Material Add(Material baseMat, int stencilID, StencilOp operation, CompareFunction compareFunction, ColorWriteMask colorWriteMask, int readMask, int writeMask);
	public static void Remove(Material customMat);
	public static void ClearAll();
	private static void .cctor();

}
//NameSpace:
private class StencilMaterial.MatEntry
{
	// Fields
	public Material baseMat;
	public Material customMat;
	public int count;
	public int stencilId;
	public StencilOp operation;
	public CompareFunction compareFunction;
	public int readMask;
	public int writeMask;
	public bool useAlphaClip;
	public ColorWriteMask colorMask;

	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine.UI
public class Text : MaskableGraphic, ILayoutElement
{
	// Fields
	private FontData m_FontData;
	protected string m_Text;
	private TextGenerator m_TextCache;
	private TextGenerator m_TextCacheForLayout;
	protected static Material s_DefaultText;
	protected bool m_DisableFontTextureRebuiltCallback;
	private readonly UIVertex[] m_TempVerts;

	// Properties
	public TextGenerator cachedTextGenerator { get; }
	public TextGenerator cachedTextGeneratorForLayout { get; }
	public override Texture mainTexture { get; }
	public Font font { get; set; }
	public virtual string text { get; set; }
	public bool supportRichText { get; set; }
	public bool resizeTextForBestFit { get; set; }
	public int resizeTextMinSize { get; set; }
	public int resizeTextMaxSize { get; set; }
	public TextAnchor alignment { get; set; }
	public bool alignByGeometry { get; set; }
	public int fontSize { get; set; }
	public HorizontalWrapMode horizontalOverflow { get; set; }
	public VerticalWrapMode verticalOverflow { get; set; }
	public float lineSpacing { get; set; }
	public FontStyle fontStyle { get; set; }
	public float pixelsPerUnit { get; }
	public virtual float minWidth { get; }
	public virtual float preferredWidth { get; }
	public virtual float flexibleWidth { get; }
	public virtual float minHeight { get; }
	public virtual float preferredHeight { get; }
	public virtual float flexibleHeight { get; }
	public virtual int layoutPriority { get; }

	// Methods
	protected void .ctor();
	public TextGenerator get_cachedTextGenerator();
	public TextGenerator get_cachedTextGeneratorForLayout();
	public override Texture get_mainTexture();
	public void FontTextureChanged();
	public Font get_font();
	public void set_font(Font value);
	public virtual string get_text();
	public virtual void set_text(string value);
	public bool get_supportRichText();
	public void set_supportRichText(bool value);
	public bool get_resizeTextForBestFit();
	public void set_resizeTextForBestFit(bool value);
	public int get_resizeTextMinSize();
	public void set_resizeTextMinSize(int value);
	public int get_resizeTextMaxSize();
	public void set_resizeTextMaxSize(int value);
	public TextAnchor get_alignment();
	public void set_alignment(TextAnchor value);
	public bool get_alignByGeometry();
	public void set_alignByGeometry(bool value);
	public int get_fontSize();
	public void set_fontSize(int value);
	public HorizontalWrapMode get_horizontalOverflow();
	public void set_horizontalOverflow(HorizontalWrapMode value);
	public VerticalWrapMode get_verticalOverflow();
	public void set_verticalOverflow(VerticalWrapMode value);
	public float get_lineSpacing();
	public void set_lineSpacing(float value);
	public FontStyle get_fontStyle();
	public void set_fontStyle(FontStyle value);
	public float get_pixelsPerUnit();
	protected override void OnEnable();
	protected override void OnDisable();
	protected override void UpdateGeometry();
	internal void AssignDefaultFont();
	public TextGenerationSettings GetGenerationSettings(Vector2 extents);
	public static Vector2 GetTextAnchorPivot(TextAnchor anchor);
	protected override void OnPopulateMesh(VertexHelper toFill);
	public virtual void CalculateLayoutInputHorizontal();
	public virtual void CalculateLayoutInputVertical();
	public virtual float get_minWidth();
	public virtual float get_preferredWidth();
	public virtual float get_flexibleWidth();
	public virtual float get_minHeight();
	public virtual float get_preferredHeight();
	public virtual float get_flexibleHeight();
	public virtual int get_layoutPriority();
	private static void .cctor();

}
//NameSpace:UnityEngine.UI
public class Toggle : Selectable, IPointerClickHandler, ISubmitHandler, ICanvasElement, IEventSystemHandler
{
	// Fields
	public Toggle.ToggleTransition toggleTransition;
	public Graphic graphic;
	private ToggleGroup m_Group;
	public Toggle.ToggleEvent onValueChanged;
	private bool m_IsOn;

	// Properties
	public ToggleGroup group { get; set; }
	public bool isOn { get; set; }

	// Methods
	protected void .ctor();
	public ToggleGroup get_group();
	public void set_group(ToggleGroup value);
	public virtual void Rebuild(CanvasUpdate executing);
	public virtual void LayoutComplete();
	public virtual void GraphicUpdateComplete();
	protected override void OnEnable();
	protected override void OnDisable();
	protected override void OnDidApplyAnimationProperties();
	private void SetToggleGroup(ToggleGroup newGroup, bool setMemberValue);
	public bool get_isOn();
	public void set_isOn(bool value);
	private void Set(bool value);
	private void Set(bool value, bool sendCallback);
	private void PlayEffect(bool instant);
	protected override void Start();
	private void InternalToggle();
	public virtual void OnPointerClick(PointerEventData eventData);
	public virtual void OnSubmit(BaseEventData eventData);
	private Transform UnityEngine.UI.ICanvasElement.get_transform();

}
//NameSpace:
public enum Toggle.ToggleTransition
{
	// Fields
	public int value__;
	public const Toggle.ToggleTransition None;
	public const Toggle.ToggleTransition Fade;

}
//NameSpace:
public class Toggle.ToggleEvent : UnityEvent`1<bool>
{
	// Methods
	public void .ctor();

}
//NameSpace:UnityEngine.UI
public class ToggleGroup : UIBehaviour
{
	// Fields
	private bool m_AllowSwitchOff;
	private List`1<Toggle> m_Toggles;
	private static Predicate`1<Toggle> <>f__am$cache0;
	private static Func`2<Togglebool> <>f__am$cache1;

	// Properties
	public bool allowSwitchOff { get; set; }

	// Methods
	protected void .ctor();
	public bool get_allowSwitchOff();
	public void set_allowSwitchOff(bool value);
	private void ValidateToggleIsInGroup(Toggle toggle);
	public void NotifyToggleOn(Toggle toggle);
	public void UnregisterToggle(Toggle toggle);
	public void RegisterToggle(Toggle toggle);
	public bool AnyTogglesOn();
	public IEnumerable`1<Toggle> ActiveToggles();
	public void SetAllTogglesOff();
	private static bool <AnyTogglesOn>m__0(Toggle x);
	private static bool <ActiveToggles>m__1(Toggle x);

}
//NameSpace:UnityEngine.UI
public class ClipperRegistry
{
	// Fields
	private static ClipperRegistry s_Instance;
	private readonly IndexedSet`1<IClipper> m_Clippers;

	// Properties
	public static ClipperRegistry instance { get; }

	// Methods
	protected void .ctor();
	public static ClipperRegistry get_instance();
	public void Cull();
	public static void Register(IClipper c);
	public static void Unregister(IClipper c);

}
//NameSpace:UnityEngine.UI
public static class Clipping
{
	// Methods
	public static Rect FindCullAndClipWorldRect(List`1<RectMask2D> rectMaskParents, out bool validRect);
	private static Rect RectIntersect(Rect a, Rect b);

}
//NameSpace:UnityEngine.UI
public interface IClipper
{
	// Methods
	public abstract void PerformClipping();

}
//NameSpace:UnityEngine.UI
public interface IClippable
{
	// Properties
	public abstract GameObject gameObject { get; }
	public abstract RectTransform rectTransform { get; }

	// Methods
	public abstract GameObject get_gameObject();
	public abstract void RecalculateClipping();
	public abstract RectTransform get_rectTransform();
	public abstract void Cull(Rect clipRect, bool validRect);
	public abstract void SetClipRect(Rect value, bool validRect);

}
//NameSpace:UnityEngine.UI
internal class RectangularVertexClipper
{
	// Fields
	private readonly Vector3[] m_WorldCorners;
	private readonly Vector3[] m_CanvasCorners;

	// Methods
	public void .ctor();
	public Rect GetCanvasRect(RectTransform t, Canvas c);

}
//NameSpace:UnityEngine.UI
public class AspectRatioFitter : UIBehaviour, ILayoutSelfController, ILayoutController
{
	// Fields
	private AspectRatioFitter.AspectMode m_AspectMode;
	private float m_AspectRatio;
	private RectTransform m_Rect;
	private bool m_DelayedSetDirty;
	private DrivenRectTransformTracker m_Tracker;

	// Properties
	public AspectRatioFitter.AspectMode aspectMode { get; set; }
	public float aspectRatio { get; set; }
	private RectTransform rectTransform { get; }

	// Methods
	protected void .ctor();
	public AspectRatioFitter.AspectMode get_aspectMode();
	public void set_aspectMode(AspectRatioFitter.AspectMode value);
	public float get_aspectRatio();
	public void set_aspectRatio(float value);
	private RectTransform get_rectTransform();
	protected override void OnEnable();
	protected override void OnDisable();
	protected virtual void Update();
	protected override void OnRectTransformDimensionsChange();
	private void UpdateRect();
	private float GetSizeDeltaToProduceSize(float size, int axis);
	private Vector2 GetParentSize();
	public virtual void SetLayoutHorizontal();
	public virtual void SetLayoutVertical();
	protected void SetDirty();

}
//NameSpace:
public enum AspectRatioFitter.AspectMode
{
	// Fields
	public int value__;
	public const AspectRatioFitter.AspectMode None;
	public const AspectRatioFitter.AspectMode WidthControlsHeight;
	public const AspectRatioFitter.AspectMode HeightControlsWidth;
	public const AspectRatioFitter.AspectMode FitInParent;
	public const AspectRatioFitter.AspectMode EnvelopeParent;

}
//NameSpace:UnityEngine.UI
public class CanvasScaler : UIBehaviour
{
	// Fields
	private CanvasScaler.ScaleMode m_UiScaleMode;
	protected float m_ReferencePixelsPerUnit;
	protected float m_ScaleFactor;
	protected Vector2 m_ReferenceResolution;
	protected CanvasScaler.ScreenMatchMode m_ScreenMatchMode;
	protected float m_MatchWidthOrHeight;
	private const float kLogBase;
	protected CanvasScaler.Unit m_PhysicalUnit;
	protected float m_FallbackScreenDPI;
	protected float m_DefaultSpriteDPI;
	protected float m_DynamicPixelsPerUnit;
	private Canvas m_Canvas;
	private float m_PrevScaleFactor;
	private float m_PrevReferencePixelsPerUnit;

	// Properties
	public CanvasScaler.ScaleMode uiScaleMode { get; set; }
	public float referencePixelsPerUnit { get; set; }
	public float scaleFactor { get; set; }
	public Vector2 referenceResolution { get; set; }
	public CanvasScaler.ScreenMatchMode screenMatchMode { get; set; }
	public float matchWidthOrHeight { get; set; }
	public CanvasScaler.Unit physicalUnit { get; set; }
	public float fallbackScreenDPI { get; set; }
	public float defaultSpriteDPI { get; set; }
	public float dynamicPixelsPerUnit { get; set; }

	// Methods
	protected void .ctor();
	public CanvasScaler.ScaleMode get_uiScaleMode();
	public void set_uiScaleMode(CanvasScaler.ScaleMode value);
	public float get_referencePixelsPerUnit();
	public void set_referencePixelsPerUnit(float value);
	public float get_scaleFactor();
	public void set_scaleFactor(float value);
	public Vector2 get_referenceResolution();
	public void set_referenceResolution(Vector2 value);
	public CanvasScaler.ScreenMatchMode get_screenMatchMode();
	public void set_screenMatchMode(CanvasScaler.ScreenMatchMode value);
	public float get_matchWidthOrHeight();
	public void set_matchWidthOrHeight(float value);
	public CanvasScaler.Unit get_physicalUnit();
	public void set_physicalUnit(CanvasScaler.Unit value);
	public float get_fallbackScreenDPI();
	public void set_fallbackScreenDPI(float value);
	public float get_defaultSpriteDPI();
	public void set_defaultSpriteDPI(float value);
	public float get_dynamicPixelsPerUnit();
	public void set_dynamicPixelsPerUnit(float value);
	protected override void OnEnable();
	protected override void OnDisable();
	protected virtual void Update();
	protected virtual void Handle();
	protected virtual void HandleWorldCanvas();
	protected virtual void HandleConstantPixelSize();
	protected virtual void HandleScaleWithScreenSize();
	protected virtual void HandleConstantPhysicalSize();
	protected void SetScaleFactor(float scaleFactor);
	protected void SetReferencePixelsPerUnit(float referencePixelsPerUnit);

}
//NameSpace:
public enum CanvasScaler.ScaleMode
{
	// Fields
	public int value__;
	public const CanvasScaler.ScaleMode ConstantPixelSize;
	public const CanvasScaler.ScaleMode ScaleWithScreenSize;
	public const CanvasScaler.ScaleMode ConstantPhysicalSize;

}
//NameSpace:
public enum CanvasScaler.ScreenMatchMode
{
	// Fields
	public int value__;
	public const CanvasScaler.ScreenMatchMode MatchWidthOrHeight;
	public const CanvasScaler.ScreenMatchMode Expand;
	public const CanvasScaler.ScreenMatchMode Shrink;

}
//NameSpace:
public enum CanvasScaler.Unit
{
	// Fields
	public int value__;
	public const CanvasScaler.Unit Centimeters;
	public const CanvasScaler.Unit Millimeters;
	public const CanvasScaler.Unit Inches;
	public const CanvasScaler.Unit Points;
	public const CanvasScaler.Unit Picas;

}
//NameSpace:UnityEngine.UI
public class ContentSizeFitter : UIBehaviour, ILayoutSelfController, ILayoutController
{
	// Fields
	protected ContentSizeFitter.FitMode m_HorizontalFit;
	protected ContentSizeFitter.FitMode m_VerticalFit;
	private RectTransform m_Rect;
	private DrivenRectTransformTracker m_Tracker;

	// Properties
	public ContentSizeFitter.FitMode horizontalFit { get; set; }
	public ContentSizeFitter.FitMode verticalFit { get; set; }
	private RectTransform rectTransform { get; }

	// Methods
	protected void .ctor();
	public ContentSizeFitter.FitMode get_horizontalFit();
	public void set_horizontalFit(ContentSizeFitter.FitMode value);
	public ContentSizeFitter.FitMode get_verticalFit();
	public void set_verticalFit(ContentSizeFitter.FitMode value);
	private RectTransform get_rectTransform();
	protected override void OnEnable();
	protected override void OnDisable();
	protected override void OnRectTransformDimensionsChange();
	private void HandleSelfFittingAlongAxis(int axis);
	public virtual void SetLayoutHorizontal();
	public virtual void SetLayoutVertical();
	protected void SetDirty();

}
//NameSpace:
public enum ContentSizeFitter.FitMode
{
	// Fields
	public int value__;
	public const ContentSizeFitter.FitMode Unconstrained;
	public const ContentSizeFitter.FitMode MinSize;
	public const ContentSizeFitter.FitMode PreferredSize;

}
//NameSpace:UnityEngine.UI
public class GridLayoutGroup : LayoutGroup
{
	// Fields
	protected GridLayoutGroup.Corner m_StartCorner;
	protected GridLayoutGroup.Axis m_StartAxis;
	protected Vector2 m_CellSize;
	protected Vector2 m_Spacing;
	protected GridLayoutGroup.Constraint m_Constraint;
	protected int m_ConstraintCount;

	// Properties
	public GridLayoutGroup.Corner startCorner { get; set; }
	public GridLayoutGroup.Axis startAxis { get; set; }
	public Vector2 cellSize { get; set; }
	public Vector2 spacing { get; set; }
	public GridLayoutGroup.Constraint constraint { get; set; }
	public int constraintCount { get; set; }

	// Methods
	protected void .ctor();
	public GridLayoutGroup.Corner get_startCorner();
	public void set_startCorner(GridLayoutGroup.Corner value);
	public GridLayoutGroup.Axis get_startAxis();
	public void set_startAxis(GridLayoutGroup.Axis value);
	public Vector2 get_cellSize();
	public void set_cellSize(Vector2 value);
	public Vector2 get_spacing();
	public void set_spacing(Vector2 value);
	public GridLayoutGroup.Constraint get_constraint();
	public void set_constraint(GridLayoutGroup.Constraint value);
	public int get_constraintCount();
	public void set_constraintCount(int value);
	public override void CalculateLayoutInputHorizontal();
	public override void CalculateLayoutInputVertical();
	public override void SetLayoutHorizontal();
	public override void SetLayoutVertical();
	private void SetCellsAlongAxis(int axis);

}
//NameSpace:
public enum GridLayoutGroup.Corner
{
	// Fields
	public int value__;
	public const GridLayoutGroup.Corner UpperLeft;
	public const GridLayoutGroup.Corner UpperRight;
	public const GridLayoutGroup.Corner LowerLeft;
	public const GridLayoutGroup.Corner LowerRight;

}
//NameSpace:
public enum GridLayoutGroup.Axis
{
	// Fields
	public int value__;
	public const GridLayoutGroup.Axis Horizontal;
	public const GridLayoutGroup.Axis Vertical;

}
//NameSpace:
public enum GridLayoutGroup.Constraint
{
	// Fields
	public int value__;
	public const GridLayoutGroup.Constraint Flexible;
	public const GridLayoutGroup.Constraint FixedColumnCount;
	public const GridLayoutGroup.Constraint FixedRowCount;

}
//NameSpace:UnityEngine.UI
public class HorizontalLayoutGroup : HorizontalOrVerticalLayoutGroup
{
	// Methods
	protected void .ctor();
	public override void CalculateLayoutInputHorizontal();
	public override void CalculateLayoutInputVertical();
	public override void SetLayoutHorizontal();
	public override void SetLayoutVertical();

}
//NameSpace:UnityEngine.UI
public abstract class HorizontalOrVerticalLayoutGroup : LayoutGroup
{
	// Fields
	protected float m_Spacing;
	protected bool m_ChildForceExpandWidth;
	protected bool m_ChildForceExpandHeight;
	protected bool m_ChildControlWidth;
	protected bool m_ChildControlHeight;

	// Properties
	public float spacing { get; set; }
	public bool childForceExpandWidth { get; set; }
	public bool childForceExpandHeight { get; set; }
	public bool childControlWidth { get; set; }
	public bool childControlHeight { get; set; }

	// Methods
	protected void .ctor();
	public float get_spacing();
	public void set_spacing(float value);
	public bool get_childForceExpandWidth();
	public void set_childForceExpandWidth(bool value);
	public bool get_childForceExpandHeight();
	public void set_childForceExpandHeight(bool value);
	public bool get_childControlWidth();
	public void set_childControlWidth(bool value);
	public bool get_childControlHeight();
	public void set_childControlHeight(bool value);
	protected void CalcAlongAxis(int axis, bool isVertical);
	protected void SetChildrenAlongAxis(int axis, bool isVertical);
	private void GetChildSizes(RectTransform child, int axis, bool controlSize, bool childForceExpand, out float min, out float preferred, out float flexible);

}
//NameSpace:UnityEngine.UI
public interface ILayoutElement
{
	// Properties
	public abstract float minWidth { get; }
	public abstract float preferredWidth { get; }
	public abstract float flexibleWidth { get; }
	public abstract float minHeight { get; }
	public abstract float preferredHeight { get; }
	public abstract float flexibleHeight { get; }
	public abstract int layoutPriority { get; }

	// Methods
	public abstract void CalculateLayoutInputHorizontal();
	public abstract void CalculateLayoutInputVertical();
	public abstract float get_minWidth();
	public abstract float get_preferredWidth();
	public abstract float get_flexibleWidth();
	public abstract float get_minHeight();
	public abstract float get_preferredHeight();
	public abstract float get_flexibleHeight();
	public abstract int get_layoutPriority();

}
//NameSpace:UnityEngine.UI
public interface ILayoutController
{
	// Methods
	public abstract void SetLayoutHorizontal();
	public abstract void SetLayoutVertical();

}
//NameSpace:UnityEngine.UI
public interface ILayoutGroup : ILayoutController
{
}
//NameSpace:UnityEngine.UI
public interface ILayoutSelfController : ILayoutController
{
}
//NameSpace:UnityEngine.UI
public interface ILayoutIgnorer
{
	// Properties
	public abstract bool ignoreLayout { get; }

	// Methods
	public abstract bool get_ignoreLayout();

}
//NameSpace:UnityEngine.UI
public class LayoutElement : UIBehaviour, ILayoutElement, ILayoutIgnorer
{
	// Fields
	private bool m_IgnoreLayout;
	private float m_MinWidth;
	private float m_MinHeight;
	private float m_PreferredWidth;
	private float m_PreferredHeight;
	private float m_FlexibleWidth;
	private float m_FlexibleHeight;
	private int m_LayoutPriority;

	// Properties
	public virtual bool ignoreLayout { get; set; }
	public virtual float minWidth { get; set; }
	public virtual float minHeight { get; set; }
	public virtual float preferredWidth { get; set; }
	public virtual float preferredHeight { get; set; }
	public virtual float flexibleWidth { get; set; }
	public virtual float flexibleHeight { get; set; }
	public virtual int layoutPriority { get; set; }

	// Methods
	protected void .ctor();
	public virtual bool get_ignoreLayout();
	public virtual void set_ignoreLayout(bool value);
	public virtual void CalculateLayoutInputHorizontal();
	public virtual void CalculateLayoutInputVertical();
	public virtual float get_minWidth();
	public virtual void set_minWidth(float value);
	public virtual float get_minHeight();
	public virtual void set_minHeight(float value);
	public virtual float get_preferredWidth();
	public virtual void set_preferredWidth(float value);
	public virtual float get_preferredHeight();
	public virtual void set_preferredHeight(float value);
	public virtual float get_flexibleWidth();
	public virtual void set_flexibleWidth(float value);
	public virtual float get_flexibleHeight();
	public virtual void set_flexibleHeight(float value);
	public virtual int get_layoutPriority();
	public virtual void set_layoutPriority(int value);
	protected override void OnEnable();
	protected override void OnTransformParentChanged();
	protected override void OnDisable();
	protected override void OnDidApplyAnimationProperties();
	protected override void OnBeforeTransformParentChanged();
	protected void SetDirty();

}
//NameSpace:UnityEngine.UI
public abstract class LayoutGroup : UIBehaviour, ILayoutElement, ILayoutGroup, ILayoutController
{
	// Fields
	protected RectOffset m_Padding;
	protected TextAnchor m_ChildAlignment;
	private RectTransform m_Rect;
	protected DrivenRectTransformTracker m_Tracker;
	private Vector2 m_TotalMinSize;
	private Vector2 m_TotalPreferredSize;
	private Vector2 m_TotalFlexibleSize;
	private List`1<RectTransform> m_RectChildren;

	// Properties
	public RectOffset padding { get; set; }
	public TextAnchor childAlignment { get; set; }
	protected RectTransform rectTransform { get; }
	protected List`1<RectTransform> rectChildren { get; }
	public virtual float minWidth { get; }
	public virtual float preferredWidth { get; }
	public virtual float flexibleWidth { get; }
	public virtual float minHeight { get; }
	public virtual float preferredHeight { get; }
	public virtual float flexibleHeight { get; }
	public virtual int layoutPriority { get; }
	private bool isRootLayoutGroup { get; }

	// Methods
	protected void .ctor();
	public RectOffset get_padding();
	public void set_padding(RectOffset value);
	public TextAnchor get_childAlignment();
	public void set_childAlignment(TextAnchor value);
	protected RectTransform get_rectTransform();
	protected List`1<RectTransform> get_rectChildren();
	public virtual void CalculateLayoutInputHorizontal();
	public abstract void CalculateLayoutInputVertical();
	public virtual float get_minWidth();
	public virtual float get_preferredWidth();
	public virtual float get_flexibleWidth();
	public virtual float get_minHeight();
	public virtual float get_preferredHeight();
	public virtual float get_flexibleHeight();
	public virtual int get_layoutPriority();
	public abstract void SetLayoutHorizontal();
	public abstract void SetLayoutVertical();
	protected override void OnEnable();
	protected override void OnDisable();
	protected override void OnDidApplyAnimationProperties();
	protected float GetTotalMinSize(int axis);
	protected float GetTotalPreferredSize(int axis);
	protected float GetTotalFlexibleSize(int axis);
	protected float GetStartOffset(int axis, float requiredSpaceWithoutPadding);
	protected float GetAlignmentOnAxis(int axis);
	protected void SetLayoutInputForAxis(float totalMin, float totalPreferred, float totalFlexible, int axis);
	protected void SetChildAlongAxis(RectTransform rect, int axis, float pos);
	protected void SetChildAlongAxis(RectTransform rect, int axis, float pos, float size);
	private bool get_isRootLayoutGroup();
	protected override void OnRectTransformDimensionsChange();
	protected virtual void OnTransformChildrenChanged();
	protected void SetProperty(T currentValue, T newValue);
	protected void SetDirty();
	private IEnumerator DelayedSetDirty(RectTransform rectTransform);

}
//NameSpace:
private sealed class LayoutGroup.<DelayedSetDirty>c__Iterator0 : IEnumerator, IDisposable, IEnumerator`1<object>
{
	// Fields
	internal RectTransform rectTransform;
	internal object $current;
	internal bool $disposing;
	internal int $PC;

	// Properties
	private object System.Collections.Generic.IEnumerator<object>.Current { get; }
	private object System.Collections.IEnumerator.Current { get; }

	// Methods
	public void .ctor();
	public bool MoveNext();
	private object System.Collections.Generic.IEnumerator<object>.get_Current();
	private object System.Collections.IEnumerator.get_Current();
	public void Dispose();
	public void Reset();

}
//NameSpace:UnityEngine.UI
public class LayoutRebuilder : ICanvasElement
{
	// Fields
	private RectTransform m_ToRebuild;
	private int m_CachedHashFromTransform;
	private static ObjectPool`1<LayoutRebuilder> s_Rebuilders;
	private static RectTransform.ReapplyDrivenProperties <>f__mg$cache0;
	private static Predicate`1<Component> <>f__am$cache0;
	private static UnityAction`1<Component> <>f__am$cache1;
	private static UnityAction`1<Component> <>f__am$cache2;
	private static UnityAction`1<Component> <>f__am$cache3;
	private static UnityAction`1<Component> <>f__am$cache4;

	// Properties
	public Transform transform { get; }

	// Methods
	private static void .cctor();
	public void .ctor();
	private void Initialize(RectTransform controller);
	private void Clear();
	private static void ReapplyDrivenProperties(RectTransform driven);
	public Transform get_transform();
	public bool IsDestroyed();
	private static void StripDisabledBehavioursFromList(List`1<Component> components);
	public static void ForceRebuildLayoutImmediate(RectTransform layoutRoot);
	public void Rebuild(CanvasUpdate executing);
	private void PerformLayoutControl(RectTransform rect, UnityAction`1<Component> action);
	private void PerformLayoutCalculation(RectTransform rect, UnityAction`1<Component> action);
	public static void MarkLayoutForRebuild(RectTransform rect);
	private static bool ValidController(RectTransform layoutRoot, List`1<Component> comps);
	private static void MarkLayoutRootForRebuild(RectTransform controller);
	public void LayoutComplete();
	public void GraphicUpdateComplete();
	public override int GetHashCode();
	public override bool Equals(object obj);
	public override string ToString();
	private static void <s_Rebuilders>m__0(LayoutRebuilder x);
	private static bool <StripDisabledBehavioursFromList>m__1(Component e);
	private static void <Rebuild>m__2(Component e);
	private static void <Rebuild>m__3(Component e);
	private static void <Rebuild>m__4(Component e);
	private static void <Rebuild>m__5(Component e);

}
//NameSpace:UnityEngine.UI
public static class LayoutUtility
{
	// Fields
	private static Func`2<ILayoutElementfloat> <>f__am$cache0;
	private static Func`2<ILayoutElementfloat> <>f__am$cache1;
	private static Func`2<ILayoutElementfloat> <>f__am$cache2;
	private static Func`2<ILayoutElementfloat> <>f__am$cache3;
	private static Func`2<ILayoutElementfloat> <>f__am$cache4;
	private static Func`2<ILayoutElementfloat> <>f__am$cache5;
	private static Func`2<ILayoutElementfloat> <>f__am$cache6;
	private static Func`2<ILayoutElementfloat> <>f__am$cache7;

	// Methods
	public static float GetMinSize(RectTransform rect, int axis);
	public static float GetPreferredSize(RectTransform rect, int axis);
	public static float GetFlexibleSize(RectTransform rect, int axis);
	public static float GetMinWidth(RectTransform rect);
	public static float GetPreferredWidth(RectTransform rect);
	public static float GetFlexibleWidth(RectTransform rect);
	public static float GetMinHeight(RectTransform rect);
	public static float GetPreferredHeight(RectTransform rect);
	public static float GetFlexibleHeight(RectTransform rect);
	public static float GetLayoutProperty(RectTransform rect, Func`2<ILayoutElementfloat> property, float defaultValue);
	public static float GetLayoutProperty(RectTransform rect, Func`2<ILayoutElementfloat> property, float defaultValue, out ILayoutElement source);
	private static float <GetMinWidth>m__0(ILayoutElement e);
	private static float <GetPreferredWidth>m__1(ILayoutElement e);
	private static float <GetPreferredWidth>m__2(ILayoutElement e);
	private static float <GetFlexibleWidth>m__3(ILayoutElement e);
	private static float <GetMinHeight>m__4(ILayoutElement e);
	private static float <GetPreferredHeight>m__5(ILayoutElement e);
	private static float <GetPreferredHeight>m__6(ILayoutElement e);
	private static float <GetFlexibleHeight>m__7(ILayoutElement e);

}
//NameSpace:UnityEngine.UI
public class VerticalLayoutGroup : HorizontalOrVerticalLayoutGroup
{
	// Methods
	protected void .ctor();
	public override void CalculateLayoutInputHorizontal();
	public override void CalculateLayoutInputVertical();
	public override void SetLayoutHorizontal();
	public override void SetLayoutVertical();

}
//NameSpace:UnityEngine.UI
public interface IMaterialModifier
{
	// Methods
	public abstract Material GetModifiedMaterial(Material baseMaterial);

}
//NameSpace:UnityEngine.UI.Collections
internal class IndexedSet`1 : IList`1<T>, ICollection`1<T>, IEnumerable`1<T>, IEnumerable
{
	// Fields
	private readonly List`1<T> m_List;
	private Dictionary`2<Tint> m_Dictionary;

	// Properties
	public int Count { get; }
	public bool IsReadOnly { get; }
	public T Item { get; set; }

	// Methods
	public void .ctor();
	public void Add(T item);
	public bool AddUnique(T item);
	public bool Remove(T item);
	public IEnumerator`1<T> GetEnumerator();
	private IEnumerator System.Collections.IEnumerable.GetEnumerator();
	public void Clear();
	public bool Contains(T item);
	public void CopyTo(T[] array, int arrayIndex);
	public int get_Count();
	public bool get_IsReadOnly();
	public int IndexOf(T item);
	public void Insert(int index, T item);
	public void RemoveAt(int index);
	public T get_Item(int index);
	public void set_Item(int index, T value);
	public void RemoveAll(Predicate`1<T> match);
	public void Sort(Comparison`1<T> sortLayoutFunction);

}
//NameSpace:UnityEngine.UI
internal static class ListPool`1
{
	// Fields
	private static readonly ObjectPool`1<List`1<T>> s_ListPool;
	private static UnityAction`1<List`1<T>> <>f__mg$cache0;

	// Methods
	private static void Clear(List`1<T> l);
	public static List`1<T> Get();
	public static void Release(List`1<T> toRelease);
	private static void .cctor();

}
//NameSpace:UnityEngine.UI
internal class ObjectPool`1
{
	// Fields
	private readonly Stack`1<T> m_Stack;
	private readonly UnityAction`1<T> m_ActionOnGet;
	private readonly UnityAction`1<T> m_ActionOnRelease;
	private int <countAll>k__BackingField;

	// Properties
	public int countAll { get; set; }
	public int countActive { get; }
	public int countInactive { get; }

	// Methods
	public void .ctor(UnityAction`1<T> actionOnGet, UnityAction`1<T> actionOnRelease);
	public int get_countAll();
	private void set_countAll(int value);
	public int get_countActive();
	public int get_countInactive();
	public T Get();
	public void Release(T element);

}
//NameSpace:UnityEngine.UI
internal class ReflectionMethodsCache
{
	// Fields
	public ReflectionMethodsCache.Raycast3DCallback raycast3D;
	public ReflectionMethodsCache.RaycastAllCallback raycast3DAll;
	public ReflectionMethodsCache.Raycast2DCallback raycast2D;
	public ReflectionMethodsCache.GetRayIntersectionAllCallback getRayIntersectionAll;
	public ReflectionMethodsCache.GetRayIntersectionAllNonAllocCallback getRayIntersectionAllNonAlloc;
	public ReflectionMethodsCache.GetRaycastNonAllocCallback getRaycastNonAlloc;
	private static ReflectionMethodsCache s_ReflectionMethodsCache;

	// Properties
	public static ReflectionMethodsCache Singleton { get; }

	// Methods
	public void .ctor();
	public static ReflectionMethodsCache get_Singleton();
	private static void .cctor();

}
//NameSpace:
public sealed class ReflectionMethodsCache.Raycast3DCallback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual bool Invoke(Ray r, out RaycastHit hit, float f, int i);
	public virtual IAsyncResult BeginInvoke(Ray r, out RaycastHit hit, float f, int i, AsyncCallback callback, object object);
	public virtual bool EndInvoke(out RaycastHit hit, IAsyncResult result);

}
//NameSpace:
public sealed class ReflectionMethodsCache.Raycast2DCallback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual RaycastHit2D Invoke(Vector2 p1, Vector2 p2, float f, int i);
	public virtual IAsyncResult BeginInvoke(Vector2 p1, Vector2 p2, float f, int i, AsyncCallback callback, object object);
	public virtual RaycastHit2D EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class ReflectionMethodsCache.RaycastAllCallback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual RaycastHit[] Invoke(Ray r, float f, int i);
	public virtual IAsyncResult BeginInvoke(Ray r, float f, int i, AsyncCallback callback, object object);
	public virtual RaycastHit[] EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class ReflectionMethodsCache.GetRayIntersectionAllCallback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual RaycastHit2D[] Invoke(Ray r, float f, int i);
	public virtual IAsyncResult BeginInvoke(Ray r, float f, int i, AsyncCallback callback, object object);
	public virtual RaycastHit2D[] EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class ReflectionMethodsCache.GetRayIntersectionAllNonAllocCallback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual int Invoke(Ray r, RaycastHit2D[] results, float f, int i);
	public virtual IAsyncResult BeginInvoke(Ray r, RaycastHit2D[] results, float f, int i, AsyncCallback callback, object object);
	public virtual int EndInvoke(IAsyncResult result);

}
//NameSpace:
public sealed class ReflectionMethodsCache.GetRaycastNonAllocCallback : MulticastDelegate
{
	// Methods
	public void .ctor(object object, IntPtr method);
	public virtual int Invoke(Ray r, RaycastHit[] results, float f, int i);
	public virtual IAsyncResult BeginInvoke(Ray r, RaycastHit[] results, float f, int i, AsyncCallback callback, object object);
	public virtual int EndInvoke(IAsyncResult result);

}
//NameSpace:UnityEngine.UI
public class VertexHelper : IDisposable
{
	// Fields
	private List`1<Vector3> m_Positions;
	private List`1<Color32> m_Colors;
	private List`1<Vector2> m_Uv0S;
	private List`1<Vector2> m_Uv1S;
	private List`1<Vector2> m_Uv2S;
	private List`1<Vector2> m_Uv3S;
	private List`1<Vector3> m_Normals;
	private List`1<Vector4> m_Tangents;
	private List`1<int> m_Indices;
	private static readonly Vector4 s_DefaultTangent;
	private static readonly Vector3 s_DefaultNormal;
	private bool m_ListsInitalized;

	// Properties
	public int currentVertCount { get; }
	public int currentIndexCount { get; }

	// Methods
	public void .ctor();
	public void .ctor(Mesh m);
	private void InitializeListIfRequired();
	public void Dispose();
	public void Clear();
	public int get_currentVertCount();
	public int get_currentIndexCount();
	public void PopulateUIVertex(UIVertex vertex, int i);
	public void SetUIVertex(UIVertex vertex, int i);
	public void FillMesh(Mesh mesh);
	internal void AddVert(Vector3 position, Color32 color, Vector2 uv0, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector3 normal, Vector4 tangent);
	public void AddVert(Vector3 position, Color32 color, Vector2 uv0, Vector2 uv1, Vector3 normal, Vector4 tangent);
	public void AddVert(Vector3 position, Color32 color, Vector2 uv0);
	public void AddVert(UIVertex v);
	public void AddTriangle(int idx0, int idx1, int idx2);
	public void AddUIVertexQuad(UIVertex[] verts);
	public void AddUIVertexStream(List`1<UIVertex> verts, List`1<int> indices);
	public void AddUIVertexTriangleStream(List`1<UIVertex> verts);
	public void GetUIVertexStream(List`1<UIVertex> stream);
	private static void .cctor();

}
//NameSpace:UnityEngine.Experimental.UI
public static class VertexHelperExtension
{
	// Methods
	public static void AddVert(VertexHelper obj, Vector3 position, Color32 color, Vector2 uv0, Vector2 uv1, Vector2 uv2, Vector2 uv3, Vector3 normal, Vector4 tangent);

}
//NameSpace:UnityEngine.UI
public abstract class BaseVertexEffect
{
	// Methods
	protected void .ctor();
	public abstract void ModifyVertices(List`1<UIVertex> vertices);

}
//NameSpace:UnityEngine.UI
public abstract class BaseMeshEffect : UIBehaviour, IMeshModifier
{
	// Fields
	private Graphic m_Graphic;

	// Properties
	protected Graphic graphic { get; }

	// Methods
	protected void .ctor();
	protected Graphic get_graphic();
	protected override void OnEnable();
	protected override void OnDisable();
	protected override void OnDidApplyAnimationProperties();
	public virtual void ModifyMesh(Mesh mesh);
	public abstract void ModifyMesh(VertexHelper vh);

}
//NameSpace:UnityEngine.UI
public interface IVertexModifier
{
	// Methods
	public abstract void ModifyVertices(List`1<UIVertex> verts);

}
//NameSpace:UnityEngine.UI
public interface IMeshModifier
{
	// Methods
	public abstract void ModifyMesh(Mesh mesh);
	public abstract void ModifyMesh(VertexHelper verts);

}
//NameSpace:UnityEngine.UI
public class Outline : Shadow
{
	// Methods
	protected void .ctor();
	public override void ModifyMesh(VertexHelper vh);

}
//NameSpace:UnityEngine.UI
public class PositionAsUV1 : BaseMeshEffect
{
	// Methods
	protected void .ctor();
	public override void ModifyMesh(VertexHelper vh);

}
//NameSpace:UnityEngine.UI
public class Shadow : BaseMeshEffect
{
	// Fields
	private Color m_EffectColor;
	private Vector2 m_EffectDistance;
	private bool m_UseGraphicAlpha;
	private const float kMaxEffectDistance;

	// Properties
	public Color effectColor { get; set; }
	public Vector2 effectDistance { get; set; }
	public bool useGraphicAlpha { get; set; }

	// Methods
	protected void .ctor();
	public Color get_effectColor();
	public void set_effectColor(Color value);
	public Vector2 get_effectDistance();
	public void set_effectDistance(Vector2 value);
	public bool get_useGraphicAlpha();
	public void set_useGraphicAlpha(bool value);
	protected void ApplyShadowZeroAlloc(List`1<UIVertex> verts, Color32 color, int start, int end, float x, float y);
	protected void ApplyShadow(List`1<UIVertex> verts, Color32 color, int start, int end, float x, float y);
	public override void ModifyMesh(VertexHelper vh);

}
//NameSpace:
internal static class <PrivateImplementationDetails>
{
	// Fields
	internal static readonly <PrivateImplementationDetails>.$ArrayType=12 $field-7BBE37982E6C057ED87163CAFC7FD6E5E42EEA46;

}
//NameSpace:
private struct <PrivateImplementationDetails>.$ArrayType=12
{
}
//NameSpace:
internal class <Module>
{
}
//NameSpace:
internal class <Module>
{
}
//NameSpace:
public class click1 : MonoBehaviour
{
	// Methods
	private void Start();
	public void Click();
	private void Update();
	public void .ctor();

}
//NameSpace:
public class click2 : MonoBehaviour
{
	// Methods
	private void Start();
	public void Click();
	private void Update();
	public void .ctor();

}
//NameSpace:
public class click3 : MonoBehaviour
{
	// Methods
	private void Start();
	public void Click();
	private void Update();
	public void .ctor();

}
//NameSpace:
public class info : MonoBehaviour
{
	// Fields
	public static int hero_power;
	public static int turn;
	public static int monster_power;
	public static int add_power;
	public static int temp_power;

	// Methods
	private void Start();
	private void Update();
	public void .ctor();
	private static void .cctor();

}